From 624b7ad5deb9f69ee47d8cc85266b7b41dde0ba5 Mon Sep 17 00:00:00 2001
From: "matt@pallissard.net" <matt@pallissard.net>
Date: Tue, 17 Nov 2020 21:51:34 -0800
Subject: [PATCH 11/16] multicore: initial typing copy

---
 src/ocaml/typing/410+multicore/annot.mli      |   24 +
 src/ocaml/typing/410+multicore/btype.ml       |  839 +++
 src/ocaml/typing/410+multicore/btype.mli      |  262 +
 src/ocaml/typing/410+multicore/cmi_format.ml  |   81 +
 src/ocaml/typing/410+multicore/cmi_format.mli |   40 +
 src/ocaml/typing/410+multicore/cmt_format.ml  |  197 +
 src/ocaml/typing/410+multicore/cmt_format.mli |  123 +
 src/ocaml/typing/410+multicore/ctype.ml       | 4825 +++++++++++++++
 src/ocaml/typing/410+multicore/ctype.mli      |  374 ++
 src/ocaml/typing/410+multicore/datarepr.ml    |  251 +
 src/ocaml/typing/410+multicore/datarepr.mli   |   48 +
 src/ocaml/typing/410+multicore/env.ml         | 3596 +++++++++++
 src/ocaml/typing/410+multicore/env.mli        |  487 ++
 src/ocaml/typing/410+multicore/ident.ml       |  361 ++
 src/ocaml/typing/410+multicore/ident.mli      |   86 +
 .../typing/410+multicore/includeclass.ml      |  116 +
 .../typing/410+multicore/includeclass.mli     |   32 +
 src/ocaml/typing/410+multicore/includecore.ml |  511 ++
 .../typing/410+multicore/includecore.mli      |   90 +
 src/ocaml/typing/410+multicore/includemod.ml  |  877 +++
 src/ocaml/typing/410+multicore/includemod.mli |   89 +
 src/ocaml/typing/410+multicore/mtype.ml       |  527 ++
 src/ocaml/typing/410+multicore/mtype.mli      |   55 +
 src/ocaml/typing/410+multicore/oprint.ml      |  827 +++
 src/ocaml/typing/410+multicore/oprint.mli     |   32 +
 .../typing/410+multicore/outcometree.mli      |  148 +
 src/ocaml/typing/410+multicore/parmatch.ml    | 2695 ++++++++
 src/ocaml/typing/410+multicore/parmatch.mli   |  143 +
 src/ocaml/typing/410+multicore/path.ml        |  146 +
 src/ocaml/typing/410+multicore/path.mli       |   64 +
 .../typing/410+multicore/persistent_env.ml    |  425 ++
 .../typing/410+multicore/persistent_env.mli   |  117 +
 src/ocaml/typing/410+multicore/predef.ml      |  248 +
 src/ocaml/typing/410+multicore/predef.mli     |   89 +
 src/ocaml/typing/410+multicore/primitive.ml   |  227 +
 src/ocaml/typing/410+multicore/primitive.mli  |   76 +
 src/ocaml/typing/410+multicore/printpat.ml    |  158 +
 src/ocaml/typing/410+multicore/printpat.mli   |   22 +
 src/ocaml/typing/410+multicore/printtyp.ml    | 2111 +++++++
 src/ocaml/typing/410+multicore/printtyp.mli   |  187 +
 src/ocaml/typing/410+multicore/printtyped.ml  |  934 +++
 src/ocaml/typing/410+multicore/printtyped.mli |   26 +
 src/ocaml/typing/410+multicore/rec_check.ml   | 1263 ++++
 src/ocaml/typing/410+multicore/rec_check.mli  |   19 +
 src/ocaml/typing/410+multicore/saved_parts.ml |   27 +
 .../typing/410+multicore/saved_parts.mli      |    3 +
 src/ocaml/typing/410+multicore/short_paths.ml | 1932 ++++++
 .../typing/410+multicore/short_paths.mli      |   46 +
 .../typing/410+multicore/short_paths_graph.ml | 1535 +++++
 .../410+multicore/short_paths_graph.mli       |  308 +
 src/ocaml/typing/410+multicore/stypes.ml      |  210 +
 src/ocaml/typing/410+multicore/stypes.mli     |   36 +
 src/ocaml/typing/410+multicore/subst.ml       |  550 ++
 src/ocaml/typing/410+multicore/subst.mli      |   86 +
 .../typing/410+multicore/tast_iterator.ml     |  510 ++
 .../typing/410+multicore/tast_iterator.mli    |   69 +
 src/ocaml/typing/410+multicore/tast_mapper.ml |  742 +++
 .../typing/410+multicore/tast_mapper.mli      |   73 +
 .../typing/410+multicore/type_immediacy.ml    |   43 +
 .../typing/410+multicore/type_immediacy.mli   |   40 +
 src/ocaml/typing/410+multicore/typeclass.ml   | 2036 +++++++
 src/ocaml/typing/410+multicore/typeclass.mli  |  130 +
 src/ocaml/typing/410+multicore/typecore.ml    | 5428 +++++++++++++++++
 src/ocaml/typing/410+multicore/typecore.mli   |  228 +
 src/ocaml/typing/410+multicore/typedecl.ml    | 1839 ++++++
 src/ocaml/typing/410+multicore/typedecl.mli   |   99 +
 .../410+multicore/typedecl_immediacy.ml       |   71 +
 .../410+multicore/typedecl_immediacy.mli      |   27 +
 .../410+multicore/typedecl_properties.ml      |   73 +
 .../410+multicore/typedecl_properties.mli     |   55 +
 .../typing/410+multicore/typedecl_unboxed.ml  |   57 +
 .../typing/410+multicore/typedecl_unboxed.mli |   25 +
 .../typing/410+multicore/typedecl_variance.ml |  384 ++
 .../410+multicore/typedecl_variance.mli       |   62 +
 src/ocaml/typing/410+multicore/typedtree.ml   |  745 +++
 src/ocaml/typing/410+multicore/typedtree.mli  |  750 +++
 src/ocaml/typing/410+multicore/typemod.ml     | 3042 +++++++++
 src/ocaml/typing/410+multicore/typemod.mli    |  146 +
 src/ocaml/typing/410+multicore/typeopt.ml     |  140 +
 src/ocaml/typing/410+multicore/typeopt.mli    |   26 +
 src/ocaml/typing/410+multicore/types.ml       |  385 ++
 src/ocaml/typing/410+multicore/types.mli      |  520 ++
 src/ocaml/typing/410+multicore/typetexp.ml    |  813 +++
 src/ocaml/typing/410+multicore/typetexp.mli   |   76 +
 src/ocaml/typing/410+multicore/untypeast.ml   |  898 +++
 src/ocaml/typing/410+multicore/untypeast.mli  |   89 +
 86 files changed, 48202 insertions(+)
 create mode 100644 src/ocaml/typing/410+multicore/annot.mli
 create mode 100644 src/ocaml/typing/410+multicore/btype.ml
 create mode 100644 src/ocaml/typing/410+multicore/btype.mli
 create mode 100644 src/ocaml/typing/410+multicore/cmi_format.ml
 create mode 100644 src/ocaml/typing/410+multicore/cmi_format.mli
 create mode 100644 src/ocaml/typing/410+multicore/cmt_format.ml
 create mode 100644 src/ocaml/typing/410+multicore/cmt_format.mli
 create mode 100644 src/ocaml/typing/410+multicore/ctype.ml
 create mode 100644 src/ocaml/typing/410+multicore/ctype.mli
 create mode 100644 src/ocaml/typing/410+multicore/datarepr.ml
 create mode 100644 src/ocaml/typing/410+multicore/datarepr.mli
 create mode 100644 src/ocaml/typing/410+multicore/env.ml
 create mode 100644 src/ocaml/typing/410+multicore/env.mli
 create mode 100644 src/ocaml/typing/410+multicore/ident.ml
 create mode 100644 src/ocaml/typing/410+multicore/ident.mli
 create mode 100644 src/ocaml/typing/410+multicore/includeclass.ml
 create mode 100644 src/ocaml/typing/410+multicore/includeclass.mli
 create mode 100644 src/ocaml/typing/410+multicore/includecore.ml
 create mode 100644 src/ocaml/typing/410+multicore/includecore.mli
 create mode 100644 src/ocaml/typing/410+multicore/includemod.ml
 create mode 100644 src/ocaml/typing/410+multicore/includemod.mli
 create mode 100644 src/ocaml/typing/410+multicore/mtype.ml
 create mode 100644 src/ocaml/typing/410+multicore/mtype.mli
 create mode 100644 src/ocaml/typing/410+multicore/oprint.ml
 create mode 100644 src/ocaml/typing/410+multicore/oprint.mli
 create mode 100644 src/ocaml/typing/410+multicore/outcometree.mli
 create mode 100644 src/ocaml/typing/410+multicore/parmatch.ml
 create mode 100644 src/ocaml/typing/410+multicore/parmatch.mli
 create mode 100644 src/ocaml/typing/410+multicore/path.ml
 create mode 100644 src/ocaml/typing/410+multicore/path.mli
 create mode 100644 src/ocaml/typing/410+multicore/persistent_env.ml
 create mode 100644 src/ocaml/typing/410+multicore/persistent_env.mli
 create mode 100644 src/ocaml/typing/410+multicore/predef.ml
 create mode 100644 src/ocaml/typing/410+multicore/predef.mli
 create mode 100644 src/ocaml/typing/410+multicore/primitive.ml
 create mode 100644 src/ocaml/typing/410+multicore/primitive.mli
 create mode 100644 src/ocaml/typing/410+multicore/printpat.ml
 create mode 100644 src/ocaml/typing/410+multicore/printpat.mli
 create mode 100644 src/ocaml/typing/410+multicore/printtyp.ml
 create mode 100644 src/ocaml/typing/410+multicore/printtyp.mli
 create mode 100644 src/ocaml/typing/410+multicore/printtyped.ml
 create mode 100644 src/ocaml/typing/410+multicore/printtyped.mli
 create mode 100644 src/ocaml/typing/410+multicore/rec_check.ml
 create mode 100644 src/ocaml/typing/410+multicore/rec_check.mli
 create mode 100644 src/ocaml/typing/410+multicore/saved_parts.ml
 create mode 100644 src/ocaml/typing/410+multicore/saved_parts.mli
 create mode 100644 src/ocaml/typing/410+multicore/short_paths.ml
 create mode 100644 src/ocaml/typing/410+multicore/short_paths.mli
 create mode 100644 src/ocaml/typing/410+multicore/short_paths_graph.ml
 create mode 100644 src/ocaml/typing/410+multicore/short_paths_graph.mli
 create mode 100644 src/ocaml/typing/410+multicore/stypes.ml
 create mode 100644 src/ocaml/typing/410+multicore/stypes.mli
 create mode 100644 src/ocaml/typing/410+multicore/subst.ml
 create mode 100644 src/ocaml/typing/410+multicore/subst.mli
 create mode 100644 src/ocaml/typing/410+multicore/tast_iterator.ml
 create mode 100644 src/ocaml/typing/410+multicore/tast_iterator.mli
 create mode 100644 src/ocaml/typing/410+multicore/tast_mapper.ml
 create mode 100644 src/ocaml/typing/410+multicore/tast_mapper.mli
 create mode 100644 src/ocaml/typing/410+multicore/type_immediacy.ml
 create mode 100644 src/ocaml/typing/410+multicore/type_immediacy.mli
 create mode 100644 src/ocaml/typing/410+multicore/typeclass.ml
 create mode 100644 src/ocaml/typing/410+multicore/typeclass.mli
 create mode 100644 src/ocaml/typing/410+multicore/typecore.ml
 create mode 100644 src/ocaml/typing/410+multicore/typecore.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedecl.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedecl.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_immediacy.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_immediacy.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_properties.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_properties.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_unboxed.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_unboxed.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_variance.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedecl_variance.mli
 create mode 100644 src/ocaml/typing/410+multicore/typedtree.ml
 create mode 100644 src/ocaml/typing/410+multicore/typedtree.mli
 create mode 100644 src/ocaml/typing/410+multicore/typemod.ml
 create mode 100644 src/ocaml/typing/410+multicore/typemod.mli
 create mode 100644 src/ocaml/typing/410+multicore/typeopt.ml
 create mode 100644 src/ocaml/typing/410+multicore/typeopt.mli
 create mode 100644 src/ocaml/typing/410+multicore/types.ml
 create mode 100644 src/ocaml/typing/410+multicore/types.mli
 create mode 100644 src/ocaml/typing/410+multicore/typetexp.ml
 create mode 100644 src/ocaml/typing/410+multicore/typetexp.mli
 create mode 100644 src/ocaml/typing/410+multicore/untypeast.ml
 create mode 100644 src/ocaml/typing/410+multicore/untypeast.mli

diff --git a/src/ocaml/typing/410+multicore/annot.mli b/src/ocaml/typing/410+multicore/annot.mli
new file mode 100644
index 00000000..3cae8f27
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/annot.mli
@@ -0,0 +1,24 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Damien Doligez, projet Gallium, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Data types for annotations (Stypes.ml) *)
+
+type call = Tail | Stack | Inline;;
+
+type ident =
+  | Iref_internal of Location.t (* defining occurrence *)
+  | Iref_external
+  | Idef of Location.t          (* scope *)
+;;
diff --git a/src/ocaml/typing/410+multicore/btype.ml b/src/ocaml/typing/410+multicore/btype.ml
new file mode 100644
index 00000000..601a5f4e
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/btype.ml
@@ -0,0 +1,839 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*  Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt  *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Basic operations on core types *)
+
+open Asttypes
+open Types
+
+open Local_store.Compiler
+
+(**** Sets, maps and hashtables of types ****)
+
+module TypeSet = Set.Make(TypeOps)
+module TypeMap = Map.Make (TypeOps)
+module TypeHash = Hashtbl.Make(TypeOps)
+
+(**** Forward declarations ****)
+
+let print_raw =
+  ref (fun _ -> assert false : Format.formatter -> type_expr -> unit)
+
+(**** Type level management ****)
+
+let generic_level = Ident.highest_scope
+
+(* Used to mark a type during a traversal. *)
+let lowest_level = Ident.lowest_scope
+let pivot_level = 2 * lowest_level - 1
+    (* pivot_level - lowest_level < lowest_level *)
+
+(**** Some type creators ****)
+
+let new_id = s_ref (-1)
+
+let newty2 level desc  =
+  incr new_id; { desc; level; scope = lowest_level; id = !new_id }
+let newgenty desc      = newty2 generic_level desc
+let newgenvar ?name () = newgenty (Tvar name)
+(*
+let newmarkedvar level =
+  incr new_id; { desc = Tvar; level = pivot_level - level; id = !new_id }
+let newmarkedgenvar () =
+  incr new_id;
+  { desc = Tvar; level = pivot_level - generic_level; id = !new_id }
+*)
+
+(**** Check some types ****)
+
+let is_Tvar = function {desc=Tvar _} -> true | _ -> false
+let is_Tunivar = function {desc=Tunivar _} -> true | _ -> false
+let is_Tconstr = function {desc=Tconstr _} -> true | _ -> false
+
+let dummy_method = "*dummy method*"
+
+(**** Definitions for backtracking ****)
+
+type change =
+    Ctype of type_expr * type_desc
+  | Ccompress of type_expr * type_desc * type_desc
+  | Clevel of type_expr * int
+  | Cscope of type_expr * int
+  | Cname of
+      (Path.t * type_expr list) option ref * (Path.t * type_expr list) option
+  | Crow of row_field option ref * row_field option
+  | Ckind of field_kind option ref * field_kind option
+  | Ccommu of commutable ref * commutable
+  | Cuniv of type_expr option ref * type_expr option
+  | Ctypeset of TypeSet.t ref * TypeSet.t
+  | Cfun of (unit -> unit)
+
+type changes =
+    Change of change * changes ref
+  | Unchanged
+  | Invalid
+
+open Local_store.Compiler
+
+let trail = s_table Weak.create 1
+
+let log_change ch =
+  match Weak.get !trail 0 with None -> ()
+  | Some r ->
+      let r' = ref Unchanged in
+      r := Change (ch, r');
+      Weak.set !trail 0 (Some r')
+
+(**** Representative of a type ****)
+
+let rec field_kind_repr =
+  function
+    Fvar {contents = Some kind} -> field_kind_repr kind
+  | kind                        -> kind
+
+let rec repr_link compress t d =
+ function
+   {desc = Tlink t' as d'} ->
+     repr_link true t d' t'
+ | {desc = Tfield (_, k, _, t') as d'} when field_kind_repr k = Fabsent ->
+     repr_link true t d' t'
+ | t' ->
+     if compress then begin
+       log_change (Ccompress (t, t.desc, d)); t.desc <- d
+     end;
+     t'
+
+let repr t =
+  match t.desc with
+   Tlink t' as d ->
+     repr_link false t d t'
+ | Tfield (_, k, _, t') as d when field_kind_repr k = Fabsent ->
+     repr_link false t d t'
+ | _ -> t
+
+let rec commu_repr = function
+    Clink r when !r <> Cunknown -> commu_repr !r
+  | c -> c
+
+let rec row_field_repr_aux tl = function
+    Reither(_, tl', _, {contents = Some fi}) ->
+      row_field_repr_aux (tl@tl') fi
+  | Reither(c, tl', m, r) ->
+      Reither(c, tl@tl', m, r)
+  | Rpresent (Some _) when tl <> [] ->
+      Rpresent (Some (List.hd tl))
+  | fi -> fi
+
+let row_field_repr fi = row_field_repr_aux [] fi
+
+let rec rev_concat l ll =
+  match ll with
+    [] -> l
+  | l'::ll -> rev_concat (l'@l) ll
+
+let rec row_repr_aux ll row =
+  match (repr row.row_more).desc with
+  | Tvariant row' ->
+      let f = row.row_fields in
+      row_repr_aux (if f = [] then ll else f::ll) row'
+  | _ ->
+      if ll = [] then row else
+      {row with row_fields = rev_concat row.row_fields ll}
+
+let row_repr row = row_repr_aux [] row
+
+let rec row_field tag row =
+  let rec find = function
+    | (tag',f) :: fields ->
+        if tag = tag' then row_field_repr f else find fields
+    | [] ->
+        match repr row.row_more with
+        | {desc=Tvariant row'} -> row_field tag row'
+        | _ -> Rabsent
+  in find row.row_fields
+
+let rec row_more row =
+  match repr row.row_more with
+  | {desc=Tvariant row'} -> row_more row'
+  | ty -> ty
+
+let merge_fixed_explanation fixed1 fixed2 =
+  match fixed1, fixed2 with
+  | Some Univar _ as x, _ | _, (Some Univar _ as x) -> x
+  | Some Fixed_private as x, _ | _, (Some Fixed_private as x) -> x
+  | Some Reified _ as x, _ | _, (Some Reified _ as x) -> x
+  | Some Rigid as x, _ | _, (Some Rigid as x) -> x
+  | None, None -> None
+
+
+let fixed_explanation row =
+  let row = row_repr row in
+  match row.row_fixed with
+  | Some _ as x -> x
+  | None ->
+      let more = repr row.row_more in
+      match more.desc with
+      | Tvar _ | Tnil -> None
+      | Tunivar _ -> Some (Univar more)
+      | Tconstr (p,_,_) -> Some (Reified p)
+      | _ -> assert false
+
+let is_fixed row = match row.row_fixed with
+  | None -> false
+  | Some _ -> true
+
+let row_fixed row = fixed_explanation row <> None
+
+
+let static_row row =
+  let row = row_repr row in
+  row.row_closed &&
+  List.for_all
+    (fun (_,f) -> match row_field_repr f with Reither _ -> false | _ -> true)
+    row.row_fields
+
+let hash_variant s =
+  let accu = ref 0 in
+  for i = 0 to String.length s - 1 do
+    accu := 223 * !accu + Char.code s.[i]
+  done;
+  (* reduce to 31 bits *)
+  accu := !accu land (1 lsl 31 - 1);
+  (* make it signed for 64 bits architectures *)
+  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu
+
+let proxy ty =
+  let ty0 = repr ty in
+  match ty0.desc with
+  | Tvariant row when not (static_row row) ->
+      row_more row
+  | Tobject (ty, _) ->
+      let rec proxy_obj ty =
+        match ty.desc with
+          Tfield (_, _, _, ty) | Tlink ty -> proxy_obj ty
+        | Tvar _ | Tunivar _ | Tconstr _ -> ty
+        | Tnil -> ty0
+        | _ -> assert false
+      in proxy_obj ty
+  | _ -> ty0
+
+(**** Utilities for fixed row private types ****)
+
+let row_of_type t =
+  match (repr t).desc with
+    Tobject(t,_) ->
+      let rec get_row t =
+        let t = repr t in
+        match t.desc with
+          Tfield(_,_,_,t) -> get_row t
+        | _ -> t
+      in get_row t
+  | Tvariant row ->
+      row_more row
+  | _ ->
+      t
+
+let has_constr_row t =
+  not (is_Tconstr t) && is_Tconstr (row_of_type t)
+
+let is_row_name s =
+  let l = String.length s in
+  if l < 4 then false else String.sub s (l-4) 4 = "#row"
+
+let is_constr_row ~allow_ident t =
+  match t.desc with
+    Tconstr (Path.Pident id, _, _) when allow_ident ->
+      is_row_name (Ident.name id)
+  | Tconstr (Path.Pdot (_, s), _, _) -> is_row_name s
+  | _ -> false
+
+
+                  (**********************************)
+                  (*  Utilities for type traversal  *)
+                  (**********************************)
+
+let rec fold_row f init row =
+  let result =
+    List.fold_left
+      (fun init (_, fi) ->
+         match row_field_repr fi with
+         | Rpresent(Some ty) -> f init ty
+         | Reither(_, tl, _, _) -> List.fold_left f init tl
+         | _ -> init)
+      init
+      row.row_fields
+  in
+  match (repr row.row_more).desc with
+    Tvariant row -> fold_row f result row
+  | Tvar _ | Tunivar _ | Tsubst _ | Tconstr _ | Tnil ->
+    begin match
+      Option.map (fun (_,l) -> List.fold_left f result l) row.row_name
+    with
+    | None -> result
+    | Some result -> result
+    end
+  | _ -> assert false
+
+let iter_row f row =
+  fold_row (fun () v -> f v) () row
+
+let fold_type_expr f init ty =
+  match ty.desc with
+    Tvar _              -> init
+  | Tarrow (_, ty1, ty2, _) ->
+    let result = f init ty1 in
+    f result ty2
+  | Ttuple l            -> List.fold_left f init l
+  | Tconstr (_, l, _)   -> List.fold_left f init l
+  | Tobject(ty, {contents = Some (_, p)})
+    ->
+    let result = f init ty in
+    List.fold_left f result p
+  | Tobject (ty, _)     -> f init ty
+  | Tvariant row        ->
+    let result = fold_row f init row in
+    f result (row_more row)
+  | Tfield (_, _, ty1, ty2) ->
+    let result = f init ty1 in
+    f result ty2
+  | Tnil                -> init
+  | Tlink ty            -> f init ty
+  | Tsubst ty           -> f init ty
+  | Tunivar _           -> init
+  | Tpoly (ty, tyl)     ->
+    let result = f init ty in
+    List.fold_left f result tyl
+  | Tpackage (_, _, l)  -> List.fold_left f init l
+
+let iter_type_expr f ty =
+  fold_type_expr (fun () v -> f v) () ty
+
+let rec iter_abbrev f = function
+    Mnil                   -> ()
+  | Mcons(_, _, ty, ty', rem) -> f ty; f ty'; iter_abbrev f rem
+  | Mlink rem              -> iter_abbrev f !rem
+
+type type_iterators =
+  { it_signature: type_iterators -> signature -> unit;
+    it_signature_item: type_iterators -> signature_item -> unit;
+    it_value_description: type_iterators -> value_description -> unit;
+    it_type_declaration: type_iterators -> type_declaration -> unit;
+    it_extension_constructor: type_iterators -> extension_constructor -> unit;
+    it_module_declaration: type_iterators -> module_declaration -> unit;
+    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
+    it_class_declaration: type_iterators -> class_declaration -> unit;
+    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
+    it_functor_param: type_iterators -> functor_parameter -> unit;
+    it_module_type: type_iterators -> module_type -> unit;
+    it_class_type: type_iterators -> class_type -> unit;
+    it_type_kind: type_iterators -> type_kind -> unit;
+    it_do_type_expr: type_iterators -> type_expr -> unit;
+    it_type_expr: type_iterators -> type_expr -> unit;
+    it_path: Path.t -> unit; }
+
+let iter_type_expr_cstr_args f = function
+  | Cstr_tuple tl -> List.iter f tl
+  | Cstr_record lbls -> List.iter (fun d -> f d.ld_type) lbls
+
+let map_type_expr_cstr_args f = function
+  | Cstr_tuple tl -> Cstr_tuple (List.map f tl)
+  | Cstr_record lbls ->
+      Cstr_record (List.map (fun d -> {d with ld_type=f d.ld_type}) lbls)
+
+let iter_type_expr_kind f = function
+  | Type_abstract -> ()
+  | Type_variant cstrs ->
+      List.iter
+        (fun cd ->
+           iter_type_expr_cstr_args f cd.cd_args;
+           Option.iter f cd.cd_res
+        )
+        cstrs
+  | Type_record(lbls, _) ->
+      List.iter (fun d -> f d.ld_type) lbls
+  | Type_open ->
+      ()
+
+
+let type_iterators =
+  let it_signature it =
+    List.iter (it.it_signature_item it)
+  and it_signature_item it = function
+      Sig_value (_, vd, _)          -> it.it_value_description it vd
+    | Sig_type (_, td, _, _)        -> it.it_type_declaration it td
+    | Sig_typext (_, td, _, _)      -> it.it_extension_constructor it td
+    | Sig_module (_, _, md, _, _)   -> it.it_module_declaration it md
+    | Sig_modtype (_, mtd, _)       -> it.it_modtype_declaration it mtd
+    | Sig_class (_, cd, _, _)       -> it.it_class_declaration it cd
+    | Sig_class_type (_, ctd, _, _) -> it.it_class_type_declaration it ctd
+  and it_value_description it vd =
+    it.it_type_expr it vd.val_type
+  and it_type_declaration it td =
+    List.iter (it.it_type_expr it) td.type_params;
+    Option.iter (it.it_type_expr it) td.type_manifest;
+    it.it_type_kind it td.type_kind
+  and it_extension_constructor it td =
+    it.it_path td.ext_type_path;
+    List.iter (it.it_type_expr it) td.ext_type_params;
+    iter_type_expr_cstr_args (it.it_type_expr it) td.ext_args;
+    Option.iter (it.it_type_expr it) td.ext_ret_type
+  and it_module_declaration it md =
+    it.it_module_type it md.md_type
+  and it_modtype_declaration it mtd =
+    Option.iter (it.it_module_type it) mtd.mtd_type
+  and it_class_declaration it cd =
+    List.iter (it.it_type_expr it) cd.cty_params;
+    it.it_class_type it cd.cty_type;
+    Option.iter (it.it_type_expr it) cd.cty_new;
+    it.it_path cd.cty_path
+  and it_class_type_declaration it ctd =
+    List.iter (it.it_type_expr it) ctd.clty_params;
+    it.it_class_type it ctd.clty_type;
+    it.it_path ctd.clty_path
+  and it_functor_param it = function
+    | Unit -> ()
+    | Named (_, mt) -> it.it_module_type it mt
+  and it_module_type it = function
+      Mty_ident p
+    | Mty_alias p -> it.it_path p
+    | Mty_signature sg -> it.it_signature it sg
+    | Mty_functor (p, mt) ->
+        it.it_functor_param it p;
+        it.it_module_type it mt
+  and it_class_type it = function
+      Cty_constr (p, tyl, cty) ->
+        it.it_path p;
+        List.iter (it.it_type_expr it) tyl;
+        it.it_class_type it cty
+    | Cty_signature cs ->
+        it.it_type_expr it cs.csig_self;
+        Vars.iter (fun _ (_,_,ty) -> it.it_type_expr it ty) cs.csig_vars;
+        List.iter
+          (fun (p, tl) -> it.it_path p; List.iter (it.it_type_expr it) tl)
+          cs.csig_inher
+    | Cty_arrow  (_, ty, cty) ->
+        it.it_type_expr it ty;
+        it.it_class_type it cty
+  and it_type_kind it kind =
+    iter_type_expr_kind (it.it_type_expr it) kind
+  and it_do_type_expr it ty =
+    iter_type_expr (it.it_type_expr it) ty;
+    match ty.desc with
+      Tconstr (p, _, _)
+    | Tobject (_, {contents=Some (p, _)})
+    | Tpackage (p, _, _) ->
+        it.it_path p
+    | Tvariant row ->
+        Option.iter (fun (p,_) -> it.it_path p) (row_repr row).row_name
+    | _ -> ()
+  and it_path _p = ()
+  in
+  { it_path; it_type_expr = it_do_type_expr; it_do_type_expr;
+    it_type_kind; it_class_type; it_functor_param; it_module_type;
+    it_signature; it_class_type_declaration; it_class_declaration;
+    it_modtype_declaration; it_module_declaration; it_extension_constructor;
+    it_type_declaration; it_value_description; it_signature_item; }
+
+let copy_row f fixed row keep more =
+  let fields = List.map
+      (fun (l, fi) -> l,
+        match row_field_repr fi with
+        | Rpresent(Some ty) -> Rpresent(Some(f ty))
+        | Reither(c, tl, m, e) ->
+            let e = if keep then e else ref None in
+            let m = if is_fixed row then fixed else m in
+            let tl = List.map f tl in
+            Reither(c, tl, m, e)
+        | _ -> fi)
+      row.row_fields in
+  let name =
+    match row.row_name with
+    | None -> None
+    | Some (path, tl) -> Some (path, List.map f tl) in
+  let row_fixed = if fixed then row.row_fixed else None in
+  { row_fields = fields; row_more = more;
+    row_bound = (); row_fixed;
+    row_closed = row.row_closed; row_name = name; }
+
+let rec copy_kind = function
+    Fvar{contents = Some k} -> copy_kind k
+  | Fvar _   -> Fvar (ref None)
+  | Fpresent -> Fpresent
+  | Fabsent  -> assert false
+
+let copy_commu c =
+  if commu_repr c = Cok then Cok else Clink (ref Cunknown)
+
+(* Since univars may be used as row variables, we need to do some
+   encoding during substitution *)
+let rec norm_univar ty =
+  match ty.desc with
+    Tunivar _ | Tsubst _ -> ty
+  | Tlink ty           -> norm_univar ty
+  | Ttuple (ty :: _)   -> norm_univar ty
+  | _                  -> assert false
+
+let rec copy_type_desc ?(keep_names=false) f = function
+    Tvar _ as ty        -> if keep_names then ty else Tvar None
+  | Tarrow (p, ty1, ty2, c)-> Tarrow (p, f ty1, f ty2, copy_commu c)
+  | Ttuple l            -> Ttuple (List.map f l)
+  | Tconstr (p, l, _)   -> Tconstr (p, List.map f l, ref Mnil)
+  | Tobject(ty, {contents = Some (p, tl)})
+                        -> Tobject (f ty, ref (Some(p, List.map f tl)))
+  | Tobject (ty, _)     -> Tobject (f ty, ref None)
+  | Tvariant _          -> assert false (* too ambiguous *)
+  | Tfield (p, k, ty1, ty2) -> (* the kind is kept shared *)
+      Tfield (p, field_kind_repr k, f ty1, f ty2)
+  | Tnil                -> Tnil
+  | Tlink ty            -> copy_type_desc f ty.desc
+  | Tsubst _            -> assert false
+  | Tunivar _ as ty     -> ty (* always keep the name *)
+  | Tpoly (ty, tyl)     ->
+      let tyl = List.map (fun x -> norm_univar (f x)) tyl in
+      Tpoly (f ty, tyl)
+  | Tpackage (p, n, l)  -> Tpackage (p, n, List.map f l)
+
+(* Utilities for copying *)
+
+module For_copy : sig
+  type copy_scope
+
+  val save_desc: copy_scope -> type_expr -> type_desc -> unit
+
+  val dup_kind: copy_scope -> field_kind option ref -> unit
+
+  val with_scope: (copy_scope -> 'a) -> 'a
+end = struct
+  type copy_scope = {
+    mutable saved_desc : (type_expr * type_desc) list;
+    (* Save association of generic nodes with their description. *)
+
+    mutable saved_kinds: field_kind option ref list;
+    (* duplicated kind variables *)
+
+    mutable new_kinds  : field_kind option ref list;
+    (* new kind variables *)
+  }
+
+  let save_desc copy_scope ty desc =
+    copy_scope.saved_desc <- (ty, desc) :: copy_scope.saved_desc
+
+  let dup_kind copy_scope r =
+    assert (Option.is_none !r);
+    if not (List.memq r copy_scope.new_kinds) then begin
+      copy_scope.saved_kinds <- r :: copy_scope.saved_kinds;
+      let r' = ref None in
+      copy_scope.new_kinds <- r' :: copy_scope.new_kinds;
+      r := Some (Fvar r')
+    end
+
+  (* Restore type descriptions. *)
+  let cleanup { saved_desc; saved_kinds; _ } =
+    List.iter (fun (ty, desc) -> ty.desc <- desc) saved_desc;
+    List.iter (fun r -> r := None) saved_kinds
+
+  let with_scope f =
+    let scope = { saved_desc = []; saved_kinds = []; new_kinds = [] } in
+    let res = f scope in
+    cleanup scope;
+    res
+end
+
+(* Mark a type. *)
+let rec mark_type ty =
+  let ty = repr ty in
+  if ty.level >= lowest_level then begin
+    ty.level <- pivot_level - ty.level;
+    iter_type_expr mark_type ty
+  end
+
+let mark_type_node ty =
+  let ty = repr ty in
+  if ty.level >= lowest_level then begin
+    ty.level <- pivot_level - ty.level;
+  end
+
+let mark_type_params ty =
+  iter_type_expr mark_type ty
+
+let type_iterators =
+  let it_type_expr it ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      mark_type_node ty;
+      it.it_do_type_expr it ty;
+    end
+  in
+  {type_iterators with it_type_expr}
+
+
+(* Remove marks from a type. *)
+let rec unmark_type ty =
+  let ty = repr ty in
+  if ty.level < lowest_level then begin
+    ty.level <- pivot_level - ty.level;
+    iter_type_expr unmark_type ty
+  end
+
+let unmark_iterators =
+  let it_type_expr _it ty = unmark_type ty in
+  {type_iterators with it_type_expr}
+
+let unmark_type_decl decl =
+  unmark_iterators.it_type_declaration unmark_iterators decl
+
+let unmark_extension_constructor ext =
+  List.iter unmark_type ext.ext_type_params;
+  iter_type_expr_cstr_args unmark_type ext.ext_args;
+  Option.iter unmark_type ext.ext_ret_type
+
+let unmark_class_signature sign =
+  unmark_type sign.csig_self;
+  Vars.iter (fun _l (_m, _v, t) -> unmark_type t) sign.csig_vars
+
+let unmark_class_type cty =
+  unmark_iterators.it_class_type unmark_iterators cty
+
+
+                  (*******************************************)
+                  (*  Memorization of abbreviation expansion *)
+                  (*******************************************)
+
+(* Search whether the expansion has been memorized. *)
+
+let lte_public p1 p2 =  (* Private <= Public *)
+  match p1, p2 with
+  | Private, _ | _, Public -> true
+  | Public, Private -> false
+
+let rec find_expans priv p1 = function
+    Mnil -> None
+  | Mcons (priv', p2, _ty0, ty, _)
+    when lte_public priv priv' && Path.same p1 p2 -> Some ty
+  | Mcons (_, _, _, _, rem)   -> find_expans priv p1 rem
+  | Mlink {contents = rem} -> find_expans priv p1 rem
+
+(* debug: check for cycles in abbreviation. only works with -principal
+let rec check_expans visited ty =
+  let ty = repr ty in
+  assert (not (List.memq ty visited));
+  match ty.desc with
+    Tconstr (path, args, abbrev) ->
+      begin match find_expans path !abbrev with
+        Some ty' -> check_expans (ty :: visited) ty'
+      | None -> ()
+      end
+  | _ -> ()
+*)
+
+let memo = ref []
+        (* Contains the list of saved abbreviation expansions. *)
+
+let cleanup_abbrev () =
+        (* Remove all memorized abbreviation expansions. *)
+  List.iter (fun abbr -> abbr := Mnil) !memo;
+  memo := []
+
+let memorize_abbrev mem priv path v v' =
+        (* Memorize the expansion of an abbreviation. *)
+  mem := Mcons (priv, path, v, v', !mem);
+  (* check_expans [] v; *)
+  memo := mem :: !memo
+
+let rec forget_abbrev_rec mem path =
+  match mem with
+    Mnil ->
+      mem
+  | Mcons (_, path', _, _, rem) when Path.same path path' ->
+      rem
+  | Mcons (priv, path', v, v', rem) ->
+      Mcons (priv, path', v, v', forget_abbrev_rec rem path)
+  | Mlink mem' ->
+      mem' := forget_abbrev_rec !mem' path;
+      raise Exit
+
+let forget_abbrev mem path =
+  try mem := forget_abbrev_rec !mem path with Exit -> ()
+
+(* debug: check for invalid abbreviations
+let rec check_abbrev_rec = function
+    Mnil -> true
+  | Mcons (_, ty1, ty2, rem) ->
+      repr ty1 != repr ty2
+  | Mlink mem' ->
+      check_abbrev_rec !mem'
+
+let check_memorized_abbrevs () =
+  List.for_all (fun mem -> check_abbrev_rec !mem) !memo
+*)
+
+                  (**********************************)
+                  (*  Utilities for labels          *)
+                  (**********************************)
+
+let is_optional = function Optional _ -> true | _ -> false
+
+let label_name = function
+    Nolabel -> ""
+  | Labelled s
+  | Optional s -> s
+
+let prefixed_label_name = function
+    Nolabel -> ""
+  | Labelled s -> "~" ^ s
+  | Optional s -> "?" ^ s
+
+let rec extract_label_aux hd l = function
+    [] -> raise Not_found
+  | (l',t as p) :: ls ->
+      if label_name l' = l then (l', t, List.rev hd, ls)
+      else extract_label_aux (p::hd) l ls
+
+let extract_label l ls = extract_label_aux [] l ls
+
+
+                  (**********************************)
+                  (*  Utilities for backtracking    *)
+                  (**********************************)
+
+let undo_change = function
+    Ctype  (ty, desc) -> ty.desc <- desc
+  | Ccompress  (ty, desc, _) -> ty.desc <- desc
+  | Clevel (ty, level) -> ty.level <- level
+  | Cscope (ty, scope) -> ty.scope <- scope
+  | Cname  (r, v) -> r := v
+  | Crow   (r, v) -> r := v
+  | Ckind  (r, v) -> r := v
+  | Ccommu (r, v) -> r := v
+  | Cuniv  (r, v) -> r := v
+  | Ctypeset (r, v) -> r := v
+  | Cfun f -> f ()
+
+type snapshot = changes ref * int
+let last_snapshot = s_ref 0
+let linked_variables = s_ref 0
+
+let log_type ty =
+  if ty.id <= !last_snapshot then log_change (Ctype (ty, ty.desc))
+let link_type ty ty' =
+  log_type ty;
+  let desc = ty.desc in
+  (match desc with
+   | Tvar _ -> incr linked_variables
+   | _ -> ());
+  ty.desc <- Tlink ty';
+  (* Name is a user-supplied name for this unification variable (obtained
+   * through a type annotation for instance). *)
+  match desc, ty'.desc with
+    Tvar name, Tvar name' ->
+      begin match name, name' with
+      | Some _, None ->  log_type ty'; ty'.desc <- Tvar name
+      | None, Some _ ->  ()
+      | Some _, Some _ ->
+          if ty.level < ty'.level then (log_type ty'; ty'.desc <- Tvar name)
+      | None, None   ->  ()
+      end
+  | _ -> ()
+  (* ; assert (check_memorized_abbrevs ()) *)
+  (*  ; check_expans [] ty' *)
+let set_type_desc ty td =
+  if td != ty.desc then begin
+    log_type ty;
+    ty.desc <- td
+  end
+let set_level ty level =
+  if level <> ty.level then begin
+    if ty.id <= !last_snapshot then log_change (Clevel (ty, ty.level));
+    ty.level <- level
+  end
+let set_scope ty scope =
+  if scope <> ty.scope then begin
+    if ty.id <= !last_snapshot then log_change (Cscope (ty, ty.scope));
+    ty.scope <- scope
+  end
+let set_univar rty ty =
+  log_change (Cuniv (rty, !rty)); rty := Some ty
+let set_name nm v =
+  log_change (Cname (nm, !nm)); nm := v
+let set_row_field e v =
+  log_change (Crow (e, !e)); e := Some v
+let set_kind rk k =
+  log_change (Ckind (rk, !rk)); rk := Some k
+let set_commu rc c =
+  log_change (Ccommu (rc, !rc)); rc := c
+let set_typeset rs s =
+  log_change (Ctypeset (rs, !rs)); rs := s
+
+let snapshot () =
+  let old = !last_snapshot in
+  last_snapshot := !new_id;
+  match Weak.get !trail 0 with Some r -> (r, old)
+  | None ->
+      let r = ref Unchanged in
+      Weak.set !trail 0 (Some r);
+      (r, old)
+
+let rec rev_log accu = function
+    Unchanged -> accu
+  | Invalid -> assert false
+  | Change (ch, next) ->
+      let d = !next in
+      next := Invalid;
+      rev_log (ch::accu) d
+
+let backtrack (changes, old) =
+  match !changes with
+    Unchanged -> last_snapshot := old
+  | Invalid -> failwith "Btype.backtrack"
+  | Change _ as change ->
+      cleanup_abbrev ();
+      let backlog = rev_log [] change in
+      List.iter undo_change backlog;
+      changes := Unchanged;
+      last_snapshot := old;
+      Weak.set !trail 0 (Some changes)
+
+let rec rev_compress_log log r =
+  match !r with
+    Unchanged | Invalid ->
+      log
+  | Change (Ccompress _, next) ->
+      rev_compress_log (r::log) next
+  | Change (_, next) ->
+      rev_compress_log log next
+
+let undo_compress (changes, _old) =
+  match !changes with
+    Unchanged
+  | Invalid -> ()
+  | Change _ ->
+      let log = rev_compress_log [] changes in
+      List.iter
+        (fun r -> match !r with
+          Change (Ccompress (ty, desc, d), next) when ty.desc == d ->
+            ty.desc <- desc; r := !next
+        | _ -> ())
+        log
+
+let is_valid (changes, _old) =
+  match !changes with
+  | Invalid -> false
+  | _ -> true
+
+let on_backtrack f =
+  log_change (Cfun f)
+
+let linked_variables () =
+  !linked_variables
diff --git a/src/ocaml/typing/410+multicore/btype.mli b/src/ocaml/typing/410+multicore/btype.mli
new file mode 100644
index 00000000..3c9ddc36
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/btype.mli
@@ -0,0 +1,262 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Basic operations on core types *)
+
+open Asttypes
+open Types
+
+(**** Sets, maps and hashtables of types ****)
+
+module TypeSet  : Set.S with type elt = type_expr
+module TypeMap  : Map.S with type key = type_expr
+module TypeHash : Hashtbl.S with type key = type_expr
+
+(**** Levels ****)
+
+val generic_level: int
+
+val newty2: int -> type_desc -> type_expr
+        (* Create a type *)
+val newgenty: type_desc -> type_expr
+        (* Create a generic type *)
+val newgenvar: ?name:string -> unit -> type_expr
+        (* Return a fresh generic variable *)
+
+(* Use Tsubst instead
+val newmarkedvar: int -> type_expr
+        (* Return a fresh marked variable *)
+val newmarkedgenvar: unit -> type_expr
+        (* Return a fresh marked generic variable *)
+*)
+
+(**** Types ****)
+
+val is_Tvar: type_expr -> bool
+val is_Tunivar: type_expr -> bool
+val is_Tconstr: type_expr -> bool
+val dummy_method: label
+
+val repr: type_expr -> type_expr
+        (* Return the canonical representative of a type. *)
+
+val field_kind_repr: field_kind -> field_kind
+        (* Return the canonical representative of an object field
+           kind. *)
+
+val commu_repr: commutable -> commutable
+        (* Return the canonical representative of a commutation lock *)
+
+(**** polymorphic variants ****)
+
+val row_repr: row_desc -> row_desc
+        (* Return the canonical representative of a row description *)
+val row_field_repr: row_field -> row_field
+val row_field: label -> row_desc -> row_field
+        (* Return the canonical representative of a row field *)
+val row_more: row_desc -> type_expr
+        (* Return the extension variable of the row *)
+
+val is_fixed: row_desc -> bool
+(* Return whether the row is directly marked as fixed or not *)
+
+val row_fixed: row_desc -> bool
+(* Return whether the row should be treated as fixed or not.
+   In particular, [is_fixed row] implies [row_fixed row].
+*)
+
+val fixed_explanation: row_desc -> fixed_explanation option
+(* Return the potential explanation for the fixed row *)
+
+val merge_fixed_explanation:
+  fixed_explanation option -> fixed_explanation option
+  -> fixed_explanation option
+(* Merge two explanations for a fixed row *)
+
+val static_row: row_desc -> bool
+        (* Return whether the row is static or not *)
+val hash_variant: label -> int
+        (* Hash function for variant tags *)
+
+val proxy: type_expr -> type_expr
+        (* Return the proxy representative of the type: either itself
+           or a row variable *)
+
+(**** Utilities for private abbreviations with fixed rows ****)
+val row_of_type: type_expr -> type_expr
+val has_constr_row: type_expr -> bool
+val is_row_name: string -> bool
+val is_constr_row: allow_ident:bool -> type_expr -> bool
+
+(**** Utilities for type traversal ****)
+
+val iter_type_expr: (type_expr -> unit) -> type_expr -> unit
+        (* Iteration on types *)
+val fold_type_expr: ('a -> type_expr -> 'a) -> 'a -> type_expr -> 'a
+val iter_row: (type_expr -> unit) -> row_desc -> unit
+        (* Iteration on types in a row *)
+val fold_row: ('a -> type_expr -> 'a) -> 'a -> row_desc -> 'a
+val iter_abbrev: (type_expr -> unit) -> abbrev_memo -> unit
+        (* Iteration on types in an abbreviation list *)
+
+type type_iterators =
+  { it_signature: type_iterators -> signature -> unit;
+    it_signature_item: type_iterators -> signature_item -> unit;
+    it_value_description: type_iterators -> value_description -> unit;
+    it_type_declaration: type_iterators -> type_declaration -> unit;
+    it_extension_constructor: type_iterators -> extension_constructor -> unit;
+    it_module_declaration: type_iterators -> module_declaration -> unit;
+    it_modtype_declaration: type_iterators -> modtype_declaration -> unit;
+    it_class_declaration: type_iterators -> class_declaration -> unit;
+    it_class_type_declaration: type_iterators -> class_type_declaration -> unit;
+    it_functor_param: type_iterators -> functor_parameter -> unit;
+    it_module_type: type_iterators -> module_type -> unit;
+    it_class_type: type_iterators -> class_type -> unit;
+    it_type_kind: type_iterators -> type_kind -> unit;
+    it_do_type_expr: type_iterators -> type_expr -> unit;
+    it_type_expr: type_iterators -> type_expr -> unit;
+    it_path: Path.t -> unit; }
+val type_iterators: type_iterators
+        (* Iteration on arbitrary type information.
+           [it_type_expr] calls [mark_type_node] to avoid loops. *)
+val unmark_iterators: type_iterators
+        (* Unmark any structure containing types. See [unmark_type] below. *)
+
+val copy_type_desc:
+    ?keep_names:bool -> (type_expr -> type_expr) -> type_desc -> type_desc
+        (* Copy on types *)
+val copy_row:
+    (type_expr -> type_expr) ->
+    bool -> row_desc -> bool -> type_expr -> row_desc
+val copy_kind: field_kind -> field_kind
+
+module For_copy : sig
+
+  type copy_scope
+        (* The private state that the primitives below are mutating, it should
+           remain scoped within a single [with_scope] call.
+
+           While it is possible to circumvent that discipline in various
+           ways, you should NOT do that. *)
+
+  val save_desc: copy_scope -> type_expr -> type_desc -> unit
+        (* Save a type description *)
+
+  val dup_kind: copy_scope -> field_kind option ref -> unit
+        (* Save a None field_kind, and make it point to a fresh Fvar *)
+
+  val with_scope: (copy_scope -> 'a) -> 'a
+        (* [with_scope f] calls [f] and restores saved type descriptions
+           before returning its result. *)
+end
+
+val lowest_level: int
+        (* Marked type: ty.level < lowest_level *)
+val pivot_level: int
+        (* Type marking: ty.level <- pivot_level - ty.level *)
+val mark_type: type_expr -> unit
+        (* Mark a type *)
+val mark_type_node: type_expr -> unit
+        (* Mark a type node (but not its sons) *)
+val mark_type_params: type_expr -> unit
+        (* Mark the sons of a type node *)
+val unmark_type: type_expr -> unit
+val unmark_type_decl: type_declaration -> unit
+val unmark_extension_constructor: extension_constructor -> unit
+val unmark_class_type: class_type -> unit
+val unmark_class_signature: class_signature -> unit
+        (* Remove marks from a type *)
+
+(**** Memorization of abbreviation expansion ****)
+
+val find_expans: private_flag -> Path.t -> abbrev_memo -> type_expr option
+        (* Look up a memorized abbreviation *)
+val cleanup_abbrev: unit -> unit
+        (* Flush the cache of abbreviation expansions.
+           When some types are saved (using [output_value]), this
+           function MUST be called just before. *)
+val memorize_abbrev:
+        abbrev_memo ref ->
+        private_flag -> Path.t -> type_expr -> type_expr -> unit
+        (* Add an expansion in the cache *)
+val forget_abbrev:
+        abbrev_memo ref -> Path.t -> unit
+        (* Remove an abbreviation from the cache *)
+
+(**** Utilities for labels ****)
+
+val is_optional : arg_label -> bool
+val label_name : arg_label -> label
+
+(* Returns the label name with first character '?' or '~' as appropriate. *)
+val prefixed_label_name : arg_label -> label
+
+val extract_label :
+    label -> (arg_label * 'a) list ->
+    arg_label * 'a * (arg_label * 'a) list * (arg_label * 'a) list
+    (* actual label, value, before list, after list *)
+
+(**** Utilities for backtracking ****)
+
+type snapshot
+        (* A snapshot for backtracking *)
+val snapshot: unit -> snapshot
+        (* Make a snapshot for later backtracking. Costs nothing *)
+val backtrack: snapshot -> unit
+        (* Backtrack to a given snapshot. Only possible if you have
+           not already backtracked to a previous snapshot.
+           Calls [cleanup_abbrev] internally *)
+val undo_compress: snapshot -> unit
+        (* Backtrack only path compression. Only meaningful if you have
+           not already backtracked to a previous snapshot.
+           Does not call [cleanup_abbrev] *)
+
+(* Functions to use when modifying a type (only Ctype?) *)
+val link_type: type_expr -> type_expr -> unit
+        (* Set the desc field of [t1] to [Tlink t2], logging the old
+           value if there is an active snapshot *)
+val set_type_desc: type_expr -> type_desc -> unit
+        (* Set directly the desc field, without sharing *)
+val set_level: type_expr -> int -> unit
+val set_scope: type_expr -> int -> unit
+val set_name:
+    (Path.t * type_expr list) option ref ->
+    (Path.t * type_expr list) option -> unit
+val set_row_field: row_field option ref -> row_field -> unit
+val set_univar: type_expr option ref -> type_expr -> unit
+val set_kind: field_kind option ref -> field_kind -> unit
+val set_commu: commutable ref -> commutable -> unit
+val set_typeset: TypeSet.t ref -> TypeSet.t -> unit
+        (* Set references, logging the old value *)
+
+(**** Forward declarations ****)
+val print_raw: (Format.formatter -> type_expr -> unit) ref
+
+val iter_type_expr_kind: (type_expr -> unit) -> (type_kind -> unit)
+
+val iter_type_expr_cstr_args: (type_expr -> unit) ->
+  (constructor_arguments -> unit)
+val map_type_expr_cstr_args: (type_expr -> type_expr) ->
+  (constructor_arguments -> constructor_arguments)
+
+(** merlin: check if a snapshot has been invalidated *)
+val is_valid: snapshot -> bool
+
+(** merlin: also register changes to arbitrary references *)
+val on_backtrack: (unit -> unit) -> unit
+
+(** merlin: Number of unification variables that have been linked so far.
+   Used to estimate the "cost" of unification. *)
+val linked_variables: unit -> int
diff --git a/src/ocaml/typing/410+multicore/cmi_format.ml b/src/ocaml/typing/410+multicore/cmi_format.ml
new file mode 100644
index 00000000..5913b168
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/cmi_format.ml
@@ -0,0 +1,81 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Fabrice Le Fessant, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Misc
+
+type pers_flags =
+  | Rectypes
+  | Alerts of alerts
+  | Opaque
+  | Unsafe_string
+
+type cmi_infos = {
+    cmi_name : Misc.modname;
+    cmi_sign : Types.signature_item list;
+    cmi_crcs : crcs;
+    cmi_flags : pers_flags list;
+}
+
+let input_cmi ic =
+  let (name, sign) = input_value ic in
+  let crcs = input_value ic in
+  let flags = input_value ic in
+  {
+      cmi_name = name;
+      cmi_sign = sign;
+      cmi_crcs = crcs;
+      cmi_flags = flags;
+    }
+
+let read_cmi filename =
+  let open Magic_numbers.Cmi in
+  let ic = open_in_bin filename in
+  try
+    let buffer =
+      really_input_string ic (String.length Config.cmi_magic_number)
+    in
+    if buffer <> Config.cmi_magic_number then begin
+      close_in ic;
+      let pre_len = String.length Config.cmi_magic_number - 3 in
+      if String.sub buffer 0 pre_len
+          = String.sub Config.cmi_magic_number 0 pre_len then
+      begin
+        raise (Error (Wrong_version_interface (filename, buffer)))
+      end else begin
+        raise(Error(Not_an_interface filename))
+      end
+    end;
+    let cmi = input_cmi ic in
+    close_in ic;
+    cmi
+  with End_of_file | Failure _ ->
+      close_in ic;
+      raise(Error(Corrupted_interface(filename)))
+    | Error e ->
+      close_in ic;
+      raise (Error e)
+
+let output_cmi filename oc cmi =
+(* beware: the provided signature must have been substituted for saving *)
+  output_string oc Config.cmi_magic_number;
+  output_value oc (cmi.cmi_name, cmi.cmi_sign);
+  flush oc;
+  let crc = Digest.file filename in
+  let crcs = (cmi.cmi_name, Some crc) :: cmi.cmi_crcs in
+  output_value oc crcs;
+  output_value oc cmi.cmi_flags;
+  crc
+
+(* Error report moved to src/ocaml/typing/magic_numbers.ml *)
diff --git a/src/ocaml/typing/410+multicore/cmi_format.mli b/src/ocaml/typing/410+multicore/cmi_format.mli
new file mode 100644
index 00000000..2ce923f9
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/cmi_format.mli
@@ -0,0 +1,40 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Fabrice Le Fessant, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Misc
+
+type pers_flags =
+  | Rectypes
+  | Alerts of alerts
+  | Opaque
+  | Unsafe_string
+
+type cmi_infos = {
+    cmi_name : modname;
+    cmi_sign : Types.signature_item list;
+    cmi_crcs : crcs;
+    cmi_flags : pers_flags list;
+}
+
+(* write the magic + the cmi information *)
+val output_cmi : string -> out_channel -> cmi_infos -> Digest.t
+
+(* read the cmi information (the magic is supposed to have already been read) *)
+val input_cmi : in_channel -> cmi_infos
+
+(* read a cmi from a filename, checking the magic *)
+val read_cmi : string -> cmi_infos
+
+(* Error report moved to {!Magic_numbers.Cmi} *)
diff --git a/src/ocaml/typing/410+multicore/cmt_format.ml b/src/ocaml/typing/410+multicore/cmt_format.ml
new file mode 100644
index 00000000..d4f2b2b8
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/cmt_format.ml
@@ -0,0 +1,197 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Fabrice Le Fessant, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Std
+open Cmi_format
+open Typedtree
+
+(* Note that in Typerex, there is an awful hack to save a cmt file
+   together with the interface file that was generated by ocaml (this
+   is because the installed version of ocaml might differ from the one
+   integrated in Typerex).
+*)
+
+
+
+let read_magic_number ic =
+  let len_magic_number = String.length Config.cmt_magic_number in
+  really_input_string ic len_magic_number
+
+type binary_annots =
+  | Packed of Types.signature * string list
+  | Implementation of structure
+  | Interface of signature
+  | Partial_implementation of binary_part array
+  | Partial_interface of binary_part array
+
+and binary_part =
+| Partial_structure of structure
+| Partial_structure_item of structure_item
+| Partial_expression of expression
+| Partial_pattern of pattern
+| Partial_class_expr of class_expr
+| Partial_signature of signature
+| Partial_signature_item of signature_item
+| Partial_module_type of module_type
+
+type cmt_infos = {
+  cmt_modname : string;
+  cmt_annots : binary_annots;
+  cmt_value_dependencies :
+    (Types.value_description * Types.value_description) list;
+  cmt_comments : (string * Location.t) list;
+  cmt_args : string array;
+  cmt_sourcefile : string option;
+  cmt_builddir : string;
+  cmt_loadpath : string list;
+  cmt_source_digest : Digest.t option;
+  cmt_initial_env : Env.t;
+  cmt_imports : (string * Digest.t option) list;
+  cmt_interface_digest : Digest.t option;
+  cmt_use_summaries : bool;
+}
+
+type error =
+    Not_a_typedtree of string
+
+let need_to_clear_env =
+  try ignore (Sys.getenv "OCAML_BINANNOT_WITHENV"); false
+  with Not_found -> true
+
+let keep_only_summary = Env.keep_only_summary
+
+open Tast_mapper
+
+let cenv =
+  {Tast_mapper.default with env = fun _sub env -> keep_only_summary env}
+
+let clear_part = function
+  | Partial_structure s -> Partial_structure (cenv.structure cenv s)
+  | Partial_structure_item s ->
+      Partial_structure_item (cenv.structure_item cenv s)
+  | Partial_expression e -> Partial_expression (cenv.expr cenv e)
+  | Partial_pattern p -> Partial_pattern (cenv.pat cenv p)
+  | Partial_class_expr ce -> Partial_class_expr (cenv.class_expr cenv ce)
+  | Partial_signature s -> Partial_signature (cenv.signature cenv s)
+  | Partial_signature_item s ->
+      Partial_signature_item (cenv.signature_item cenv s)
+  | Partial_module_type s -> Partial_module_type (cenv.module_type cenv s)
+
+let clear_env binary_annots =
+  if need_to_clear_env then
+    match binary_annots with
+    | Implementation s -> Implementation (cenv.structure cenv s)
+    | Interface s -> Interface (cenv.signature cenv s)
+    | Packed _ -> binary_annots
+    | Partial_implementation array ->
+        Partial_implementation (Array.map clear_part array)
+    | Partial_interface array ->
+        Partial_interface (Array.map clear_part array)
+
+  else binary_annots
+
+exception Error of error
+
+let input_cmt ic = (input_value ic : cmt_infos)
+
+let output_cmt oc cmt =
+  output_string oc Config.cmt_magic_number;
+  output_value oc (cmt : cmt_infos)
+
+let read filename =
+(*  Printf.fprintf stderr "Cmt_format.read %s\n%!" filename; *)
+  let ic = open_in_bin filename in
+  Misc.try_finally
+    ~always:(fun () -> close_in ic)
+    (fun () ->
+       let magic_number = read_magic_number ic in
+       let cmi, cmt =
+         if magic_number = Config.cmt_magic_number then
+           None, Some (input_cmt ic)
+         else if magic_number = Config.cmi_magic_number then
+           let cmi = Cmi_format.input_cmi ic in
+           let cmt = try
+               let magic_number = read_magic_number ic in
+               if magic_number = Config.cmt_magic_number then
+                 let cmt = input_cmt ic in
+                 Some cmt
+               else None
+             with _ -> None
+           in
+           Some cmi, cmt
+         else
+           raise Magic_numbers.Cmi.(Error(Not_an_interface filename))
+       in
+       cmi, cmt
+    )
+
+let read_cmt filename =
+  match read filename with
+      _, None -> raise (Error (Not_a_typedtree filename))
+    | _, Some cmt -> cmt
+
+let read_cmi filename =
+  match read filename with
+      None, _ ->
+        raise Magic_numbers.Cmi.(Error (Not_an_interface filename))
+    | Some cmi, _ -> cmi
+
+let saved_types = ref []
+let value_deps = ref []
+
+let clear () =
+  saved_types := [];
+  value_deps := []
+
+let add_saved_type b = saved_types := b :: !saved_types
+let get_saved_types () = !saved_types
+let set_saved_types l = saved_types := l
+
+(*let record_value_dependency vd1 vd2 =
+  if vd1.Types.val_loc <> vd2.Types.val_loc then
+    value_deps := (vd1, vd2) :: !value_deps*)
+
+let record_value_dependency _vd1 _vd2 = ()
+
+let save_cmt filename modname binary_annots sourcefile initial_env cmi =
+  if !Clflags.binary_annotations && not !Clflags.print_types then begin
+    Misc.output_to_file_via_temporary
+       ~mode:[Open_binary] filename
+       (fun temp_file_name oc ->
+         let this_crc =
+           match cmi with
+           | None -> None
+           | Some cmi -> Some (output_cmi temp_file_name oc cmi)
+         in
+         let source_digest = Option.map ~f:Digest.file sourcefile in
+         let cmt = {
+           cmt_modname = modname;
+           cmt_annots = clear_env binary_annots;
+           cmt_value_dependencies = !value_deps;
+           cmt_comments = [];
+           cmt_args = Sys.argv;
+           cmt_sourcefile = sourcefile;
+           cmt_builddir = Location.rewrite_absolute_path (Sys.getcwd ());
+           cmt_loadpath = Load_path.get_paths ();
+           cmt_source_digest = source_digest;
+           cmt_initial_env = if need_to_clear_env then
+               keep_only_summary initial_env else initial_env;
+           cmt_imports = List.sort ~cmp:compare (Env.imports ());
+           cmt_interface_digest = this_crc;
+           cmt_use_summaries = need_to_clear_env;
+         } in
+         output_cmt oc cmt)
+  end;
+  clear ()
diff --git a/src/ocaml/typing/410+multicore/cmt_format.mli b/src/ocaml/typing/410+multicore/cmt_format.mli
new file mode 100644
index 00000000..7649de7b
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/cmt_format.mli
@@ -0,0 +1,123 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Fabrice Le Fessant, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2012 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** cmt and cmti files format. *)
+
+open Misc
+
+(** The layout of a cmt file is as follows:
+      <cmt> := \{<cmi>\} <cmt magic> \{cmt infos\} \{<source info>\}
+    where <cmi> is the cmi file format:
+      <cmi> := <cmi magic> <cmi info>.
+    More precisely, the optional <cmi> part must be present if and only if
+    the file is:
+    - a cmti, or
+    - a cmt, for a ml file which has no corresponding mli (hence no
+    corresponding cmti).
+
+    Thus, we provide a common reading function for cmi and cmt(i)
+    files which returns an option for each of the three parts: cmi
+    info, cmt info, source info. *)
+
+open Typedtree
+
+type binary_annots =
+  | Packed of Types.signature * string list
+  | Implementation of structure
+  | Interface of signature
+  | Partial_implementation of binary_part array
+  | Partial_interface of binary_part array
+
+and binary_part =
+  | Partial_structure of structure
+  | Partial_structure_item of structure_item
+  | Partial_expression of expression
+  | Partial_pattern of pattern
+  | Partial_class_expr of class_expr
+  | Partial_signature of signature
+  | Partial_signature_item of signature_item
+  | Partial_module_type of module_type
+
+type cmt_infos = {
+  cmt_modname : modname;
+  cmt_annots : binary_annots;
+  cmt_value_dependencies :
+    (Types.value_description * Types.value_description) list;
+  cmt_comments : (string * Location.t) list;
+  cmt_args : string array;
+  cmt_sourcefile : string option;
+  cmt_builddir : string;
+  cmt_loadpath : string list;
+  cmt_source_digest : string option;
+  cmt_initial_env : Env.t;
+  cmt_imports : crcs;
+  cmt_interface_digest : Digest.t option;
+  cmt_use_summaries : bool;
+}
+
+type error =
+    Not_a_typedtree of string
+
+exception Error of error
+
+(** [read filename] opens filename, and extract both the cmi_infos, if
+    it exists, and the cmt_infos, if it exists. Thus, it can be used
+    with .cmi, .cmt and .cmti files.
+
+    .cmti files always contain a cmi_infos at the beginning. .cmt files
+    only contain a cmi_infos at the beginning if there is no associated
+    .cmti file.
+*)
+val read : string -> Cmi_format.cmi_infos option * cmt_infos option
+
+val read_cmt : string -> cmt_infos
+val read_cmi : string -> Cmi_format.cmi_infos
+
+(** [save_cmt filename modname binary_annots sourcefile initial_env cmi]
+    writes a cmt(i) file.  *)
+val save_cmt :
+  string ->  (* filename.cmt to generate *)
+  string ->  (* module name *)
+  binary_annots ->
+  string option ->  (* source file *)
+  Env.t -> (* initial env *)
+  Cmi_format.cmi_infos option -> (* if a .cmi was generated *)
+  unit
+
+(* Miscellaneous functions *)
+
+val read_magic_number : in_channel -> string
+
+val clear: unit -> unit
+
+val add_saved_type : binary_part -> unit
+val get_saved_types : unit -> binary_part list
+val set_saved_types : binary_part list -> unit
+
+val record_value_dependency:
+  Types.value_description -> Types.value_description -> unit
+
+
+(*
+
+  val is_magic_number : string -> bool
+  val read : in_channel -> Env.cmi_infos option * t
+  val write_magic_number : out_channel -> unit
+  val write : out_channel -> t -> unit
+
+  val find : string list -> string -> string
+  val read_signature : 'a -> string -> Types.signature * 'b list * 'c list
+
+*)
diff --git a/src/ocaml/typing/410+multicore/ctype.ml b/src/ocaml/typing/410+multicore/ctype.ml
new file mode 100644
index 00000000..b38e3c81
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/ctype.ml
@@ -0,0 +1,4825 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*  Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt  *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Operations on core types *)
+
+open Misc
+open Asttypes
+open Types
+open Btype
+
+open Local_store.Compiler
+
+(*
+   Type manipulation after type inference
+   ======================================
+   If one wants to manipulate a type after type inference (for
+   instance, during code generation or in the debugger), one must
+   first make sure that the type levels are correct, using the
+   function [correct_levels]. Then, this type can be correctly
+   manipulated by [apply], [expand_head] and [moregeneral].
+*)
+
+(*
+   General notes
+   =============
+   - As much sharing as possible should be kept : it makes types
+     smaller and better abbreviated.
+     When necessary, some sharing can be lost. Types will still be
+     printed correctly (+++ TO DO...), and abbreviations defined by a
+     class do not depend on sharing thanks to constrained
+     abbreviations. (Of course, even if some sharing is lost, typing
+     will still be correct.)
+   - All nodes of a type have a level : that way, one know whether a
+     node need to be duplicated or not when instantiating a type.
+   - Levels of a type are decreasing (generic level being considered
+     as greatest).
+   - The level of a type constructor is superior to the binding
+     time of its path.
+   - Recursive types without limitation should be handled (even if
+     there is still an occur check). This avoid treating specially the
+     case for objects, for instance. Furthermore, the occur check
+     policy can then be easily changed.
+*)
+
+(**** Errors ****)
+
+module Unification_trace = struct
+
+  type position = First | Second
+  let swap_position = function
+    | First -> Second
+    | Second -> First
+
+  type desc = { t: type_expr; expanded: type_expr option }
+  type 'a diff = { got: 'a; expected: 'a}
+
+  type 'a escape =
+    | Constructor of Path.t
+    | Univ of type_expr
+    (* The type_expr argument of [Univ] is always a [Tunivar _],
+       we keep a [type_expr] to track renaming in {!Printtyp} *)
+    | Self
+    | Module_type of Path.t
+    | Equation of 'a
+
+  type fixed_row_case =
+    | Cannot_be_closed
+    | Cannot_add_tags of string list
+
+  type variant =
+    | No_intersection
+    | No_tags of position * (Asttypes.label * row_field) list
+    | Incompatible_types_for of string
+    | Fixed_row of position * fixed_row_case * fixed_explanation
+
+
+  type obj =
+    | Missing_field of position * string
+    | Abstract_row of position
+    | Self_cannot_be_closed
+
+  type 'a elt =
+    | Diff of 'a diff
+    | Variant of variant
+    | Obj of obj
+    | Escape of {context:type_expr option; kind: 'a escape}
+    | Incompatible_fields of {name:string; diff:type_expr diff }
+    | Rec_occur of type_expr * type_expr
+
+  type t = desc elt list
+  let short t = { t; expanded = None }
+  let map_diff f r =
+    (* ordering is often meaningful when dealing with type_expr *)
+    let got = f r.got in
+    let expected = f r.expected in
+    { got; expected}
+  let diff got expected = Diff (map_diff short {got;expected})
+
+  let map_desc f { t; expanded } =
+    let t = f t in
+    let expanded = Std.Option.map ~f expanded in
+    { t; expanded }
+
+  let map_elt f = function
+    | Diff x -> Diff (map_diff f x)
+    | Escape {kind=Equation x; context} -> Escape {kind=Equation(f x); context}
+    | Rec_occur (_,_)
+    | Escape {kind=(Univ _ | Self|Constructor _ | Module_type _ ); _}
+    | Variant _ | Obj _
+    | Incompatible_fields _ as x -> x
+  let map f = List.map (map_elt f)
+
+
+  (* Convert desc to type_expr * type_expr *)
+  let flatten_desc f x = match x.expanded with
+    | None -> f x.t x.t
+    | Some expanded -> f x.t expanded
+  let flatten f = map (flatten_desc f)
+
+  (* Permute the expected and actual values *)
+  let swap_diff x = { got = x.expected; expected = x.got }
+  let swap_elt = function
+    | Diff x -> Diff (swap_diff x)
+    | Incompatible_fields {name;diff} ->
+        Incompatible_fields { name; diff = swap_diff diff}
+    | Obj (Missing_field(pos,s)) -> Obj(Missing_field(swap_position pos,s))
+    | Obj (Abstract_row pos) -> Obj(Abstract_row (swap_position pos))
+    | Variant (Fixed_row(pos,k,f)) -> Variant (Fixed_row(swap_position pos,k,f))
+    | Variant (No_tags(pos,f)) -> Variant (No_tags(swap_position pos,f))
+    | x -> x
+  let swap x = List.map swap_elt x
+
+  exception Unify of t
+
+  let escape kind =  Escape { kind; context = None}
+  let scope_escape x = Unify[escape (Equation (short x))]
+  let rec_occur x y = Unify[Rec_occur(x, y)]
+  let incompatible_fields name got expected =
+    Incompatible_fields {name; diff={got; expected} }
+
+  let explain trace f =
+    let rec explain = function
+      | [] -> None
+      | [h] -> f ~prev:None h
+      | h :: (prev :: _ as rem) ->
+        match f ~prev:(Some prev) h with
+        | Some _ as m -> m
+        | None -> explain rem in
+    explain (List.rev trace)
+  
+  let map_types f = map (map_desc f)
+end
+module Trace = Unification_trace
+
+exception Unify = Trace.Unify
+
+exception Tags of label * label
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Tags (l, l') ->
+          Some
+            Location.
+              (errorf ~loc:(in_file !input_name)
+                 "In this program,@ variant constructors@ `%s and `%s@ \
+                  have the same hash value.@ Change one of them." l l'
+              )
+      | _ -> None
+    )
+
+exception Subtype of Unification_trace.t * Unification_trace.t
+
+exception Cannot_expand
+
+exception Cannot_apply
+
+(**** Type level management ****)
+
+let current_level = s_ref 0
+let nongen_level = s_ref 0
+let global_level = s_ref 1
+let saved_level = s_ref []
+
+type levels =
+    { current_level: int; nongen_level: int; global_level: int;
+      saved_level: (int * int) list; }
+let save_levels () =
+  { current_level = !current_level;
+    nongen_level = !nongen_level;
+    global_level = !global_level;
+    saved_level = !saved_level }
+let set_levels l =
+  current_level := l.current_level;
+  nongen_level := l.nongen_level;
+  global_level := l.global_level;
+  saved_level := l.saved_level
+
+let get_current_level () = !current_level
+let init_def level = current_level := level; nongen_level := level
+let begin_def () =
+  saved_level := (!current_level, !nongen_level) :: !saved_level;
+  incr current_level; nongen_level := !current_level
+let begin_class_def () =
+  saved_level := (!current_level, !nongen_level) :: !saved_level;
+  incr current_level
+let raise_nongen_level () =
+  saved_level := (!current_level, !nongen_level) :: !saved_level;
+  nongen_level := !current_level
+let end_def () =
+  let (cl, nl) = List.hd !saved_level in
+  saved_level := List.tl !saved_level;
+  current_level := cl; nongen_level := nl
+let create_scope () =
+  init_def (!current_level + 1);
+  !current_level
+
+let reset_global_level () =
+  global_level := !current_level + 1
+let increase_global_level () =
+  let gl = !global_level in
+  global_level := !current_level;
+  gl
+let restore_global_level gl =
+  global_level := gl
+
+(**** Whether a path points to an object type (with hidden row variable) ****)
+let is_object_type path =
+  let name =
+    match path with Path.Pident id -> Ident.name id
+    | Path.Pdot(_, s) -> s
+    | Path.Papply _ -> assert false
+  in name.[0] = '#'
+
+(**** Control tracing of GADT instances *)
+
+let trace_gadt_instances = ref false
+let check_trace_gadt_instances env =
+  not !trace_gadt_instances && Env.has_local_constraints env &&
+  (trace_gadt_instances := true; cleanup_abbrev (); true)
+
+let reset_trace_gadt_instances b =
+  if b then trace_gadt_instances := false
+
+let wrap_trace_gadt_instances env f x =
+  let b = check_trace_gadt_instances env in
+  let y = f x in
+  reset_trace_gadt_instances b;
+  y
+
+(**** Abbreviations without parameters ****)
+(* Shall reset after generalizing *)
+
+let simple_abbrevs = ref Mnil
+
+let proper_abbrevs path tl abbrev =
+  if tl <> [] || !trace_gadt_instances || !Clflags.principal ||
+     is_object_type path
+  then abbrev
+  else simple_abbrevs
+
+(**** Some type creators ****)
+
+(* Re-export generic type creators *)
+
+let newty2             = Btype.newty2
+let newty desc         = newty2 !current_level desc
+
+let newvar ?name ()         = newty2 !current_level (Tvar name)
+let newvar2 ?name level     = newty2 level (Tvar name)
+let new_global_var ?name () = newty2 !global_level (Tvar name)
+
+let newobj fields      = newty (Tobject (fields, ref None))
+
+let newconstr path tyl = newty (Tconstr (path, tyl, ref Mnil))
+
+let none = newty (Ttuple [])                (* Clearly ill-formed type *)
+
+(**** Representative of a type ****)
+
+(* Re-export repr *)
+let repr = repr
+
+(**** Type maps ****)
+
+module TypePairs =
+  Hashtbl.Make (struct
+    type t = type_expr * type_expr
+    let equal (t1, t1') (t2, t2') = (t1 == t2) && (t1' == t2')
+    let hash (t, t') = t.id + 93 * t'.id
+ end)
+
+
+(**** unification mode ****)
+
+type unification_mode =
+  | Expression (* unification in expression *)
+  | Pattern (* unification in pattern which may add local constraints *)
+
+let umode = ref Expression
+let generate_equations = ref false
+let assume_injective = ref false
+
+let set_mode_pattern ~generate ~injective f =
+  Misc.protect_refs
+    [Misc.R (umode, Pattern);
+     Misc.R (generate_equations, generate);
+     Misc.R (assume_injective, injective)] f
+
+(*** Checks for type definitions ***)
+
+let in_current_module = function
+  | Path.Pident _ -> true
+  | Path.Pdot _ | Path.Papply _ -> false
+
+let in_pervasives p =
+  in_current_module p &&
+  try ignore (Env.find_type p Env.initial_safe_string); true
+  with Not_found -> false
+
+let is_datatype decl=
+  match decl.type_kind with
+    Type_record _ | Type_variant _ | Type_open -> true
+  | Type_abstract -> false
+
+
+                  (**********************************************)
+                  (*  Miscellaneous operations on object types  *)
+                  (**********************************************)
+
+(* Note:
+   We need to maintain some invariants:
+   * cty_self must be a Tobject
+   * ...
+*)
+
+(**** Object field manipulation. ****)
+
+let object_fields ty =
+  match (repr ty).desc with
+    Tobject (fields, _) -> fields
+  | _                   -> assert false
+
+let flatten_fields ty =
+  let rec flatten l ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tfield(s, k, ty1, ty2) ->
+        flatten ((s, k, ty1)::l) ty2
+    | _ ->
+        (l, ty)
+  in
+    let (l, r) = flatten [] ty in
+    (List.sort (fun (n, _, _) (n', _, _) -> compare n n') l, r)
+
+let build_fields level =
+  List.fold_right
+    (fun (s, k, ty1) ty2 -> newty2 level (Tfield(s, k, ty1, ty2)))
+
+let associate_fields fields1 fields2 =
+  let rec associate p s s' =
+    function
+      (l, []) ->
+        (List.rev p, (List.rev s) @ l, List.rev s')
+    | ([], l') ->
+        (List.rev p, List.rev s, (List.rev s') @ l')
+    | ((n, k, t)::r, (n', k', t')::r') when n = n' ->
+        associate ((n, k, t, k', t')::p) s s' (r, r')
+    | ((n, k, t)::r, ((n', _k', _t')::_ as l')) when n < n' ->
+        associate p ((n, k, t)::s) s' (r, l')
+    | (((_n, _k, _t)::_ as l), (n', k', t')::r') (* when n > n' *) ->
+        associate p s ((n', k', t')::s') (l, r')
+  in
+  associate [] [] [] (fields1, fields2)
+
+let rec has_dummy_method ty =
+  match repr ty with
+    {desc = Tfield (m, _, _, ty2)} ->
+      m = dummy_method || has_dummy_method ty2
+  | _ -> false
+
+let is_self_type = function
+  | Tobject (ty, _) -> has_dummy_method ty
+  | _ -> false
+
+(**** Check whether an object is open ****)
+
+(* +++ The abbreviation should eventually be expanded *)
+let rec object_row ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tobject (t, _)     -> object_row t
+  | Tfield(_, _, _, t) -> object_row t
+  | _ -> ty
+
+let opened_object ty =
+  match (object_row ty).desc with
+  | Tvar _  | Tunivar _ | Tconstr _ -> true
+  | _                               -> false
+
+let concrete_object ty =
+  match (object_row ty).desc with
+  | Tvar _             -> false
+  | _                  -> true
+
+(**** Close an object ****)
+
+let close_object ty =
+  let rec close ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tvar _ ->
+        link_type ty (newty2 ty.level Tnil); true
+    | Tfield(lab, _, _, _) when lab = dummy_method ->
+        false
+    | Tfield(_, _, _, ty') -> close ty'
+    | _                    -> assert false
+  in
+  match (repr ty).desc with
+    Tobject (ty, _)   -> close ty
+  | _                 -> assert false
+
+(**** Row variable of an object type ****)
+
+let row_variable ty =
+  let rec find ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tfield (_, _, _, ty) -> find ty
+    | Tvar _               -> ty
+    | _                    -> assert false
+  in
+  match (repr ty).desc with
+    Tobject (fi, _) -> find fi
+  | _               -> assert false
+
+(**** Object name manipulation ****)
+(* +++ Bientot obsolete *)
+
+let set_object_name id rv params ty =
+  match (repr ty).desc with
+    Tobject (_fi, nm) ->
+      set_name nm (Some (Path.Pident id, rv::params))
+  | _ ->
+      assert false
+
+let remove_object_name ty =
+  match (repr ty).desc with
+    Tobject (_, nm)   -> set_name nm None
+  | Tconstr (_, _, _) -> ()
+  | _                 -> fatal_error "Ctype.remove_object_name"
+
+(**** Hiding of private methods ****)
+
+let hide_private_methods ty =
+  match (repr ty).desc with
+    Tobject (fi, nm) ->
+      nm := None;
+      let (fl, _) = flatten_fields fi in
+      List.iter
+        (function (_, k, _) ->
+          match field_kind_repr k with
+            Fvar r -> set_kind r Fabsent
+          | _      -> ())
+        fl
+  | _ ->
+      assert false
+
+
+                              (*******************************)
+                              (*  Operations on class types  *)
+                              (*******************************)
+
+
+let rec signature_of_class_type =
+  function
+    Cty_constr (_, _, cty) -> signature_of_class_type cty
+  | Cty_signature sign     -> sign
+  | Cty_arrow (_, _, cty)   -> signature_of_class_type cty
+
+let self_type cty =
+  repr (signature_of_class_type cty).csig_self
+
+let rec class_type_arity =
+  function
+    Cty_constr (_, _, cty) ->  class_type_arity cty
+  | Cty_signature _        ->  0
+  | Cty_arrow (_, _, cty)    ->  1 + class_type_arity cty
+
+
+                  (*******************************************)
+                  (*  Miscellaneous operations on row types  *)
+                  (*******************************************)
+
+let sort_row_fields = List.sort (fun (p,_) (q,_) -> compare p q)
+
+let rec merge_rf r1 r2 pairs fi1 fi2 =
+  match fi1, fi2 with
+    (l1,f1 as p1)::fi1', (l2,f2 as p2)::fi2' ->
+      if l1 = l2 then merge_rf r1 r2 ((l1,f1,f2)::pairs) fi1' fi2' else
+      if l1 < l2 then merge_rf (p1::r1) r2 pairs fi1' fi2 else
+      merge_rf r1 (p2::r2) pairs fi1 fi2'
+  | [], _ -> (List.rev r1, List.rev_append r2 fi2, pairs)
+  | _, [] -> (List.rev_append r1 fi1, List.rev r2, pairs)
+
+let merge_row_fields fi1 fi2 =
+  match fi1, fi2 with
+    [], _ | _, [] -> (fi1, fi2, [])
+  | [p1], _ when not (List.mem_assoc (fst p1) fi2) -> (fi1, fi2, [])
+  | _, [p2] when not (List.mem_assoc (fst p2) fi1) -> (fi1, fi2, [])
+  | _ -> merge_rf [] [] [] (sort_row_fields fi1) (sort_row_fields fi2)
+
+let rec filter_row_fields erase = function
+    [] -> []
+  | (_l,f as p)::fi ->
+      let fi = filter_row_fields erase fi in
+      match row_field_repr f with
+        Rabsent -> fi
+      | Reither(_,_,false,e) when erase -> set_row_field e Rabsent; fi
+      | _ -> p :: fi
+
+                    (**************************************)
+                    (*  Check genericity of type schemes  *)
+                    (**************************************)
+
+
+exception Non_closed of type_expr * bool
+
+let free_variables = ref []
+let really_closed = ref None
+
+let rec free_vars_rec real ty =
+  let ty = repr ty in
+  if ty.level >= lowest_level then begin
+    ty.level <- pivot_level - ty.level;
+    begin match ty.desc, !really_closed with
+      Tvar _, _ ->
+        free_variables := (ty, real) :: !free_variables
+    | Tconstr (path, tl, _), Some env ->
+        begin try
+          let (_, body, _) = Env.find_type_expansion path env in
+          if (repr body).level <> generic_level then
+            free_variables := (ty, real) :: !free_variables
+        with Not_found -> ()
+        end;
+        List.iter (free_vars_rec true) tl
+(* Do not count "virtual" free variables
+    | Tobject(ty, {contents = Some (_, p)}) ->
+        free_vars_rec false ty; List.iter (free_vars_rec true) p
+*)
+    | Tobject (ty, _), _ ->
+        free_vars_rec false ty
+    | Tfield (_, _, ty1, ty2), _ ->
+        free_vars_rec true ty1; free_vars_rec false ty2
+    | Tvariant row, _ ->
+        let row = row_repr row in
+        iter_row (free_vars_rec true) row;
+        if not (static_row row) then free_vars_rec false row.row_more
+    | _    ->
+        iter_type_expr (free_vars_rec true) ty
+    end;
+  end
+
+let free_vars ?env ty =
+  free_variables := [];
+  really_closed := env;
+  free_vars_rec true ty;
+  let res = !free_variables in
+  free_variables := [];
+  really_closed := None;
+  res
+
+let free_variables ?env ty =
+  let tl = List.map fst (free_vars ?env ty) in
+  unmark_type ty;
+  tl
+
+let closed_type ty =
+  match free_vars ty with
+      []           -> ()
+  | (v, real) :: _ -> raise (Non_closed (v, real))
+
+let closed_parameterized_type params ty =
+  List.iter mark_type params;
+  let ok =
+    try closed_type ty; true with Non_closed _ -> false in
+  List.iter unmark_type params;
+  unmark_type ty;
+  ok
+
+let closed_type_decl decl =
+  try
+    List.iter mark_type decl.type_params;
+    begin match decl.type_kind with
+      Type_abstract ->
+        ()
+    | Type_variant v ->
+        List.iter
+          (fun {cd_args; cd_res; _} ->
+            match cd_res with
+            | Some _ -> ()
+            | None ->
+                match cd_args with
+                | Cstr_tuple l ->  List.iter closed_type l
+                | Cstr_record l -> List.iter (fun l -> closed_type l.ld_type) l
+          )
+          v
+    | Type_record(r, _rep) ->
+        List.iter (fun l -> closed_type l.ld_type) r
+    | Type_open -> ()
+    end;
+    begin match decl.type_manifest with
+      None    -> ()
+    | Some ty -> closed_type ty
+    end;
+    unmark_type_decl decl;
+    None
+  with Non_closed (ty, _) ->
+    unmark_type_decl decl;
+    Some ty
+
+let closed_extension_constructor ext =
+  try
+    List.iter mark_type ext.ext_type_params;
+    begin match ext.ext_ret_type with
+    | Some _ -> ()
+    | None -> iter_type_expr_cstr_args closed_type ext.ext_args
+    end;
+    unmark_extension_constructor ext;
+    None
+  with Non_closed (ty, _) ->
+    unmark_extension_constructor ext;
+    Some ty
+
+type closed_class_failure =
+    CC_Method of type_expr * bool * string * type_expr
+  | CC_Value of type_expr * bool * string * type_expr
+
+exception CCFailure of closed_class_failure
+
+let closed_class params sign =
+  let ty = object_fields (repr sign.csig_self) in
+  let (fields, rest) = flatten_fields ty in
+  List.iter mark_type params;
+  mark_type rest;
+  List.iter
+    (fun (lab, _, ty) -> if lab = dummy_method then mark_type ty)
+    fields;
+  try
+    mark_type_node (repr sign.csig_self);
+    List.iter
+      (fun (lab, kind, ty) ->
+        if field_kind_repr kind = Fpresent then
+        try closed_type ty with Non_closed (ty0, real) ->
+          raise (CCFailure (CC_Method (ty0, real, lab, ty))))
+      fields;
+    mark_type_params (repr sign.csig_self);
+    List.iter unmark_type params;
+    unmark_class_signature sign;
+    None
+  with CCFailure reason ->
+    mark_type_params (repr sign.csig_self);
+    List.iter unmark_type params;
+    unmark_class_signature sign;
+    Some reason
+
+
+                            (**********************)
+                            (*  Type duplication  *)
+                            (**********************)
+
+
+(* Duplicate a type, preserving only type variables *)
+let duplicate_type ty =
+  Subst.type_expr Subst.identity ty
+
+(* Same, for class types *)
+let duplicate_class_type ty =
+  Subst.class_type Subst.identity ty
+
+
+                         (*****************************)
+                         (*  Type level manipulation  *)
+                         (*****************************)
+
+(*
+   It would be a bit more efficient to remove abbreviation expansions
+   rather than generalizing them: these expansions will usually not be
+   used anymore. However, this is not possible in the general case, as
+   [expand_abbrev] (via [subst]) requires these expansions to be
+   preserved. Does it worth duplicating this code ?
+*)
+let rec generalize ty =
+  let ty = repr ty in
+  if (ty.level > !current_level) && (ty.level <> generic_level) then begin
+    set_level ty generic_level;
+    begin match ty.desc with
+      Tconstr (_, _, abbrev) ->
+        iter_abbrev generalize !abbrev
+    | _ -> ()
+    end;
+    iter_type_expr generalize ty
+  end
+
+let generalize ty =
+  simple_abbrevs := Mnil;
+  generalize ty
+
+(* Generalize the structure and lower the variables *)
+
+let rec generalize_structure var_level ty =
+  let ty = repr ty in
+  if ty.level <> generic_level then begin
+    if is_Tvar ty && ty.level > var_level then
+      set_level ty var_level
+    else if
+      ty.level > !current_level &&
+      match ty.desc with
+        Tconstr (p, _, abbrev) ->
+          not (is_object_type p) && (abbrev := Mnil; true)
+      | _ -> true
+    then begin
+      set_level ty generic_level;
+      iter_type_expr (generalize_structure var_level) ty
+    end
+  end
+
+let generalize_structure ty =
+  simple_abbrevs := Mnil;
+  generalize_structure !current_level ty
+
+(* Generalize the spine of a function, if the level >= !current_level *)
+
+let rec generalize_spine ty =
+  let ty = repr ty in
+  if ty.level < !current_level || ty.level = generic_level then () else
+  match ty.desc with
+    Tarrow (_, ty1, ty2, _) ->
+      set_level ty generic_level;
+      generalize_spine ty1;
+      generalize_spine ty2;
+  | Tpoly (ty', _) ->
+      set_level ty generic_level;
+      generalize_spine ty'
+  | Ttuple tyl
+  | Tpackage (_, _, tyl) ->
+      set_level ty generic_level;
+      List.iter generalize_spine tyl
+  | Tconstr (p, tyl, memo) when not (is_object_type p) ->
+      set_level ty generic_level;
+      memo := Mnil;
+      List.iter generalize_spine tyl
+  | _ -> ()
+
+let forward_try_expand_once = (* Forward declaration *)
+  ref (fun _env _ty -> raise Cannot_expand)
+
+(*
+   Lower the levels of a type (assume [level] is not
+   [generic_level]).
+*)
+
+let rec normalize_package_path env p =
+  let t =
+    try (Env.find_modtype p env).mtd_type
+    with Not_found -> None
+  in
+  match t with
+  | Some (Mty_ident p) -> normalize_package_path env p
+  | Some (Mty_signature _ | Mty_functor _ | Mty_alias _) | None ->
+      match p with
+        Path.Pdot (p1, s) ->
+          (* For module aliases *)
+          let p1' = Env.normalize_module_path None env p1 in
+          if Path.same p1 p1' then p else
+          normalize_package_path env (Path.Pdot (p1', s))
+      | _ -> p
+
+let check_scope_escape env level ty =
+  let rec loop ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      ty.level <- pivot_level - ty.level;
+      if level < ty.scope then
+        raise(Trace.scope_escape ty);
+      begin match ty.desc with
+      | Tconstr (p, _, _) when level < Path.scope p ->
+          begin match !forward_try_expand_once env ty with
+          | ty' -> aux ty'
+          | exception Cannot_expand ->
+              raise Trace.(Unify [escape (Constructor p)])
+          end
+      | Tpackage (p, nl, tl) when level < Path.scope p ->
+          let p' = normalize_package_path env p in
+          if Path.same p p' then raise Trace.(Unify [escape (Module_type p)]);
+          aux { ty with desc = Tpackage (p', nl, tl) }
+      | _ ->
+        iter_type_expr loop ty
+      end;
+    end
+  and aux ty =
+    loop ty;
+    unmark_type ty
+  in
+  try aux ty;
+  with Unify [Trace.Escape x] ->
+    raise Trace.(Unify[Escape { x with context = Some ty }])
+
+let update_scope scope ty =
+  let ty = repr ty in
+  let scope = max scope ty.scope in
+  if ty.level < scope then raise (Trace.scope_escape ty);
+  set_scope ty scope
+
+(* Note: the level of a type constructor must be greater than its binding
+    time. That way, a type constructor cannot escape the scope of its
+    definition, as would be the case in
+      let x = ref []
+      module M = struct type t let _ = (x : t list ref) end
+    (without this constraint, the type system would actually be unsound.)
+*)
+
+let rec update_level env level expand ty =
+  let ty = repr ty in
+  if ty.level > level then begin
+    if level < ty.scope then raise (Trace.scope_escape ty);
+    match ty.desc with
+      Tconstr(p, _tl, _abbrev) when level < Path.scope p ->
+        (* Try first to replace an abbreviation by its expansion. *)
+        begin try
+          link_type ty (!forward_try_expand_once env ty);
+          update_level env level expand ty
+        with Cannot_expand ->
+          raise Trace.(Unify [escape(Constructor p)])
+        end
+    | Tconstr(p, (_ :: _ as tl), _) ->
+        let variance =
+          try (Env.find_type p env).type_variance
+          with Not_found -> List.map (fun _ -> Variance.may_inv) tl in
+        let needs_expand =
+          expand ||
+          List.exists2
+            (fun var ty -> var = Variance.null && (repr ty).level > level)
+            variance tl
+        in
+        begin try
+          if not needs_expand then raise Cannot_expand;
+          link_type ty (!forward_try_expand_once env ty);
+          update_level env level expand ty
+        with Cannot_expand ->
+          set_level ty level;
+          iter_type_expr (update_level env level expand) ty
+        end
+    | Tpackage (p, nl, tl) when level < Path.scope p ->
+        let p' = normalize_package_path env p in
+        if Path.same p p' then raise Trace.(Unify [escape (Module_type p)]);
+        set_type_desc ty (Tpackage (p', nl, tl));
+        update_level env level expand ty
+    | Tobject(_, ({contents=Some(p, _tl)} as nm))
+      when level < Path.scope p ->
+        set_name nm None;
+        update_level env level expand ty
+    | Tvariant row ->
+        let row = row_repr row in
+        begin match row.row_name with
+        | Some (p, _tl) when level < Path.scope p ->
+            set_type_desc ty (Tvariant {row with row_name = None})
+        | _ -> ()
+        end;
+        set_level ty level;
+        iter_type_expr (update_level env level expand) ty
+    | Tfield(lab, _, ty1, _)
+      when lab = dummy_method && (repr ty1).level > level ->
+        raise Trace.(Unify [escape Self])
+    | _ ->
+        set_level ty level;
+        (* XXX what about abbreviations in Tconstr ? *)
+        iter_type_expr (update_level env level expand) ty
+  end
+
+(* First try without expanding, then expand everything,
+   to avoid combinatorial blow-up *)
+let update_level env level ty =
+  let ty = repr ty in
+  if ty.level > level then begin
+    let snap = snapshot () in
+    try
+      update_level env level false ty
+    with Unify _ ->
+      backtrack snap;
+      update_level env level true ty
+  end
+
+(* Lower level of type variables inside contravariant branches *)
+
+let rec lower_contravariant env var_level visited contra ty =
+  let ty = repr ty in
+  let must_visit =
+    ty.level > var_level &&
+    match Hashtbl.find visited ty.id with
+    | done_contra -> contra && not done_contra
+    | exception Not_found -> true
+  in
+  if must_visit then begin
+    Hashtbl.add visited ty.id contra;
+    let lower_rec = lower_contravariant env var_level visited in
+    match ty.desc with
+      Tvar _ -> if contra then set_level ty var_level
+    | Tconstr (_, [], _) -> ()
+    | Tconstr (path, tyl, _abbrev) ->
+       let variance, maybe_expand =
+         try
+           let typ = Env.find_type path env in
+           typ.type_variance,
+           typ.type_kind = Type_abstract
+          with Not_found ->
+            (* See testsuite/tests/typing-missing-cmi-2 for an example *)
+            List.map (fun _ -> Variance.may_inv) tyl,
+            false
+        in
+        if List.for_all ((=) Variance.null) variance then () else
+          let not_expanded () =
+            List.iter2
+              (fun v t ->
+                if v = Variance.null then () else
+                  if Variance.(mem May_weak v)
+                  then lower_rec true t
+                  else lower_rec contra t)
+              variance tyl in
+          if maybe_expand then (* we expand cautiously to avoid missing cmis *)
+            match !forward_try_expand_once env ty with
+            | ty -> lower_rec contra ty
+            | exception Cannot_expand -> not_expanded ()
+          else not_expanded ()
+    | Tpackage (_, _, tyl) ->
+        List.iter (lower_rec true) tyl
+    | Tarrow (_, t1, t2, _) ->
+        lower_rec true t1;
+        lower_rec contra t2
+    | _ ->
+        iter_type_expr (lower_rec contra) ty
+  end
+
+let lower_contravariant env ty =
+  simple_abbrevs := Mnil;
+  lower_contravariant env !nongen_level (Hashtbl.create 7) false ty
+
+(* Correct the levels of type [ty]. *)
+let correct_levels ty =
+  duplicate_type ty
+
+(* Only generalize the type ty0 in ty *)
+let limited_generalize ty0 ty =
+  let ty0 = repr ty0 in
+
+  let graph = Hashtbl.create 17 in
+  let idx = ref lowest_level in
+  let roots = ref [] in
+
+  let rec inverse pty ty =
+    let ty = repr ty in
+    if (ty.level > !current_level) || (ty.level = generic_level) then begin
+      decr idx;
+      Hashtbl.add graph !idx (ty, ref pty);
+      if (ty.level = generic_level) || (ty == ty0) then
+        roots := ty :: !roots;
+      set_level ty !idx;
+      iter_type_expr (inverse [ty]) ty
+    end else if ty.level < lowest_level then begin
+      let (_, parents) = Hashtbl.find graph ty.level in
+      parents := pty @ !parents
+    end
+
+  and generalize_parents ty =
+    let idx = ty.level in
+    if idx <> generic_level then begin
+      set_level ty generic_level;
+      List.iter generalize_parents !(snd (Hashtbl.find graph idx));
+      (* Special case for rows: must generalize the row variable *)
+      match ty.desc with
+        Tvariant row ->
+          let more = row_more row in
+          let lv = more.level in
+          if (lv < lowest_level || lv > !current_level)
+          && lv <> generic_level then set_level more generic_level
+      | _ -> ()
+    end
+  in
+
+  inverse [] ty;
+  if ty0.level < lowest_level then
+    iter_type_expr (inverse []) ty0;
+  List.iter generalize_parents !roots;
+  Hashtbl.iter
+    (fun _ (ty, _) ->
+       if ty.level <> generic_level then set_level ty !current_level)
+    graph
+
+
+(* Compute statically the free univars of all nodes in a type *)
+(* This avoids doing it repeatedly during instantiation *)
+
+type inv_type_expr =
+    { inv_type : type_expr;
+      mutable inv_parents : inv_type_expr list }
+
+let rec inv_type hash pty ty =
+  let ty = repr ty in
+  try
+    let inv = TypeHash.find hash ty in
+    inv.inv_parents <- pty @ inv.inv_parents
+  with Not_found ->
+    let inv = { inv_type = ty; inv_parents = pty } in
+    TypeHash.add hash ty inv;
+    iter_type_expr (inv_type hash [inv]) ty
+
+let compute_univars ty =
+  let inverted = TypeHash.create 17 in
+  inv_type inverted [] ty;
+  let node_univars = TypeHash.create 17 in
+  let rec add_univar univ inv =
+    match inv.inv_type.desc with
+      Tpoly (_ty, tl) when List.memq univ (List.map repr tl) -> ()
+    | _ ->
+        try
+          let univs = TypeHash.find node_univars inv.inv_type in
+          if not (TypeSet.mem univ !univs) then begin
+            univs := TypeSet.add univ !univs;
+            List.iter (add_univar univ) inv.inv_parents
+          end
+        with Not_found ->
+          TypeHash.add node_univars inv.inv_type (ref(TypeSet.singleton univ));
+          List.iter (add_univar univ) inv.inv_parents
+  in
+  TypeHash.iter (fun ty inv -> if is_Tunivar ty then add_univar ty inv)
+    inverted;
+  fun ty ->
+    try !(TypeHash.find node_univars ty) with Not_found -> TypeSet.empty
+
+
+                              (*******************)
+                              (*  Instantiation  *)
+                              (*******************)
+
+
+let rec find_repr p1 =
+  function
+    Mnil ->
+      None
+  | Mcons (Public, p2, ty, _, _) when Path.same p1 p2 ->
+      Some ty
+  | Mcons (_, _, _, _, rem) ->
+      find_repr p1 rem
+  | Mlink {contents = rem} ->
+      find_repr p1 rem
+
+(*
+   Generic nodes are duplicated, while non-generic nodes are left
+   as-is.
+   During instantiation, the description of a generic node is first
+   replaced by a link to a stub ([Tsubst (newvar ())]). Once the
+   copy is made, it replaces the stub.
+   After instantiation, the description of generic node, which was
+   stored by [save_desc], must be put back, using [cleanup_types].
+*)
+
+let abbreviations = ref (ref Mnil)
+  (* Abbreviation memorized. *)
+
+(* partial: we may not wish to copy the non generic types
+   before we call type_pat *)
+let rec copy ?partial ?keep_names scope ty =
+  let copy = copy ?partial ?keep_names scope in
+  let ty = repr ty in
+  match ty.desc with
+    Tsubst ty -> ty
+  | _ ->
+    if ty.level <> generic_level && partial = None then ty else
+    (* We only forget types that are non generic and do not contain
+       free univars *)
+    let forget =
+      if ty.level = generic_level then generic_level else
+      match partial with
+        None -> assert false
+      | Some (free_univars, keep) ->
+          if TypeSet.is_empty (free_univars ty) then
+            if keep then ty.level else !current_level
+          else generic_level
+    in
+    if forget <> generic_level then newty2 forget (Tvar None) else
+    let desc = ty.desc in
+    For_copy.save_desc scope ty desc;
+    let t = newvar() in          (* Stub *)
+    set_scope t ty.scope;
+    ty.desc <- Tsubst t;
+    t.desc <-
+      begin match desc with
+      | Tconstr (p, tl, _) ->
+          let abbrevs = proper_abbrevs p tl !abbreviations in
+          begin match find_repr p !abbrevs with
+            Some ty when repr ty != t ->
+              Tlink ty
+          | _ ->
+          (*
+             One must allocate a new reference, so that abbrevia-
+             tions belonging to different branches of a type are
+             independent.
+             Moreover, a reference containing a [Mcons] must be
+             shared, so that the memorized expansion of an abbrevi-
+             ation can be released by changing the content of just
+             one reference.
+          *)
+              Tconstr (p, List.map copy tl,
+                       ref (match !(!abbreviations) with
+                              Mcons _ -> Mlink !abbreviations
+                            | abbrev  -> abbrev))
+          end
+      | Tvariant row0 ->
+          let row = row_repr row0 in
+          let more = repr row.row_more in
+          (* We must substitute in a subtle way *)
+          (* Tsubst takes a tuple containing the row var and the variant *)
+          begin match more.desc with
+            Tsubst {desc = Ttuple [_;ty2]} ->
+              (* This variant type has been already copied *)
+              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
+              Tlink ty2
+          | _ ->
+              (* If the row variable is not generic, we must keep it *)
+              let keep = more.level <> generic_level && partial = None in
+              let more' =
+                match more.desc with
+                  Tsubst ty -> ty
+                | Tconstr _ | Tnil ->
+                    For_copy.save_desc scope more more.desc;
+                    copy more
+                | Tvar _ | Tunivar _ ->
+                    For_copy.save_desc scope more more.desc;
+                    if keep then more else newty more.desc
+                |  _ -> assert false
+              in
+              let row =
+                match repr more' with (* PR#6163 *)
+                  {desc=Tconstr (x,_,_)} when not (is_fixed row) ->
+                    {row with row_fixed = Some (Reified x)}
+                | _ -> row
+              in
+              (* Open row if partial for pattern and contains Reither *)
+              let more', row =
+                match partial with
+                  Some (free_univars, false) ->
+                    let more' =
+                      if more.id != more'.id then more' else
+                      let lv = if keep then more.level else !current_level in
+                      newty2 lv (Tvar None)
+                    in
+                    let not_reither (_, f) =
+                      match row_field_repr f with
+                        Reither _ -> false
+                      | _ -> true
+                    in
+                    if row.row_closed && not (is_fixed row)
+                    && TypeSet.is_empty (free_univars ty)
+                    && not (List.for_all not_reither row.row_fields) then
+                      (more',
+                       {row_fields = List.filter not_reither row.row_fields;
+                        row_more = more'; row_bound = ();
+                        row_closed = false; row_fixed = None; row_name = None})
+                    else (more', row)
+                | _ -> (more', row)
+              in
+              (* Register new type first for recursion *)
+              more.desc <- Tsubst(newgenty(Ttuple[more';t]));
+              (* Return a new copy *)
+              Tvariant (copy_row copy true row keep more')
+          end
+      | Tfield (_p, k, _ty1, ty2) ->
+          begin match field_kind_repr k with
+            Fabsent  -> Tlink (copy ty2)
+          | Fpresent -> copy_type_desc copy desc
+          | Fvar r ->
+              For_copy.dup_kind scope r;
+              copy_type_desc copy desc
+          end
+      | Tobject (ty1, _) when partial <> None ->
+          Tobject (copy ty1, ref None)
+      | _ -> copy_type_desc ?keep_names copy desc
+      end;
+    t
+
+(**** Variants of instantiations ****)
+
+let instance ?partial sch =
+  let partial =
+    match partial with
+      None -> None
+    | Some keep -> Some (compute_univars sch, keep)
+  in
+  For_copy.with_scope (fun scope -> copy ?partial scope sch)
+
+let generic_instance sch =
+  let old = !current_level in
+  current_level := generic_level;
+  let ty = instance sch in
+  current_level := old;
+  ty
+
+let instance_list schl =
+  For_copy.with_scope (fun scope -> List.map (fun t -> copy scope t) schl)
+
+let reified_var_counter = ref Vars.empty
+let reset_reified_var_counter () =
+  reified_var_counter := Vars.empty
+
+(* names given to new type constructors.
+   Used for existential types and
+   local constraints *)
+let get_new_abstract_name s =
+  let index =
+    try Vars.find s !reified_var_counter + 1
+    with Not_found -> 0 in
+  reified_var_counter := Vars.add s index !reified_var_counter;
+  if index = 0 && s <> "" && s.[String.length s - 1] <> '$' then s else
+  Printf.sprintf "%s%d" s index
+
+let new_declaration expansion_scope manifest =
+  {
+    type_params = [];
+    type_arity = 0;
+    type_kind = Type_abstract;
+    type_private = Public;
+    type_manifest = manifest;
+    type_variance = [];
+    type_is_newtype = true;
+    type_expansion_scope = expansion_scope;
+    type_loc = Location.none;
+    type_attributes = [];
+    type_immediate = Unknown;
+    type_unboxed = unboxed_false_default_false;
+  }
+
+let existential_name cstr ty = match repr ty with
+  | {desc = Tvar (Some name)} -> "$" ^ cstr.cstr_name ^ "_'" ^ name
+  | _ -> "$" ^ cstr.cstr_name
+
+let instance_constructor ?in_pattern cstr =
+  For_copy.with_scope (fun scope ->
+    begin match in_pattern with
+    | None -> ()
+    | Some (env, expansion_scope) ->
+        let process existential =
+          let decl = new_declaration expansion_scope None in
+          let name = existential_name cstr existential in
+          let path =
+            Path.Pident
+              (Ident.create_scoped ~scope:expansion_scope
+                 (get_new_abstract_name name))
+          in
+          let new_env = Env.add_local_type path decl !env in
+          env := new_env;
+          let to_unify = newty (Tconstr (path,[],ref Mnil)) in
+          let tv = copy scope existential in
+          assert (is_Tvar tv);
+          link_type tv to_unify
+        in
+        List.iter process cstr.cstr_existentials
+    end;
+    let ty_res = copy scope cstr.cstr_res in
+    let ty_args = List.map (copy scope) cstr.cstr_args in
+    (ty_args, ty_res)
+  )
+
+let instance_parameterized_type ?keep_names sch_args sch =
+  For_copy.with_scope (fun scope ->
+    let ty_args = List.map (fun t -> copy ?keep_names scope t) sch_args in
+    let ty = copy scope sch in
+    (ty_args, ty)
+  )
+
+let instance_parameterized_type_2 sch_args sch_lst sch =
+  For_copy.with_scope (fun scope ->
+    let ty_args = List.map (copy scope) sch_args in
+    let ty_lst = List.map (copy scope) sch_lst in
+    let ty = copy scope sch in
+    (ty_args, ty_lst, ty)
+  )
+
+let map_kind f = function
+  | Type_abstract -> Type_abstract
+  | Type_open -> Type_open
+  | Type_variant cl ->
+      Type_variant (
+        List.map
+          (fun c ->
+             {c with
+              cd_args = map_type_expr_cstr_args f c.cd_args;
+              cd_res = Option.map f c.cd_res
+             })
+          cl)
+  | Type_record (fl, rr) ->
+      Type_record (
+        List.map
+          (fun l ->
+             {l with ld_type = f l.ld_type}
+          ) fl, rr)
+
+
+let instance_declaration decl =
+  For_copy.with_scope (fun scope ->
+    {decl with type_params = List.map (copy scope) decl.type_params;
+     type_manifest = Option.map (copy scope) decl.type_manifest;
+     type_kind = map_kind (copy scope) decl.type_kind;
+    }
+  )
+
+let generic_instance_declaration decl =
+  let old = !current_level in
+  current_level := generic_level;
+  let decl = instance_declaration decl in
+  current_level := old;
+  decl
+
+let instance_class params cty =
+  let rec copy_class_type scope = function
+    | Cty_constr (path, tyl, cty) ->
+        let tyl' = List.map (copy scope) tyl in
+        let cty' = copy_class_type scope cty in
+        Cty_constr (path, tyl', cty')
+    | Cty_signature sign ->
+        Cty_signature
+          {csig_self = copy scope sign.csig_self;
+           csig_vars =
+             Vars.map (function (m, v, ty) -> (m, v, copy scope ty))
+               sign.csig_vars;
+           csig_concr = sign.csig_concr;
+           csig_inher =
+             List.map (fun (p,tl) -> (p, List.map (copy scope) tl))
+               sign.csig_inher}
+    | Cty_arrow (l, ty, cty) ->
+        Cty_arrow (l, copy scope ty, copy_class_type scope cty)
+  in
+  For_copy.with_scope (fun scope ->
+    let params' = List.map (copy scope) params in
+    let cty' = copy_class_type scope cty in
+    (params', cty')
+  )
+
+(**** Instantiation for types with free universal variables ****)
+
+let rec diff_list l1 l2 =
+  if l1 == l2 then [] else
+  match l1 with [] -> invalid_arg "Ctype.diff_list"
+  | a :: l1 -> a :: diff_list l1 l2
+
+let conflicts free bound =
+  let bound = List.map repr bound in
+  TypeSet.exists (fun t -> List.memq (repr t) bound) free
+
+let delayed_copy = ref []
+    (* copying to do later *)
+
+(* Copy without sharing until there are no free univars left *)
+(* all free univars must be included in [visited]            *)
+let rec copy_sep cleanup_scope fixed free bound visited ty =
+  let ty = repr ty in
+  let univars = free ty in
+  if TypeSet.is_empty univars then
+    if ty.level <> generic_level then ty else
+    let t = newvar () in
+    delayed_copy :=
+      lazy (t.desc <- Tlink (copy cleanup_scope ty))
+      :: !delayed_copy;
+    t
+  else try
+    let t, bound_t = List.assq ty visited in
+    let dl = if is_Tunivar ty then [] else diff_list bound bound_t in
+    if dl <> [] && conflicts univars dl then raise Not_found;
+    t
+  with Not_found -> begin
+    let t = newvar() in          (* Stub *)
+    let visited =
+      match ty.desc with
+        Tarrow _ | Ttuple _ | Tvariant _ | Tconstr _ | Tobject _ | Tpackage _ ->
+          (ty,(t,bound)) :: visited
+      | _ -> visited in
+    let copy_rec = copy_sep cleanup_scope fixed free bound visited in
+    t.desc <-
+      begin match ty.desc with
+      | Tvariant row0 ->
+          let row = row_repr row0 in
+          let more = repr row.row_more in
+          (* We shall really check the level on the row variable *)
+          let keep = is_Tvar more && more.level <> generic_level in
+          let more' = copy_rec more in
+          let fixed' = fixed && is_Tvar (repr more') in
+          let row = copy_row copy_rec fixed' row keep more' in
+          Tvariant row
+      | Tpoly (t1, tl) ->
+          let tl = List.map repr tl in
+          let tl' = List.map (fun t -> newty t.desc) tl in
+          let bound = tl @ bound in
+          let visited =
+            List.map2 (fun ty t -> ty,(t,bound)) tl tl' @ visited in
+          Tpoly (copy_sep cleanup_scope fixed free bound visited t1, tl')
+      | _ -> copy_type_desc copy_rec ty.desc
+      end;
+    t
+  end
+
+let instance_poly' cleanup_scope ~keep_names fixed univars sch =
+  let univars = List.map repr univars in
+  let copy_var ty =
+    match ty.desc with
+      Tunivar name -> if keep_names then newty (Tvar name) else newvar ()
+    | _ -> assert false
+  in
+  let vars = List.map copy_var univars in
+  let pairs = List.map2 (fun u v -> u, (v, [])) univars vars in
+  delayed_copy := [];
+  let ty = copy_sep cleanup_scope fixed (compute_univars sch) [] pairs sch in
+  List.iter Lazy.force !delayed_copy;
+  delayed_copy := [];
+  vars, ty
+
+let instance_poly ?(keep_names=false) fixed univars sch =
+  For_copy.with_scope (fun cleanup_scope ->
+    instance_poly' cleanup_scope ~keep_names fixed univars sch
+  )
+
+let instance_label fixed lbl =
+  For_copy.with_scope (fun scope ->
+    let ty_res = copy scope lbl.lbl_res in
+    let vars, ty_arg =
+      match repr lbl.lbl_arg with
+        {desc = Tpoly (ty, tl)} ->
+          instance_poly' scope ~keep_names:false fixed tl ty
+      | _ ->
+          [], copy scope lbl.lbl_arg
+    in
+    (vars, ty_arg, ty_res)
+  )
+
+(**** Instantiation with parameter substitution ****)
+
+let unify' = (* Forward declaration *)
+  ref (fun _env _ty1 _ty2 -> raise (Unify []))
+
+let subst env level priv abbrev ty params args body =
+  if List.length params <> List.length args then raise (Unify []);
+  let old_level = !current_level in
+  current_level := level;
+  try
+    let body0 = newvar () in          (* Stub *)
+    begin match ty with
+      None      -> ()
+    | Some ({desc = Tconstr (path, tl, _)} as ty) ->
+        let abbrev = proper_abbrevs path tl abbrev in
+        memorize_abbrev abbrev priv path ty body0
+    | _ ->
+        assert false
+    end;
+    abbreviations := abbrev;
+    let (params', body') = instance_parameterized_type params body in
+    abbreviations := ref Mnil;
+    !unify' env body0 body';
+    List.iter2 (!unify' env) params' args;
+    current_level := old_level;
+    body'
+  with Unify _ as exn ->
+    current_level := old_level;
+    raise exn
+
+(*
+   Only the shape of the type matters, not whether it is generic or
+   not. [generic_level] might be somewhat slower, but it ensures
+   invariants on types are enforced (decreasing levels), and we don't
+   care about efficiency here.
+*)
+let apply env params body args =
+  try
+    subst env generic_level Public (ref Mnil) None params args body
+  with
+    Unify _ -> raise Cannot_apply
+
+let () = Subst.ctype_apply_env_empty := apply Env.empty
+
+                              (****************************)
+                              (*  Abbreviation expansion  *)
+                              (****************************)
+
+(*
+   If the environment has changed, memorized expansions might not
+   be correct anymore, and so we flush the cache. This is safe but
+   quite pessimistic: it would be enough to flush the cache when a
+   type or module definition is overridden in the environment.
+*)
+let previous_env = ref Env.empty
+(*let string_of_kind = function Public -> "public" | Private -> "private"*)
+let check_abbrev_env env =
+  if env != !previous_env then begin
+    (* prerr_endline "cleanup expansion cache"; *)
+    cleanup_abbrev ();
+    previous_env := env
+  end
+
+
+(* Expand an abbreviation. The expansion is memorized. *)
+(*
+   Assume the level is greater than the path binding time of the
+   expanded abbreviation.
+*)
+(*
+   An abbreviation expansion will fail in either of these cases:
+   1. The type constructor does not correspond to a manifest type.
+   2. The type constructor is defined in an external file, and this
+      file is not in the path (missing -I options).
+   3. The type constructor is not in the "local" environment. This can
+      happens when a non-generic type variable has been instantiated
+      afterwards to the not yet defined type constructor. (Actually,
+      this cannot happen at the moment due to the strong constraints
+      between type levels and constructor binding time.)
+   4. The expansion requires the expansion of another abbreviation,
+      and this other expansion fails.
+*)
+let expand_abbrev_gen kind find_type_expansion env ty =
+  check_abbrev_env env;
+  match ty with
+    {desc = Tconstr (path, args, abbrev); level = level; scope} ->
+      let lookup_abbrev = proper_abbrevs path args abbrev in
+      begin match find_expans kind path !lookup_abbrev with
+        Some ty' ->
+          (* prerr_endline
+            ("found a "^string_of_kind kind^" expansion for "^Path.name path);*)
+          if level <> generic_level then
+            begin try
+              update_level env level ty'
+            with Unify _ ->
+              (* XXX This should not happen.
+                 However, levels are not correctly restored after a
+                 typing error *)
+              ()
+            end;
+          begin try
+            update_scope scope ty';
+          with Unify _ ->
+            (* XXX This should not happen.
+               However, levels are not correctly restored after a
+               typing error *)
+            ()
+          end;
+          let ty' = repr ty' in
+          (* assert (ty != ty'); *) (* PR#7324 *)
+          ty'
+      | None ->
+          match find_type_expansion path env with
+          | exception Not_found ->
+            (* another way to expand is to normalize the path itself *)
+            let path' = Env.normalize_type_path None env path in
+            if Path.same path path' then raise Cannot_expand
+            else newty2 level (Tconstr (path', args, abbrev))
+          | (params, body, lv) ->
+            (* prerr_endline
+              ("add a "^string_of_kind kind^" expansion for "^Path.name path);*)
+            let ty' = subst env level kind abbrev (Some ty) params args body in
+            (* For gadts, remember type as non exportable *)
+            (* The ambiguous level registered for ty' should be the highest *)
+            if !trace_gadt_instances then begin
+              let scope = max lv ty.scope in
+              if level < scope then raise (Trace.scope_escape ty);
+              set_scope ty scope;
+              set_scope ty' scope
+            end;
+            ty'
+      end
+  | _ ->
+      assert false
+
+(* Expand respecting privacy *)
+let expand_abbrev env ty =
+  expand_abbrev_gen Public Env.find_type_expansion env ty
+
+(* Expand once the head of a type *)
+let expand_head_once env ty =
+  try expand_abbrev env (repr ty) with Cannot_expand -> assert false
+
+(* Check whether a type can be expanded *)
+let safe_abbrev env ty =
+  let snap = Btype.snapshot () in
+  try ignore (expand_abbrev env ty); true
+  with Cannot_expand | Unify _ ->
+    Btype.backtrack snap;
+    false
+
+(* Expand the head of a type once.
+   Raise Cannot_expand if the type cannot be expanded.
+   May raise Unify, if a recursion was hidden in the type. *)
+let try_expand_once env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr _ -> repr (expand_abbrev env ty)
+  | _ -> raise Cannot_expand
+
+(* This one only raises Cannot_expand *)
+let try_expand_safe env ty =
+  let snap = Btype.snapshot () in
+  try try_expand_once env ty
+  with Unify _ ->
+    Btype.backtrack snap; raise Cannot_expand
+
+(* Fully expand the head of a type. *)
+let rec try_expand_head try_once env ty =
+  let ty' = try_once env ty in
+  try try_expand_head try_once env ty'
+  with Cannot_expand -> ty'
+
+(* Unsafe full expansion, may raise Unify. *)
+let expand_head_unif env ty =
+  try try_expand_head try_expand_once env ty with Cannot_expand -> repr ty
+
+(* Safe version of expand_head, never fails *)
+let expand_head env ty =
+  try try_expand_head try_expand_safe env ty with Cannot_expand -> repr ty
+
+let _ = forward_try_expand_once := try_expand_safe
+
+
+(* Expand until we find a non-abstract type declaration,
+   use try_expand_safe to avoid raising "Unify _" when
+   called on recursive types
+ *)
+
+let rec extract_concrete_typedecl env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr (p, _, _) ->
+      let decl = Env.find_type p env in
+      if decl.type_kind <> Type_abstract then (p, p, decl) else
+      let ty =
+        try try_expand_safe env ty with Cannot_expand -> raise Not_found
+      in
+      let (_, p', decl) = extract_concrete_typedecl env ty in
+        (p, p', decl)
+  | _ -> raise Not_found
+
+(* Implementing function [expand_head_opt], the compiler's own version of
+   [expand_head] used for type-based optimisations.
+   [expand_head_opt] uses [Env.find_type_expansion_opt] to access the
+   manifest type information of private abstract data types which is
+   normally hidden to the type-checker out of the implementation module of
+   the private abbreviation. *)
+
+let expand_abbrev_opt =
+  expand_abbrev_gen Private Env.find_type_expansion_opt
+
+let try_expand_once_opt env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr _ -> repr (expand_abbrev_opt env ty)
+  | _ -> raise Cannot_expand
+
+let rec try_expand_head_opt env ty =
+  let ty' = try_expand_once_opt env ty in
+  begin try
+    try_expand_head_opt env ty'
+  with Cannot_expand ->
+    ty'
+  end
+
+let expand_head_opt env ty =
+  let snap = Btype.snapshot () in
+  try try_expand_head_opt env ty
+  with Cannot_expand | Unify _ -> (* expand_head shall never fail *)
+    Btype.backtrack snap;
+    repr ty
+
+(* Make sure that the type parameters of the type constructor [ty]
+   respect the type constraints *)
+let enforce_constraints env ty =
+  match ty with
+    {desc = Tconstr (path, args, _abbrev); level = level} ->
+      begin try
+        let decl = Env.find_type path env in
+        ignore
+          (subst env level Public (ref Mnil) None decl.type_params args
+             (newvar2 level))
+      with Not_found -> ()
+      end
+  | _ ->
+      assert false
+
+(* Recursively expand the head of a type.
+   Also expand #-types. *)
+let full_expand env ty =
+  let ty = repr (expand_head env ty) in
+  match ty.desc with
+    Tobject (fi, {contents = Some (_, v::_)}) when is_Tvar (repr v) ->
+      newty2 ty.level (Tobject (fi, ref None))
+  | _ ->
+      ty
+
+(*
+   Check whether the abbreviation expands to a well-defined type.
+   During the typing of a class, abbreviations for correspondings
+   types expand to non-generic types.
+*)
+let generic_abbrev env path =
+  try
+    let (_, body, _) = Env.find_type_expansion path env in
+    (repr body).level = generic_level
+  with
+    Not_found ->
+      false
+
+let generic_private_abbrev env path =
+  try
+    match Env.find_type path env with
+      {type_kind = Type_abstract;
+       type_private = Private;
+       type_manifest = Some body} ->
+         (repr body).level = generic_level
+    | _ -> false
+  with Not_found -> false
+
+let is_contractive env p =
+  try
+    let decl = Env.find_type p env in
+    in_pervasives p && decl.type_manifest = None || is_datatype decl
+  with Not_found -> false
+
+
+                              (*****************)
+                              (*  Occur check  *)
+                              (*****************)
+
+
+exception Occur
+
+let rec occur_rec env allow_recursive visited ty0 = function
+  | {desc=Tlink ty} ->
+      occur_rec env allow_recursive visited ty0 ty
+  | ty ->
+  if ty == ty0  then raise Occur;
+  match ty.desc with
+    Tconstr(p, _tl, _abbrev) ->
+      if allow_recursive && is_contractive env p then () else
+      begin try
+        if TypeSet.mem ty visited then raise Occur;
+        let visited = TypeSet.add ty visited in
+        iter_type_expr (occur_rec env allow_recursive visited ty0) ty
+      with Occur -> try
+        let ty' = try_expand_head try_expand_once env ty in
+        (* This call used to be inlined, but there seems no reason for it.
+           Message was referring to change in rev. 1.58 of the CVS repo. *)
+        occur_rec env allow_recursive visited ty0 ty'
+      with Cannot_expand ->
+        raise Occur
+      end
+  | Tobject _ | Tvariant _ ->
+      ()
+  | _ ->
+      if allow_recursive ||  TypeSet.mem ty visited then () else begin
+        let visited = TypeSet.add ty visited in
+        iter_type_expr (occur_rec env allow_recursive visited ty0) ty
+      end
+
+let type_changed = ref false (* trace possible changes to the studied type *)
+
+let merge r b = if b then r := true
+
+let occur env ty0 ty =
+  let allow_recursive = !Clflags.recursive_types || !umode = Pattern  in
+  let old = !type_changed in
+  try
+    while
+      type_changed := false;
+      occur_rec env allow_recursive TypeSet.empty ty0 ty;
+      !type_changed
+    do () (* prerr_endline "changed" *) done;
+    merge type_changed old
+  with exn ->
+    merge type_changed old;
+    match exn with
+    | Occur -> raise (Trace.rec_occur ty0 ty)
+    | _ -> raise exn
+
+let occur_in env ty0 t =
+  try occur env ty0 t; false with Unify _ -> true
+
+(* Check that a local constraint is well-founded *)
+(* PR#6405: not needed since we allow recursion and work on normalized types *)
+(* PR#6992: we actually need it for contractiveness *)
+(* This is a simplified version of occur, only for the rectypes case *)
+
+let rec local_non_recursive_abbrev strict visited env p ty =
+  (*Format.eprintf "@[Check %s =@ %a@]@." (Path.name p) !Btype.print_raw ty;*)
+  let ty = repr ty in
+  if not (List.memq ty visited) then begin
+    match ty.desc with
+      Tconstr(p', args, _abbrev) ->
+        if Path.same p p' then raise Occur;
+        if not strict && is_contractive env p' then () else
+        let visited = ty :: visited in
+        begin try
+          (* try expanding, since [p] could be hidden *)
+          local_non_recursive_abbrev strict visited env p
+            (try_expand_head try_expand_once_opt env ty)
+        with Cannot_expand ->
+          let params =
+            try (Env.find_type p' env).type_params
+            with Not_found -> args
+          in
+          List.iter2
+            (fun tv ty ->
+              let strict = strict || not (is_Tvar (repr tv)) in
+              local_non_recursive_abbrev strict visited env p ty)
+            params args
+        end
+    | _ ->
+        if strict then (* PR#7374 *)
+          let visited = ty :: visited in
+          iter_type_expr (local_non_recursive_abbrev true visited env p) ty
+  end
+
+let local_non_recursive_abbrev env p ty =
+  try (* PR#7397: need to check trace_gadt_instances *)
+    wrap_trace_gadt_instances env
+      (local_non_recursive_abbrev false [] env p) ty;
+    true
+  with Occur -> false
+
+
+                   (*****************************)
+                   (*  Polymorphic Unification  *)
+                   (*****************************)
+
+(* Since we cannot duplicate universal variables, unification must
+   be done at meta-level, using bindings in univar_pairs *)
+let rec unify_univar t1 t2 = function
+    (cl1, cl2) :: rem ->
+      let find_univ t cl =
+        try
+          let (_, r) = List.find (fun (t',_) -> t == repr t') cl in
+          Some r
+        with Not_found -> None
+      in
+      begin match find_univ t1 cl1, find_univ t2 cl2 with
+        Some {contents=Some t'2}, Some _ when t2 == repr t'2 ->
+          ()
+      | Some({contents=None} as r1), Some({contents=None} as r2) ->
+          set_univar r1 t2; set_univar r2 t1
+      | None, None ->
+          unify_univar t1 t2 rem
+      | _ ->
+          raise (Unify [])
+      end
+  | [] -> raise (Unify [])
+
+(* Test the occurrence of free univars in a type *)
+(* that's way too expensive. Must do some kind of caching *)
+let occur_univar env ty =
+  let visited = ref TypeMap.empty in
+  let rec occur_rec bound ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level &&
+      if TypeSet.is_empty bound then
+        (ty.level <- pivot_level - ty.level; true)
+      else try
+        let bound' = TypeMap.find ty !visited in
+        if TypeSet.exists (fun x -> not (TypeSet.mem x bound)) bound' then
+          (visited := TypeMap.add ty (TypeSet.inter bound bound') !visited;
+           true)
+        else false
+      with Not_found ->
+        visited := TypeMap.add ty bound !visited;
+        true
+    then
+      match ty.desc with
+        Tunivar _ ->
+          if not (TypeSet.mem ty bound) then
+            raise Trace.(Unify [escape (Univ ty)])
+      | Tpoly (ty, tyl) ->
+          let bound = List.fold_right TypeSet.add (List.map repr tyl) bound in
+          occur_rec bound  ty
+      | Tconstr (_, [], _) -> ()
+      | Tconstr (p, tl, _) ->
+          begin try
+            let td = Env.find_type p env in
+            List.iter2
+              (fun t v ->
+                if Variance.(mem May_pos v || mem May_neg v)
+                then occur_rec bound t)
+              tl td.type_variance
+          with Not_found ->
+            List.iter (occur_rec bound) tl
+          end
+      | _ -> iter_type_expr (occur_rec bound) ty
+  in
+  Misc.try_finally (fun () ->
+      occur_rec TypeSet.empty ty
+    )
+    ~always:(fun () -> unmark_type ty)
+
+(* Grouping univars by families according to their binders *)
+let add_univars =
+  List.fold_left (fun s (t,_) -> TypeSet.add (repr t) s)
+
+let get_univar_family univar_pairs univars =
+  if univars = [] then TypeSet.empty else
+  let insert s = function
+      cl1, (_::_ as cl2) ->
+        if List.exists (fun (t1,_) -> TypeSet.mem (repr t1) s) cl1 then
+          add_univars s cl2
+        else s
+    | _ -> s
+  in
+  let s = List.fold_right TypeSet.add univars TypeSet.empty in
+  List.fold_left insert s univar_pairs
+
+(* Whether a family of univars escapes from a type *)
+let univars_escape env univar_pairs vl ty =
+  let family = get_univar_family univar_pairs vl in
+  let visited = ref TypeSet.empty in
+  let rec occur t =
+    let t = repr t in
+    if TypeSet.mem t !visited then () else begin
+      visited := TypeSet.add t !visited;
+      match t.desc with
+        Tpoly (t, tl) ->
+          if List.exists (fun t -> TypeSet.mem (repr t) family) tl then ()
+          else occur t
+      | Tunivar _ ->
+          if TypeSet.mem t family then raise Trace.(Unify [escape(Univ t)])
+      | Tconstr (_, [], _) -> ()
+      | Tconstr (p, tl, _) ->
+          begin try
+            let td = Env.find_type p env in
+            List.iter2
+              (fun t v ->
+                if Variance.(mem May_pos v || mem May_neg v) then occur t)
+              tl td.type_variance
+          with Not_found ->
+            List.iter occur tl
+          end
+      | _ ->
+          iter_type_expr occur t
+    end
+  in
+  occur ty
+
+(* Wrapper checking that no variable escapes and updating univar_pairs *)
+let enter_poly env univar_pairs t1 tl1 t2 tl2 f =
+  let old_univars = !univar_pairs in
+  let known_univars =
+    List.fold_left (fun s (cl,_) -> add_univars s cl)
+      TypeSet.empty old_univars
+  in
+  let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
+  if List.exists (fun t -> TypeSet.mem t known_univars) tl1 then
+     univars_escape env old_univars tl1 (newty(Tpoly(t2,tl2)));
+  if List.exists (fun t -> TypeSet.mem t known_univars) tl2 then
+    univars_escape env old_univars tl2 (newty(Tpoly(t1,tl1)));
+  let cl1 = List.map (fun t -> t, ref None) tl1
+  and cl2 = List.map (fun t -> t, ref None) tl2 in
+  univar_pairs := (cl1,cl2) :: (cl2,cl1) :: old_univars;
+  Misc.try_finally (fun () -> f t1 t2)
+    ~always:(fun () -> univar_pairs := old_univars)
+
+let univar_pairs = ref []
+
+(* assumption: [ty] is fully generalized. *)
+let reify_univars ty =
+  let rec subst_univar scope vars ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      ty.level <- pivot_level - ty.level;
+      match ty.desc with
+      | Tvar name ->
+          For_copy.save_desc scope ty ty.desc;
+          let t = newty2 ty.level (Tunivar name) in
+          vars := t :: !vars;
+          ty.desc <- Tsubst t
+      | _ ->
+          iter_type_expr (subst_univar scope vars) ty
+    end
+  in
+  let vars = ref [] in
+  let ty =
+    For_copy.with_scope (fun scope ->
+      subst_univar scope vars ty;
+      unmark_type ty;
+      copy scope ty
+    )
+  in
+  newty2 ty.level (Tpoly(repr ty, !vars))
+
+
+                              (*****************)
+                              (*  Unification  *)
+                              (*****************)
+
+
+
+let rec has_cached_expansion p abbrev =
+  match abbrev with
+    Mnil                   -> false
+  | Mcons(_, p', _, _, rem)   -> Path.same p p' || has_cached_expansion p rem
+  | Mlink rem              -> has_cached_expansion p !rem
+
+(**** Transform error trace ****)
+(* +++ Move it to some other place ? *)
+
+let expand_trace env trace =
+  let expand_desc x = match x.Trace.expanded with
+    | None -> Trace.{ t = repr x.t; expanded= Some(full_expand env x.t) }
+    | Some _ -> x in
+  Unification_trace.map expand_desc trace
+
+(**** Unification ****)
+
+(* Return whether [t0] occurs in [ty]. Objects are also traversed. *)
+let deep_occur t0 ty =
+  let rec occur_rec ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      if ty == t0 then raise Occur;
+      ty.level <- pivot_level - ty.level;
+      iter_type_expr occur_rec ty
+    end
+  in
+  try
+    occur_rec ty; unmark_type ty; false
+  with Occur ->
+    unmark_type ty; true
+
+(*
+   1. When unifying two non-abbreviated types, one type is made a link
+      to the other. When unifying an abbreviated type with a
+      non-abbreviated type, the non-abbreviated type is made a link to
+      the other one. When unifying to abbreviated types, these two
+      types are kept distincts, but they are made to (temporally)
+      expand to the same type.
+   2. Abbreviations with at least one parameter are systematically
+      expanded. The overhead does not seem too high, and that way
+      abbreviations where some parameters does not appear in the
+      expansion, such as ['a t = int], are correctly handled. In
+      particular, for this example, unifying ['a t] with ['b t] keeps
+      ['a] and ['b] distincts. (Is it really important ?)
+   3. Unifying an abbreviation ['a t = 'a] with ['a] should not yield
+      ['a t as 'a]. Indeed, the type variable would otherwise be lost.
+      This problem occurs for abbreviations expanding to a type
+      variable, but also to many other constrained abbreviations (for
+      instance, [(< x : 'a > -> unit) t = <x : 'a>]). The solution is
+      that, if an abbreviation is unified with some subpart of its
+      parameters, then the parameter actually does not get
+      abbreviated.  It would be possible to check whether some
+      information is indeed lost, but it probably does not worth it.
+*)
+
+let gadt_equations_level = ref None
+
+let get_gadt_equations_level () =
+  match !gadt_equations_level with
+  | None -> assert false
+  | Some x -> x
+
+
+(* a local constraint can be added only if the rhs
+   of the constraint does not contain any Tvars.
+   They need to be removed using this function *)
+let reify env t =
+  let fresh_constr_scope = get_gadt_equations_level () in
+  let create_fresh_constr lev name =
+    let name = match name with Some s -> "$'"^s | _ -> "$" in
+    let path =
+      Path.Pident
+        (Ident.create_scoped ~scope:fresh_constr_scope
+           (get_new_abstract_name name))
+    in
+    let decl = new_declaration fresh_constr_scope None in
+    let new_env = Env.add_local_type path decl !env in
+    let t = newty2 lev (Tconstr (path,[],ref Mnil))  in
+    env := new_env;
+    path, t
+  in
+  let visited = ref TypeSet.empty in
+  let rec iterator ty =
+    let ty = repr ty in
+    if TypeSet.mem ty !visited then () else begin
+      visited := TypeSet.add ty !visited;
+      match ty.desc with
+        Tvar o ->
+          let path, t = create_fresh_constr ty.level o in
+          link_type ty t;
+          if ty.level < fresh_constr_scope then
+            raise Trace.(Unify [escape (Constructor path)])
+      | Tvariant r ->
+          let r = row_repr r in
+          if not (static_row r) then begin
+            if is_fixed r then iterator (row_more r) else
+            let m = r.row_more in
+            match m.desc with
+              Tvar o ->
+                let path, t = create_fresh_constr m.level o in
+                let row =
+                  let row_fixed = Some (Reified path) in
+                  {r with row_fields=[]; row_fixed; row_more = t} in
+                link_type m (newty2 m.level (Tvariant row));
+                if m.level < fresh_constr_scope then
+                  raise Trace.(Unify [escape (Constructor path)])
+            | _ -> assert false
+          end;
+          iter_row iterator r
+      | Tconstr (p, _, _) when is_object_type p ->
+          iter_type_expr iterator (full_expand !env ty)
+      | _ ->
+          iter_type_expr iterator ty
+    end
+  in
+  iterator t
+
+let is_newtype env p =
+  try
+    let decl = Env.find_type p env in
+    decl.type_expansion_scope <> Btype.lowest_level &&
+    decl.type_kind = Type_abstract &&
+    decl.type_private = Public
+  with Not_found -> false
+
+let non_aliasable p decl =
+  (* in_pervasives p ||  (subsumed by in_current_module) *)
+  in_current_module p && not decl.type_is_newtype
+
+let is_instantiable env p =
+  try
+    let decl = Env.find_type p env in
+    decl.type_kind = Type_abstract &&
+    decl.type_private = Public &&
+    decl.type_arity = 0 &&
+    decl.type_manifest = None &&
+    not (non_aliasable p decl)
+  with Not_found -> false
+
+
+(* PR#7113: -safe-string should be a global property *)
+let compatible_paths p1 p2 =
+  let open Predef in
+  Path.same p1 p2 ||
+  Path.same p1 path_bytes && Path.same p2 path_string ||
+  Path.same p1 path_string && Path.same p2 path_bytes
+
+(* Check for datatypes carefully; see PR#6348 *)
+let rec expands_to_datatype env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr (p, _, _) ->
+      begin try
+        is_datatype (Env.find_type p env) ||
+        expands_to_datatype env (try_expand_once env ty)
+      with Not_found | Cannot_expand -> false
+      end
+  | _ -> false
+
+(* mcomp type_pairs subst env t1 t2 does not raise an
+   exception if it is possible that t1 and t2 are actually
+   equal, assuming the types in type_pairs are equal and
+   that the mapping subst holds.
+   Assumes that both t1 and t2 do not contain any tvars
+   and that both their objects and variants are closed
+ *)
+
+let rec mcomp type_pairs env t1 t2 =
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then () else
+  match (t1.desc, t2.desc) with
+  | (Tvar _, _)
+  | (_, Tvar _)  ->
+      ()
+  | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
+      ()
+  | _ ->
+      let t1' = expand_head_opt env t1 in
+      let t2' = expand_head_opt env t2 in
+      (* Expansion may have changed the representative of the types... *)
+      let t1' = repr t1' and t2' = repr t2' in
+      if t1' == t2' then () else
+      begin try TypePairs.find type_pairs (t1', t2')
+      with Not_found ->
+        TypePairs.add type_pairs (t1', t2') ();
+        match (t1'.desc, t2'.desc) with
+        | (Tvar _, _)
+        | (_, Tvar _)  ->
+            ()
+        | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _))
+          when l1 = l2 || not (is_optional l1 || is_optional l2) ->
+            mcomp type_pairs env t1 t2;
+            mcomp type_pairs env u1 u2;
+        | (Ttuple tl1, Ttuple tl2) ->
+            mcomp_list type_pairs env tl1 tl2
+        | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) ->
+            mcomp_type_decl type_pairs env p1 p2 tl1 tl2
+        | (Tconstr (p, _, _), _) | (_, Tconstr (p, _, _)) ->
+            begin try
+              let decl = Env.find_type p env in
+              if non_aliasable p decl || is_datatype decl then raise (Unify [])
+            with Not_found -> ()
+            end
+        (*
+        | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) when n1 = n2 ->
+            mcomp_list type_pairs env tl1 tl2
+        *)
+        | (Tpackage _, Tpackage _) -> ()
+        | (Tvariant row1, Tvariant row2) ->
+            mcomp_row type_pairs env row1 row2
+        | (Tobject (fi1, _), Tobject (fi2, _)) ->
+            mcomp_fields type_pairs env fi1 fi2
+        | (Tfield _, Tfield _) ->       (* Actually unused *)
+            mcomp_fields type_pairs env t1' t2'
+        | (Tnil, Tnil) ->
+            ()
+        | (Tpoly (t1, []), Tpoly (t2, [])) ->
+            mcomp type_pairs env t1 t2
+        | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
+            enter_poly env univar_pairs t1 tl1 t2 tl2
+              (mcomp type_pairs env)
+        | (Tunivar _, Tunivar _) ->
+            unify_univar t1' t2' !univar_pairs
+        | (_, _) ->
+            raise (Unify [])
+      end
+
+and mcomp_list type_pairs env tl1 tl2 =
+  if List.length tl1 <> List.length tl2 then
+    raise (Unify []);
+  List.iter2 (mcomp type_pairs env) tl1 tl2
+
+and mcomp_fields type_pairs env ty1 ty2 =
+  if not (concrete_object ty1 && concrete_object ty2) then assert false;
+  let (fields2, rest2) = flatten_fields ty2 in
+  let (fields1, rest1) = flatten_fields ty1 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let has_present =
+    List.exists (fun (_, k, _) -> field_kind_repr k = Fpresent) in
+  mcomp type_pairs env rest1 rest2;
+  if has_present miss1  && (object_row ty2).desc = Tnil
+  || has_present miss2  && (object_row ty1).desc = Tnil then raise (Unify []);
+  List.iter
+    (function (_n, k1, t1, k2, t2) ->
+       mcomp_kind k1 k2;
+       mcomp type_pairs env t1 t2)
+    pairs
+
+and mcomp_kind k1 k2 =
+  let k1 = field_kind_repr k1 in
+  let k2 = field_kind_repr k2 in
+  match k1, k2 with
+    (Fpresent, Fabsent)
+  | (Fabsent, Fpresent) -> raise (Unify [])
+  | _                   -> ()
+
+and mcomp_row type_pairs env row1 row2 =
+  let row1 = row_repr row1 and row2 = row_repr row2 in
+  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
+  let cannot_erase (_,f) =
+    match row_field_repr f with
+      Rpresent _ -> true
+    | Rabsent | Reither _ -> false
+  in
+  if row1.row_closed && List.exists cannot_erase r2
+  || row2.row_closed && List.exists cannot_erase r1 then raise (Unify []);
+  List.iter
+    (fun (_,f1,f2) ->
+      match row_field_repr f1, row_field_repr f2 with
+      | Rpresent None, (Rpresent (Some _) | Reither (_, _::_, _, _) | Rabsent)
+      | Rpresent (Some _), (Rpresent None | Reither (true, _, _, _) | Rabsent)
+      | (Reither (_, _::_, _, _) | Rabsent), Rpresent None
+      | (Reither (true, _, _, _) | Rabsent), Rpresent (Some _) ->
+          raise (Unify [])
+      | Rpresent(Some t1), Rpresent(Some t2) ->
+          mcomp type_pairs env t1 t2
+      | Rpresent(Some t1), Reither(false, tl2, _, _) ->
+          List.iter (mcomp type_pairs env t1) tl2
+      | Reither(false, tl1, _, _), Rpresent(Some t2) ->
+          List.iter (mcomp type_pairs env t2) tl1
+      | _ -> ())
+    pairs
+
+and mcomp_type_decl type_pairs env p1 p2 tl1 tl2 =
+  try
+    let decl = Env.find_type p1 env in
+    let decl' = Env.find_type p2 env in
+    if compatible_paths p1 p2 then begin
+      let inj =
+        try List.map Variance.(mem Inj) (Env.find_type p1 env).type_variance
+        with Not_found -> List.map (fun _ -> false) tl1
+      in
+      List.iter2
+        (fun i (t1,t2) -> if i then mcomp type_pairs env t1 t2)
+        inj (List.combine tl1 tl2)
+    end else if non_aliasable p1 decl && non_aliasable p2 decl' then
+      raise (Unify [])
+    else
+      match decl.type_kind, decl'.type_kind with
+      | Type_record (lst,r), Type_record (lst',r') when r = r' ->
+          mcomp_list type_pairs env tl1 tl2;
+          mcomp_record_description type_pairs env lst lst'
+      | Type_variant v1, Type_variant v2 ->
+          mcomp_list type_pairs env tl1 tl2;
+          mcomp_variant_description type_pairs env v1 v2
+      | Type_open, Type_open ->
+          mcomp_list type_pairs env tl1 tl2
+      | Type_abstract, Type_abstract -> ()
+      | Type_abstract, _ when not (non_aliasable p1 decl)-> ()
+      | _, Type_abstract when not (non_aliasable p2 decl') -> ()
+      | _ -> raise (Unify [])
+  with Not_found -> ()
+
+and mcomp_type_option type_pairs env t t' =
+  match t, t' with
+    None, None -> ()
+  | Some t, Some t' -> mcomp type_pairs env t t'
+  | _ -> raise (Unify [])
+
+and mcomp_variant_description type_pairs env xs ys =
+  let rec iter = fun x y ->
+    match x, y with
+    | c1 :: xs, c2 :: ys   ->
+      mcomp_type_option type_pairs env c1.cd_res c2.cd_res;
+      begin match c1.cd_args, c2.cd_args with
+      | Cstr_tuple l1, Cstr_tuple l2 -> mcomp_list type_pairs env l1 l2
+      | Cstr_record l1, Cstr_record l2 ->
+          mcomp_record_description type_pairs env l1 l2
+      | _ -> raise (Unify [])
+      end;
+     if Ident.name c1.cd_id = Ident.name c2.cd_id
+      then iter xs ys
+      else raise (Unify [])
+    | [],[] -> ()
+    | _ -> raise (Unify [])
+  in
+  iter xs ys
+
+and mcomp_record_description type_pairs env =
+  let rec iter x y =
+    match x, y with
+    | l1 :: xs, l2 :: ys ->
+        mcomp type_pairs env l1.ld_type l2.ld_type;
+        if Ident.name l1.ld_id = Ident.name l2.ld_id &&
+           l1.ld_mutable = l2.ld_mutable
+        then iter xs ys
+        else raise (Unify [])
+    | [], [] -> ()
+    | _ -> raise (Unify [])
+  in
+  iter
+
+let mcomp env t1 t2 =
+  mcomp (TypePairs.create 4) env t1 t2
+
+(* Real unification *)
+
+let find_lowest_level ty =
+  let lowest = ref generic_level in
+  let rec find ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      if ty.level < !lowest then lowest := ty.level;
+      ty.level <- pivot_level - ty.level;
+      iter_type_expr find ty
+    end
+  in find ty; unmark_type ty; !lowest
+
+let find_expansion_scope env path =
+  (Env.find_type path env).type_expansion_scope
+
+let add_gadt_equation env source destination =
+  (* Format.eprintf "@[add_gadt_equation %s %a@]@."
+    (Path.name source) !Btype.print_raw destination; *)
+  if local_non_recursive_abbrev !env source destination then begin
+    let destination = duplicate_type destination in
+    let expansion_scope =
+      max (Path.scope source) (get_gadt_equations_level ())
+    in
+    let decl = new_declaration expansion_scope (Some destination) in
+    env := Env.add_local_type source decl !env;
+    cleanup_abbrev ()
+  end
+
+let unify_eq_set = TypePairs.create 11
+
+let order_type_pair t1 t2 =
+  if t1.id <= t2.id then (t1, t2) else (t2, t1)
+
+let add_type_equality t1 t2 =
+  TypePairs.add unify_eq_set (order_type_pair t1 t2) ()
+
+let eq_package_path env p1 p2 =
+  Path.same p1 p2 ||
+  Path.same (normalize_package_path env p1) (normalize_package_path env p2)
+
+let nondep_type' = ref (fun _ _ _ -> assert false)
+let package_subtype = ref (fun _ _ _ _ _ _ _ -> assert false)
+
+let rec concat_longident lid1 =
+  let open Longident in
+  function
+    Lident s -> Ldot (lid1, s)
+  | Ldot (lid2, s) -> Ldot (concat_longident lid1 lid2, s)
+  | Lapply (lid2, lid) -> Lapply (concat_longident lid1 lid2, lid)
+
+let nondep_instance env level id ty =
+  let ty = !nondep_type' env [id] ty in
+  if level = generic_level then duplicate_type ty else
+  let old = !current_level in
+  current_level := level;
+  let ty = instance ty in
+  current_level := old;
+  ty
+
+(* Find the type paths nl1 in the module type mty2, and add them to the
+   list (nl2, tl2). raise Not_found if impossible *)
+let complete_type_list ?(allow_absent=false) env nl1 lv2 mty2 nl2 tl2 =
+  (* This is morally WRONG: we're adding a (dummy) module without a scope in the
+     environment. However no operation which cares about levels/scopes is going
+     to happen while this module exists.
+     The only operations that happen are:
+     - Env.find_type_by_name
+     - nondep_instance
+     None of which check the scope.
+
+     It'd be nice if we avoided creating such temporary dummy modules and broken
+     environments though. *)
+  let id2 = Ident.create_local "Pkg" in
+  let env' = Env.add_module id2 Mp_present mty2 env in
+  let rec complete nl1 ntl2 =
+    match nl1, ntl2 with
+      [], _ -> ntl2
+    | n :: nl, (n2, _ as nt2) :: ntl' when n >= n2 ->
+        nt2 :: complete (if n = n2 then nl else nl1) ntl'
+    | n :: nl, _ ->
+        let lid = concat_longident (Longident.Lident "Pkg") n in
+        match Env.find_type_by_name lid env' with
+        | (_, {type_arity = 0; type_kind = Type_abstract;
+               type_private = Public; type_manifest = Some t2}) ->
+            (n, nondep_instance env' lv2 id2 t2) :: complete nl ntl2
+        | (_, {type_arity = 0; type_kind = Type_abstract;
+               type_private = Public; type_manifest = None})
+          when allow_absent ->
+            complete nl ntl2
+        | _ -> raise Exit
+        | exception Not_found when allow_absent->
+            complete nl ntl2
+  in
+  match complete nl1 (List.combine nl2 tl2) with
+  | res -> res
+  | exception Exit -> raise Not_found
+
+(* raise Not_found rather than Unify if the module types are incompatible *)
+let unify_package env unify_list lv1 p1 n1 tl1 lv2 p2 n2 tl2 =
+  let ntl2 = complete_type_list env n1 lv2 (Mty_ident p2) n2 tl2
+  and ntl1 = complete_type_list env n2 lv1 (Mty_ident p1) n1 tl1 in
+  unify_list (List.map snd ntl1) (List.map snd ntl2);
+  if eq_package_path env p1 p2
+  || !package_subtype env p1 n1 tl1 p2 n2 tl2
+  && !package_subtype env p2 n2 tl2 p1 n1 tl1 then () else raise Not_found
+
+
+(* force unification in Reither when one side has a non-conjunctive type *)
+let rigid_variants = ref false
+
+(* drop not force unification in Reither, even in fixed case
+   (not sound, only use it when checking exhaustiveness) *)
+let passive_variants = ref false
+let with_passive_variants f x =
+  if !passive_variants then f x else
+  match passive_variants := true; f x with
+  | r           -> passive_variants := false; r
+  | exception e -> passive_variants := false; raise e
+
+let unify_eq t1 t2 =
+  t1 == t2 ||
+  match !umode with
+  | Expression -> false
+  | Pattern ->
+      try TypePairs.find unify_eq_set (order_type_pair t1 t2); true
+      with Not_found -> false
+
+let unify1_var env t1 t2 =
+  assert (is_Tvar t1);
+  occur env t1 t2;
+  occur_univar env t2;
+  let d1 = t1.desc in
+  link_type t1 t2;
+  try
+    update_level env t1.level t2;
+    update_scope t1.scope t2
+  with Unify _ as e ->
+    t1.desc <- d1;
+    raise e
+
+let rec unify (env:Env.t ref) t1 t2 =
+  (* First step: special cases (optimizations) *)
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if unify_eq t1 t2 then () else
+  let reset_tracing = check_trace_gadt_instances !env in
+
+  try
+    type_changed := true;
+    begin match (t1.desc, t2.desc) with
+      (Tvar _, Tconstr _) when deep_occur t1 t2 ->
+        unify2 env t1 t2
+    | (Tconstr _, Tvar _) when deep_occur t2 t1 ->
+        unify2 env t1 t2
+    | (Tvar _, _) ->
+        unify1_var !env t1 t2
+    | (_, Tvar _) ->
+        unify1_var !env t2 t1
+    | (Tunivar _, Tunivar _) ->
+        unify_univar t1 t2 !univar_pairs;
+        update_level !env t1.level t2;
+        update_scope t1.scope t2;
+        link_type t1 t2
+    | (Tconstr (p1, [], a1), Tconstr (p2, [], a2))
+          when Path.same p1 p2 (* && actual_mode !env = Old *)
+            (* This optimization assumes that t1 does not expand to t2
+               (and conversely), so we fall back to the general case
+               when any of the types has a cached expansion. *)
+            && not (has_cached_expansion p1 !a1
+                 || has_cached_expansion p2 !a2) ->
+        update_level !env t1.level t2;
+        update_scope t1.scope t2;
+        link_type t1 t2
+    | (Tconstr (p1, [], _), Tconstr (p2, [], _))
+      when Env.has_local_constraints !env
+      && is_newtype !env p1 && is_newtype !env p2 ->
+        (* Do not use local constraints more than necessary *)
+        begin try
+          if find_expansion_scope !env p1 > find_expansion_scope !env p2 then
+            unify env t1 (try_expand_once !env t2)
+          else
+            unify env (try_expand_once !env t1) t2
+        with Cannot_expand ->
+          unify2 env t1 t2
+        end
+    | _ ->
+        unify2 env t1 t2
+    end;
+    reset_trace_gadt_instances reset_tracing;
+  with Unify trace ->
+    reset_trace_gadt_instances reset_tracing;
+    raise( Unify (Trace.diff t1 t2 :: trace) )
+
+and unify2 env t1 t2 =
+  (* Second step: expansion of abbreviations *)
+  (* Expansion may change the representative of the types. *)
+  ignore (expand_head_unif !env t1);
+  ignore (expand_head_unif !env t2);
+  let t1' = expand_head_unif !env t1 in
+  let t2' = expand_head_unif !env t2 in
+  let lv = min t1'.level t2'.level in
+  let scope = max t1'.scope t2'.scope in
+  update_level !env lv t2;
+  update_level !env lv t1;
+  update_scope scope t2;
+  update_scope scope t1;
+  if unify_eq t1' t2' then () else
+
+  let t1 = repr t1 and t2 = repr t2 in
+  let t1, t2 =
+    if !Clflags.principal
+    && (find_lowest_level t1' < lv || find_lowest_level t2' < lv) then
+      (* Expand abbreviations hiding a lower level *)
+      (* Should also do it for parameterized types, after unification... *)
+      (match t1.desc with Tconstr (_, [], _) -> t1' | _ -> t1),
+      (match t2.desc with Tconstr (_, [], _) -> t2' | _ -> t2)
+    else (t1, t2)
+  in
+  if unify_eq t1 t1' || not (unify_eq t2 t2') then
+    unify3 env t1 t1' t2 t2'
+  else
+    try unify3 env t2 t2' t1 t1' with Unify trace ->
+      raise (Unify (Trace.swap trace))
+
+and unify3 env t1 t1' t2 t2' =
+  (* Third step: truly unification *)
+  (* Assumes either [t1 == t1'] or [t2 != t2'] *)
+  let d1 = t1'.desc and d2 = t2'.desc in
+  let create_recursion = (t2 != t2') && (deep_occur t1' t2) in
+
+  begin match (d1, d2) with (* handle vars and univars specially *)
+    (Tunivar _, Tunivar _) ->
+      unify_univar t1' t2' !univar_pairs;
+      link_type t1' t2'
+  | (Tvar _, _) ->
+      occur !env t1' t2;
+      occur_univar !env t2;
+      link_type t1' t2;
+  | (_, Tvar _) ->
+      occur !env t2' t1;
+      occur_univar !env t1;
+      link_type t2' t1;
+  | (Tfield _, Tfield _) -> (* special case for GADTs *)
+      unify_fields env t1' t2'
+  | _ ->
+    begin match !umode with
+    | Expression ->
+        occur !env t1' t2';
+        if is_self_type d1 (* PR#7711: do not abbreviate self type *)
+        then link_type t1' t2'
+        else link_type t1' t2
+    | Pattern ->
+        add_type_equality t1' t2'
+    end;
+    try
+      begin match (d1, d2) with
+        (Tarrow (l1, t1, u1, c1), Tarrow (l2, t2, u2, c2)) when l1 = l2 ||
+        (!Clflags.classic || !umode = Pattern) &&
+        not (is_optional l1 || is_optional l2) ->
+          unify  env t1 t2; unify env  u1 u2;
+          begin match commu_repr c1, commu_repr c2 with
+            Clink r, c2 -> set_commu r c2
+          | c1, Clink r -> set_commu r c1
+          | _ -> ()
+          end
+      | (Ttuple tl1, Ttuple tl2) ->
+          unify_list env tl1 tl2
+      | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
+          if !umode = Expression || not !generate_equations then
+            unify_list env tl1 tl2
+          else if !assume_injective then
+            set_mode_pattern ~generate:true ~injective:false
+                             (fun () -> unify_list env tl1 tl2)
+          else if in_current_module p1 (* || in_pervasives p1 *)
+                  || List.exists (expands_to_datatype !env) [t1'; t1; t2] then
+            unify_list env tl1 tl2
+          else
+            let inj =
+              try List.map Variance.(mem Inj)
+                    (Env.find_type p1 !env).type_variance
+              with Not_found -> List.map (fun _ -> false) tl1
+            in
+            List.iter2
+              (fun i (t1, t2) ->
+                if i then unify env t1 t2 else
+                set_mode_pattern ~generate:false ~injective:false
+                  begin fun () ->
+                    let snap = snapshot () in
+                    try unify env t1 t2 with Unify _ ->
+                      backtrack snap;
+                      reify env t1; reify env t2
+                  end)
+              inj (List.combine tl1 tl2)
+      | (Tconstr (path,[],_),
+         Tconstr (path',[],_))
+        when is_instantiable !env path && is_instantiable !env path'
+        && !generate_equations ->
+          let source, destination =
+            if Path.scope path > Path.scope path'
+            then  path , t2'
+            else  path', t1'
+          in
+          add_gadt_equation env source destination
+      | (Tconstr (path,[],_), _)
+        when is_instantiable !env path && !generate_equations ->
+          reify env t2';
+          add_gadt_equation env path t2'
+      | (_, Tconstr (path,[],_))
+        when is_instantiable !env path && !generate_equations ->
+          reify env t1';
+          add_gadt_equation env path t1'
+      | (Tconstr (_,_,_), _) | (_, Tconstr (_,_,_)) when !umode = Pattern ->
+          reify env t1';
+          reify env t2';
+          if !generate_equations then mcomp !env t1' t2'
+      | (Tobject (fi1, nm1), Tobject (fi2, _)) ->
+          unify_fields env fi1 fi2;
+          (* Type [t2'] may have been instantiated by [unify_fields] *)
+          (* XXX One should do some kind of unification... *)
+          begin match (repr t2').desc with
+            Tobject (_, {contents = Some (_, va::_)}) when
+              (match (repr va).desc with
+                Tvar _|Tunivar _|Tnil -> true | _ -> false) -> ()
+          | Tobject (_, nm2) -> set_name nm2 !nm1
+          | _ -> ()
+          end
+      | (Tvariant row1, Tvariant row2) ->
+          if !umode = Expression then
+            unify_row env row1 row2
+          else begin
+            let snap = snapshot () in
+            try unify_row env row1 row2
+            with Unify _ ->
+              backtrack snap;
+              reify env t1';
+              reify env t2';
+              if !generate_equations then mcomp !env t1' t2'
+          end
+      | (Tfield(f,kind,_,rem), Tnil) | (Tnil, Tfield(f,kind,_,rem)) ->
+          begin match field_kind_repr kind with
+            Fvar r when f <> dummy_method ->
+              set_kind r Fabsent;
+              if d2 = Tnil then unify env rem t2'
+              else unify env (newty2 rem.level Tnil) rem
+          | _      ->
+              if f = dummy_method then
+                raise (Unify Trace.[Obj Self_cannot_be_closed])
+              else if d1 = Tnil then
+                raise (Unify Trace.[Obj(Missing_field (First, f))])
+              else
+                raise (Unify Trace.[Obj(Missing_field (Second, f))])
+          end
+      | (Tnil, Tnil) ->
+          ()
+      | (Tpoly (t1, []), Tpoly (t2, [])) ->
+          unify env t1 t2
+      | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
+          enter_poly !env univar_pairs t1 tl1 t2 tl2 (unify env)
+      | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
+          begin try
+            unify_package !env (unify_list env)
+              t1.level p1 n1 tl1 t2.level p2 n2 tl2
+          with Not_found ->
+            if !umode = Expression then raise (Unify []);
+            List.iter (reify env) (tl1 @ tl2);
+            (* if !generate_equations then List.iter2 (mcomp !env) tl1 tl2 *)
+          end
+      | (Tnil,  Tconstr _ ) -> raise (Unify Trace.[Obj(Abstract_row Second)])
+      | (Tconstr _,  Tnil ) -> raise (Unify Trace.[Obj(Abstract_row First)])
+      | (_, _) -> raise (Unify [])
+      end;
+      (* XXX Commentaires + changer "create_recursion"
+         ||| Comments + change "create_recursion" *)
+      if create_recursion then
+        match t2.desc with
+          Tconstr (p, tl, abbrev) ->
+            forget_abbrev abbrev p;
+            let t2'' = expand_head_unif !env t2 in
+            if not (closed_parameterized_type tl t2'') then
+              link_type (repr t2) (repr t2')
+        | _ ->
+            () (* t2 has already been expanded by update_level *)
+    with Unify trace ->
+      t1'.desc <- d1;
+      raise (Unify trace)
+  end
+
+and unify_list env tl1 tl2 =
+  if List.length tl1 <> List.length tl2 then
+    raise (Unify []);
+  List.iter2 (unify env) tl1 tl2
+
+(* Build a fresh row variable for unification *)
+and make_rowvar level use1 rest1 use2 rest2  =
+  let set_name ty name =
+    match ty.desc with
+      Tvar None -> set_type_desc ty (Tvar name)
+    | _ -> ()
+  in
+  let name =
+    match rest1.desc, rest2.desc with
+      Tvar (Some _ as name1), Tvar (Some _ as name2) ->
+        if rest1.level <= rest2.level then name1 else name2
+    | Tvar (Some _ as name), _ ->
+        if use2 then set_name rest2 name; name
+    | _, Tvar (Some _ as name) ->
+        if use1 then set_name rest2 name; name
+    | _ -> None
+  in
+  if use1 then rest1 else
+  if use2 then rest2 else newvar2 ?name level
+
+and unify_fields env ty1 ty2 =          (* Optimization *)
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let l1 = (repr ty1).level and l2 = (repr ty2).level in
+  let va = make_rowvar (min l1 l2) (miss2=[]) rest1 (miss1=[]) rest2 in
+  let d1 = rest1.desc and d2 = rest2.desc in
+  try
+    unify env (build_fields l1 miss1 va) rest2;
+    unify env rest1 (build_fields l2 miss2 va);
+    List.iter
+      (fun (n, k1, t1, k2, t2) ->
+        unify_kind k1 k2;
+        try
+          if !trace_gadt_instances then begin
+            update_level !env va.level t1;
+            update_scope va.scope t1
+          end;
+          unify env t1 t2
+        with Unify trace ->
+          raise( Unify (Trace.incompatible_fields n t1 t2 :: trace) )
+      )
+      pairs
+  with exn ->
+    set_type_desc rest1 d1;
+    set_type_desc rest2 d2;
+    raise exn
+
+and unify_kind k1 k2 =
+  let k1 = field_kind_repr k1 in
+  let k2 = field_kind_repr k2 in
+  if k1 == k2 then () else
+  match k1, k2 with
+    (Fvar r, (Fvar _ | Fpresent)) -> set_kind r k2
+  | (Fpresent, Fvar r)            -> set_kind r k1
+  | (Fpresent, Fpresent)          -> ()
+  | _                             -> assert false
+
+and unify_row env row1 row2 =
+  let row1 = row_repr row1 and row2 = row_repr row2 in
+  let rm1 = row_more row1 and rm2 = row_more row2 in
+  if unify_eq rm1 rm2 then () else
+  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
+  if r1 <> [] && r2 <> [] then begin
+    let ht = Hashtbl.create (List.length r1) in
+    List.iter (fun (l,_) -> Hashtbl.add ht (hash_variant l) l) r1;
+    List.iter
+      (fun (l,_) ->
+        try raise (Tags(l, Hashtbl.find ht (hash_variant l)))
+        with Not_found -> ())
+      r2
+  end;
+  let fixed1 = fixed_explanation row1 and fixed2 = fixed_explanation row2 in
+  let more = match fixed1, fixed2 with
+    | Some _, _ -> rm1
+    | None, Some _ -> rm2
+    | None, None -> newty2 (min rm1.level rm2.level) (Tvar None)
+  in
+  let fixed = merge_fixed_explanation fixed1 fixed2
+  and closed = row1.row_closed || row2.row_closed in
+  let keep switch =
+    List.for_all
+      (fun (_,f1,f2) ->
+        let f1, f2 = switch f1 f2 in
+        row_field_repr f1 = Rabsent || row_field_repr f2 <> Rabsent)
+      pairs
+  in
+  let empty fields =
+    List.for_all (fun (_,f) -> row_field_repr f = Rabsent) fields in
+  (* Check whether we are going to build an empty type *)
+  if closed && (empty r1 || row2.row_closed) && (empty r2 || row1.row_closed)
+  && List.for_all
+      (fun (_,f1,f2) ->
+        row_field_repr f1 = Rabsent || row_field_repr f2 = Rabsent)
+      pairs
+  then raise Trace.( Unify [Variant No_intersection] );
+  let name =
+    if row1.row_name <> None && (row1.row_closed || empty r2) &&
+      (not row2.row_closed || keep (fun f1 f2 -> f1, f2) && empty r1)
+    then row1.row_name
+    else if row2.row_name <> None && (row2.row_closed || empty r1) &&
+      (not row1.row_closed || keep (fun f1 f2 -> f2, f1) && empty r2)
+    then row2.row_name
+    else None
+  in
+  let row0 = {row_fields = []; row_more = more; row_bound = ();
+              row_closed = closed; row_fixed = fixed; row_name = name} in
+  let set_more row rest =
+    let rest =
+      if closed then
+        filter_row_fields row.row_closed rest
+      else rest in
+    begin match fixed_explanation row with
+      | None ->
+          if rest <> [] && row.row_closed then
+            let pos = if row == row1 then Trace.First else Trace.Second in
+            raise Trace.(Unify [Variant (No_tags(pos,rest))])
+      | Some fixed ->
+          let pos = if row == row1 then Trace.First else Trace.Second in
+          if closed && not row.row_closed then
+            raise Trace.(Unify [Variant(Fixed_row(pos,Cannot_be_closed,fixed))])
+          else if rest <> [] then
+            let case = Trace.Cannot_add_tags (List.map fst rest) in
+            raise Trace.(Unify [Variant(Fixed_row(pos,case,fixed))])
+    end;
+    (* The following test is not principal... should rather use Tnil *)
+    let rm = row_more row in
+    (*if !trace_gadt_instances && rm.desc = Tnil then () else*)
+    if !trace_gadt_instances then
+      update_level !env rm.level (newgenty (Tvariant row));
+    if row_fixed row then
+      if more == rm then () else
+      if is_Tvar rm then link_type rm more else unify env rm more
+    else
+      let ty = newgenty (Tvariant {row0 with row_fields = rest}) in
+      update_level !env rm.level ty;
+      update_scope rm.scope ty;
+      link_type rm ty
+  in
+  let md1 = rm1.desc and md2 = rm2.desc in
+  begin try
+    set_more row2 r1;
+    set_more row1 r2;
+    List.iter
+      (fun (l,f1,f2) ->
+        try unify_row_field env fixed1 fixed2 more l f1 f2
+        with Unify trace ->
+          raise Trace.( Unify( Variant (Incompatible_types_for l) :: trace ))
+      )
+      pairs;
+    if static_row row1 then begin
+      let rm = row_more row1 in
+      if is_Tvar rm then link_type rm (newty2 rm.level Tnil)
+    end
+  with exn ->
+    set_type_desc rm1 md1; set_type_desc rm2 md2; raise exn
+  end
+
+and unify_row_field env fixed1 fixed2 more l f1 f2 =
+  let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
+  let if_not_fixed (pos,fixed) f =
+    match fixed with
+    | None -> f ()
+    | Some fix ->
+        let tr = Trace.[ Variant (Fixed_row (pos,Cannot_add_tags [l],fix)) ] in
+        raise (Unify tr) in
+  let first = Trace.First, fixed1 and second = Trace.Second, fixed2 in
+  let either_fixed = match fixed1, fixed2 with
+    | None, None -> false
+    | _ -> true in
+  if f1 == f2 then () else
+  match f1, f2 with
+    Rpresent(Some t1), Rpresent(Some t2) -> unify env t1 t2
+  | Rpresent None, Rpresent None -> ()
+  | Reither(c1, tl1, m1, e1), Reither(c2, tl2, m2, e2) ->
+      if e1 == e2 then () else
+      if either_fixed && not (c1 || c2)
+      && List.length tl1 = List.length tl2 then begin
+        (* PR#7496 *)
+        let f = Reither (c1 || c2, [], m1 || m2, ref None) in
+        set_row_field e1 f; set_row_field e2 f;
+        List.iter2 (unify env) tl1 tl2
+      end
+      else let redo =
+        not !passive_variants &&
+        (m1 || m2 || either_fixed ||
+         !rigid_variants && (List.length tl1 = 1 || List.length tl2 = 1)) &&
+        begin match tl1 @ tl2 with [] -> false
+        | t1 :: tl ->
+            if c1 || c2 then raise (Unify []);
+            List.iter (unify env t1) tl;
+            !e1 <> None || !e2 <> None
+        end in
+      if redo then unify_row_field env fixed1 fixed2 more l f1 f2 else
+      let tl1 = List.map repr tl1 and tl2 = List.map repr tl2 in
+      let rec remq tl = function [] -> []
+        | ty :: tl' ->
+            if List.memq ty tl then remq tl tl' else ty :: remq tl tl'
+      in
+      let tl2' = remq tl2 tl1 and tl1' = remq tl1 tl2 in
+      (* PR#6744 *)
+      let split_univars =
+        List.partition
+          (fun ty -> try occur_univar !env ty; true with Unify _ -> false) in
+      let (tl1',tlu1) = split_univars tl1'
+      and (tl2',tlu2) = split_univars tl2' in
+      begin match tlu1, tlu2 with
+        [], [] -> ()
+      | (tu1::tlu1), _ :: _ ->
+          (* Attempt to merge all the types containing univars *)
+          if not !passive_variants then
+          List.iter (unify env tu1) (tlu1@tlu2)
+      | (tu::_, []) | ([], tu::_) -> occur_univar !env tu
+      end;
+      (* Is this handling of levels really principal? *)
+      List.iter (fun ty ->
+        let rm = repr more in
+        update_level !env rm.level ty;
+        update_scope rm.scope ty;
+      ) (tl1' @ tl2');
+      let e = ref None in
+      let f1' = Reither(c1 || c2, tl1', m1 || m2, e)
+      and f2' = Reither(c1 || c2, tl2', m1 || m2, e) in
+      set_row_field e1 f1'; set_row_field e2 f2';
+  | Reither(_, _, false, e1), Rabsent ->
+      if_not_fixed first (fun () -> set_row_field e1 f2)
+  | Rabsent, Reither(_, _, false, e2) ->
+      if_not_fixed second (fun () -> set_row_field e2 f1)
+  | Rabsent, Rabsent -> ()
+  | Reither(false, tl, _, e1), Rpresent(Some t2) ->
+      if_not_fixed first (fun () ->
+          set_row_field e1 f2;
+          let rm = repr more in
+          update_level !env rm.level t2;
+          update_scope rm.scope t2;
+          (try List.iter (fun t1 -> unify env t1 t2) tl
+           with exn -> e1 := None; raise exn)
+        )
+  | Rpresent(Some t1), Reither(false, tl, _, e2) ->
+      if_not_fixed second (fun () ->
+          set_row_field e2 f1;
+          let rm = repr more in
+          update_level !env rm.level t1;
+          update_scope rm.scope t1;
+          (try List.iter (unify env t1) tl
+           with exn -> e2 := None; raise exn)
+        )
+  | Reither(true, [], _, e1), Rpresent None ->
+      if_not_fixed first (fun () -> set_row_field e1 f2)
+  | Rpresent None, Reither(true, [], _, e2) ->
+      if_not_fixed second (fun () -> set_row_field e2 f1)
+  | _ -> raise (Unify [])
+
+
+let unify env ty1 ty2 =
+  let snap = Btype.snapshot () in
+  try
+    unify env ty1 ty2
+  with
+    Unify trace ->
+      undo_compress snap;
+      raise (Unify (expand_trace !env trace))
+
+let unify_gadt ~equations_level:lev (env:Env.t ref) ty1 ty2 =
+  try
+    univar_pairs := [];
+    gadt_equations_level := Some lev;
+    set_mode_pattern ~generate:true ~injective:true
+                     (fun () -> unify env ty1 ty2);
+    gadt_equations_level := None;
+    TypePairs.clear unify_eq_set;
+  with e ->
+    gadt_equations_level := None;
+    TypePairs.clear unify_eq_set;
+    raise e
+
+let unify_var env t1 t2 =
+  let t1 = repr t1 and t2 = repr t2 in
+  if t1 == t2 then () else
+  match t1.desc, t2.desc with
+    Tvar _, Tconstr _ when deep_occur t1 t2 ->
+      unify (ref env) t1 t2
+  | Tvar _, _ ->
+      let reset_tracing = check_trace_gadt_instances env in
+      begin try
+        occur env t1 t2;
+        update_level env t1.level t2;
+        update_scope t1.scope t2;
+        link_type t1 t2;
+        reset_trace_gadt_instances reset_tracing;
+      with Unify trace ->
+        reset_trace_gadt_instances reset_tracing;
+        let expanded_trace = expand_trace env @@ Trace.diff t1 t2 :: trace in
+        raise (Unify expanded_trace)
+      end
+  | _ ->
+      unify (ref env) t1 t2
+
+let _ = unify' := unify_var
+
+let unify_pairs env ty1 ty2 pairs =
+  univar_pairs := pairs;
+  unify env ty1 ty2
+
+let unify env ty1 ty2 =
+  unify_pairs (ref env) ty1 ty2 []
+
+
+
+(**** Special cases of unification ****)
+
+let expand_head_trace env t =
+  let reset_tracing = check_trace_gadt_instances env in
+  let t = expand_head_unif env t in
+  reset_trace_gadt_instances reset_tracing;
+  t
+
+(*
+   Unify [t] and [l:'a -> 'b]. Return ['a] and ['b].
+   In label mode, label mismatch is accepted when
+   (1) the requested label is ""
+   (2) the original label is not optional
+*)
+
+let filter_arrow env t l =
+  let t = expand_head_trace env t in
+  match t.desc with
+    Tvar _ ->
+      let lv = t.level in
+      let t1 = newvar2 lv and t2 = newvar2 lv in
+      let t' = newty2 lv (Tarrow (l, t1, t2, Cok)) in
+      link_type t t';
+      (t1, t2)
+  | Tarrow(l', t1, t2, _)
+    when l = l' || !Clflags.classic && l = Nolabel && not (is_optional l') ->
+      (t1, t2)
+  | _ ->
+      raise (Unify [])
+
+(* Used by [filter_method]. *)
+let rec filter_method_field env name priv ty =
+  let ty = expand_head_trace env ty in
+  match ty.desc with
+    Tvar _ ->
+      let level = ty.level in
+      let ty1 = newvar2 level and ty2 = newvar2 level in
+      let ty' = newty2 level (Tfield (name,
+                                      begin match priv with
+                                        Private -> Fvar (ref None)
+                                      | Public  -> Fpresent
+                                      end,
+                                      ty1, ty2))
+      in
+      link_type ty ty';
+      ty1
+  | Tfield(n, kind, ty1, ty2) ->
+      let kind = field_kind_repr kind in
+      if (n = name) && (kind <> Fabsent) then begin
+        if priv = Public then
+          unify_kind kind Fpresent;
+        ty1
+      end else
+        filter_method_field env name priv ty2
+  | _ ->
+      raise (Unify [])
+
+(* Unify [ty] and [< name : 'a; .. >]. Return ['a]. *)
+let filter_method env name priv ty =
+  let ty = expand_head_trace env ty in
+  match ty.desc with
+    Tvar _ ->
+      let ty1 = newvar () in
+      let ty' = newobj ty1 in
+      update_level env ty.level ty';
+      update_scope ty.scope ty';
+      link_type ty ty';
+      filter_method_field env name priv ty1
+  | Tobject(f, _) ->
+      filter_method_field env name priv f
+  | _ ->
+      raise (Unify [])
+
+let check_filter_method env name priv ty =
+  ignore(filter_method env name priv ty)
+
+let filter_self_method env lab priv meths ty =
+  let ty' = filter_method env lab priv ty in
+  try
+    Meths.find lab !meths
+  with Not_found ->
+    let pair = (Ident.create_local lab, ty') in
+    meths := Meths.add lab pair !meths;
+    pair
+
+
+                        (***********************************)
+                        (*  Matching between type schemes  *)
+                        (***********************************)
+
+(*
+   Update the level of [ty]. First check that the levels of generic
+   variables from the subject are not lowered.
+*)
+let moregen_occur env level ty =
+  let rec occur ty =
+    let ty = repr ty in
+    if ty.level > level then begin
+      if is_Tvar ty && ty.level >= generic_level - 1 then raise Occur;
+      ty.level <- pivot_level - ty.level;
+      match ty.desc with
+        Tvariant row when static_row row ->
+          iter_row occur row
+      | _ ->
+          iter_type_expr occur ty
+    end
+  in
+  begin try
+    occur ty; unmark_type ty
+  with Occur ->
+    unmark_type ty; raise (Unify [])
+  end;
+  (* also check for free univars *)
+  occur_univar env ty;
+  update_level env level ty
+
+let may_instantiate inst_nongen t1 =
+  if inst_nongen then t1.level <> generic_level - 1
+                 else t1.level =  generic_level
+
+let rec moregen inst_nongen type_pairs env t1 t2 =
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then () else
+
+  try
+    match (t1.desc, t2.desc) with
+      (Tvar _, _) when may_instantiate inst_nongen t1 ->
+        moregen_occur env t1.level t2;
+        update_scope t1.scope t2;
+        occur env t1 t2;
+        link_type t1 t2
+    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
+        ()
+    | _ ->
+        let t1' = expand_head env t1 in
+        let t2' = expand_head env t2 in
+        (* Expansion may have changed the representative of the types... *)
+        let t1' = repr t1' and t2' = repr t2' in
+        if t1' == t2' then () else
+        begin try
+          TypePairs.find type_pairs (t1', t2')
+        with Not_found ->
+          TypePairs.add type_pairs (t1', t2') ();
+          match (t1'.desc, t2'.desc) with
+            (Tvar _, _) when may_instantiate inst_nongen t1' ->
+              moregen_occur env t1'.level t2;
+              update_scope t1'.scope t2;
+              link_type t1' t2
+          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
+            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
+              moregen inst_nongen type_pairs env t1 t2;
+              moregen inst_nongen type_pairs env u1 u2
+          | (Ttuple tl1, Ttuple tl2) ->
+              moregen_list inst_nongen type_pairs env tl1 tl2
+          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
+                when Path.same p1 p2 ->
+              moregen_list inst_nongen type_pairs env tl1 tl2
+          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
+              begin try
+                unify_package env (moregen_list inst_nongen type_pairs env)
+                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
+              with Not_found -> raise (Unify [])
+              end
+          | (Tvariant row1, Tvariant row2) ->
+              moregen_row inst_nongen type_pairs env row1 row2
+          | (Tobject (fi1, _nm1), Tobject (fi2, _nm2)) ->
+              moregen_fields inst_nongen type_pairs env fi1 fi2
+          | (Tfield _, Tfield _) ->           (* Actually unused *)
+              moregen_fields inst_nongen type_pairs env t1' t2'
+          | (Tnil, Tnil) ->
+              ()
+          | (Tpoly (t1, []), Tpoly (t2, [])) ->
+              moregen inst_nongen type_pairs env t1 t2
+          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
+              enter_poly env univar_pairs t1 tl1 t2 tl2
+                (moregen inst_nongen type_pairs env)
+          | (Tunivar _, Tunivar _) ->
+              unify_univar t1' t2' !univar_pairs
+          | (_, _) ->
+              raise (Unify [])
+        end
+  with Unify trace ->  raise( Unify ( Trace.diff t1 t2 :: trace ) )
+
+and moregen_list inst_nongen type_pairs env tl1 tl2 =
+  if List.length tl1 <> List.length tl2 then
+    raise (Unify []);
+  List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2
+
+and moregen_fields inst_nongen type_pairs env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  if miss1 <> [] then raise (Unify []);
+  moregen inst_nongen type_pairs env rest1
+    (build_fields (repr ty2).level miss2 rest2);
+  List.iter
+    (fun (n, k1, t1, k2, t2) ->
+       moregen_kind k1 k2;
+       try moregen inst_nongen type_pairs env t1 t2 with Unify trace ->
+         let e = Trace.diff
+             (newty (Tfield(n, k1, t1, rest2)))
+             (newty (Tfield(n, k2, t2, rest2))) in
+         raise( Unify ( e :: trace ) )
+    )
+    pairs
+
+and moregen_kind k1 k2 =
+  let k1 = field_kind_repr k1 in
+  let k2 = field_kind_repr k2 in
+  if k1 == k2 then () else
+  match k1, k2 with
+    (Fvar r, (Fvar _ | Fpresent))  -> set_kind r k2
+  | (Fpresent, Fpresent)           -> ()
+  | _                              -> raise (Unify [])
+
+and moregen_row inst_nongen type_pairs env row1 row2 =
+  let row1 = row_repr row1 and row2 = row_repr row2 in
+  let rm1 = repr row1.row_more and rm2 = repr row2.row_more in
+  if rm1 == rm2 then () else
+  let may_inst =
+    is_Tvar rm1 && may_instantiate inst_nongen rm1 || rm1.desc = Tnil in
+  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
+  let r1, r2 =
+    if row2.row_closed then
+      filter_row_fields may_inst r1, filter_row_fields false r2
+    else r1, r2
+  in
+  if r1 <> [] || row1.row_closed && (not row2.row_closed || r2 <> [])
+  then raise (Unify []);
+  begin match rm1.desc, rm2.desc with
+    Tunivar _, Tunivar _ ->
+      unify_univar rm1 rm2 !univar_pairs
+  | Tunivar _, _ | _, Tunivar _ ->
+      raise (Unify [])
+  | _ when static_row row1 -> ()
+  | _ when may_inst ->
+      let ext =
+        newgenty (Tvariant {row2 with row_fields = r2; row_name = None})
+      in
+      moregen_occur env rm1.level ext;
+      update_scope rm1.scope ext;
+      link_type rm1 ext
+  | Tconstr _, Tconstr _ ->
+      moregen inst_nongen type_pairs env rm1 rm2
+  | _ -> raise (Unify [])
+  end;
+  List.iter
+    (fun (_l,f1,f2) ->
+      let f1 = row_field_repr f1 and f2 = row_field_repr f2 in
+      if f1 == f2 then () else
+      match f1, f2 with
+        Rpresent(Some t1), Rpresent(Some t2) ->
+          moregen inst_nongen type_pairs env t1 t2
+      | Rpresent None, Rpresent None -> ()
+      | Reither(false, tl1, _, e1), Rpresent(Some t2) when may_inst ->
+          set_row_field e1 f2;
+          List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2) tl1
+      | Reither(c1, tl1, _, e1), Reither(c2, tl2, m2, e2) ->
+          if e1 != e2 then begin
+            if c1 && not c2 then raise(Unify []);
+            set_row_field e1 (Reither (c2, [], m2, e2));
+            if List.length tl1 = List.length tl2 then
+              List.iter2 (moregen inst_nongen type_pairs env) tl1 tl2
+            else match tl2 with
+              t2 :: _ ->
+                List.iter (fun t1 -> moregen inst_nongen type_pairs env t1 t2)
+                  tl1
+            | [] ->
+                if tl1 <> [] then raise (Unify [])
+          end
+      | Reither(true, [], _, e1), Rpresent None when may_inst ->
+          set_row_field e1 f2
+      | Reither(_, _, _, e1), Rabsent when may_inst ->
+          set_row_field e1 f2
+      | Rabsent, Rabsent -> ()
+      | _ -> raise (Unify []))
+    pairs
+
+(* Must empty univar_pairs first *)
+let moregen inst_nongen type_pairs env patt subj =
+  univar_pairs := [];
+  moregen inst_nongen type_pairs env patt subj
+
+(*
+   Non-generic variable can be instantiated only if [inst_nongen] is
+   true. So, [inst_nongen] should be set to false if the subject might
+   contain non-generic variables (and we do not want them to be
+   instantiated).
+   Usually, the subject is given by the user, and the pattern
+   is unimportant.  So, no need to propagate abbreviations.
+*)
+let moregeneral env inst_nongen pat_sch subj_sch =
+  let old_level = !current_level in
+  current_level := generic_level - 1;
+  (*
+     Generic variables are first duplicated with [instance].  So,
+     their levels are lowered to [generic_level - 1].  The subject is
+     then copied with [duplicate_type].  That way, its levels won't be
+     changed.
+  *)
+  let subj = duplicate_type (instance subj_sch) in
+  current_level := generic_level;
+  (* Duplicate generic variables *)
+  let patt = instance pat_sch in
+  let res =
+    try moregen inst_nongen (TypePairs.create 13) env patt subj; true with
+      Unify _ -> false
+  in
+  current_level := old_level;
+  res
+
+
+(* Alternative approach: "rigidify" a type scheme,
+   and check validity after unification *)
+(* Simpler, no? *)
+
+let rec rigidify_rec vars ty =
+  let ty = repr ty in
+  if ty.level >= lowest_level then begin
+    ty.level <- pivot_level - ty.level;
+    match ty.desc with
+    | Tvar _ ->
+        if not (List.memq ty !vars) then vars := ty :: !vars
+    | Tvariant row ->
+        let row = row_repr row in
+        let more = repr row.row_more in
+        if is_Tvar more && not (row_fixed row) then begin
+          let more' = newty2 more.level more.desc in
+          let row' =
+            {row with row_fixed=Some Rigid; row_fields=[]; row_more=more'}
+          in link_type more (newty2 ty.level (Tvariant row'))
+        end;
+        iter_row (rigidify_rec vars) row;
+        (* only consider the row variable if the variant is not static *)
+        if not (static_row row) then rigidify_rec vars (row_more row)
+    | _ ->
+        iter_type_expr (rigidify_rec vars) ty
+  end
+
+let rigidify ty =
+  let vars = ref [] in
+  rigidify_rec vars ty;
+  unmark_type ty;
+  !vars
+
+let all_distinct_vars env vars =
+  let tyl = ref [] in
+  List.for_all
+    (fun ty ->
+      let ty = expand_head env ty in
+      if List.memq ty !tyl then false else
+      (tyl := ty :: !tyl; is_Tvar ty))
+    vars
+
+let matches env ty ty' =
+  let snap = snapshot () in
+  let vars = rigidify ty in
+  cleanup_abbrev ();
+  let ok =
+    try unify env ty ty'; all_distinct_vars env vars
+    with Unify _ -> false
+  in
+  backtrack snap;
+  ok
+
+
+                 (*********************************************)
+                 (*  Equivalence between parameterized types  *)
+                 (*********************************************)
+
+let expand_head_rigid env ty =
+  let old = !rigid_variants in
+  rigid_variants := true;
+  let ty' = expand_head env ty in
+  rigid_variants := old; ty'
+
+let normalize_subst subst =
+  if List.exists
+      (function {desc=Tlink _}, _ | _, {desc=Tlink _} -> true | _ -> false)
+      !subst
+  then subst := List.map (fun (t1,t2) -> repr t1, repr t2) !subst
+
+let rec eqtype rename type_pairs subst env t1 t2 =
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then () else
+
+  try
+    match (t1.desc, t2.desc) with
+      (Tvar _, Tvar _) when rename ->
+        begin try
+          normalize_subst subst;
+          if List.assq t1 !subst != t2 then raise (Unify [])
+        with Not_found ->
+          if List.exists (fun (_, t) -> t == t2) !subst then raise (Unify []);
+          subst := (t1, t2) :: !subst
+        end
+    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
+        ()
+    | _ ->
+        let t1' = expand_head_rigid env t1 in
+        let t2' = expand_head_rigid env t2 in
+        (* Expansion may have changed the representative of the types... *)
+        let t1' = repr t1' and t2' = repr t2' in
+        if t1' == t2' then () else
+        begin try
+          TypePairs.find type_pairs (t1', t2')
+        with Not_found ->
+          TypePairs.add type_pairs (t1', t2') ();
+          match (t1'.desc, t2'.desc) with
+            (Tvar _, Tvar _) when rename ->
+              begin try
+                normalize_subst subst;
+                if List.assq t1' !subst != t2' then raise (Unify [])
+              with Not_found ->
+                if List.exists (fun (_, t) -> t == t2') !subst
+                then raise (Unify []);
+                subst := (t1', t2') :: !subst
+              end
+          | (Tarrow (l1, t1, u1, _), Tarrow (l2, t2, u2, _)) when l1 = l2
+            || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
+              eqtype rename type_pairs subst env t1 t2;
+              eqtype rename type_pairs subst env u1 u2;
+          | (Ttuple tl1, Ttuple tl2) ->
+              eqtype_list rename type_pairs subst env tl1 tl2
+          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
+                when Path.same p1 p2 ->
+              eqtype_list rename type_pairs subst env tl1 tl2
+          | (Tpackage (p1, n1, tl1), Tpackage (p2, n2, tl2)) ->
+              begin try
+                unify_package env (eqtype_list rename type_pairs subst env)
+                  t1'.level p1 n1 tl1 t2'.level p2 n2 tl2
+              with Not_found -> raise (Unify [])
+              end
+          | (Tvariant row1, Tvariant row2) ->
+              eqtype_row rename type_pairs subst env row1 row2
+          | (Tobject (fi1, _nm1), Tobject (fi2, _nm2)) ->
+              eqtype_fields rename type_pairs subst env fi1 fi2
+          | (Tfield _, Tfield _) ->       (* Actually unused *)
+              eqtype_fields rename type_pairs subst env t1' t2'
+          | (Tnil, Tnil) ->
+              ()
+          | (Tpoly (t1, []), Tpoly (t2, [])) ->
+              eqtype rename type_pairs subst env t1 t2
+          | (Tpoly (t1, tl1), Tpoly (t2, tl2)) ->
+              enter_poly env univar_pairs t1 tl1 t2 tl2
+                (eqtype rename type_pairs subst env)
+          | (Tunivar _, Tunivar _) ->
+              unify_univar t1' t2' !univar_pairs
+          | (_, _) ->
+              raise (Unify [])
+        end
+  with Unify trace ->  raise ( Unify (Trace.diff t1 t2 :: trace) )
+
+and eqtype_list rename type_pairs subst env tl1 tl2 =
+  if List.length tl1 <> List.length tl2 then
+    raise (Unify []);
+  List.iter2 (eqtype rename type_pairs subst env) tl1 tl2
+
+and eqtype_fields rename type_pairs subst env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1 in
+  let (fields2, rest2) = flatten_fields ty2 in
+  (* First check if same row => already equal *)
+  let same_row =
+    rest1 == rest2 || TypePairs.mem type_pairs (rest1,rest2) ||
+    (rename && List.mem (rest1, rest2) !subst)
+  in
+  if same_row then () else
+  (* Try expansion, needed when called from Includecore.type_manifest *)
+  match expand_head_rigid env rest2 with
+    {desc=Tobject(ty2,_)} -> eqtype_fields rename type_pairs subst env ty1 ty2
+  | _ ->
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  eqtype rename type_pairs subst env rest1 rest2;
+  if (miss1 <> []) || (miss2 <> []) then raise (Unify []);
+  List.iter
+    (function (n, k1, t1, k2, t2) ->
+       eqtype_kind k1 k2;
+       try eqtype rename type_pairs subst env t1 t2 with Unify trace ->
+         let e = Trace.diff
+             (newty (Tfield(n, k1, t1, rest2)))
+             (newty (Tfield(n, k2, t2, rest2))) in
+         raise ( Unify ( e :: trace ) )
+    )
+    pairs
+
+and eqtype_kind k1 k2 =
+  let k1 = field_kind_repr k1 in
+  let k2 = field_kind_repr k2 in
+  match k1, k2 with
+    (Fvar _, Fvar _)
+  | (Fpresent, Fpresent) -> ()
+  | _                    -> raise (Unify [])
+
+and eqtype_row rename type_pairs subst env row1 row2 =
+  (* Try expansion, needed when called from Includecore.type_manifest *)
+  match expand_head_rigid env (row_more row2) with
+    {desc=Tvariant row2} -> eqtype_row rename type_pairs subst env row1 row2
+  | _ ->
+  let row1 = row_repr row1 and row2 = row_repr row2 in
+  let r1, r2, pairs = merge_row_fields row1.row_fields row2.row_fields in
+  if row1.row_closed <> row2.row_closed
+  || not row1.row_closed && (r1 <> [] || r2 <> [])
+  || filter_row_fields false (r1 @ r2) <> []
+  then raise (Unify []);
+  if not (static_row row1) then
+    eqtype rename type_pairs subst env row1.row_more row2.row_more;
+  List.iter
+    (fun (_,f1,f2) ->
+      match row_field_repr f1, row_field_repr f2 with
+        Rpresent(Some t1), Rpresent(Some t2) ->
+          eqtype rename type_pairs subst env t1 t2
+      | Reither(c1, [], _, _), Reither(c2, [], _, _) when c1 = c2 ->
+          ()
+      | Reither(c1, t1::tl1, _, _), Reither(c2, t2::tl2, _, _) when c1 = c2 ->
+          eqtype rename type_pairs subst env t1 t2;
+          if List.length tl1 = List.length tl2 then
+            (* if same length allow different types (meaning?) *)
+            List.iter2 (eqtype rename type_pairs subst env) tl1 tl2
+          else begin
+            (* otherwise everything must be equal *)
+            List.iter (eqtype rename type_pairs subst env t1) tl2;
+            List.iter (fun t1 -> eqtype rename type_pairs subst env t1 t2) tl1
+          end
+      | Rpresent None, Rpresent None -> ()
+      | Rabsent, Rabsent -> ()
+      | _ -> raise (Unify []))
+    pairs
+
+(* Must empty univar_pairs first *)
+let eqtype_list rename type_pairs subst env tl1 tl2 =
+  univar_pairs := [];
+  let snap = Btype.snapshot () in
+  Misc.try_finally
+    ~always:(fun () -> backtrack snap)
+    (fun () -> eqtype_list rename type_pairs subst env tl1 tl2)
+
+let eqtype rename type_pairs subst env t1 t2 =
+  eqtype_list rename type_pairs subst env [t1] [t2]
+
+(* Two modes: with or without renaming of variables *)
+let equal env rename tyl1 tyl2 =
+  try
+    eqtype_list rename (TypePairs.create 11) (ref []) env tyl1 tyl2; true
+  with
+    Unify _ -> false
+
+
+                          (*************************)
+                          (*  Class type matching  *)
+                          (*************************)
+
+
+type class_match_failure =
+    CM_Virtual_class
+  | CM_Parameter_arity_mismatch of int * int
+  | CM_Type_parameter_mismatch of Env.t * Unification_trace.t
+  | CM_Class_type_mismatch of Env.t * class_type * class_type
+  | CM_Parameter_mismatch of Env.t * Unification_trace.t
+  | CM_Val_type_mismatch of string * Env.t * Unification_trace.t
+  | CM_Meth_type_mismatch of string * Env.t * Unification_trace.t
+  | CM_Non_mutable_value of string
+  | CM_Non_concrete_value of string
+  | CM_Missing_value of string
+  | CM_Missing_method of string
+  | CM_Hide_public of string
+  | CM_Hide_virtual of string * string
+  | CM_Public_method of string
+  | CM_Private_method of string
+  | CM_Virtual_method of string
+
+exception Failure of class_match_failure list
+
+let rec moregen_clty trace type_pairs env cty1 cty2 =
+  try
+    match cty1, cty2 with
+      Cty_constr (_, _, cty1), _ ->
+        moregen_clty true type_pairs env cty1 cty2
+    | _, Cty_constr (_, _, cty2) ->
+        moregen_clty true type_pairs env cty1 cty2
+    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
+        begin try moregen true type_pairs env ty1 ty2 with Unify trace ->
+          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
+        end;
+        moregen_clty false type_pairs env cty1' cty2'
+    | Cty_signature sign1, Cty_signature sign2 ->
+        let ty1 = object_fields (repr sign1.csig_self) in
+        let ty2 = object_fields (repr sign2.csig_self) in
+        let (fields1, _rest1) = flatten_fields ty1
+        and (fields2, _rest2) = flatten_fields ty2 in
+        let (pairs, _miss1, _miss2) = associate_fields fields1 fields2 in
+        List.iter
+          (fun (lab, _k1, t1, _k2, t2) ->
+            begin try moregen true type_pairs env t1 t2 with Unify trace ->
+              raise (Failure [CM_Meth_type_mismatch
+                                 (lab, env, expand_trace env trace)])
+           end)
+        pairs;
+      Vars.iter
+        (fun lab (_mut, _v, ty) ->
+           let (_mut', _v', ty') = Vars.find lab sign1.csig_vars in
+           try moregen true type_pairs env ty' ty with Unify trace ->
+             raise (Failure [CM_Val_type_mismatch
+                                (lab, env, expand_trace env trace)]))
+        sign2.csig_vars
+  | _ ->
+      raise (Failure [])
+  with
+    Failure error when trace || error = [] ->
+      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))
+
+let match_class_types ?(trace=true) env pat_sch subj_sch =
+  let type_pairs = TypePairs.create 53 in
+  let old_level = !current_level in
+  current_level := generic_level - 1;
+  (*
+     Generic variables are first duplicated with [instance].  So,
+     their levels are lowered to [generic_level - 1].  The subject is
+     then copied with [duplicate_type].  That way, its levels won't be
+     changed.
+  *)
+  let (_, subj_inst) = instance_class [] subj_sch in
+  let subj = duplicate_class_type subj_inst in
+  current_level := generic_level;
+  (* Duplicate generic variables *)
+  let (_, patt) = instance_class [] pat_sch in
+  let res =
+    let sign1 = signature_of_class_type patt in
+    let sign2 = signature_of_class_type subj in
+    let t1 = repr sign1.csig_self in
+    let t2 = repr sign2.csig_self in
+    TypePairs.add type_pairs (t1, t2) ();
+    let (fields1, rest1) = flatten_fields (object_fields t1)
+    and (fields2, rest2) = flatten_fields (object_fields t2) in
+    let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+    let error =
+      List.fold_right
+        (fun (lab, k, _) err ->
+           let err =
+             let k = field_kind_repr k in
+             begin match k with
+               Fvar r -> set_kind r Fabsent; err
+             | _      -> CM_Hide_public lab::err
+             end
+           in
+           if lab = dummy_method || Concr.mem lab sign1.csig_concr then err
+           else CM_Hide_virtual ("method", lab) :: err)
+        miss1 []
+    in
+    let missing_method = List.map (fun (m, _, _) -> m) miss2 in
+    let error =
+      (List.map (fun m -> CM_Missing_method m) missing_method) @ error
+    in
+    (* Always succeeds *)
+    moregen true type_pairs env rest1 rest2;
+    let error =
+      List.fold_right
+        (fun (lab, k1, _t1, k2, _t2) err ->
+           try moregen_kind k1 k2; err with
+             Unify _ -> CM_Public_method lab::err)
+        pairs error
+    in
+    let error =
+      Vars.fold
+        (fun lab (mut, vr, _ty) err ->
+          try
+            let (mut', vr', _ty') = Vars.find lab sign1.csig_vars in
+            if mut = Mutable && mut' <> Mutable then
+              CM_Non_mutable_value lab::err
+            else if vr = Concrete && vr' <> Concrete then
+              CM_Non_concrete_value lab::err
+            else
+              err
+          with Not_found ->
+            CM_Missing_value lab::err)
+        sign2.csig_vars error
+    in
+    let error =
+      Vars.fold
+        (fun lab (_,vr,_) err ->
+          if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
+            CM_Hide_virtual ("instance variable", lab) :: err
+          else err)
+        sign1.csig_vars error
+    in
+    let error =
+      List.fold_right
+        (fun e l ->
+           if List.mem e missing_method then l else CM_Virtual_method e::l)
+        (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
+        error
+    in
+    match error with
+      [] ->
+        begin try
+          moregen_clty trace type_pairs env patt subj;
+          []
+        with
+          Failure r -> r
+        end
+    | error ->
+        CM_Class_type_mismatch (env, patt, subj)::error
+  in
+  current_level := old_level;
+  res
+
+let rec equal_clty trace type_pairs subst env cty1 cty2 =
+  try
+    match cty1, cty2 with
+      Cty_constr (_, _, cty1), Cty_constr (_, _, cty2) ->
+        equal_clty true type_pairs subst env cty1 cty2
+    | Cty_constr (_, _, cty1), _ ->
+        equal_clty true type_pairs subst env cty1 cty2
+    | _, Cty_constr (_, _, cty2) ->
+        equal_clty true type_pairs subst env cty1 cty2
+    | Cty_arrow (l1, ty1, cty1'), Cty_arrow (l2, ty2, cty2') when l1 = l2 ->
+        begin try eqtype true type_pairs subst env ty1 ty2 with Unify trace ->
+          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
+        end;
+        equal_clty false type_pairs subst env cty1' cty2'
+    | Cty_signature sign1, Cty_signature sign2 ->
+        let ty1 = object_fields (repr sign1.csig_self) in
+        let ty2 = object_fields (repr sign2.csig_self) in
+        let (fields1, _rest1) = flatten_fields ty1
+        and (fields2, _rest2) = flatten_fields ty2 in
+        let (pairs, _miss1, _miss2) = associate_fields fields1 fields2 in
+        List.iter
+          (fun (lab, _k1, t1, _k2, t2) ->
+             begin try eqtype true type_pairs subst env t1 t2 with
+               Unify trace ->
+                 raise (Failure [CM_Meth_type_mismatch
+                                    (lab, env, expand_trace env trace)])
+             end)
+          pairs;
+        Vars.iter
+          (fun lab (_, _, ty) ->
+             let (_, _, ty') = Vars.find lab sign1.csig_vars in
+             try eqtype true type_pairs subst env ty' ty with Unify trace ->
+               raise (Failure [CM_Val_type_mismatch
+                                  (lab, env, expand_trace env trace)]))
+          sign2.csig_vars
+    | _ ->
+        raise
+          (Failure (if trace then []
+                    else [CM_Class_type_mismatch (env, cty1, cty2)]))
+  with
+    Failure error when trace ->
+      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))
+
+let match_class_declarations env patt_params patt_type subj_params subj_type =
+  let type_pairs = TypePairs.create 53 in
+  let subst = ref [] in
+  let sign1 = signature_of_class_type patt_type in
+  let sign2 = signature_of_class_type subj_type in
+  let t1 = repr sign1.csig_self in
+  let t2 = repr sign2.csig_self in
+  TypePairs.add type_pairs (t1, t2) ();
+  let (fields1, rest1) = flatten_fields (object_fields t1)
+  and (fields2, rest2) = flatten_fields (object_fields t2) in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let error =
+    List.fold_right
+      (fun (lab, k, _) err ->
+        let err =
+          let k = field_kind_repr k in
+          begin match k with
+            Fvar _ -> err
+          | _      -> CM_Hide_public lab::err
+          end
+        in
+        if Concr.mem lab sign1.csig_concr then err
+        else CM_Hide_virtual ("method", lab) :: err)
+      miss1 []
+  in
+  let missing_method = List.map (fun (m, _, _) -> m) miss2 in
+  let error =
+    (List.map (fun m -> CM_Missing_method m) missing_method) @ error
+  in
+  (* Always succeeds *)
+  eqtype true type_pairs subst env rest1 rest2;
+  let error =
+    List.fold_right
+      (fun (lab, k1, _t1, k2, _t2) err ->
+        let k1 = field_kind_repr k1 in
+        let k2 = field_kind_repr k2 in
+        match k1, k2 with
+          (Fvar _, Fvar _)
+        | (Fpresent, Fpresent) -> err
+        | (Fvar _, Fpresent)   -> CM_Private_method lab::err
+        | (Fpresent, Fvar _)  -> CM_Public_method lab::err
+        | _                    -> assert false)
+      pairs error
+  in
+  let error =
+    Vars.fold
+      (fun lab (mut, vr, _ty) err ->
+         try
+           let (mut', vr', _ty') = Vars.find lab sign1.csig_vars in
+           if mut = Mutable && mut' <> Mutable then
+             CM_Non_mutable_value lab::err
+           else if vr = Concrete && vr' <> Concrete then
+             CM_Non_concrete_value lab::err
+           else
+             err
+         with Not_found ->
+           CM_Missing_value lab::err)
+      sign2.csig_vars error
+  in
+  let error =
+    Vars.fold
+      (fun lab (_,vr,_) err ->
+        if vr = Virtual && not (Vars.mem lab sign2.csig_vars) then
+          CM_Hide_virtual ("instance variable", lab) :: err
+        else err)
+      sign1.csig_vars error
+  in
+  let error =
+    List.fold_right
+      (fun e l ->
+        if List.mem e missing_method then l else CM_Virtual_method e::l)
+      (Concr.elements (Concr.diff sign2.csig_concr sign1.csig_concr))
+      error
+  in
+  match error with
+    [] ->
+      begin try
+        let lp = List.length patt_params in
+        let ls = List.length subj_params in
+        if lp  <> ls then
+          raise (Failure [CM_Parameter_arity_mismatch (lp, ls)]);
+        List.iter2 (fun p s ->
+          try eqtype true type_pairs subst env p s with Unify trace ->
+            raise (Failure [CM_Type_parameter_mismatch
+                               (env, expand_trace env trace)]))
+          patt_params subj_params;
+     (* old code: equal_clty false type_pairs subst env patt_type subj_type; *)
+        equal_clty false type_pairs subst env
+          (Cty_signature sign1) (Cty_signature sign2);
+        (* Use moregeneral for class parameters, need to recheck everything to
+           keeps relationships (PR#4824) *)
+        let clty_params =
+          List.fold_right (fun ty cty -> Cty_arrow (Labelled "*",ty,cty)) in
+        match_class_types ~trace:false env
+          (clty_params patt_params patt_type)
+          (clty_params subj_params subj_type)
+      with
+        Failure r -> r
+      end
+  | error ->
+      error
+
+
+                              (***************)
+                              (*  Subtyping  *)
+                              (***************)
+
+
+(**** Build a subtype of a given type. ****)
+
+(* build_subtype:
+   [visited] traces traversed object and variant types
+   [loops] is a mapping from variables to variables, to reproduce
+     positive loops in a class type
+   [posi] true if the current variance is positive
+   [level] number of expansions/enlargement allowed on this branch *)
+
+let warn = ref false  (* whether double coercion might do better *)
+let pred_expand n = if n mod 2 = 0 && n > 0 then pred n else n
+let pred_enlarge n = if n mod 2 = 1 then pred n else n
+
+type change = Unchanged | Equiv | Changed
+let collect l = List.fold_left (fun c1 (_, c2) -> max c1 c2) Unchanged l
+
+let rec filter_visited = function
+    [] -> []
+  | {desc=Tobject _|Tvariant _} :: _ as l -> l
+  | _ :: l -> filter_visited l
+
+let memq_warn t visited =
+  if List.memq t visited then (warn := true; true) else false
+
+let find_cltype_for_path env p =
+  let cl_abbr = Env.find_hash_type p env in
+  match cl_abbr.type_manifest with
+    Some ty ->
+      begin match (repr ty).desc with
+        Tobject(_,{contents=Some(p',_)}) when Path.same p p' -> cl_abbr, ty
+      | _ -> raise Not_found
+      end
+  | None -> assert false
+
+let has_constr_row' env t =
+  has_constr_row (expand_abbrev env t)
+
+let rec build_subtype env visited loops posi level t =
+  let t = repr t in
+  match t.desc with
+    Tvar _ ->
+      if posi then
+        try
+          let t' = List.assq t loops in
+          warn := true;
+          (t', Equiv)
+        with Not_found ->
+          (t, Unchanged)
+      else
+        (t, Unchanged)
+  | Tarrow(l, t1, t2, _) ->
+      if memq_warn t visited then (t, Unchanged) else
+      let visited = t :: visited in
+      let (t1', c1) = build_subtype env visited loops (not posi) level t1 in
+      let (t2', c2) = build_subtype env visited loops posi level t2 in
+      let c = max c1 c2 in
+      if c > Unchanged then (newty (Tarrow(l, t1', t2', Cok)), c)
+      else (t, Unchanged)
+  | Ttuple tlist ->
+      if memq_warn t visited then (t, Unchanged) else
+      let visited = t :: visited in
+      let tlist' =
+        List.map (build_subtype env visited loops posi level) tlist
+      in
+      let c = collect tlist' in
+      if c > Unchanged then (newty (Ttuple (List.map fst tlist')), c)
+      else (t, Unchanged)
+  | Tconstr(p, tl, abbrev)
+    when level > 0 && generic_abbrev env p && safe_abbrev env t
+    && not (has_constr_row' env t) ->
+      let t' = repr (expand_abbrev env t) in
+      let level' = pred_expand level in
+      begin try match t'.desc with
+        Tobject _ when posi && not (opened_object t') ->
+          let cl_abbr, body = find_cltype_for_path env p in
+          let ty =
+            subst env !current_level Public abbrev None
+              cl_abbr.type_params tl body in
+          let ty = repr ty in
+          let ty1, tl1 =
+            match ty.desc with
+              Tobject(ty1,{contents=Some(p',tl1)}) when Path.same p p' ->
+                ty1, tl1
+            | _ -> raise Not_found
+          in
+          (* Fix PR#4505: do not set ty to Tvar when it appears in tl1,
+             as this occurrence might break the occur check.
+             XXX not clear whether this correct anyway... *)
+          if List.exists (deep_occur ty) tl1 then raise Not_found;
+          ty.desc <- Tvar None;
+          let t'' = newvar () in
+          let loops = (ty, t'') :: loops in
+          (* May discard [visited] as level is going down *)
+          let (ty1', c) =
+            build_subtype env [t'] loops posi (pred_enlarge level') ty1 in
+          assert (is_Tvar t'');
+          let nm =
+            if c > Equiv || deep_occur ty ty1' then None else Some(p,tl1) in
+          t''.desc <- Tobject (ty1', ref nm);
+          (try unify_var env ty t with Unify _ -> assert false);
+          (t'', Changed)
+      | _ -> raise Not_found
+      with Not_found ->
+        let (t'',c) = build_subtype env visited loops posi level' t' in
+        if c > Unchanged then (t'',c)
+        else (t, Unchanged)
+      end
+  | Tconstr(p, tl, _abbrev) ->
+      (* Must check recursion on constructors, since we do not always
+         expand them *)
+      if memq_warn t visited then (t, Unchanged) else
+      let visited = t :: visited in
+      begin try
+        let decl = Env.find_type p env in
+        if level = 0 && generic_abbrev env p && safe_abbrev env t
+        && not (has_constr_row' env t)
+        then warn := true;
+        let tl' =
+          List.map2
+            (fun v t ->
+              let (co,cn) = Variance.get_upper v in
+              if cn then
+                if co then (t, Unchanged)
+                else build_subtype env visited loops (not posi) level t
+              else
+                if co then build_subtype env visited loops posi level t
+                else (newvar(), Changed))
+            decl.type_variance tl
+        in
+        let c = collect tl' in
+        if c > Unchanged then (newconstr p (List.map fst tl'), c)
+        else (t, Unchanged)
+      with Not_found ->
+        (t, Unchanged)
+      end
+  | Tvariant row ->
+      let row = row_repr row in
+      if memq_warn t visited || not (static_row row) then (t, Unchanged) else
+      let level' = pred_enlarge level in
+      let visited =
+        t :: if level' < level then [] else filter_visited visited in
+      let fields = filter_row_fields false row.row_fields in
+      let fields =
+        List.map
+          (fun (l,f as orig) -> match row_field_repr f with
+            Rpresent None ->
+              if posi then
+                (l, Reither(true, [], false, ref None)), Unchanged
+              else
+                orig, Unchanged
+          | Rpresent(Some t) ->
+              let (t', c) = build_subtype env visited loops posi level' t in
+              let f =
+                if posi && level > 0
+                then Reither(false, [t'], false, ref None)
+                else Rpresent(Some t')
+              in (l, f), c
+          | _ -> assert false)
+          fields
+      in
+      let c = collect fields in
+      let row =
+        { row_fields = List.map fst fields; row_more = newvar();
+          row_bound = (); row_closed = posi; row_fixed = None;
+          row_name = if c > Unchanged then None else row.row_name }
+      in
+      (newty (Tvariant row), Changed)
+  | Tobject (t1, _) ->
+      if memq_warn t visited || opened_object t1 then (t, Unchanged) else
+      let level' = pred_enlarge level in
+      let visited =
+        t :: if level' < level then [] else filter_visited visited in
+      let (t1', c) = build_subtype env visited loops posi level' t1 in
+      if c > Unchanged then (newty (Tobject (t1', ref None)), c)
+      else (t, Unchanged)
+  | Tfield(s, _, t1, t2) (* Always present *) ->
+      let (t1', c1) = build_subtype env visited loops posi level t1 in
+      let (t2', c2) = build_subtype env visited loops posi level t2 in
+      let c = max c1 c2 in
+      if c > Unchanged then (newty (Tfield(s, Fpresent, t1', t2')), c)
+      else (t, Unchanged)
+  | Tnil ->
+      if posi then
+        let v = newvar () in
+        (v, Changed)
+      else begin
+        warn := true;
+        (t, Unchanged)
+      end
+  | Tsubst _ | Tlink _ ->
+      assert false
+  | Tpoly(t1, tl) ->
+      let (t1', c) = build_subtype env visited loops posi level t1 in
+      if c > Unchanged then (newty (Tpoly(t1', tl)), c)
+      else (t, Unchanged)
+  | Tunivar _ | Tpackage _ ->
+      (t, Unchanged)
+
+let enlarge_type env ty =
+  warn := false;
+  (* [level = 4] allows 2 expansions involving objects/variants *)
+  let (ty', _) = build_subtype env [] [] true 4 ty in
+  (ty', !warn)
+
+(**** Check whether a type is a subtype of another type. ****)
+
+(*
+    During the traversal, a trace of visited types is maintained. It
+    is printed in case of error.
+    Constraints (pairs of types that must be equals) are accumulated
+    rather than being enforced straight. Indeed, the result would
+    otherwise depend on the order in which these constraints are
+    enforced.
+    A function enforcing these constraints is returned. That way, type
+    variables can be bound to their actual values before this function
+    is called (see Typecore).
+    Only well-defined abbreviations are expanded (hence the tests
+    [generic_abbrev ...]).
+*)
+
+let subtypes = TypePairs.create 17
+
+let subtype_error env trace =
+  raise (Subtype (expand_trace env (List.rev trace), []))
+
+let rec subtype_rec env trace t1 t2 cstrs =
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then cstrs else
+
+  begin try
+    TypePairs.find subtypes (t1, t2);
+    cstrs
+  with Not_found ->
+    TypePairs.add subtypes (t1, t2) ();
+    match (t1.desc, t2.desc) with
+      (Tvar _, _) | (_, Tvar _) ->
+        (trace, t1, t2, !univar_pairs)::cstrs
+    | (Tarrow(l1, t1, u1, _), Tarrow(l2, t2, u2, _)) when l1 = l2
+      || !Clflags.classic && not (is_optional l1 || is_optional l2) ->
+        let cstrs = subtype_rec env (Trace.diff t2 t1::trace) t2 t1 cstrs in
+        subtype_rec env (Trace.diff u1 u2::trace) u1 u2 cstrs
+    | (Ttuple tl1, Ttuple tl2) ->
+        subtype_list env trace tl1 tl2 cstrs
+    | (Tconstr(p1, [], _), Tconstr(p2, [], _)) when Path.same p1 p2 ->
+        cstrs
+    | (Tconstr(p1, _tl1, _abbrev1), _)
+      when generic_abbrev env p1 && safe_abbrev env t1 ->
+        subtype_rec env trace (expand_abbrev env t1) t2 cstrs
+    | (_, Tconstr(p2, _tl2, _abbrev2))
+      when generic_abbrev env p2 && safe_abbrev env t2 ->
+        subtype_rec env trace t1 (expand_abbrev env t2) cstrs
+    | (Tconstr(p1, tl1, _), Tconstr(p2, tl2, _)) when Path.same p1 p2 ->
+        begin try
+          let decl = Env.find_type p1 env in
+          List.fold_left2
+            (fun cstrs v (t1, t2) ->
+              let (co, cn) = Variance.get_upper v in
+              if co then
+                if cn then
+                  (trace, newty2 t1.level (Ttuple[t1]),
+                   newty2 t2.level (Ttuple[t2]), !univar_pairs) :: cstrs
+                else subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs
+              else
+                if cn then subtype_rec env (Trace.diff t2 t1::trace) t2 t1 cstrs
+                else cstrs)
+            cstrs decl.type_variance (List.combine tl1 tl2)
+        with Not_found ->
+          (trace, t1, t2, !univar_pairs)::cstrs
+        end
+    | (Tconstr(p1, _, _), _) when generic_private_abbrev env p1 ->
+        subtype_rec env trace (expand_abbrev_opt env t1) t2 cstrs
+(*  | (_, Tconstr(p2, _, _)) when generic_private_abbrev false env p2 ->
+        subtype_rec env trace t1 (expand_abbrev_opt env t2) cstrs *)
+    | (Tobject (f1, _), Tobject (f2, _))
+      when is_Tvar (object_row f1) && is_Tvar (object_row f2) ->
+        (* Same row variable implies same object. *)
+        (trace, t1, t2, !univar_pairs)::cstrs
+    | (Tobject (f1, _), Tobject (f2, _)) ->
+        subtype_fields env trace f1 f2 cstrs
+    | (Tvariant row1, Tvariant row2) ->
+        begin try
+          subtype_row env trace row1 row2 cstrs
+        with Exit ->
+          (trace, t1, t2, !univar_pairs)::cstrs
+        end
+    | (Tpoly (u1, []), Tpoly (u2, [])) ->
+        subtype_rec env trace u1 u2 cstrs
+    | (Tpoly (u1, tl1), Tpoly (u2, [])) ->
+        let _, u1' = instance_poly false tl1 u1 in
+        subtype_rec env trace u1' u2 cstrs
+    | (Tpoly (u1, tl1), Tpoly (u2,tl2)) ->
+        begin try
+          enter_poly env univar_pairs u1 tl1 u2 tl2
+            (fun t1 t2 -> subtype_rec env trace t1 t2 cstrs)
+        with Unify _ ->
+          (trace, t1, t2, !univar_pairs)::cstrs
+        end
+    | (Tpackage (p1, nl1, tl1), Tpackage (p2, nl2, tl2)) ->
+        begin try
+          let ntl1 = complete_type_list env nl2 t1.level (Mty_ident p1) nl1 tl1
+          and ntl2 = complete_type_list env nl1 t2.level (Mty_ident p2) nl2 tl2
+              ~allow_absent:true in
+          let cstrs' =
+            List.map
+              (fun (n2,t2) -> (trace, List.assoc n2 ntl1, t2, !univar_pairs))
+              ntl2
+          in
+          if eq_package_path env p1 p2 then cstrs' @ cstrs
+          else begin
+            (* need to check module subtyping *)
+            let snap = Btype.snapshot () in
+            try
+              List.iter (fun (_, t1, t2, _) -> unify env t1 t2) cstrs';
+              if !package_subtype env p1 nl1 tl1 p2 nl2 tl2
+              then (Btype.backtrack snap; cstrs' @ cstrs)
+              else raise (Unify [])
+            with Unify _ ->
+              Btype.backtrack snap; raise Not_found
+          end
+        with Not_found ->
+          (trace, t1, t2, !univar_pairs)::cstrs
+        end
+    | (_, _) ->
+        (trace, t1, t2, !univar_pairs)::cstrs
+  end
+
+and subtype_list env trace tl1 tl2 cstrs =
+  if List.length tl1 <> List.length tl2 then
+    subtype_error env trace;
+  List.fold_left2
+    (fun cstrs t1 t2 -> subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs)
+    cstrs tl1 tl2
+
+and subtype_fields env trace ty1 ty2 cstrs =
+  (* Assume that either rest1 or rest2 is not Tvar *)
+  let (fields1, rest1) = flatten_fields ty1 in
+  let (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let cstrs =
+    if rest2.desc = Tnil then cstrs else
+    if miss1 = [] then
+      subtype_rec env (Trace.diff rest1 rest2::trace) rest1 rest2 cstrs
+    else
+      (trace, build_fields (repr ty1).level miss1 rest1, rest2,
+       !univar_pairs) :: cstrs
+  in
+  let cstrs =
+    if miss2 = [] then cstrs else
+    (trace, rest1, build_fields (repr ty2).level miss2 (newvar ()),
+     !univar_pairs) :: cstrs
+  in
+  List.fold_left
+    (fun cstrs (_, _k1, t1, _k2, t2) ->
+      (* These fields are always present *)
+      subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs)
+    cstrs pairs
+
+and subtype_row env trace row1 row2 cstrs =
+  let row1 = row_repr row1 and row2 = row_repr row2 in
+  let r1, r2, pairs =
+    merge_row_fields row1.row_fields row2.row_fields in
+  let r1 = if row2.row_closed then filter_row_fields false r1 else r1 in
+  let r2 = if row1.row_closed then filter_row_fields false r2 else r2 in
+  let more1 = repr row1.row_more
+  and more2 = repr row2.row_more in
+  match more1.desc, more2.desc with
+    Tconstr(p1,_,_), Tconstr(p2,_,_) when Path.same p1 p2 ->
+      subtype_rec env (Trace.diff more1 more2::trace) more1 more2 cstrs
+  | (Tvar _|Tconstr _|Tnil), (Tvar _|Tconstr _|Tnil)
+    when row1.row_closed && r1 = [] ->
+      List.fold_left
+        (fun cstrs (_,f1,f2) ->
+          match row_field_repr f1, row_field_repr f2 with
+            (Rpresent None|Reither(true,_,_,_)), Rpresent None ->
+              cstrs
+          | Rpresent(Some t1), Rpresent(Some t2) ->
+              subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs
+          | Reither(false, t1::_, _, _), Rpresent(Some t2) ->
+              subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs
+          | Rabsent, _ -> cstrs
+          | _ -> raise Exit)
+        cstrs pairs
+  | Tunivar _, Tunivar _
+    when row1.row_closed = row2.row_closed && r1 = [] && r2 = [] ->
+      let cstrs =
+        subtype_rec env (Trace.diff more1 more2::trace) more1 more2 cstrs in
+      List.fold_left
+        (fun cstrs (_,f1,f2) ->
+          match row_field_repr f1, row_field_repr f2 with
+            Rpresent None, Rpresent None
+          | Reither(true,[],_,_), Reither(true,[],_,_)
+          | Rabsent, Rabsent ->
+              cstrs
+          | Rpresent(Some t1), Rpresent(Some t2)
+          | Reither(false,[t1],_,_), Reither(false,[t2],_,_) ->
+              subtype_rec env (Trace.diff t1 t2::trace) t1 t2 cstrs
+          | _ -> raise Exit)
+        cstrs pairs
+  | _ ->
+      raise Exit
+
+let subtype env ty1 ty2 =
+  TypePairs.clear subtypes;
+  univar_pairs := [];
+  (* Build constraint set. *)
+  let cstrs = subtype_rec env [Trace.diff ty1 ty2] ty1 ty2 [] in
+  TypePairs.clear subtypes;
+  (* Enforce constraints. *)
+  function () ->
+    List.iter
+      (function (trace0, t1, t2, pairs) ->
+         try unify_pairs (ref env) t1 t2 pairs with Unify trace ->
+           raise (Subtype (expand_trace env (List.rev trace0),
+                           List.tl trace)))
+      (List.rev cstrs)
+
+                              (*******************)
+                              (*  Miscellaneous  *)
+                              (*******************)
+
+(* Utility for printing. The resulting type is not used in computation. *)
+let rec unalias_object ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tfield (s, k, t1, t2) ->
+      newty2 ty.level (Tfield (s, k, t1, unalias_object t2))
+  | Tvar _ | Tnil ->
+      newty2 ty.level ty.desc
+  | Tunivar _ ->
+      ty
+  | Tconstr _ ->
+      newvar2 ty.level
+  | _ ->
+      assert false
+
+let unalias ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar _ | Tunivar _ ->
+      ty
+  | Tvariant row ->
+      let row = row_repr row in
+      let more = row.row_more in
+      newty2 ty.level
+        (Tvariant {row with row_more = newty2 more.level more.desc})
+  | Tobject (ty, nm) ->
+      newty2 ty.level (Tobject (unalias_object ty, nm))
+  | _ ->
+      newty2 ty.level ty.desc
+
+(* Return the arity (as for curried functions) of the given type. *)
+let rec arity ty =
+  match (repr ty).desc with
+    Tarrow(_, _t1, t2, _) -> 1 + arity t2
+  | _ -> 0
+
+(* Check whether an abbreviation expands to itself. *)
+let cyclic_abbrev env id ty =
+  let rec check_cycle seen ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tconstr (p, _tl, _abbrev) ->
+        p = Path.Pident id || List.memq ty seen ||
+        begin try
+          check_cycle (ty :: seen) (expand_abbrev_opt env ty)
+        with
+          Cannot_expand -> false
+        | Unify _ -> true
+        end
+    | _ ->
+        false
+  in check_cycle [] ty
+
+(* Check for non-generalizable type variables *)
+exception Non_closed0
+let visited = ref TypeSet.empty
+
+let rec closed_schema_rec env ty =
+  let ty = repr ty in
+  if TypeSet.mem ty !visited then () else begin
+    visited := TypeSet.add ty !visited;
+    match ty.desc with
+      Tvar _ when ty.level <> generic_level ->
+        raise Non_closed0
+    | Tconstr _ ->
+        let old = !visited in
+        begin try iter_type_expr (closed_schema_rec env) ty
+        with Non_closed0 -> try
+          visited := old;
+          closed_schema_rec env (try_expand_head try_expand_safe env ty)
+        with Cannot_expand ->
+          raise Non_closed0
+        end
+    | Tfield(_, kind, t1, t2) ->
+        if field_kind_repr kind = Fpresent then
+          closed_schema_rec env t1;
+        closed_schema_rec env t2
+    | Tvariant row ->
+        let row = row_repr row in
+        iter_row (closed_schema_rec env) row;
+        if not (static_row row) then closed_schema_rec env row.row_more
+    | _ ->
+        iter_type_expr (closed_schema_rec env) ty
+  end
+
+(* Return whether all variables of type [ty] are generic. *)
+let closed_schema env ty =
+  visited := TypeSet.empty;
+  try
+    closed_schema_rec env ty;
+    visited := TypeSet.empty;
+    true
+  with Non_closed0 ->
+    visited := TypeSet.empty;
+    false
+
+(* Normalize a type before printing, saving... *)
+(* Cannot use mark_type because deep_occur uses it too *)
+let rec normalize_type_rec env visited ty =
+  let ty = repr ty in
+  if not (TypeSet.mem ty !visited) then begin
+    visited := TypeSet.add ty !visited;
+    let tm = row_of_type ty in
+    begin if not (is_Tconstr ty) && is_constr_row ~allow_ident:false tm then
+      match tm.desc with (* PR#7348 *)
+        Tconstr (Path.Pdot(m,i), tl, _abbrev) ->
+          let i' = String.sub i 0 (String.length i - 4) in
+          set_type_desc ty (Tconstr(Path.Pdot(m,i'), tl, ref Mnil))
+      | _ -> assert false
+    else match ty.desc with
+    | Tvariant row ->
+      let row = row_repr row in
+      let fields = List.map
+          (fun (l,f0) ->
+            let f = row_field_repr f0 in l,
+            match f with Reither(b, ty::(_::_ as tyl), m, e) ->
+              let tyl' =
+                List.fold_left
+                  (fun tyl ty ->
+                    if List.exists (fun ty' -> equal env false [ty] [ty']) tyl
+                    then tyl else ty::tyl)
+                  [ty] tyl
+              in
+              if f != f0 || List.length tyl' < List.length tyl then
+                Reither(b, List.rev tyl', m, e)
+              else f
+            | _ -> f)
+          row.row_fields in
+      let fields =
+        List.sort (fun (p,_) (q,_) -> compare p q)
+          (List.filter (fun (_,fi) -> fi <> Rabsent) fields) in
+      set_type_desc ty (Tvariant {row with row_fields = fields})
+    | Tobject (fi, nm) ->
+        begin match !nm with
+        | None -> ()
+        | Some (n, v :: l) ->
+            if deep_occur ty (newgenty (Ttuple l)) then
+              (* The abbreviation may be hiding something, so remove it *)
+              set_name nm None
+            else let v' = repr v in
+            begin match v'.desc with
+            | Tvar _ | Tunivar _ ->
+                if v' != v then set_name nm (Some (n, v' :: l))
+            | Tnil ->
+                set_type_desc ty (Tconstr (n, l, ref Mnil))
+            | _ -> set_name nm None
+            end
+        | _ ->
+            fatal_error "Ctype.normalize_type_rec"
+        end;
+        let fi = repr fi in
+        if fi.level < lowest_level then () else
+        let fields, row = flatten_fields fi in
+        let fi' = build_fields fi.level fields row in
+        set_type_desc fi fi'.desc
+    | _ -> ()
+    end;
+    iter_type_expr (normalize_type_rec env visited) ty
+  end
+
+let normalize_type env ty =
+  normalize_type_rec env (ref TypeSet.empty) ty
+
+
+                              (*************************)
+                              (*  Remove dependencies  *)
+                              (*************************)
+
+
+(*
+   Variables are left unchanged. Other type nodes are duplicated, with
+   levels set to generic level.
+   We cannot use Tsubst here, because unification may be called by
+   expand_abbrev.
+*)
+
+let nondep_hash     = TypeHash.create 47
+let nondep_variants = TypeHash.create 17
+let clear_hash ()   =
+  TypeHash.clear nondep_hash; TypeHash.clear nondep_variants
+
+exception Nondep_cannot_erase of Ident.t
+
+let rec nondep_type_rec ?(expand_private=false) env ids ty =
+  let expand_abbrev env t =
+    if expand_private then expand_abbrev_opt env t else expand_abbrev env t
+  in
+  match ty.desc with
+    Tvar _ | Tunivar _ -> ty
+  | Tlink ty -> nondep_type_rec env ids ty
+  | _ -> try TypeHash.find nondep_hash ty
+  with Not_found ->
+    let ty' = newgenvar () in        (* Stub *)
+    TypeHash.add nondep_hash ty ty';
+    ty'.desc <-
+      begin match ty.desc with
+      | Tconstr(p, tl, _abbrev) ->
+          begin match Path.find_free_opt ids p with
+          | Some id ->
+              begin try
+                Tlink (nondep_type_rec ~expand_private env ids
+                         (expand_abbrev env (newty2 ty.level ty.desc)))
+                (*
+                   The [Tlink] is important. The expanded type may be a
+                   variable, or may not be completely copied yet
+                   (recursive type), so one cannot just take its
+                   description.
+                 *)
+              with Cannot_expand | Unify _ ->
+                raise (Nondep_cannot_erase id)
+              end
+          | None ->
+              Tconstr(p, List.map (nondep_type_rec env ids) tl, ref Mnil)
+          end
+      | Tpackage(p, nl, tl) when Path.exists_free ids p ->
+          let p' = normalize_package_path env p in
+          begin match Path.find_free_opt ids p' with
+          | Some id -> raise (Nondep_cannot_erase id)
+          | None -> Tpackage (p', nl, List.map (nondep_type_rec env ids) tl)
+          end
+      | Tobject (t1, name) ->
+          Tobject (nondep_type_rec env ids t1,
+                 ref (match !name with
+                        None -> None
+                      | Some (p, tl) ->
+                          if Path.exists_free ids p then None
+                          else Some (p, List.map (nondep_type_rec env ids) tl)))
+      | Tvariant row ->
+          let row = row_repr row in
+          let more = repr row.row_more in
+          (* We must keep sharing according to the row variable *)
+          begin try
+            let ty2 = TypeHash.find nondep_variants more in
+            (* This variant type has been already copied *)
+            TypeHash.add nondep_hash ty ty2;
+            Tlink ty2
+          with Not_found ->
+            (* Register new type first for recursion *)
+            TypeHash.add nondep_variants more ty';
+            let static = static_row row in
+            let more' = if static then newgenty Tnil else more in
+            (* Return a new copy *)
+            let row =
+              copy_row (nondep_type_rec env ids) true row true more' in
+            match row.row_name with
+              Some (p, _tl) when Path.exists_free ids p ->
+                Tvariant {row with row_name = None}
+            | _ -> Tvariant row
+          end
+      | _ -> copy_type_desc (nondep_type_rec env ids) ty.desc
+      end;
+    ty'
+
+let nondep_type env id ty =
+  try
+    let ty' = nondep_type_rec env id ty in
+    clear_hash ();
+    ty'
+  with Nondep_cannot_erase _ as exn ->
+    clear_hash ();
+    raise exn
+
+let () = nondep_type' := nondep_type
+
+(* Preserve sharing inside type declarations. *)
+let nondep_type_decl env mid is_covariant decl =
+  try
+    let params = List.map (nondep_type_rec env mid) decl.type_params in
+    let tk =
+      try map_kind (nondep_type_rec env mid) decl.type_kind
+      with Nondep_cannot_erase _ when is_covariant -> Type_abstract
+    and tm, priv =
+      match decl.type_manifest with
+      | None -> None, decl.type_private
+      | Some ty ->
+          try Some (nondep_type_rec env mid ty), decl.type_private
+          with Nondep_cannot_erase _ when is_covariant ->
+            clear_hash ();
+            try Some (nondep_type_rec ~expand_private:true env mid ty),
+                Private
+            with Nondep_cannot_erase _ ->
+              None, decl.type_private
+    in
+    clear_hash ();
+    let priv =
+      match tm with
+      | Some ty when Btype.has_constr_row ty -> Private
+      | _ -> priv
+    in
+    { type_params = params;
+      type_arity = decl.type_arity;
+      type_kind = tk;
+      type_manifest = tm;
+      type_private = priv;
+      type_variance = decl.type_variance;
+      type_is_newtype = false;
+      type_expansion_scope = Btype.lowest_level;
+      type_loc = decl.type_loc;
+      type_attributes = decl.type_attributes;
+      type_immediate = decl.type_immediate;
+      type_unboxed = decl.type_unboxed;
+    }
+  with Nondep_cannot_erase _ as exn ->
+    clear_hash ();
+    raise exn
+
+(* Preserve sharing inside extension constructors. *)
+let nondep_extension_constructor env ids ext =
+  try
+    let type_path, type_params =
+      match Path.find_free_opt ids ext.ext_type_path with
+      | Some id ->
+        begin
+          let ty =
+            newgenty (Tconstr(ext.ext_type_path, ext.ext_type_params, ref Mnil))
+          in
+          let ty' = nondep_type_rec env ids ty in
+            match (repr ty').desc with
+                Tconstr(p, tl, _) -> p, tl
+              | _ -> raise (Nondep_cannot_erase id)
+        end
+      | None ->
+        let type_params =
+          List.map (nondep_type_rec env ids) ext.ext_type_params
+        in
+          ext.ext_type_path, type_params
+    in
+    let args = map_type_expr_cstr_args (nondep_type_rec env ids) ext.ext_args in
+    let ret_type = Option.map (nondep_type_rec env ids) ext.ext_ret_type in
+      clear_hash ();
+      { ext_type_path = type_path;
+        ext_type_params = type_params;
+        ext_args = args;
+        ext_ret_type = ret_type;
+        ext_private = ext.ext_private;
+        ext_attributes = ext.ext_attributes;
+        ext_loc = ext.ext_loc;
+      }
+  with Nondep_cannot_erase _ as exn ->
+    clear_hash ();
+    raise exn
+
+
+(* Preserve sharing inside class types. *)
+let nondep_class_signature env id sign =
+  { csig_self = nondep_type_rec env id sign.csig_self;
+    csig_vars =
+      Vars.map (function (m, v, t) -> (m, v, nondep_type_rec env id t))
+        sign.csig_vars;
+    csig_concr = sign.csig_concr;
+    csig_inher =
+      List.map (fun (p,tl) -> (p, List.map (nondep_type_rec env id) tl))
+        sign.csig_inher }
+
+let rec nondep_class_type env ids =
+  function
+    Cty_constr (p, _, cty) when Path.exists_free ids p ->
+      nondep_class_type env ids cty
+  | Cty_constr (p, tyl, cty) ->
+      Cty_constr (p, List.map (nondep_type_rec env ids) tyl,
+                   nondep_class_type env ids cty)
+  | Cty_signature sign ->
+      Cty_signature (nondep_class_signature env ids sign)
+  | Cty_arrow (l, ty, cty) ->
+      Cty_arrow (l, nondep_type_rec env ids ty, nondep_class_type env ids cty)
+
+let nondep_class_declaration env ids decl =
+  assert (not (Path.exists_free ids decl.cty_path));
+  let decl =
+    { cty_params = List.map (nondep_type_rec env ids) decl.cty_params;
+      cty_variance = decl.cty_variance;
+      cty_type = nondep_class_type env ids decl.cty_type;
+      cty_path = decl.cty_path;
+      cty_new =
+        begin match decl.cty_new with
+          None    -> None
+        | Some ty -> Some (nondep_type_rec env ids ty)
+        end;
+      cty_loc = decl.cty_loc;
+      cty_attributes = decl.cty_attributes;
+    }
+  in
+  clear_hash ();
+  decl
+
+let nondep_cltype_declaration env ids decl =
+  assert (not (Path.exists_free ids decl.clty_path));
+  let decl =
+    { clty_params = List.map (nondep_type_rec env ids) decl.clty_params;
+      clty_variance = decl.clty_variance;
+      clty_type = nondep_class_type env ids decl.clty_type;
+      clty_path = decl.clty_path;
+      clty_loc = decl.clty_loc;
+      clty_attributes = decl.clty_attributes;
+    }
+  in
+  clear_hash ();
+  decl
+
+(* collapse conjunctive types in class parameters *)
+let rec collapse_conj env visited ty =
+  let ty = repr ty in
+  if List.memq ty visited then () else
+  let visited = ty :: visited in
+  match ty.desc with
+    Tvariant row ->
+      let row = row_repr row in
+      List.iter
+        (fun (_l,fi) ->
+          match row_field_repr fi with
+            Reither (c, t1::(_::_ as tl), m, e) ->
+              List.iter (unify env t1) tl;
+              set_row_field e (Reither (c, [t1], m, ref None))
+          | _ ->
+              ())
+        row.row_fields;
+      iter_row (collapse_conj env visited) row
+  | _ ->
+      iter_type_expr (collapse_conj env visited) ty
+
+let collapse_conj_params env params =
+  List.iter (collapse_conj env []) params
+
+let same_constr env t1 t2 =
+  let t1 = expand_head env t1 in
+  let t2 = expand_head env t2 in
+  match t1.desc, t2.desc with
+  | Tconstr (p1, _, _), Tconstr (p2, _, _) -> Path.same p1 p2
+  | _ -> false
+
+let () =
+  Env.same_constr := same_constr
+
+let is_immediate = function
+  | Type_immediacy.Unknown -> false
+  | Type_immediacy.Always -> true
+  | Type_immediacy.Always_on_64bits ->
+      (* In bytecode, we don't know at compile time whether we are
+         targeting 32 or 64 bits. *)
+      !Clflags.native_code && Sys.word_size = 64
+
+let immediacy env typ =
+   match (repr typ).desc with
+  | Tconstr(p, _args, _abbrev) ->
+    begin try
+      let type_decl = Env.find_type p env in
+      type_decl.type_immediate
+    with Not_found -> Type_immediacy.Unknown
+    (* This can happen due to e.g. missing -I options,
+       causing some .cmi files to be unavailable.
+       Maybe we should emit a warning. *)
+    end
+  | Tvariant row ->
+      let row = Btype.row_repr row in
+      (* if all labels are devoid of arguments, not a pointer *)
+      if
+        not row.row_closed
+        || List.exists
+          (function
+            | _, (Rpresent (Some _) | Reither (false, _, _, _)) -> true
+            | _ -> false)
+          row.row_fields
+      then
+        Type_immediacy.Unknown
+      else
+        Type_immediacy.Always
+  | _ -> Type_immediacy.Unknown
+
+let maybe_pointer_type env typ = not (is_immediate (immediacy env typ))
diff --git a/src/ocaml/typing/410+multicore/ctype.mli b/src/ocaml/typing/410+multicore/ctype.mli
new file mode 100644
index 00000000..be01b776
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/ctype.mli
@@ -0,0 +1,374 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Operations on core types *)
+
+open Asttypes
+open Types
+
+module Unification_trace: sig
+  (** Unification traces are used to explain unification errors
+      when printing error messages *)
+
+  type position = First | Second
+  type desc = { t: type_expr; expanded: type_expr option }
+  type 'a diff = { got: 'a; expected: 'a}
+
+   (** Scope escape related errors *)
+    type 'a escape =
+    | Constructor of Path.t
+    | Univ of type_expr
+    (** The type_expr argument of [Univ] is always a [Tunivar _],
+        we keep a [type_expr] to track renaming in {!Printtyp} *)
+    | Self
+    | Module_type of Path.t
+    | Equation of 'a
+
+   (** Errors for polymorphic variants *)
+
+  type fixed_row_case =
+    | Cannot_be_closed
+    | Cannot_add_tags of string list
+
+  type variant =
+    | No_intersection
+    | No_tags of position * (Asttypes.label * row_field) list
+    | Incompatible_types_for of string
+    | Fixed_row of position * fixed_row_case * fixed_explanation
+    (** Fixed row types,  e.g. ['a. [> `X] as 'a] *)
+
+  type obj =
+    | Missing_field of position * string
+    | Abstract_row of position
+    | Self_cannot_be_closed
+
+  type 'a elt =
+    | Diff of 'a diff
+    | Variant of variant
+    | Obj of obj
+    | Escape of {context: type_expr option; kind:'a escape}
+    | Incompatible_fields of {name:string; diff: type_expr diff }
+    | Rec_occur of type_expr * type_expr
+
+  type t = desc elt list
+
+  val diff: type_expr -> type_expr -> desc elt
+
+  (** [map_diff f {expected;got}] is [{expected=f expected; got=f got}] *)
+  val map_diff: ('a -> 'b) -> 'a diff -> 'b diff
+
+  (** [flatten f trace] flattens all elements of type {!desc} in
+      [trace] to either [f x.t expanded] if [x.expanded=Some expanded]
+      or [f x.t x.t] otherwise *)
+  val flatten: (type_expr -> type_expr -> 'a) -> t -> 'a elt list
+
+  (** Switch [expected] and [got] *)
+  val swap: t -> t
+
+  (** [explain trace f] calls [f] on trace elements starting from the end
+      until [f ~prev elt] is [Some _], returns that
+      or [None] if the end of the trace is reached. *)
+  val explain:
+          'a elt list ->
+          (prev:'a elt option -> 'a elt -> 'b option) ->
+          'b option
+
+  (** merlin specific *)
+  val map_types : (type_expr -> type_expr) -> t -> t
+end
+
+exception Unify of Unification_trace.t
+exception Tags of label * label
+exception Subtype of Unification_trace.t * Unification_trace.t
+exception Cannot_expand
+exception Cannot_apply
+
+val init_def: int -> unit
+        (* Set the initial variable level *)
+val begin_def: unit -> unit
+        (* Raise the variable level by one at the beginning of a definition. *)
+val end_def: unit -> unit
+        (* Lower the variable level by one at the end of a definition *)
+val begin_class_def: unit -> unit
+val raise_nongen_level: unit -> unit
+val reset_global_level: unit -> unit
+        (* Reset the global level before typing an expression *)
+val increase_global_level: unit -> int
+val restore_global_level: int -> unit
+        (* This pair of functions is only used in Typetexp *)
+type levels =
+    { current_level: int; nongen_level: int; global_level: int;
+      saved_level: (int * int) list; }
+val save_levels: unit -> levels
+val set_levels: levels -> unit
+
+val create_scope : unit -> int
+
+val newty: type_desc -> type_expr
+val newvar: ?name:string -> unit -> type_expr
+val newvar2: ?name:string -> int -> type_expr
+        (* Return a fresh variable *)
+val new_global_var: ?name:string -> unit -> type_expr
+        (* Return a fresh variable, bound at toplevel
+           (as type variables ['a] in type constraints). *)
+val newobj: type_expr -> type_expr
+val newconstr: Path.t -> type_expr list -> type_expr
+val none: type_expr
+        (* A dummy type expression *)
+
+val repr: type_expr -> type_expr
+        (* Return the canonical representative of a type. *)
+
+val object_fields: type_expr -> type_expr
+val flatten_fields:
+        type_expr -> (string * field_kind * type_expr) list * type_expr
+        (* Transform a field type into a list of pairs label-type *)
+        (* The fields are sorted *)
+val associate_fields:
+        (string * field_kind * type_expr) list ->
+        (string * field_kind * type_expr) list ->
+        (string * field_kind * type_expr * field_kind * type_expr) list *
+        (string * field_kind * type_expr) list *
+        (string * field_kind * type_expr) list
+val opened_object: type_expr -> bool
+val close_object: type_expr -> bool
+val row_variable: type_expr -> type_expr
+        (* Return the row variable of an open object type *)
+val set_object_name:
+        Ident.t -> type_expr -> type_expr list -> type_expr -> unit
+val remove_object_name: type_expr -> unit
+val hide_private_methods: type_expr -> unit
+val find_cltype_for_path: Env.t -> Path.t -> type_declaration * type_expr
+
+val sort_row_fields: (label * row_field) list -> (label * row_field) list
+val merge_row_fields:
+        (label * row_field) list -> (label * row_field) list ->
+        (label * row_field) list * (label * row_field) list *
+        (label * row_field * row_field) list
+val filter_row_fields:
+        bool -> (label * row_field) list -> (label * row_field) list
+
+val generalize: type_expr -> unit
+        (* Generalize in-place the given type *)
+val lower_contravariant: Env.t -> type_expr -> unit
+        (* Lower level of type variables inside contravariant branches;
+           to be used before generalize for expansive expressions *)
+val generalize_structure: type_expr -> unit
+        (* Same, but variables are only lowered to !current_level *)
+val generalize_spine: type_expr -> unit
+        (* Special function to generalize a method during inference *)
+val correct_levels: type_expr -> type_expr
+        (* Returns a copy with decreasing levels *)
+val limited_generalize: type_expr -> type_expr -> unit
+        (* Only generalize some part of the type
+           Make the remaining of the type non-generalizable *)
+
+val check_scope_escape : Env.t -> int -> type_expr -> unit
+        (* [check_scope_escape env lvl ty] ensures that [ty] could be raised
+           to the level [lvl] without any scope escape.
+           Raises [Unify] otherwise *)
+
+val instance: ?partial:bool -> type_expr -> type_expr
+        (* Take an instance of a type scheme *)
+        (* partial=None  -> normal
+           partial=false -> newvar() for non generic subterms
+           partial=true  -> newty2 ty.level Tvar for non generic subterms *)
+val generic_instance: type_expr -> type_expr
+        (* Same as instance, but new nodes at generic_level *)
+val instance_list: type_expr list -> type_expr list
+        (* Take an instance of a list of type schemes *)
+val existential_name: constructor_description -> type_expr -> string
+val instance_constructor:
+        ?in_pattern:Env.t ref * int ->
+        constructor_description -> type_expr list * type_expr
+        (* Same, for a constructor *)
+val instance_parameterized_type:
+        ?keep_names:bool ->
+        type_expr list -> type_expr -> type_expr list * type_expr
+val instance_parameterized_type_2:
+        type_expr list -> type_expr list -> type_expr ->
+        type_expr list * type_expr list * type_expr
+val instance_declaration: type_declaration -> type_declaration
+val generic_instance_declaration: type_declaration -> type_declaration
+        (* Same as instance_declaration, but new nodes at generic_level *)
+val instance_class:
+        type_expr list -> class_type -> type_expr list * class_type
+val instance_poly:
+        ?keep_names:bool ->
+        bool -> type_expr list -> type_expr -> type_expr list * type_expr
+        (* Take an instance of a type scheme containing free univars *)
+val instance_label:
+        bool -> label_description -> type_expr list * type_expr * type_expr
+        (* Same, for a label *)
+val apply:
+        Env.t -> type_expr list -> type_expr -> type_expr list -> type_expr
+        (* [apply [p1...pN] t [a1...aN]] match the arguments [ai] to
+        the parameters [pi] and returns the corresponding instance of
+        [t]. Exception [Cannot_apply] is raised in case of failure. *)
+
+val expand_head_once: Env.t -> type_expr -> type_expr
+val expand_head: Env.t -> type_expr -> type_expr
+val try_expand_once_opt: Env.t -> type_expr -> type_expr
+val expand_head_opt: Env.t -> type_expr -> type_expr
+(** The compiler's own version of [expand_head] necessary for type-based
+    optimisations. *)
+
+val full_expand: Env.t -> type_expr -> type_expr
+val extract_concrete_typedecl:
+        Env.t -> type_expr -> Path.t * Path.t * type_declaration
+        (* Return the original path of the types, and the first concrete
+           type declaration found expanding it.
+           Raise [Not_found] if none appears or not a type constructor. *)
+
+val enforce_constraints: Env.t -> type_expr -> unit
+
+val unify: Env.t -> type_expr -> type_expr -> unit
+        (* Unify the two types given. Raise [Unify] if not possible. *)
+val unify_gadt:
+        equations_level:int -> Env.t ref -> type_expr -> type_expr -> unit
+        (* Unify the two types given and update the environment with the
+           local constraints. Raise [Unify] if not possible. *)
+val unify_var: Env.t -> type_expr -> type_expr -> unit
+        (* Same as [unify], but allow free univars when first type
+           is a variable. *)
+val with_passive_variants: ('a -> 'b) -> ('a -> 'b)
+        (* Call [f] in passive_variants mode, for exhaustiveness check. *)
+val filter_arrow: Env.t -> type_expr -> arg_label -> type_expr * type_expr
+        (* A special case of unification (with l:'a -> 'b). *)
+val filter_method: Env.t -> string -> private_flag -> type_expr -> type_expr
+        (* A special case of unification (with {m : 'a; 'b}). *)
+val check_filter_method: Env.t -> string -> private_flag -> type_expr -> unit
+        (* A special case of unification (with {m : 'a; 'b}), returning unit. *)
+val occur_in: Env.t -> type_expr -> type_expr -> bool
+val deep_occur: type_expr -> type_expr -> bool
+val filter_self_method:
+        Env.t -> string -> private_flag -> (Ident.t * type_expr) Meths.t ref ->
+        type_expr -> Ident.t * type_expr
+val moregeneral: Env.t -> bool -> type_expr -> type_expr -> bool
+        (* Check if the first type scheme is more general than the second. *)
+
+val rigidify: type_expr -> type_expr list
+        (* "Rigidify" a type and return its type variable *)
+val all_distinct_vars: Env.t -> type_expr list -> bool
+        (* Check those types are all distinct type variables *)
+val matches: Env.t -> type_expr -> type_expr -> bool
+        (* Same as [moregeneral false], implemented using the two above
+           functions and backtracking. Ignore levels *)
+
+val reify_univars : Types.type_expr -> Types.type_expr
+        (* Replaces all the variables of a type by a univar. *)
+
+type class_match_failure =
+    CM_Virtual_class
+  | CM_Parameter_arity_mismatch of int * int
+  | CM_Type_parameter_mismatch of Env.t * Unification_trace.t
+  | CM_Class_type_mismatch of Env.t * class_type * class_type
+  | CM_Parameter_mismatch of Env.t * Unification_trace.t
+  | CM_Val_type_mismatch of string * Env.t * Unification_trace.t
+  | CM_Meth_type_mismatch of string * Env.t * Unification_trace.t
+  | CM_Non_mutable_value of string
+  | CM_Non_concrete_value of string
+  | CM_Missing_value of string
+  | CM_Missing_method of string
+  | CM_Hide_public of string
+  | CM_Hide_virtual of string * string
+  | CM_Public_method of string
+  | CM_Private_method of string
+  | CM_Virtual_method of string
+val match_class_types:
+    ?trace:bool -> Env.t -> class_type -> class_type -> class_match_failure list
+        (* Check if the first class type is more general than the second. *)
+val equal: Env.t -> bool -> type_expr list -> type_expr list -> bool
+        (* [equal env [x1...xn] tau [y1...yn] sigma]
+           checks whether the parameterized types
+           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
+val match_class_declarations:
+        Env.t -> type_expr list -> class_type -> type_expr list ->
+        class_type -> class_match_failure list
+        (* Check if the first class type is more general than the second. *)
+
+val enlarge_type: Env.t -> type_expr -> type_expr * bool
+        (* Make a type larger, flag is true if some pruning had to be done *)
+val subtype: Env.t -> type_expr -> type_expr -> unit -> unit
+        (* [subtype env t1 t2] checks that [t1] is a subtype of [t2].
+           It accumulates the constraints the type variables must
+           enforce and returns a function that enforces this
+           constraints. *)
+
+exception Nondep_cannot_erase of Ident.t
+
+val nondep_type: Env.t -> Ident.t list -> type_expr -> type_expr
+        (* Return a type equivalent to the given type but without
+           references to any of the given identifiers.
+           Raise [Nondep_cannot_erase id] if no such type exists because [id],
+           in particular, could not be erased. *)
+val nondep_type_decl:
+        Env.t -> Ident.t list -> bool -> type_declaration -> type_declaration
+        (* Same for type declarations. *)
+val nondep_extension_constructor:
+        Env.t -> Ident.t list -> extension_constructor ->
+        extension_constructor
+          (* Same for extension constructor *)
+val nondep_class_declaration:
+        Env.t -> Ident.t list -> class_declaration -> class_declaration
+        (* Same for class declarations. *)
+val nondep_cltype_declaration:
+  Env.t -> Ident.t list -> class_type_declaration -> class_type_declaration
+        (* Same for class type declarations. *)
+(*val correct_abbrev: Env.t -> Path.t -> type_expr list -> type_expr -> unit*)
+val cyclic_abbrev: Env.t -> Ident.t -> type_expr -> bool
+val is_contractive: Env.t -> Path.t -> bool
+val normalize_type: Env.t -> type_expr -> unit
+
+val closed_schema: Env.t -> type_expr -> bool
+        (* Check whether the given type scheme contains no non-generic
+           type variables *)
+
+val free_variables: ?env:Env.t -> type_expr -> type_expr list
+        (* If env present, then check for incomplete definitions too *)
+val closed_type_decl: type_declaration -> type_expr option
+val closed_extension_constructor: extension_constructor -> type_expr option
+type closed_class_failure =
+    CC_Method of type_expr * bool * string * type_expr
+  | CC_Value of type_expr * bool * string * type_expr
+val closed_class:
+        type_expr list -> class_signature -> closed_class_failure option
+        (* Check whether all type variables are bound *)
+
+val unalias: type_expr -> type_expr
+val signature_of_class_type: class_type -> class_signature
+val self_type: class_type -> type_expr
+val class_type_arity: class_type -> int
+val arity: type_expr -> int
+        (* Return the arity (as for curried functions) of the given type. *)
+
+val collapse_conj_params: Env.t -> type_expr list -> unit
+        (* Collapse conjunctive types in class parameters *)
+
+val get_current_level: unit -> int
+val wrap_trace_gadt_instances: Env.t -> ('a -> 'b) -> 'a -> 'b
+val reset_reified_var_counter: unit -> unit
+
+val immediacy : Env.t -> type_expr -> Type_immediacy.t
+
+val maybe_pointer_type : Env.t -> type_expr -> bool
+       (* True if type is possibly pointer, false if definitely not a pointer *)
+
+(* Stubs *)
+val package_subtype :
+    (Env.t -> Path.t -> Longident.t list -> type_expr list ->
+      Path.t -> Longident.t list -> type_expr list -> bool) ref
+
+val mcomp : Env.t -> type_expr -> type_expr -> unit
diff --git a/src/ocaml/typing/410+multicore/datarepr.ml b/src/ocaml/typing/410+multicore/datarepr.ml
new file mode 100644
index 00000000..61d79bac
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/datarepr.ml
@@ -0,0 +1,251 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Compute constructor and label descriptions from type declarations,
+   determining their representation. *)
+
+open Asttypes
+open Types
+open Btype
+
+(* Simplified version of Ctype.free_vars *)
+let free_vars ?(param=false) ty =
+  let ret = ref TypeSet.empty in
+  let rec loop ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      ty.level <- pivot_level - ty.level;
+      match ty.desc with
+      | Tvar _ ->
+          ret := TypeSet.add ty !ret
+      | Tvariant row ->
+          let row = row_repr row in
+          iter_row loop row;
+          if not (static_row row) then begin
+            match row.row_more.desc with
+            | Tvar _ when param -> ret := TypeSet.add ty !ret
+            | _ -> loop row.row_more
+          end
+      (* XXX: What about Tobject ? *)
+      | _ ->
+          iter_type_expr loop ty
+    end
+  in
+  loop ty;
+  unmark_type ty;
+  !ret
+
+let newgenconstr path tyl = newgenty (Tconstr (path, tyl, ref Mnil))
+
+let constructor_existentials cd_args cd_res =
+  let tyl =
+    match cd_args with
+    | Cstr_tuple l -> l
+    | Cstr_record l -> List.map (fun l -> l.ld_type) l
+  in
+  let existentials =
+    match cd_res with
+    | None -> []
+    | Some type_ret ->
+        let arg_vars_set = free_vars (newgenty (Ttuple tyl)) in
+        let res_vars = free_vars type_ret in
+        TypeSet.elements (TypeSet.diff arg_vars_set res_vars)
+  in
+  (tyl, existentials)
+
+let constructor_args priv cd_args cd_res path rep =
+  let tyl, existentials = constructor_existentials cd_args cd_res in
+  match cd_args with
+  | Cstr_tuple l -> existentials, l, None
+  | Cstr_record lbls ->
+      let arg_vars_set = free_vars ~param:true (newgenty (Ttuple tyl)) in
+      let type_params = TypeSet.elements arg_vars_set in
+      let type_unboxed =
+        match rep with
+        | Record_unboxed _ -> unboxed_true_default_false
+        | _ -> unboxed_false_default_false
+      in
+      let tdecl =
+        {
+          type_params;
+          type_arity = List.length type_params;
+          type_kind = Type_record (lbls, rep);
+          type_private = priv;
+          type_manifest = None;
+          type_variance = List.map (fun _ -> Variance.full) type_params;
+          type_is_newtype = false;
+          type_expansion_scope = Btype.lowest_level;
+          type_loc = Location.none;
+          type_attributes = [];
+          type_immediate = Unknown;
+          type_unboxed;
+        }
+      in
+      existentials,
+      [ newgenconstr path type_params ],
+      Some tdecl
+
+let constructor_descrs ty_path decl cstrs =
+  let ty_res = newgenconstr ty_path decl.type_params in
+  let num_consts = ref 0 and num_nonconsts = ref 0  and num_normal = ref 0 in
+  List.iter
+    (fun {cd_args; cd_res; _} ->
+      if cd_args = Cstr_tuple [] then incr num_consts else incr num_nonconsts;
+      if cd_res = None then incr num_normal)
+    cstrs;
+  let rec describe_constructors idx_const idx_nonconst = function
+      [] -> []
+    | {cd_id; cd_args; cd_res; cd_loc; cd_attributes} :: rem ->
+        let ty_res =
+          match cd_res with
+          | Some ty_res' -> ty_res'
+          | None -> ty_res
+        in
+        let (tag, descr_rem) =
+          match cd_args with
+          | _ when decl.type_unboxed.unboxed ->
+            assert (rem = []);
+            (Cstr_unboxed, [])
+          | Cstr_tuple [] -> (Cstr_constant idx_const,
+                   describe_constructors (idx_const+1) idx_nonconst rem)
+          | _  -> (Cstr_block idx_nonconst,
+                   describe_constructors idx_const (idx_nonconst+1) rem) in
+        let cstr_name = Ident.name cd_id in
+        let existentials, cstr_args, cstr_inlined =
+          let representation =
+            if decl.type_unboxed.unboxed
+            then Record_unboxed true
+            else Record_inlined idx_nonconst
+          in
+          constructor_args decl.type_private cd_args cd_res
+            (Path.Pdot (ty_path, cstr_name)) representation
+        in
+        let cstr =
+          { cstr_name;
+            cstr_res = ty_res;
+            cstr_existentials = existentials;
+            cstr_args;
+            cstr_arity = List.length cstr_args;
+            cstr_tag = tag;
+            cstr_consts = !num_consts;
+            cstr_nonconsts = !num_nonconsts;
+            cstr_normal = !num_normal;
+            cstr_private = decl.type_private;
+            cstr_generalized = cd_res <> None;
+            cstr_loc = cd_loc;
+            cstr_attributes = cd_attributes;
+            cstr_inlined;
+          } in
+        (cd_id, cstr) :: descr_rem in
+  describe_constructors 0 0 cstrs
+
+let extension_descr path_ext ext =
+  let ty_res =
+    match ext.ext_ret_type with
+        Some type_ret -> type_ret
+      | None -> newgenconstr ext.ext_type_path ext.ext_type_params
+  in
+  let existentials, cstr_args, cstr_inlined =
+    constructor_args ext.ext_private ext.ext_args ext.ext_ret_type
+      path_ext (Record_extension path_ext)
+  in
+    { cstr_name = Path.last path_ext;
+      cstr_res = ty_res;
+      cstr_existentials = existentials;
+      cstr_args;
+      cstr_arity = List.length cstr_args;
+      cstr_tag = Cstr_extension(path_ext, cstr_args = []);
+      cstr_consts = -1;
+      cstr_nonconsts = -1;
+      cstr_private = ext.ext_private;
+      cstr_normal = -1;
+      cstr_generalized = ext.ext_ret_type <> None;
+      cstr_loc = ext.ext_loc;
+      cstr_attributes = ext.ext_attributes;
+      cstr_inlined;
+    }
+
+let none = {desc = Ttuple []; level = -1; scope = Btype.generic_level; id = -1}
+                                        (* Clearly ill-formed type *)
+let dummy_label =
+  { lbl_name = ""; lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
+    lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular;
+    lbl_private = Public;
+    lbl_loc = Location.none;
+    lbl_attributes = [];
+  }
+
+let label_descrs ty_res lbls repres priv =
+  let all_labels = Array.make (List.length lbls) dummy_label in
+  let rec describe_labels num = function
+      [] -> []
+    | l :: rest ->
+        let lbl =
+          { lbl_name = Ident.name l.ld_id;
+            lbl_res = ty_res;
+            lbl_arg = l.ld_type;
+            lbl_mut = l.ld_mutable;
+            lbl_pos = num;
+            lbl_all = all_labels;
+            lbl_repres = repres;
+            lbl_private = priv;
+            lbl_loc = l.ld_loc;
+            lbl_attributes = l.ld_attributes;
+          } in
+        all_labels.(num) <- lbl;
+        (l.ld_id, lbl) :: describe_labels (num+1) rest in
+  describe_labels 0 lbls
+
+exception Constr_not_found
+
+let rec find_constr tag num_const num_nonconst = function
+    [] ->
+      raise Constr_not_found
+  | {cd_args = Cstr_tuple []; _} as c  :: rem ->
+      if tag = Cstr_constant num_const
+      then c
+      else find_constr tag (num_const + 1) num_nonconst rem
+  | c :: rem ->
+      if tag = Cstr_block num_nonconst || tag = Cstr_unboxed
+      then c
+      else find_constr tag num_const (num_nonconst + 1) rem
+
+let find_constr_by_tag tag cstrlist =
+  find_constr tag 0 0 cstrlist
+
+let constructors_of_type ty_path decl =
+  match decl.type_kind with
+  | Type_variant cstrs -> constructor_descrs ty_path decl cstrs
+  | Type_record _ | Type_abstract | Type_open -> []
+
+let labels_of_type ty_path decl =
+  match decl.type_kind with
+  | Type_record(labels, rep) ->
+      label_descrs (newgenconstr ty_path decl.type_params)
+        labels rep decl.type_private
+  | Type_variant _ | Type_abstract | Type_open -> []
+
+(* Set row_name in Env, cf. GPR#1204/1329 *)
+let set_row_name decl path =
+  match decl.type_manifest with
+    None -> ()
+  | Some ty ->
+      let ty = repr ty in
+      match ty.desc with
+        Tvariant row when static_row row ->
+          let row = {(row_repr row) with
+                     row_name = Some (path, decl.type_params)} in
+          ty.desc <- Tvariant row
+      | _ -> ()
diff --git a/src/ocaml/typing/410+multicore/datarepr.mli b/src/ocaml/typing/410+multicore/datarepr.mli
new file mode 100644
index 00000000..30dc1f1f
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/datarepr.mli
@@ -0,0 +1,48 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Compute constructor and label descriptions from type declarations,
+   determining their representation. *)
+
+open Types
+
+val extension_descr:
+  Path.t -> extension_constructor -> constructor_description
+
+val labels_of_type:
+  Path.t -> type_declaration ->
+  (Ident.t * label_description) list
+val constructors_of_type:
+  Path.t -> type_declaration ->
+  (Ident.t * constructor_description) list
+
+
+exception Constr_not_found
+
+val find_constr_by_tag:
+  constructor_tag -> constructor_declaration list ->
+    constructor_declaration
+
+val constructor_existentials :
+    constructor_arguments -> type_expr option -> type_expr list * type_expr list
+(** Takes [cd_args] and [cd_res] from a [constructor_declaration] and
+    returns:
+    - the types of the constructor's arguments
+    - the existential variables introduced by the constructor
+ *)
+
+
+(* Set the polymorphic variant row_name field *)
+val set_row_name : type_declaration -> Path.t -> unit
diff --git a/src/ocaml/typing/410+multicore/env.ml b/src/ocaml/typing/410+multicore/env.ml
new file mode 100644
index 00000000..844e3922
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/env.ml
@@ -0,0 +1,3596 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Environment handling *)
+
+open Cmi_format
+open Misc
+open Asttypes
+open Longident
+open Path
+open Types
+open Btype
+
+open Local_store.Compiler
+
+let add_delayed_check_forward = ref (fun _ -> assert false)
+
+let value_declarations : ((string * Location.t), (unit -> unit)) Hashtbl.t ref =
+  s_table Hashtbl.create 16
+    (* This table is used to usage of value declarations.  A declaration is
+       identified with its name and location.  The callback attached to a
+       declaration is called whenever the value is used explicitly
+       (lookup_value) or implicitly (inclusion test between signatures,
+       cf Includemod.value_descriptions). *)
+
+let type_declarations = s_table Hashtbl.create 16
+let module_declarations = s_table Hashtbl.create 16
+
+type constructor_usage = Positive | Pattern | Privatize
+type constructor_usages =
+    {
+     mutable cu_positive: bool;
+     mutable cu_pattern: bool;
+     mutable cu_privatize: bool;
+    }
+
+let cu_positive cu =
+  if not cu.cu_positive then (
+    on_backtrack (fun () -> cu.cu_positive <- false);
+    cu.cu_positive <- true
+  )
+
+let cu_pattern cu =
+  if not cu.cu_pattern then (
+    on_backtrack (fun () -> cu.cu_pattern <- false);
+    cu.cu_pattern <- true
+  )
+
+let cu_privatize cu =
+  if not cu.cu_privatize then (
+    on_backtrack (fun () -> cu.cu_privatize <- false);
+    cu.cu_privatize <- true
+  )
+
+let add_constructor_usage priv cu usage =
+  match priv with
+  | Asttypes.Private -> cu_positive cu
+  | Asttypes.Public -> begin
+      match usage with
+      | Positive -> cu_positive cu
+      | Pattern -> cu_pattern cu
+      | Privatize -> cu_privatize cu
+    end
+
+let backtracking_add tbl key value =
+  on_backtrack (fun () -> Hashtbl.remove tbl key);
+  Hashtbl.add tbl key value
+
+let backtracking_set r v =
+  let v' = !r in
+  on_backtrack (fun () -> r := v');
+  r := v
+
+let constructor_usages () =
+  {cu_positive = false; cu_pattern = false; cu_privatize = false}
+
+let used_constructors :
+    (string * Location.t * string, (constructor_usage -> unit)) Hashtbl.t ref
+  = s_table Hashtbl.create 16
+
+(** Map indexed by the name of module components. *)
+module NameMap = String.Map
+
+type value_unbound_reason =
+  | Val_unbound_instance_variable
+  | Val_unbound_self
+  | Val_unbound_ancestor
+  | Val_unbound_ghost_recursive of Location.t
+
+type module_unbound_reason =
+  | Mod_unbound_illegal_recursion
+
+type summary =
+    Env_empty
+  | Env_value of summary * Ident.t * value_description
+  | Env_type of summary * Ident.t * type_declaration
+  | Env_extension of summary * Ident.t * extension_constructor
+  | Env_module of summary * Ident.t * module_presence * module_declaration
+  | Env_modtype of summary * Ident.t * modtype_declaration
+  | Env_class of summary * Ident.t * class_declaration
+  | Env_cltype of summary * Ident.t * class_type_declaration
+  | Env_open of summary * Path.t
+  | Env_functor_arg of summary * Ident.t
+  | Env_constraints of summary * type_declaration Path.Map.t
+  | Env_copy_types of summary
+  | Env_persistent of summary * Ident.t
+  | Env_value_unbound of summary * string * value_unbound_reason
+  | Env_module_unbound of summary * string * module_unbound_reason
+
+type address =
+  | Aident of Ident.t
+  | Adot of address * int
+
+module TycompTbl =
+  struct
+    (** This module is used to store components of types (i.e. labels
+        and constructors).  We keep a representation of each nested
+        "open" and the set of local bindings between each of them. *)
+
+    type 'a t = {
+      current: 'a Ident.tbl;
+      (** Local bindings since the last open. *)
+
+      opened: 'a opened option;
+      (** Symbolic representation of the last (innermost) open, if any. *)
+    }
+
+    and 'a opened = {
+      components: ('a list) NameMap.t;
+      (** Components from the opened module. We keep a list of
+          bindings for each name, as in comp_labels and
+          comp_constrs. *)
+
+      using: (string -> ('a * 'a) option -> unit) option;
+      (** A callback to be applied when a component is used from this
+          "open".  This is used to detect unused "opens".  The
+          arguments are used to detect shadowing. *)
+
+      next: 'a t;
+      (** The table before opening the module. *)
+    }
+
+    let empty = { current = Ident.empty; opened = None }
+
+    let add id x tbl =
+      {tbl with current = Ident.add id x tbl.current}
+
+    let add_open slot wrap components next =
+      let using =
+        match slot with
+        | None -> None
+        | Some f -> Some (fun s x -> f s (wrap x))
+      in
+      {
+        current = Ident.empty;
+        opened = Some {using; components; next};
+      }
+
+    let rec find_same id tbl =
+      try Ident.find_same id tbl.current
+      with Not_found as exn ->
+        begin match tbl.opened with
+        | Some {next; _} -> find_same id next
+        | None -> raise exn
+        end
+
+    let nothing = fun () -> ()
+
+    let mk_callback rest name desc using =
+      match using with
+      | None -> nothing
+      | Some f ->
+          (fun () ->
+             match rest with
+             | [] -> f name None
+             | (hidden, _) :: _ -> f name (Some (desc, hidden)))
+
+    let rec find_all ~mark name tbl =
+      List.map (fun (_id, desc) -> desc, nothing)
+        (Ident.find_all name tbl.current) @
+      match tbl.opened with
+      | None -> []
+      | Some {using; next; components} ->
+          let rest = find_all ~mark name next in
+          let using = if mark then using else None in
+          match NameMap.find name components with
+          | exception Not_found -> rest
+          | opened ->
+              List.map
+                (fun desc -> desc, mk_callback rest name desc using)
+                opened
+              @ rest
+
+    let rec fold_name f tbl acc =
+      let acc = Ident.fold_name (fun _id d -> f d) tbl.current acc in
+      match tbl.opened with
+      | Some {using = _; next; components} ->
+          acc
+          |> NameMap.fold
+            (fun _name -> List.fold_right f)
+            components
+          |> fold_name f next
+      | None ->
+          acc
+
+    let rec local_keys tbl acc =
+      let acc = Ident.fold_all (fun k _ accu -> k::accu) tbl.current acc in
+      match tbl.opened with
+      | Some o -> local_keys o.next acc
+      | None -> acc
+
+    let diff_keys is_local tbl1 tbl2 =
+      let keys2 = local_keys tbl2 [] in
+      List.filter
+        (fun id ->
+           is_local (find_same id tbl2) &&
+           try ignore (find_same id tbl1); false
+           with Not_found -> true)
+        keys2
+
+  end
+
+
+module IdTbl =
+  struct
+    (** This module is used to store all kinds of components except
+        (labels and constructors) in environments.  We keep a
+        representation of each nested "open" and the set of local
+        bindings between each of them. *)
+
+
+    type ('a, 'b) t = {
+      current: 'a Ident.tbl;
+      (** Local bindings since the last open *)
+
+      layer: ('a, 'b) layer;
+      (** Symbolic representation of the last (innermost) open, if any. *)
+    }
+
+    and ('a, 'b) layer =
+      | Open of {
+          root: Path.t;
+          (** The path of the opened module, to be prefixed in front of
+              its local names to produce a valid path in the current
+              environment. *)
+
+          components: 'b NameMap.t;
+          (** Components from the opened module. *)
+
+          using: (string -> ('a * 'a) option -> unit) option;
+          (** A callback to be applied when a component is used from this
+              "open".  This is used to detect unused "opens".  The
+              arguments are used to detect shadowing. *)
+
+          next: ('a, 'b) t;
+          (** The table before opening the module. *)
+        }
+
+      | Map of {
+          f: ('a -> 'a);
+          next: ('a, 'b) t;
+        }
+
+      | Nothing
+
+    let empty = { current = Ident.empty; layer = Nothing }
+
+    let add id x tbl =
+      {tbl with current = Ident.add id x tbl.current}
+
+    let remove id tbl =
+      {tbl with current = Ident.remove id tbl.current}
+
+    let add_open slot wrap root components next =
+      let using =
+        match slot with
+        | None -> None
+        | Some f -> Some (fun s x -> f s (wrap x))
+      in
+      {
+        current = Ident.empty;
+        layer = Open {using; root; components; next};
+      }
+
+    let map f next =
+      {
+        current = Ident.empty;
+        layer = Map {f; next}
+      }
+
+    let rec find_same id tbl =
+      try Ident.find_same id tbl.current
+      with Not_found as exn ->
+        begin match tbl.layer with
+        | Open {next; _} -> find_same id next
+        | Map {f; next} -> f (find_same id next)
+        | Nothing -> raise exn
+        end
+
+    let rec find_name wrap ~mark name tbl =
+      try
+        let (id, desc) = Ident.find_name name tbl.current in
+        Pident id, desc
+      with Not_found as exn ->
+        begin match tbl.layer with
+        | Open {using; root; next; components} ->
+            begin try
+              let descr = wrap (NameMap.find name components) in
+              let res = Pdot (root, name), descr in
+              if mark then begin match using with
+              | None -> ()
+              | Some f -> begin
+                  match find_name wrap ~mark:false name next with
+                  | exception Not_found -> f name None
+                  | _, descr' -> f name (Some (descr', descr))
+                end
+              end;
+              res
+            with Not_found ->
+              find_name wrap ~mark name next
+            end
+        | Map {f; next} ->
+            let (p, desc) =  find_name wrap ~mark name next in
+            p, f desc
+        | Nothing ->
+            raise exn
+        end
+
+    let rec find_all wrap name tbl =
+      List.map
+        (fun (id, desc) -> Pident id, desc)
+        (Ident.find_all name tbl.current) @
+      match tbl.layer with
+      | Nothing -> []
+      | Open {root; using = _; next; components} ->
+          begin try
+            let desc = wrap (NameMap.find name components) in
+            (Pdot (root, name), desc) :: find_all wrap name next
+          with Not_found ->
+            find_all wrap name next
+          end
+      | Map {f; next} ->
+          List.map (fun (p, desc) -> (p, f desc))
+            (find_all wrap name next)
+
+    let rec fold_name wrap f tbl acc =
+      let acc =
+        Ident.fold_name
+          (fun id d -> f (Ident.name id) (Pident id, d))
+          tbl.current acc
+      in
+      match tbl.layer with
+      | Open {root; using = _; next; components} ->
+          acc
+          |> NameMap.fold
+            (fun name desc -> f name (Pdot (root, name), wrap desc))
+            components
+          |> fold_name wrap f next
+      | Nothing ->
+          acc
+      | Map {f=g; next} ->
+          acc
+          |> fold_name wrap
+               (fun name (path, desc) -> f name (path, g desc))
+               next
+
+    let rec local_keys tbl acc =
+      let acc = Ident.fold_all (fun k _ accu -> k::accu) tbl.current acc in
+      match tbl.layer with
+      | Open {next; _ } | Map {next; _} -> local_keys next acc
+      | Nothing -> acc
+
+
+    let rec iter wrap f tbl =
+      Ident.iter (fun id desc -> f id (Pident id, desc)) tbl.current;
+      match tbl.layer with
+      | Open {root; using = _; next; components} ->
+          NameMap.iter
+            (fun s x ->
+               let root_scope = Path.scope root in
+              f (Ident.create_scoped ~scope:root_scope s)
+                (Pdot (root, s), wrap x))
+            components;
+          iter wrap f next
+      | Map {f=g; next} ->
+          iter wrap (fun id (path, desc) -> f id (path, g desc)) next
+      | Nothing -> ()
+
+    let diff_keys tbl1 tbl2 =
+      let keys2 = local_keys tbl2 [] in
+      List.filter
+        (fun id ->
+           try ignore (find_same id tbl1); false
+           with Not_found -> true)
+        keys2
+
+
+  end
+
+type type_descriptions =
+    constructor_description list * label_description list
+
+let in_signature_flag = 0x01
+
+type t = {
+  values: (value_entry, value_data) IdTbl.t;
+  constrs: constructor_data TycompTbl.t;
+  labels: label_data TycompTbl.t;
+  types: (type_data, type_data) IdTbl.t;
+  modules: (module_entry, module_data) IdTbl.t;
+  modtypes: (modtype_data, modtype_data) IdTbl.t;
+  classes: (class_data, class_data) IdTbl.t;
+  cltypes: (cltype_data, cltype_data) IdTbl.t;
+  functor_args: unit Ident.tbl;
+  summary: summary;
+  local_constraints: type_declaration Path.Map.t;
+  flags: int;
+  short_paths: Short_paths.t option;
+  short_paths_additions: short_paths_addition list;
+}
+
+and module_declaration_lazy =
+  (Subst.t * Subst.scoping * module_declaration, module_declaration) EnvLazy.t
+
+and module_components =
+  {
+    alerts: alerts;
+    loc: Location.t;
+    comps:
+      (components_maker,
+       (module_components_repr, module_components_failure) result)
+        EnvLazy.t;
+  }
+
+and components_maker = {
+  cm_env: t;
+  cm_freshening_subst: Subst.t option;
+  cm_prefixing_subst: Subst.t;
+  cm_path: Path.t;
+  cm_addr: address_lazy;
+  cm_mty: Types.module_type;
+}
+
+and module_components_repr =
+    Structure_comps of structure_components
+  | Functor_comps of functor_components
+
+and module_components_failure =
+  | No_components_abstract
+  | No_components_alias of Path.t
+
+and structure_components = {
+  mutable comp_values: value_data NameMap.t;
+  mutable comp_constrs: constructor_data list NameMap.t;
+  mutable comp_labels: label_data list NameMap.t;
+  mutable comp_types: type_data NameMap.t;
+  mutable comp_modules: module_data NameMap.t;
+  mutable comp_modtypes: modtype_data NameMap.t;
+  mutable comp_classes: class_data NameMap.t;
+  mutable comp_cltypes: cltype_data NameMap.t;
+}
+
+and functor_components = {
+  fcomp_arg: functor_parameter;
+  (* Formal parameter and argument signature *)
+  fcomp_res: module_type;               (* Result signature *)
+  fcomp_cache: (Path.t, module_components) Hashtbl.t;  (* For memoization *)
+  fcomp_subst_cache: (Path.t, module_type) Hashtbl.t
+}
+
+and address_unforced =
+  | Projection of { parent : address_lazy; pos : int; }
+  | ModAlias of { env : t; path : Path.t; }
+
+and address_lazy = (address_unforced, address) EnvLazy.t
+
+and value_data =
+  { vda_description : value_description;
+    vda_address : address_lazy }
+
+and value_entry =
+  | Val_bound of value_data
+  | Val_unbound of value_unbound_reason
+
+and constructor_data =
+  { cda_description : constructor_description;
+    cda_address : address_lazy option; }
+
+and label_data = label_description
+
+and type_data =
+  { tda_declaration : type_declaration;
+    tda_descriptions : type_descriptions; }
+
+and module_data =
+  { mda_declaration : module_declaration_lazy;
+    mda_components : module_components;
+    mda_address : address_lazy; }
+
+and module_entry =
+  | Mod_local of module_data
+  | Mod_persistent
+  | Mod_unbound of module_unbound_reason
+
+and modtype_data = modtype_declaration
+
+and class_data =
+  { clda_declaration : class_declaration;
+    clda_address : address_lazy }
+
+and cltype_data = class_type_declaration
+
+and short_paths_addition =
+  | Type of Ident.t * type_declaration
+  | Class_type of Ident.t * class_type_declaration
+  | Module_type of Ident.t * modtype_declaration
+  | Module of Ident.t * module_declaration * module_components
+  | Type_open of Path.t * type_data NameMap.t
+  | Class_type_open of Path.t * class_type_declaration NameMap.t
+  | Module_type_open of Path.t * modtype_declaration NameMap.t
+  | Module_open of Path.t * module_data NameMap.t
+
+let empty_structure =
+  Structure_comps {
+    comp_values = NameMap.empty;
+    comp_constrs = NameMap.empty;
+    comp_labels = NameMap.empty;
+    comp_types = NameMap.empty;
+    comp_modules = NameMap.empty; comp_modtypes = NameMap.empty;
+    comp_classes = NameMap.empty;
+    comp_cltypes = NameMap.empty }
+
+type unbound_value_hint =
+  | No_hint
+  | Missing_rec of Location.t
+
+type lookup_error =
+  | Unbound_value of Longident.t * unbound_value_hint
+  | Unbound_type of Longident.t
+  | Unbound_constructor of Longident.t
+  | Unbound_label of Longident.t
+  | Unbound_module of Longident.t
+  | Unbound_class of Longident.t
+  | Unbound_modtype of Longident.t
+  | Unbound_cltype of Longident.t
+  | Unbound_instance_variable of string
+  | Not_an_instance_variable of string
+  | Masked_instance_variable of Longident.t
+  | Masked_self_variable of Longident.t
+  | Masked_ancestor_variable of Longident.t
+  | Structure_used_as_functor of Longident.t
+  | Abstract_used_as_functor of Longident.t
+  | Functor_used_as_structure of Longident.t
+  | Abstract_used_as_structure of Longident.t
+  | Generative_used_as_applicative of Longident.t
+  | Illegal_reference_to_recursive_module
+  | Cannot_scrape_alias of Longident.t * Path.t
+
+type error =
+  | Missing_module of Location.t * Path.t * Path.t
+  | Illegal_value_name of Location.t * string
+  | Lookup_error of Location.t * t * lookup_error
+
+exception Error of error
+
+let error err = raise (Error err)
+
+let lookup_error loc env err =
+  error (Lookup_error(loc, env, err))
+
+let copy_local ~from env =
+  { env with
+    local_constraints = from.local_constraints;
+    flags = from.flags }
+
+let same_constr = ref (fun _ _ _ -> assert false)
+
+let check_well_formed_module = ref (fun _ -> assert false)
+
+(* Helper to decide whether to report an identifier shadowing
+   by some 'open'. For labels and constructors, we do not report
+   if the two elements are from the same re-exported declaration.
+
+   Later, one could also interpret some attributes on value and
+   type declarations to silence the shadowing warnings. *)
+
+let check_shadowing env = function
+  | `Constructor (Some (cda1, cda2))
+    when not (!same_constr env
+                cda1.cda_description.cstr_res
+                cda2.cda_description.cstr_res) ->
+      Some "constructor"
+  | `Label (Some (l1, l2))
+    when not (!same_constr env l1.lbl_res l2.lbl_res) ->
+      Some "label"
+  | `Value (Some _) -> Some "value"
+  | `Type (Some _) -> Some "type"
+  | `Module (Some _) | `Component (Some _) -> Some "module"
+  | `Module_type (Some _) -> Some "module type"
+  | `Class (Some _) -> Some "class"
+  | `Class_type (Some _) -> Some "class type"
+  | `Constructor _ | `Label _
+  | `Value None | `Type None | `Module None | `Module_type None
+  | `Class None | `Class_type None | `Component None ->
+      None
+
+let subst_modtype_maker (subst, scoping, md) =
+  {md with md_type = Subst.modtype scoping subst md.md_type}
+
+let empty = {
+  values = IdTbl.empty; constrs = TycompTbl.empty;
+  labels = TycompTbl.empty; types = IdTbl.empty;
+  modules = IdTbl.empty; modtypes = IdTbl.empty;
+  classes = IdTbl.empty; cltypes = IdTbl.empty;
+  summary = Env_empty; local_constraints = Path.Map.empty;
+  flags = 0;
+  functor_args = Ident.empty;
+  short_paths = None;
+  short_paths_additions = [];
+ }
+
+let in_signature b env =
+  let flags =
+    if b then env.flags lor in_signature_flag
+    else env.flags land (lnot in_signature_flag)
+  in
+  {env with flags}
+
+let is_in_signature env = env.flags land in_signature_flag <> 0
+
+let has_local_constraints env =
+  not (Path.Map.is_empty env.local_constraints)
+
+let is_ident = function
+    Pident _ -> true
+  | Pdot _ | Papply _ -> false
+
+let is_ext cda =
+  match cda.cda_description with
+  | {cstr_tag = Cstr_extension _} -> true
+  | _ -> false
+
+let is_local_ext cda =
+  match cda.cda_description with
+  | {cstr_tag = Cstr_extension(p, _)} -> is_ident p
+  | _ -> false
+
+let diff env1 env2 =
+  IdTbl.diff_keys env1.values env2.values @
+  TycompTbl.diff_keys is_local_ext env1.constrs env2.constrs @
+  IdTbl.diff_keys env1.modules env2.modules @
+  IdTbl.diff_keys env1.classes env2.classes
+
+(* Functions for use in "wrap" parameters in IdTbl *)
+let wrap_identity x = x
+let wrap_value vda = Val_bound vda
+let wrap_module mda = Mod_local mda
+
+(* Forward declarations *)
+
+let components_of_module_maker' =
+  ref ((fun _ -> assert false) :
+          components_maker ->
+            (module_components_repr, module_components_failure) result)
+
+let components_of_functor_appl' =
+  ref ((fun ~loc:_ _f _env _p1 _p2 -> assert false) :
+          loc:Location.t -> functor_components -> t ->
+            Path.t -> Path.t -> module_components)
+let check_functor_application =
+  (* to be filled by Includemod *)
+  ref ((fun ~errors:_ ~loc:_ _env _mty1 _path1 _mty2 _path2 -> assert false) :
+          errors:bool -> loc:Location.t -> t -> module_type ->
+            Path.t -> module_type -> Path.t -> unit)
+let strengthen =
+  (* to be filled with Mtype.strengthen *)
+  ref ((fun ~aliasable:_ _env _mty _path -> assert false) :
+         aliasable:bool -> t -> module_type -> Path.t -> module_type)
+
+let shorten_module_path =
+  (* to be filled with Printtyp.shorten_module_path *)
+  ref ((fun _ _ -> assert false) :
+         t -> Path.t -> Path.t)
+
+let md md_type =
+  {md_type; md_attributes=[]; md_loc=Location.none}
+
+(* Print addresses *)
+
+let rec print_address ppf = function
+  | Aident id -> Format.fprintf ppf "%s" (Ident.name id)
+  | Adot(a, pos) -> Format.fprintf ppf "%a.[%i]" print_address a pos
+
+(* The name of the compilation unit currently compiled.
+   "" if outside a compilation unit. *)
+module Current_unit_name : sig
+  val get : unit -> modname
+  val set : modname -> unit
+  val is : modname -> bool
+  val is_name_of : Ident.t -> bool
+end = struct
+  let current_unit =
+    ref ""
+  let get () =
+    !current_unit
+  let set name =
+    current_unit := name
+  let is name =
+    !current_unit = name
+  let is_name_of id =
+    is (Ident.name id)
+end
+
+let set_unit_name = Current_unit_name.set
+let get_unit_name = Current_unit_name.get
+
+let find_same_module id tbl =
+  match IdTbl.find_same id tbl with
+  | x -> x
+  | exception Not_found
+    when Ident.persistent id && not (Current_unit_name.is_name_of id) ->
+      Mod_persistent
+
+let find_name_module ~mark name tbl =
+  match IdTbl.find_name wrap_module ~mark name tbl with
+  | x -> x
+  | exception Not_found when not (Current_unit_name.is name) ->
+      let path = Pident(Ident.create_persistent name) in
+      path, Mod_persistent
+
+(* Short paths basis *)
+
+let short_paths_module_components_desc' = ref (fun _ -> assert false)
+
+let short_paths_components name pm =
+  let path = Pident (Ident.create_persistent name) in
+  lazy (!short_paths_module_components_desc' empty path pm.mda_components)
+
+exception Cmi_cache_store of module_data
+
+let add_persistent_structure id env =
+  if not (Ident.persistent id) then invalid_arg "Env.add_persistent_structure";
+  if not (Current_unit_name.is_name_of id) then
+    { env with
+      modules = IdTbl.add id Mod_persistent env.modules;
+      summary = Env_persistent (env.summary, id);
+    }
+  else
+    env
+
+let components_of_module ~alerts ~loc env fs ps path addr mty =
+  {
+    alerts;
+    loc;
+    comps = EnvLazy.create {
+      cm_env = env;
+      cm_freshening_subst = fs;
+      cm_prefixing_subst = ps;
+      cm_path = path;
+      cm_addr = addr;
+      cm_mty = mty
+    }
+  }
+
+let sign_of_cmi ~freshen { Persistent_env.Persistent_signature.cmi; cmi_cache } =
+  let name = cmi.cmi_name in
+  let sign = cmi.cmi_sign in
+  let flags = cmi.cmi_flags in
+  let id_subst = Subst.(make_loc_ghost identity) in
+  let id = Ident.create_persistent name in
+  let path = Pident id in
+  let alerts =
+    List.fold_left (fun acc -> function Alerts s -> s | _ -> acc)
+      String.Map.empty
+      flags
+  in
+  let loc = Location.none in
+  let md = md (Mty_signature sign) in
+  let mda_address = EnvLazy.create_forced (Aident id) in
+  let mda_declaration =
+    EnvLazy.create (id_subst, Subst.Make_local, md)
+  in
+  let mda_components =
+    let freshening_subst =
+      if freshen then (Some id_subst) else None
+    in
+    components_of_module ~alerts ~loc
+      empty freshening_subst id_subst
+      path mda_address (Mty_signature sign)
+  in
+  let result = {
+    mda_declaration;
+    mda_components;
+    mda_address;
+  } in
+  cmi_cache := Cmi_cache_store result;
+  result
+
+(*   let pm_signature =
+    match !cmi_cache with
+    | Cmi_cache_store pm_signature -> pm_signature
+    | _ ->
+      let sg = lazy (Subst.signature Make_local id_subst sign) in
+      cmi_cache := Cmi_cache_store sg;
+      sg
+  in *)
+
+let read_sign_of_cmi = sign_of_cmi ~freshen:true
+
+let save_sign_of_cmi = sign_of_cmi ~freshen:false
+
+let persistent_env : module_data Persistent_env.t ref =
+  s_table Persistent_env.empty ()
+
+let without_cmis f x =
+  Persistent_env.without_cmis !persistent_env f x
+
+let imports () = Persistent_env.imports !persistent_env
+
+let import_crcs ~source crcs =
+  Persistent_env.import_crcs !persistent_env ~source crcs
+
+let read_pers_mod modname filename =
+  Persistent_env.read !persistent_env
+    read_sign_of_cmi short_paths_components modname filename
+
+let find_pers_mod name =
+  Persistent_env.find !persistent_env
+    read_sign_of_cmi short_paths_components name
+
+let check_pers_mod ~loc name =
+  Persistent_env.check !persistent_env
+    read_sign_of_cmi short_paths_components ~loc name
+
+let crc_of_unit name =
+  Persistent_env.crc_of_unit !persistent_env
+    read_sign_of_cmi short_paths_components name
+
+let is_imported_opaque modname =
+  Persistent_env.is_imported_opaque !persistent_env modname
+
+let reset_declaration_caches () =
+  Hashtbl.clear !value_declarations;
+  Hashtbl.clear !type_declarations;
+  Hashtbl.clear !module_declarations;
+  Hashtbl.clear !used_constructors;
+  ()
+
+let reset_cache () =
+  Current_unit_name.set "";
+  Persistent_env.clear !persistent_env;
+  reset_declaration_caches ();
+  ()
+
+let reset_cache_toplevel () =
+  Persistent_env.clear_missing !persistent_env;
+  reset_declaration_caches ();
+  ()
+
+(* get_components *)
+
+let get_components_res c =
+  match Persistent_env.can_load_cmis !persistent_env with
+  | Persistent_env.Can_load_cmis ->
+    EnvLazy.force !components_of_module_maker' c.comps
+  | Persistent_env.Cannot_load_cmis log ->
+    EnvLazy.force_logged log !components_of_module_maker' c.comps
+
+let get_components c =
+  match get_components_res c with
+  | Error _ -> empty_structure
+  | Ok c -> c
+
+(* Module type of functor application *)
+
+let modtype_of_functor_appl fcomp p1 p2 =
+  match fcomp.fcomp_res with
+  | Mty_alias _ as mty -> mty
+  | mty ->
+      try
+        Hashtbl.find fcomp.fcomp_subst_cache p2
+      with Not_found ->
+        let scope = Path.scope (Papply(p1, p2)) in
+        let mty =
+          let subst =
+            match fcomp.fcomp_arg with
+            | Unit
+            | Named (None, _) -> Subst.identity
+            | Named (Some param, _) -> Subst.add_module param p2 Subst.identity
+          in
+          Subst.modtype (Rescope scope) subst mty
+        in
+        Hashtbl.add fcomp.fcomp_subst_cache p2 mty;
+        mty
+
+(* Lookup by identifier *)
+
+let find_ident_module id env =
+  match find_same_module id env.modules with
+  | Mod_local data -> data
+  | Mod_unbound _ -> raise Not_found
+  | Mod_persistent -> find_pers_mod (Ident.name id)
+
+let rec find_module_components path env =
+  match path with
+  | Pident id -> (find_ident_module id env).mda_components
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      (NameMap.find s sc.comp_modules).mda_components
+  | Papply(p1, p2) ->
+      let fc = find_functor_components p1 env in
+      let loc = Location.(in_file !input_name) in
+      !components_of_functor_appl' ~loc fc env p1 p2
+
+and find_structure_components path env =
+  match get_components (find_module_components path env) with
+  | Structure_comps c -> c
+  | Functor_comps _ -> raise Not_found
+
+and find_functor_components path env =
+  match get_components (find_module_components path env) with
+  | Functor_comps f -> f
+  | Structure_comps _ -> raise Not_found
+
+let find_module ~alias path env =
+  match path with
+  | Pident id ->
+      let data = find_ident_module id env in
+      EnvLazy.force subst_modtype_maker data.mda_declaration
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      let data = NameMap.find s sc.comp_modules in
+      EnvLazy.force subst_modtype_maker data.mda_declaration
+  | Papply(p1, p2) ->
+      let fc = find_functor_components p1 env in
+      if alias then md (fc.fcomp_res)
+      else md (modtype_of_functor_appl fc p1 p2)
+
+let find_value_full path env =
+  match path with
+  | Pident id -> begin
+      match IdTbl.find_same id env.values with
+      | Val_bound data -> data
+      | Val_unbound _ -> raise Not_found
+    end
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      NameMap.find s sc.comp_values
+  | Papply _ -> raise Not_found
+
+let find_type_full path env =
+  match path with
+  | Pident id -> IdTbl.find_same id env.types
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      NameMap.find s sc.comp_types
+  | Papply _ -> raise Not_found
+
+let find_modtype path env =
+  match path with
+  | Pident id -> IdTbl.find_same id env.modtypes
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      NameMap.find s sc.comp_modtypes
+  | Papply _ -> raise Not_found
+
+let find_class_full path env =
+  match path with
+  | Pident id -> IdTbl.find_same id env.classes
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      NameMap.find s sc.comp_classes
+  | Papply _ -> raise Not_found
+
+let find_cltype path env =
+  match path with
+  | Pident id -> IdTbl.find_same id env.cltypes
+  | Pdot(p, s) ->
+      let sc = find_structure_components p env in
+      NameMap.find s sc.comp_cltypes
+  | Papply _ -> raise Not_found
+
+let find_value path env =
+  (find_value_full path env).vda_description
+
+let find_class path env =
+  (find_class_full path env).clda_declaration
+
+let find_ident_constructor id env =
+  (TycompTbl.find_same id env.constrs).cda_description
+
+let find_ident_label id env =
+  TycompTbl.find_same id env.labels
+
+let type_of_cstr path = function
+  | {cstr_inlined = Some decl; _} ->
+      let labels =
+        List.map snd (Datarepr.labels_of_type path decl)
+      in
+      { tda_declaration = decl; tda_descriptions = ([], labels) }
+  | _ ->
+      assert false
+
+let find_type_full path env =
+  match Path.constructor_typath path with
+  | Regular p -> begin
+      match Path.Map.find p env.local_constraints with
+      | decl ->
+          { tda_declaration = decl; tda_descriptions = [], [] }
+      | exception Not_found -> find_type_full p env
+    end
+  | Cstr (ty_path, s) ->
+      let tda =
+        try find_type_full ty_path env
+        with Not_found -> assert false
+      in
+      let (cstrs, _) = tda.tda_descriptions in
+      let cstr =
+        try List.find (fun cstr -> cstr.cstr_name = s) cstrs
+        with Not_found -> assert false
+      in
+      type_of_cstr path cstr
+  | LocalExt id ->
+      let cstr =
+        try (TycompTbl.find_same id env.constrs).cda_description
+        with Not_found -> assert false
+      in
+      type_of_cstr path cstr
+  | Ext (mod_path, s) ->
+      let comps =
+        try find_structure_components mod_path env
+        with Not_found -> assert false
+      in
+      let cstrs =
+        try NameMap.find s comps.comp_constrs
+        with Not_found -> assert false
+      in
+      let exts = List.filter is_ext cstrs in
+      match exts with
+      | [cda] -> type_of_cstr path cda.cda_description
+      | _ -> assert false
+
+let find_type p env =
+  (find_type_full p env).tda_declaration
+let find_type_descrs p env =
+  (find_type_full p env).tda_descriptions
+
+let rec find_module_address path env =
+  match path with
+  | Pident id -> get_address (find_ident_module id env).mda_address
+  | Pdot(p, s) ->
+      let c = find_structure_components p env in
+      get_address (NameMap.find s c.comp_modules).mda_address
+  | Papply _ -> raise Not_found
+
+and force_address = function
+  | Projection { parent; pos } -> Adot(get_address parent, pos)
+  | ModAlias { env; path } -> find_module_address path env
+
+and get_address a =
+  EnvLazy.force force_address a
+
+let find_value_address path env =
+  get_address (find_value_full path env).vda_address
+
+let find_class_address path env =
+  get_address (find_class_full path env).clda_address
+
+let rec get_constrs_address = function
+  | [] -> raise Not_found
+  | cda :: rest ->
+    match cda.cda_address with
+    | None -> get_constrs_address rest
+    | Some a -> get_address a
+
+let find_constructor_address path env =
+  match path with
+  | Pident id -> begin
+      let cda = TycompTbl.find_same id env.constrs in
+      match cda.cda_address with
+      | None -> raise Not_found
+      | Some addr -> get_address addr
+    end
+  | Pdot(p, s) ->
+      let c = find_structure_components p env in
+      get_constrs_address (NameMap.find s c.comp_constrs)
+  | Papply _ ->
+      raise Not_found
+
+let find_hash_type path env =
+  match path with
+  | Pident id ->
+      let name = "#" ^ Ident.name id in
+      let _, tda =
+        IdTbl.find_name wrap_identity ~mark:false name env.types
+      in
+      tda.tda_declaration
+  | Pdot(p, s) ->
+      let c = find_structure_components p env in
+      let name = "#" ^ s in
+      let tda = NameMap.find name c.comp_types in
+      tda.tda_declaration
+  | Papply _ ->
+      raise Not_found
+
+let required_globals = s_ref []
+let reset_required_globals () = required_globals := []
+let get_required_globals () = !required_globals
+let add_required_global id =
+  if Ident.global id && not !Clflags.transparent_modules
+  && not (List.exists (Ident.same id) !required_globals)
+  then required_globals := id :: !required_globals
+
+let rec normalize_module_path lax env = function
+  | Pident id as path when lax && Ident.persistent id ->
+      path (* fast path (avoids lookup) *)
+  | Pdot (p, s) as path ->
+      let p' = normalize_module_path lax env p in
+      if p == p' then expand_module_path lax env path
+      else expand_module_path lax env (Pdot(p', s))
+  | Papply (p1, p2) as path ->
+      let p1' = normalize_module_path lax env p1 in
+      let p2' = normalize_module_path true env p2 in
+      if p1 == p1' && p2 == p2' then expand_module_path lax env path
+      else expand_module_path lax env (Papply(p1', p2'))
+  | Pident _ as path ->
+      expand_module_path lax env path
+
+and expand_module_path lax env path =
+  try match find_module ~alias:true path env with
+    {md_type=Mty_alias path1} ->
+      let path' = normalize_module_path lax env path1 in
+      if lax || !Clflags.transparent_modules then path' else
+      let id = Path.head path in
+      if Ident.global id && not (Ident.same id (Path.head path'))
+      then add_required_global id;
+      path'
+  | _ -> path
+  with Not_found when lax
+  || (match path with Pident id -> not (Ident.persistent id) | _ -> true) ->
+      path
+
+let normalize_module_path oloc env path =
+  try normalize_module_path (oloc = None) env path
+  with Not_found ->
+    match oloc with None -> assert false
+    | Some loc ->
+        error (Missing_module(loc, path,
+                              normalize_module_path true env path))
+
+let normalize_path_prefix oloc env path =
+  match path with
+    Pdot(p, s) ->
+      let p2 = normalize_module_path oloc env p in
+      if p == p2 then path else Pdot(p2, s)
+  | Pident _ ->
+      path
+  | Papply _ ->
+      assert false
+
+let normalize_type_path oloc env path =
+  (* Inlined version of Path.is_constructor_typath:
+     constructor type paths (i.e. path pointing to an inline
+     record argument of a constructpr) are built as a regular
+     type path followed by a capitalized constructor name. *)
+  match path with
+  | Pident _ ->
+      path
+  | Pdot(p, s) ->
+      let p2 =
+        if Path.is_uident s && not (Path.is_uident (Path.last p)) then
+          (* Cstr M.t.C *)
+          normalize_path_prefix oloc env p
+        else
+          (* Regular M.t, Ext M.C *)
+          normalize_module_path oloc env p
+      in
+      if p == p2 then path else Pdot (p2, s)
+  | Papply _ ->
+      assert false
+
+let find_module path env =
+  find_module ~alias:false path env
+
+(* Find the manifest type associated to a type when appropriate:
+   - the type should be public or should have a private row,
+   - the type should have an associated manifest type. *)
+let find_type_expansion path env =
+  let decl = find_type path env in
+  match decl.type_manifest with
+  | Some body when decl.type_private = Public
+              || decl.type_kind <> Type_abstract
+              || Btype.has_constr_row body ->
+      (decl.type_params, body, decl.type_expansion_scope)
+  (* The manifest type of Private abstract data types without
+     private row are still considered unknown to the type system.
+     Hence, this case is caught by the following clause that also handles
+     purely abstract data types without manifest type definition. *)
+  | _ -> raise Not_found
+
+(* Find the manifest type information associated to a type, i.e.
+   the necessary information for the compiler's type-based optimisations.
+   In particular, the manifest type associated to a private abstract type
+   is revealed for the sake of compiler's type-based optimisations. *)
+let find_type_expansion_opt path env =
+  let decl = find_type path env in
+  match decl.type_manifest with
+  (* The manifest type of Private abstract data types can still get
+     an approximation using their manifest type. *)
+  | Some body ->
+      (decl.type_params, body, decl.type_expansion_scope)
+  | _ -> raise Not_found
+
+let find_modtype_expansion path env =
+  match (find_modtype path env).mtd_type with
+  | None -> raise Not_found
+  | Some mty -> mty
+
+let rec is_functor_arg path env =
+  match path with
+    Pident id ->
+      begin try Ident.find_same id env.functor_args; true
+      with Not_found -> false
+      end
+  | Pdot (p, _s) -> is_functor_arg p env
+  | Papply _ -> true
+
+(* Copying types associated with values *)
+
+let make_copy_of_types env0 =
+  let memo = Hashtbl.create 16 in
+  let copy t =
+    try
+      Hashtbl.find memo t.id
+    with Not_found ->
+      let t2 = Subst.type_expr Subst.identity t in
+      Hashtbl.add memo t.id t2;
+      t2
+  in
+  let f = function
+    | Val_unbound _ as entry -> entry
+    | Val_bound vda ->
+        let desc = vda.vda_description in
+        let desc = { desc with val_type = copy desc.val_type } in
+        Val_bound { vda with vda_description = desc }
+  in
+  let values =
+    IdTbl.map f env0.values
+  in
+  (fun env ->
+     if env.values != env0.values then fatal_error "Env.make_copy_of_types";
+     {env with values; summary = Env_copy_types env.summary}
+  )
+
+(* Helper to handle optional substitutions. *)
+
+let may_subst subst_f sub x =
+  match sub with
+  | None -> x
+  | Some sub -> subst_f sub x
+
+(* Iter on an environment (ignoring the body of functors and
+   not yet evaluated structures) *)
+
+type iter_cont = unit -> unit
+let iter_env_cont = ref []
+
+let rec scrape_alias_for_visit env (sub : Subst.t option) mty =
+  match mty with
+  | Mty_alias path ->
+      begin match may_subst Subst.module_path sub path with
+      | Pident id
+        when Ident.persistent id
+          && not (Persistent_env.looked_up !persistent_env (Ident.name id)) ->
+          false
+      | path -> (* PR#6600: find_module may raise Not_found *)
+          try scrape_alias_for_visit env sub (find_module path env).md_type
+          with Not_found -> false
+      end
+  | _ -> true
+
+let iter_env wrap proj1 proj2 f env () =
+  IdTbl.iter wrap (fun id x -> f (Pident id) x) (proj1 env);
+  let rec iter_components path path' mcomps =
+    let cont () =
+      let visit =
+        match EnvLazy.get_arg mcomps.comps with
+        | None -> true
+        | Some { cm_mty; cm_freshening_subst; _ } ->
+            scrape_alias_for_visit env cm_freshening_subst cm_mty
+      in
+      if not visit then () else
+      match get_components mcomps with
+        Structure_comps comps ->
+          NameMap.iter
+            (fun s d -> f (Pdot (path, s)) (Pdot (path', s), d))
+            (proj2 comps);
+          NameMap.iter
+            (fun s mda ->
+              iter_components
+                (Pdot (path, s)) (Pdot (path', s)) mda.mda_components)
+            comps.comp_modules
+      | Functor_comps _ -> ()
+    in iter_env_cont := (path, cont) :: !iter_env_cont
+  in
+  IdTbl.iter wrap_module
+    (fun id (path, entry) ->
+       match entry with
+       | Mod_unbound _ -> ()
+       | Mod_local data ->
+           iter_components (Pident id) path data.mda_components
+       | Mod_persistent ->
+           let modname = Ident.name id in
+           match Persistent_env.find_in_cache !persistent_env modname with
+           | None -> ()
+           | Some data ->
+               iter_components (Pident id) path data.mda_components)
+    env.modules
+
+let run_iter_cont l =
+  iter_env_cont := [];
+  List.iter (fun c -> c ()) l;
+  let cont = List.rev !iter_env_cont in
+  iter_env_cont := [];
+  cont
+
+let iter_types f =
+  iter_env wrap_identity (fun env -> env.types) (fun sc -> sc.comp_types)
+    (fun p1 (p2, tda) -> f p1 (p2, tda.tda_declaration))
+
+let same_types env1 env2 =
+  env1.types == env2.types && env1.modules == env2.modules
+
+let used_persistent () =
+  Persistent_env.fold !persistent_env
+    (fun s _m r -> Concr.add s r)
+    Concr.empty
+
+let find_all_comps wrap proj s (p, mda) =
+  match get_components mda.mda_components with
+    Functor_comps _ -> []
+  | Structure_comps comps ->
+      try
+        let c = NameMap.find s (proj comps) in
+        [Pdot(p,s), wrap c]
+      with Not_found -> []
+
+let rec find_shadowed_comps path env =
+  match path with
+  | Pident id ->
+      List.filter_map
+        (fun (p, data) ->
+           match data with
+           | Mod_local x -> Some (p, x)
+           | Mod_unbound _ | Mod_persistent -> None)
+        (IdTbl.find_all wrap_module (Ident.name id) env.modules)
+  | Pdot (p, s) ->
+      let l = find_shadowed_comps p env in
+      let l' =
+        List.map
+          (find_all_comps wrap_identity
+             (fun comps -> comps.comp_modules) s) l
+      in
+      List.flatten l'
+  | Papply _ -> []
+
+let find_shadowed wrap proj1 proj2 path env =
+  match path with
+    Pident id ->
+      IdTbl.find_all wrap (Ident.name id) (proj1 env)
+  | Pdot (p, s) ->
+      let l = find_shadowed_comps p env in
+      let l' = List.map (find_all_comps wrap proj2 s) l in
+      List.flatten l'
+  | Papply _ -> []
+
+let find_shadowed_types path env =
+  List.map fst
+    (find_shadowed wrap_identity
+       (fun env -> env.types) (fun comps -> comps.comp_types) path env)
+
+(* Expand manifest module type names at the top of the given module type *)
+
+let rec scrape_alias env sub ?path mty =
+  match mty, path with
+    Mty_ident _, _ ->
+      let p =
+        match may_subst (Subst.modtype Keep) sub mty with
+        | Mty_ident p -> p
+        | _ -> assert false (* only [Mty_ident]s in [sub] *)
+      in
+      begin try
+        scrape_alias env sub (find_modtype_expansion p env) ?path
+      with Not_found ->
+        mty
+      end
+  | Mty_alias path, _ ->
+      let path = may_subst Subst.module_path sub path in
+      begin try
+        scrape_alias env sub (find_module path env).md_type ~path
+      with Not_found ->
+        (*Location.prerr_warning Location.none
+          (Warnings.No_cmi_file (Path.name path));*)
+        mty
+      end
+  | mty, Some path ->
+      !strengthen ~aliasable:true env mty path
+  | _ -> mty
+
+(* Given a signature and a root path, prefix all idents in the signature
+   by the root path and build the corresponding substitution. *)
+
+let prefix_idents root freshening_sub prefixing_sub sg =
+  let refresh id add_fn = function
+    | None -> id, None
+    | Some sub ->
+      let id' = Ident.rename id in
+      id', Some (add_fn id (Pident id') sub)
+  in
+  let rec prefix_idents root items_and_paths freshening_sub prefixing_sub =
+    function
+    | [] -> (List.rev items_and_paths, freshening_sub, prefixing_sub)
+    | Sig_value(id, _, _) as item :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      prefix_idents root
+        ((item, p) :: items_and_paths) freshening_sub prefixing_sub rem
+    | Sig_type(id, td, rs, vis) :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub = refresh id Subst.add_type freshening_sub in
+      prefix_idents root
+        ((Sig_type(id', td, rs, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_type id' p prefixing_sub)
+        rem
+    | Sig_typext(id, ec, es, vis) :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub = refresh id Subst.add_type freshening_sub in
+      (* we extend the substitution in case of an inlined record *)
+      prefix_idents root
+        ((Sig_typext(id', ec, es, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_type id' p prefixing_sub)
+        rem
+    | Sig_module(id, pres, md, rs, vis) :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub = refresh id Subst.add_module freshening_sub in
+      prefix_idents root
+        ((Sig_module(id', pres, md, rs, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_module id' p prefixing_sub)
+        rem
+    | Sig_modtype(id, mtd, vis) :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub =
+        refresh id (fun i p s -> Subst.add_modtype i (Mty_ident p) s)
+          freshening_sub
+      in
+      prefix_idents root
+        ((Sig_modtype(id', mtd, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_modtype id' (Mty_ident p) prefixing_sub)
+        rem
+    | Sig_class(id, cd, rs, vis) :: rem ->
+      (* pretend this is a type, cf. PR#6650 *)
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub = refresh id Subst.add_type freshening_sub in
+      prefix_idents root
+        ((Sig_class(id', cd, rs, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_type id' p prefixing_sub)
+        rem
+    | Sig_class_type(id, ctd, rs, vis) :: rem ->
+      let p = Pdot(root, Ident.name id) in
+      let id', freshening_sub = refresh id Subst.add_type freshening_sub in
+      prefix_idents root
+        ((Sig_class_type(id', ctd, rs, vis), p) :: items_and_paths)
+        freshening_sub
+        (Subst.add_type id' p prefixing_sub)
+        rem
+  in
+  prefix_idents root [] freshening_sub prefixing_sub sg
+
+(* Short path additions *)
+
+let short_paths_type predef id decl old =
+  if not predef && !Clflags.real_paths then old
+  else Type(id, decl) :: old
+
+let short_paths_type_open path decls old =
+  if !Clflags.real_paths then old
+  else Type_open(path, decls) :: old
+
+let unbound_class = Path.Pident (Ident.create_local "*undef*")
+
+let is_dummy_class decl =
+  Path.same decl.clty_path unbound_class
+
+let short_paths_class_type id decl old =
+  if !Clflags.real_paths || is_dummy_class decl then old
+  else Class_type(id, decl) :: old
+
+let short_paths_class_type_open path decls old =
+  if !Clflags.real_paths then old
+  else Class_type_open(path, decls) :: old
+
+let short_paths_module_type id decl old =
+  if !Clflags.real_paths then old
+  else Module_type(id, decl) :: old
+
+let short_paths_module_type_open path decls old =
+  if !Clflags.real_paths then old
+  else Module_type_open(path, decls) :: old
+
+let short_paths_module id decl comps old =
+  if !Clflags.real_paths then old
+  else Module(id, decl, comps) :: old
+
+let short_paths_module_open path comps old =
+  if !Clflags.real_paths then old
+  else Module_open(path, comps) :: old
+
+(* Compute structure descriptions *)
+
+let add_to_tbl id decl tbl =
+  let decls = try NameMap.find id tbl with Not_found -> [] in
+  NameMap.add id (decl :: decls) tbl
+
+let value_declaration_address (_ : t) id decl =
+  match decl.val_kind with
+  | Val_prim _ -> EnvLazy.create_failed Not_found
+  | _ -> EnvLazy.create_forced (Aident id)
+
+let extension_declaration_address (_ : t) id (_ : extension_constructor) =
+  EnvLazy.create_forced (Aident id)
+
+let class_declaration_address (_ : t) id (_ : class_declaration) =
+  EnvLazy.create_forced (Aident id)
+
+let module_declaration_address env id presence md =
+  match presence with
+  | Mp_absent -> begin
+      match md.md_type with
+      | Mty_alias path -> EnvLazy.create (ModAlias {env; path})
+      | _ -> assert false
+    end
+  | Mp_present ->
+      EnvLazy.create_forced (Aident id)
+
+let rec components_of_module_maker
+          {cm_env; cm_freshening_subst; cm_prefixing_subst;
+           cm_path; cm_addr; cm_mty} : _ result =
+  match scrape_alias cm_env cm_freshening_subst cm_mty with
+    Mty_signature sg ->
+      let c =
+        { comp_values = NameMap.empty;
+          comp_constrs = NameMap.empty;
+          comp_labels = NameMap.empty; comp_types = NameMap.empty;
+          comp_modules = NameMap.empty; comp_modtypes = NameMap.empty;
+          comp_classes = NameMap.empty; comp_cltypes = NameMap.empty }
+      in
+      let items_and_paths, freshening_sub, prefixing_sub =
+        prefix_idents cm_path cm_freshening_subst cm_prefixing_subst sg
+      in
+      let env = ref cm_env in
+      let pos = ref 0 in
+      let next_address () =
+        let addr : address_unforced =
+          Projection { parent = cm_addr; pos = !pos }
+        in
+        incr pos;
+        EnvLazy.create addr
+      in
+      let sub = may_subst Subst.compose freshening_sub prefixing_sub in
+      List.iter (fun (item, path) ->
+        match item with
+          Sig_value(id, decl, _) ->
+            let decl' = Subst.value_description sub decl in
+            let addr =
+              match decl.val_kind with
+              | Val_prim _ -> EnvLazy.create_failed Not_found
+              | _ -> next_address ()
+            in
+            let vda = { vda_description = decl'; vda_address = addr } in
+            c.comp_values <- NameMap.add (Ident.name id) vda c.comp_values;
+        | Sig_type(id, decl, _, _) ->
+            let fresh_decl =
+              may_subst Subst.type_declaration freshening_sub decl
+            in
+            let final_decl = Subst.type_declaration prefixing_sub fresh_decl in
+            Datarepr.set_row_name final_decl
+              (Subst.type_path prefixing_sub (Path.Pident id));
+            let constructors =
+              List.map snd (Datarepr.constructors_of_type path final_decl) in
+            let labels =
+              List.map snd (Datarepr.labels_of_type path final_decl) in
+            let tda =
+              { tda_declaration = final_decl;
+                tda_descriptions = (constructors, labels); }
+            in
+            c.comp_types <- NameMap.add (Ident.name id) tda c.comp_types;
+            List.iter
+              (fun descr ->
+                 let cda = { cda_description = descr; cda_address = None } in
+                 c.comp_constrs <-
+                   add_to_tbl descr.cstr_name cda c.comp_constrs)
+              constructors;
+            List.iter
+              (fun descr ->
+                c.comp_labels <-
+                  add_to_tbl descr.lbl_name descr c.comp_labels)
+              labels;
+            env := store_type_infos id fresh_decl !env
+        | Sig_typext(id, ext, _, _) ->
+            let ext' = Subst.extension_constructor sub ext in
+            let descr = Datarepr.extension_descr path ext' in
+            let addr = next_address () in
+            let cda = { cda_description = descr; cda_address = Some addr } in
+            c.comp_constrs <- add_to_tbl (Ident.name id) cda c.comp_constrs
+        | Sig_module(id, pres, md, _, _) ->
+            let md' =
+              (* The prefixed items get the same scope as [cm_path], which is
+                 the prefix. *)
+              EnvLazy.create (sub, Subst.Rescope (Path.scope cm_path), md)
+            in
+            let addr =
+              match pres with
+              | Mp_absent -> begin
+                  match md.md_type with
+                  | Mty_alias p ->
+                      let path = may_subst Subst.module_path freshening_sub p in
+                      EnvLazy.create (ModAlias {env = !env; path})
+                  | _ -> assert false
+                end
+              | Mp_present -> next_address ()
+            in
+            let alerts =
+              Builtin_attributes.alerts_of_attrs md.md_attributes
+            in
+            let comps =
+              components_of_module ~alerts ~loc:md.md_loc !env freshening_sub
+                prefixing_sub path addr md.md_type
+            in
+            let mda =
+              { mda_declaration = md';
+                mda_components = comps;
+                mda_address = addr }
+            in
+            c.comp_modules <-
+              NameMap.add (Ident.name id) mda c.comp_modules;
+            env :=
+              store_module ~freshening_sub ~check:None id addr pres md !env
+        | Sig_modtype(id, decl, _) ->
+            let fresh_decl =
+              (* the fresh_decl is only going in the local temporary env, and
+                 shouldn't be used for anything. So we make the items local. *)
+              may_subst (Subst.modtype_declaration Make_local) freshening_sub
+                decl
+            in
+            let final_decl =
+              (* The prefixed items get the same scope as [cm_path], which is
+                 the prefix. *)
+              Subst.modtype_declaration (Rescope (Path.scope cm_path))
+                prefixing_sub fresh_decl
+            in
+            c.comp_modtypes <-
+              NameMap.add (Ident.name id) final_decl c.comp_modtypes;
+            env := store_modtype id fresh_decl !env
+        | Sig_class(id, decl, _, _) ->
+            let decl' = Subst.class_declaration sub decl in
+            let addr = next_address () in
+            let clda = { clda_declaration = decl'; clda_address = addr } in
+            c.comp_classes <- NameMap.add (Ident.name id) clda c.comp_classes
+        | Sig_class_type(id, decl, _, _) ->
+            let decl' = Subst.cltype_declaration sub decl in
+            c.comp_cltypes <-
+              NameMap.add (Ident.name id) decl' c.comp_cltypes)
+        items_and_paths;
+        Ok (Structure_comps c)
+  | Mty_functor(arg, ty_res) ->
+      let sub =
+        may_subst Subst.compose cm_freshening_subst cm_prefixing_subst
+      in
+      let scoping = Subst.Rescope (Path.scope cm_path) in
+        Ok (Functor_comps {
+          (* fcomp_arg and fcomp_res must be prefixed eagerly, because
+             they are interpreted in the outer environment *)
+          fcomp_arg =
+            (match arg with
+            | Unit -> Unit
+            | Named (param, ty_arg) ->
+              Named (param, Subst.modtype scoping sub ty_arg));
+          fcomp_res = Subst.modtype scoping sub ty_res;
+          fcomp_cache = Hashtbl.create 17;
+          fcomp_subst_cache = Hashtbl.create 17 })
+  | Mty_ident _ -> Error No_components_abstract
+  | Mty_alias p -> Error (No_components_alias p)
+
+(* Insertion of bindings by identifier + path *)
+
+and check_usage loc id warn tbl =
+  if not loc.Location.loc_ghost && Warnings.is_active (warn "") then begin
+    let name = Ident.name id in
+    let key = (name, loc) in
+    if Hashtbl.mem tbl key then ()
+    else let used = ref false in
+    backtracking_add tbl key (fun () -> used := true);
+    if not (name = "" || name.[0] = '_' || name.[0] = '#')
+    then
+      !add_delayed_check_forward
+        (fun () -> if not !used then Location.prerr_warning loc (warn name))
+  end;
+
+and check_value_name name loc =
+  (* Note: we could also check here general validity of the
+     identifier, to protect against bad identifiers forged by -pp or
+     -ppx preprocessors. *)
+  if String.length name > 0 && (name.[0] = '#') then
+    for i = 1 to String.length name - 1 do
+      if name.[i] = '#' then
+        error (Illegal_value_name(loc, name))
+    done
+
+and store_value ?check id addr decl env =
+  check_value_name (Ident.name id) decl.val_loc;
+  Option.iter (fun f -> check_usage decl.val_loc id f !value_declarations) check;
+  let vda = { vda_description = decl; vda_address = addr } in
+  { env with
+    values = IdTbl.add id (Val_bound vda) env.values;
+    summary = Env_value(env.summary, id, decl) }
+
+and store_type ~check ~predef id info env =
+  let loc = info.type_loc in
+  if check then
+    check_usage loc id (fun s -> Warnings.Unused_type_declaration s)
+      !type_declarations;
+  let path = Pident id in
+  let constructors = Datarepr.constructors_of_type path info in
+  let labels = Datarepr.labels_of_type path info in
+  let descrs = (List.map snd constructors, List.map snd labels) in
+  let tda = { tda_declaration = info; tda_descriptions = descrs } in
+  if check && not loc.Location.loc_ghost &&
+    Warnings.is_active (Warnings.Unused_constructor ("", false, false))
+  then begin
+    let ty_name = Ident.name id in
+    let priv = info.type_private in
+    List.iter
+      begin fun (_, cstr) ->
+        let name = cstr.cstr_name in
+        let loc = cstr.cstr_loc in
+        let k = (ty_name, loc, name) in
+        if not (Hashtbl.mem !used_constructors k) then
+          let used = constructor_usages () in
+          backtracking_add !used_constructors k (add_constructor_usage priv used);
+          if not (ty_name = "" || ty_name.[0] = '_')
+          then !add_delayed_check_forward
+              (fun () ->
+                if not (is_in_signature env) && not used.cu_positive then
+                  Location.prerr_warning loc
+                    (Warnings.Unused_constructor
+                       (name, used.cu_pattern, used.cu_privatize)))
+      end
+      constructors
+  end;
+  { env with
+    constrs =
+      List.fold_right
+        (fun (id, descr) constrs ->
+           let cda = { cda_description = descr; cda_address = None } in
+           TycompTbl.add id cda constrs)
+        constructors env.constrs;
+    labels =
+      List.fold_right
+        (fun (id, descr) labels -> TycompTbl.add id descr labels)
+        labels env.labels;
+    types = IdTbl.add id tda env.types;
+    summary = Env_type(env.summary, id, info);
+    short_paths_additions =
+      short_paths_type predef id info env.short_paths_additions; }
+
+and store_type_infos id info env =
+  (* Simplified version of store_type that doesn't compute and store
+     constructor and label infos, but simply record the arity and
+     manifest-ness of the type.  Used in components_of_module to
+     keep track of type abbreviations (e.g. type t = float) in the
+     computation of label representations. *)
+  let tda = { tda_declaration = info; tda_descriptions = [], [] } in
+  { env with
+    types = IdTbl.add id tda env.types;
+    summary = Env_type(env.summary, id, info);
+    short_paths_additions =
+      short_paths_type false id info env.short_paths_additions; }
+
+and store_extension ~check id addr ext env =
+  let loc = ext.ext_loc in
+  let cstr = Datarepr.extension_descr (Pident id) ext in
+  let cda = { cda_description = cstr; cda_address = Some addr } in
+  if check && not loc.Location.loc_ghost &&
+    Warnings.is_active (Warnings.Unused_extension ("", false, false, false))
+  then begin
+    let priv = ext.ext_private in
+    let is_exception = Path.same ext.ext_type_path Predef.path_exn in
+    let ty_name = Path.last ext.ext_type_path in
+    let name = cstr.cstr_name in
+    let k = (ty_name, loc, name) in
+    if not (Hashtbl.mem !used_constructors k) then begin
+      let used = constructor_usages () in
+      backtracking_add !used_constructors k (add_constructor_usage priv used);
+      !add_delayed_check_forward
+        (fun () ->
+          if not (is_in_signature env) && not used.cu_positive then
+            Location.prerr_warning loc
+              (Warnings.Unused_extension
+                 (name, is_exception, used.cu_pattern, used.cu_privatize)
+              )
+        )
+    end;
+  end;
+  { env with
+    constrs = TycompTbl.add id cda env.constrs;
+    summary = Env_extension(env.summary, id, ext) }
+
+and store_module ~check ~freshening_sub id addr presence md env =
+  let loc = md.md_loc in
+  Option.iter (fun f -> check_usage loc id f !module_declarations) check;
+  let alerts = Builtin_attributes.alerts_of_attrs md.md_attributes in
+  let module_decl_lazy =
+    match freshening_sub with
+    | None -> EnvLazy.create_forced md
+    | Some s -> EnvLazy.create (s, Subst.Rescope (Ident.scope id), md)
+  in
+  let comps =
+    components_of_module ~alerts ~loc:md.md_loc
+      env freshening_sub Subst.identity (Pident id) addr md.md_type
+  in
+  let mda =
+    { mda_declaration = module_decl_lazy;
+      mda_components = comps;
+      mda_address = addr }
+  in
+  { env with
+    modules = IdTbl.add id (Mod_local mda) env.modules;
+    summary = Env_module(env.summary, id, presence, md);
+    short_paths_additions =
+      short_paths_module id md comps env.short_paths_additions; }
+
+and store_modtype id info env =
+  { env with
+    modtypes = IdTbl.add id info env.modtypes;
+    summary = Env_modtype(env.summary, id, info);
+    short_paths_additions =
+      short_paths_module_type id info env.short_paths_additions; }
+
+and store_class id addr desc env =
+  let clda = { clda_declaration = desc; clda_address = addr } in
+  { env with
+    classes = IdTbl.add id clda env.classes;
+    summary = Env_class(env.summary, id, desc) }
+
+and store_cltype id desc env =
+  { env with
+    cltypes = IdTbl.add id desc env.cltypes;
+    summary = Env_cltype(env.summary, id, desc);
+    short_paths_additions =
+      short_paths_class_type id desc env.short_paths_additions; }
+
+let scrape_alias env mty = scrape_alias env None mty
+
+(* Compute the components of a functor application in a path. *)
+
+let components_of_functor_appl ~loc f env p1 p2 =
+  try
+    Hashtbl.find f.fcomp_cache p2
+  with Not_found ->
+    let p = Papply(p1, p2) in
+    let sub =
+      match f.fcomp_arg with
+      | Unit
+      | Named (None, _) -> Subst.identity
+      | Named (Some param, _) -> Subst.add_module param p2 Subst.identity
+    in
+    (* we have to apply eagerly instead of passing sub to [components_of_module]
+       because of the call to [check_well_formed_module]. *)
+    let mty = Subst.modtype (Rescope (Path.scope p)) sub f.fcomp_res in
+    let addr = EnvLazy.create_failed Not_found in
+    !check_well_formed_module env loc
+      ("the signature of " ^ Path.name p) mty;
+    let comps =
+      components_of_module ~alerts:String.Map.empty
+        ~loc:Location.none
+        (*???*)
+        env None Subst.identity p addr mty
+    in
+    Hashtbl.add f.fcomp_cache p2 comps;
+    comps
+
+(* Define forward functions *)
+
+let _ =
+  components_of_functor_appl' := components_of_functor_appl;
+  components_of_module_maker' := components_of_module_maker
+
+(* Insertion of bindings by identifier *)
+
+let add_functor_arg id env =
+  {env with
+   functor_args = Ident.add id () env.functor_args;
+   summary = Env_functor_arg (env.summary, id)}
+
+let add_value ?check id desc env =
+  let addr = value_declaration_address env id desc in
+  store_value ?check id addr desc env
+
+let add_type ~check ~predef id info env =
+  store_type ~check ~predef id info env
+
+and add_extension ~check id ext env =
+  let addr = extension_declaration_address env id ext in
+  store_extension ~check id addr ext env
+
+and add_module_declaration ?(arg=false) ~check id presence md env =
+  let check =
+    if not check then
+      None
+    else if arg && is_in_signature env then
+      Some (fun s -> Warnings.Unused_functor_parameter s)
+    else
+      Some (fun s -> Warnings.Unused_module s)
+  in
+  let addr = module_declaration_address env id presence md in
+  let env = store_module ~freshening_sub:None ~check id addr presence md env in
+  if arg then add_functor_arg id env else env
+
+and add_modtype id info env =
+  store_modtype id info env
+
+and add_class id ty env =
+  let addr = class_declaration_address env id ty in
+  store_class id addr ty env
+
+and add_cltype id ty env =
+  store_cltype id ty env
+
+let add_module ?arg id presence mty env =
+  add_module_declaration ~check:false ?arg id presence (md mty) env
+
+let add_local_type path info env =
+  { env with
+    local_constraints = Path.Map.add path info env.local_constraints }
+
+
+(* Insertion of bindings by name *)
+
+let enter_value ?check name desc env =
+  let id = Ident.create_local name in
+  let addr = value_declaration_address env id desc in
+  let env = store_value ?check id addr desc env in
+  (id, env)
+
+let enter_type ~scope name info env =
+  let id = Ident.create_scoped ~scope name in
+  let env = store_type ~check:true ~predef:false id info env in
+  (id, env)
+
+let enter_extension ~scope name ext env =
+  let id = Ident.create_scoped ~scope name in
+  let addr = extension_declaration_address env id ext in
+  let env = store_extension ~check:true id addr ext env in
+  (id, env)
+
+let enter_module_declaration ~scope ?arg s presence md env =
+  let id = Ident.create_scoped ~scope s in
+  (id, add_module_declaration ?arg ~check:true id presence md env)
+
+let enter_modtype ~scope name mtd env =
+  let id = Ident.create_scoped ~scope name in
+  let env = store_modtype id mtd env in
+  (id, env)
+
+let enter_class ~scope name desc env =
+  let id = Ident.create_scoped ~scope name in
+  let addr = class_declaration_address env id desc in
+  let env = store_class id addr desc env in
+  (id, env)
+
+let enter_cltype ~scope name desc env =
+  let id = Ident.create_scoped ~scope name in
+  let env = store_cltype id desc env in
+  (id, env)
+
+let enter_module ~scope ?arg s presence mty env =
+  enter_module_declaration ~scope ?arg s presence (md mty) env
+
+(* Insertion of all components of a signature *)
+
+let add_item comp env =
+  match comp with
+    Sig_value(id, decl, _)    -> add_value id decl env
+  | Sig_type(id, decl, _, _)  -> add_type ~check:false ~predef:false id decl env
+  | Sig_typext(id, ext, _, _) -> add_extension ~check:false id ext env
+  | Sig_module(id, presence, md, _, _) ->
+      add_module_declaration ~check:false id presence md env
+  | Sig_modtype(id, decl, _)  -> add_modtype id decl env
+  | Sig_class(id, decl, _, _) -> add_class id decl env
+  | Sig_class_type(id, decl, _, _) -> add_cltype id decl env
+
+let rec add_signature sg env =
+  match sg with
+    [] -> env
+  | comp :: rem -> add_signature rem (add_item comp env)
+
+let enter_signature ~scope sg env =
+  let sg = Subst.signature (Rescope scope) Subst.identity sg in
+  sg, add_signature sg env
+
+(* Add "unbound" bindings *)
+
+let enter_unbound_value name reason env =
+  let id = Ident.create_local name in
+  { env with
+    values = IdTbl.add id (Val_unbound reason) env.values;
+    summary = Env_value_unbound(env.summary, name, reason) }
+
+let enter_unbound_module name reason env =
+  let id = Ident.create_local name in
+  { env with
+    modules = IdTbl.add id (Mod_unbound reason) env.modules;
+    summary = Env_module_unbound(env.summary, name, reason) }
+
+(* Open a signature path *)
+
+let add_components slot root env0 comps =
+  let add_l w comps env0 =
+    TycompTbl.add_open slot w comps env0
+  in
+  let add w comps env0 = IdTbl.add_open slot w root comps env0 in
+  let add_types w comps env0 additions =
+    let types = add w comps env0 in
+    let additions = short_paths_type_open root comps additions in
+    types, additions
+  in
+  let add_cltypes w comps env0 additions =
+    let cltypes = add w comps env0 in
+    let additions = short_paths_class_type_open root comps additions in
+    cltypes, additions
+  in
+  let add_modtypes w comps env0 additions =
+    let modtypes = add w comps env0 in
+    let additions = short_paths_module_type_open root comps additions in
+    modtypes, additions
+  in
+  let add_modules w comps env0 additions =
+    let modules = add w comps env0 in
+    let additions = short_paths_module_open root comps additions in
+    modules, additions
+  in
+  let constrs =
+    add_l (fun x -> `Constructor x) comps.comp_constrs env0.constrs
+  in
+  let labels =
+    add_l (fun x -> `Label x) comps.comp_labels env0.labels
+  in
+  let values =
+    add (fun x -> `Value x) comps.comp_values env0.values
+  in
+  let types, additions =
+    add_types (fun x -> `Type x)
+      comps.comp_types env0.types env0.short_paths_additions
+  in
+  let modtypes, additions =
+    add_modtypes (fun x -> `Module_type x)
+      comps.comp_modtypes env0.modtypes additions
+  in
+  let classes =
+    add (fun x -> `Class x) comps.comp_classes env0.classes
+  in
+  let cltypes, additions =
+    add_cltypes (fun x -> `Class_type x)
+      comps.comp_cltypes env0.cltypes additions
+  in
+  let modules, additions =
+    add_modules (fun x -> `Module x)
+      comps.comp_modules env0.modules additions
+  in
+  { env0 with
+    summary = Env_open(env0.summary, root);
+    constrs;
+    labels;
+    values;
+    types;
+    modtypes;
+    classes;
+    cltypes;
+    modules;
+    short_paths_additions = additions
+  }
+
+let open_signature slot root env0 =
+  match get_components (find_module_components root env0) with
+  | Functor_comps _ -> None
+  | Structure_comps comps ->
+    Some (add_components slot root env0 comps)
+
+
+(* Open a signature from a file *)
+
+let open_pers_signature name env =
+  match open_signature None (Pident(Ident.create_persistent name)) env with
+  | Some env -> env
+  | None -> assert false (* a compilation unit cannot refer to a functor *)
+
+let open_signature
+    ?(used_slot = ref false)
+    ?(loc = Location.none) ?(toplevel = false)
+    ovf root env =
+  let unused root =
+    match ovf with
+    | Asttypes.Fresh -> Warnings.Unused_open (Path.name root)
+    | Asttypes.Override -> Warnings.Unused_open_bang (Path.name root)
+  in
+  let warn_unused =
+    Warnings.is_active (unused root)
+  and warn_shadow_id =
+    Warnings.is_active (Warnings.Open_shadow_identifier ("", ""))
+  and warn_shadow_lc =
+    Warnings.is_active (Warnings.Open_shadow_label_constructor ("",""))
+  in
+  if not toplevel && not loc.Location.loc_ghost
+     && (warn_unused || warn_shadow_id || warn_shadow_lc)
+  then begin
+    let used = used_slot in
+    if warn_unused then
+      !add_delayed_check_forward
+        (fun () ->
+           if not !used then begin
+             used := true;
+             Location.prerr_warning loc (unused (!shorten_module_path env root))
+           end
+        );
+    let shadowed = ref [] in
+    let slot s b =
+      begin match check_shadowing env b with
+      | Some kind when
+          ovf = Asttypes.Fresh && not (List.mem (kind, s) !shadowed) ->
+          shadowed := (kind, s) :: !shadowed;
+          let w =
+            match kind with
+            | "label" | "constructor" ->
+                Warnings.Open_shadow_label_constructor (kind, s)
+            | _ -> Warnings.Open_shadow_identifier (kind, s)
+          in
+          Location.prerr_warning loc w
+      | _ -> ()
+      end;
+      backtracking_set used true
+    in
+    open_signature (Some slot) root env
+  end
+  else open_signature None root env
+
+(* Read a signature from a file *)
+let read_signature modname filename =
+  let mda = read_pers_mod modname filename in
+  let md = EnvLazy.force subst_modtype_maker mda.mda_declaration in
+  match md.md_type with
+  | Mty_signature sg -> sg
+  | Mty_ident _ | Mty_functor _ | Mty_alias _ -> assert false
+
+let is_identchar_latin1 = function
+  | 'A'..'Z' | 'a'..'z' | '_' | '\192'..'\214' | '\216'..'\246'
+  | '\248'..'\255' | '\'' | '0'..'9' -> true
+  | _ -> false
+
+let unit_name_of_filename fn =
+  match Filename.extension fn with
+  | ".cmi" -> begin
+      let unit =
+        String.capitalize_ascii (Filename.remove_extension fn)
+      in
+      if Std.String.for_all is_identchar_latin1 unit then
+        Some unit
+      else
+        None
+    end
+  | _ -> None
+
+let persistent_structures_of_dir dir =
+  Load_path.Dir.files dir
+  |> List.to_seq
+  |> Seq.filter_map unit_name_of_filename
+  |> String.Set.of_seq
+
+(* Save a signature to a file *)
+let save_signature_with_transform cmi_transform ~alerts sg modname filename =
+  Btype.cleanup_abbrev ();
+  Subst.reset_for_saving ();
+  let sg = Subst.signature Make_local (Subst.for_saving Subst.identity) sg in
+  let cmi =
+    Persistent_env.make_cmi !persistent_env modname sg alerts
+    |> cmi_transform in
+  let cmi_cache = ref Not_found in
+  let pm = save_sign_of_cmi
+      { Persistent_env.Persistent_signature.cmi; filename; cmi_cache } in
+  Persistent_env.save_cmi !persistent_env
+    { Persistent_env.Persistent_signature.filename; cmi; cmi_cache } pm;
+  cmi
+
+let save_signature ~alerts sg modname filename =
+  save_signature_with_transform (fun cmi -> cmi)
+    ~alerts sg modname filename
+
+let save_signature_with_imports ~alerts sg modname filename imports =
+  let with_imports cmi = { cmi with cmi_crcs = imports } in
+  save_signature_with_transform with_imports
+    ~alerts sg modname filename
+
+(* Make the initial environment *)
+let (initial_safe_string, initial_unsafe_string) =
+  Predef.build_initial_env
+    (add_type ~check:false ~predef:true)
+    (add_extension ~check:false)
+    empty
+
+let add_type ~check id info env =
+  add_type ~check ~predef:false id info env
+
+(* Tracking usage *)
+
+let mark_module_used name loc =
+  match Hashtbl.find !module_declarations (name, loc) with
+  | mark -> mark ()
+  | exception Not_found -> ()
+
+let mark_modtype_used _name _mtd = ()
+
+let mark_value_used name vd =
+  match Hashtbl.find !value_declarations (name, vd.val_loc) with
+  | mark -> mark ()
+  | exception Not_found -> ()
+
+let mark_type_used name td =
+  match Hashtbl.find !type_declarations (name, td.type_loc) with
+  | mark -> mark ()
+  | exception Not_found -> ()
+
+let mark_type_path_used env path =
+  match find_type path env with
+  | decl -> mark_type_used (Path.last path) decl
+  | exception Not_found -> ()
+
+let mark_constructor_used usage ty_name cd =
+  let name = Ident.name cd.cd_id in
+  let loc = cd.cd_loc in
+  let k = (ty_name, loc, name) in
+  match Hashtbl.find !used_constructors k with
+  | mark -> mark usage
+  | exception Not_found -> ()
+
+let mark_extension_used usage name ext =
+  let ty_name = Path.last ext.ext_type_path in
+  let loc = ext.ext_loc in
+  let k = (ty_name, loc, name) in
+  match Hashtbl.find !used_constructors k with
+  | mark -> mark usage
+  | exception Not_found -> ()
+
+let mark_constructor_description_used usage env cstr =
+  let ty_path =
+    match repr cstr.cstr_res with
+    | {desc=Tconstr(path, _, _)} -> path
+    | _ -> assert false
+  in
+  mark_type_path_used env ty_path;
+  let ty_name = Path.last ty_path in
+  let k = (ty_name, cstr.cstr_loc, cstr.cstr_name) in
+  match Hashtbl.find !used_constructors k with
+  | mark -> mark usage
+  | exception Not_found -> ()
+
+let mark_label_description_used () env lbl =
+  let ty_path =
+    match repr lbl.lbl_res with
+    | {desc=Tconstr(path, _, _)} -> path
+    | _ -> assert false
+  in
+  mark_type_path_used env ty_path
+
+let mark_class_used name cty =
+  match Hashtbl.find !type_declarations (name, cty.cty_loc) with
+  | mark -> mark ()
+  | exception Not_found -> ()
+
+let mark_cltype_used name clty =
+  match Hashtbl.find !type_declarations (name, clty.clty_loc) with
+  | mark -> mark ()
+  | exception Not_found -> ()
+
+let set_value_used_callback name vd callback =
+  let key = (name, vd.val_loc) in
+  try
+    let old = Hashtbl.find !value_declarations key in
+    Hashtbl.replace !value_declarations key (fun () -> old (); callback ())
+      (* this is to support cases like:
+               let x = let x = 1 in x in x
+         where the two declarations have the same location
+         (e.g. resulting from Camlp4 expansion of grammar entries) *)
+  with Not_found ->
+    Hashtbl.add !value_declarations key callback
+
+let set_type_used_callback name td callback =
+  let loc = td.type_loc in
+  if loc.Location.loc_ghost then ()
+  else let key = (name, loc) in
+  let old =
+    try Hashtbl.find !type_declarations key
+    with Not_found -> ignore
+  in
+  Hashtbl.replace !type_declarations key (fun () -> callback old)
+
+(* Lookup by name *)
+
+let may_lookup_error report_errors loc env err =
+  if report_errors then lookup_error loc env err
+  else raise Not_found
+
+let report_module_unbound ~errors ~loc env reason =
+  match reason with
+  | Mod_unbound_illegal_recursion ->
+      (* see #5965 *)
+    may_lookup_error errors loc env Illegal_reference_to_recursive_module
+
+let report_value_unbound ~errors ~loc env reason lid =
+  match reason with
+  | Val_unbound_instance_variable ->
+      may_lookup_error errors loc env (Masked_instance_variable lid)
+  | Val_unbound_self ->
+      may_lookup_error errors loc env (Masked_self_variable lid)
+  | Val_unbound_ancestor ->
+      may_lookup_error errors loc env (Masked_ancestor_variable lid)
+  | Val_unbound_ghost_recursive rloc ->
+      let show_hint =
+        (* Only display the "missing rec" hint for non-ghost code *)
+        not loc.Location.loc_ghost
+        && not rloc.Location.loc_ghost
+      in
+      let hint =
+        if show_hint then Missing_rec rloc else No_hint
+      in
+      may_lookup_error errors loc env (Unbound_value(lid, hint))
+
+let use_module ~use ~loc name path mda =
+  if use then begin
+    let comps = mda.mda_components in
+    mark_module_used name comps.loc;
+    Misc.String.Map.iter
+      (fun kind message ->
+         let message = if message = "" then "" else "\n" ^ message in
+         Location.alert ~kind loc
+           (Printf.sprintf "module %s%s" (Path.name path) message)
+      )
+      comps.alerts
+  end
+
+let use_value ~use ~loc name path vda =
+  if use then begin
+    let desc = vda.vda_description in
+    mark_value_used name desc;
+    Builtin_attributes.check_alerts loc desc.val_attributes
+      (Path.name path)
+  end
+
+let use_type ~use ~loc name path tda =
+  if use then begin
+    let decl = tda.tda_declaration in
+    mark_type_used name decl;
+    Builtin_attributes.check_alerts loc decl.type_attributes
+      (Path.name path)
+  end
+
+let use_modtype ~use ~loc name path desc =
+  if use then begin
+    mark_modtype_used name desc;
+    Builtin_attributes.check_alerts loc desc.mtd_attributes
+      (Path.name path)
+  end
+
+let use_class ~use ~loc name path clda =
+  if use then begin
+    let desc = clda.clda_declaration in
+    mark_class_used name desc;
+    Builtin_attributes.check_alerts loc desc.cty_attributes
+      (Path.name path)
+  end
+
+let use_cltype ~use ~loc name path desc =
+  if use then begin
+    mark_cltype_used name desc;
+    Builtin_attributes.check_alerts loc desc.clty_attributes
+      (Path.name path)
+  end
+
+let use_label ~use ~loc env lbl =
+  if use then begin
+    mark_label_description_used () env lbl;
+    Builtin_attributes.check_alerts loc lbl.lbl_attributes lbl.lbl_name
+  end
+
+let use_constructor_desc ~use ~loc usage env cstr =
+  if use then begin
+    mark_constructor_description_used usage env cstr;
+    Builtin_attributes.check_alerts loc cstr.cstr_attributes cstr.cstr_name
+  end
+
+let use_constructor ~use ~loc usage env cda =
+  use_constructor_desc ~use ~loc usage env cda.cda_description
+
+type _ load =
+  | Load : module_data load
+  | Don't_load : unit load
+
+let lookup_ident_module (type a) (load : a load) ~errors ~use ~loc s env =
+  let path, data =
+    match find_name_module ~mark:use s env.modules with
+    | res -> res
+    | exception Not_found ->
+        may_lookup_error errors loc env (Unbound_module (Lident s))
+  in
+  match data with
+  | Mod_local mda -> begin
+      use_module ~use ~loc s path mda;
+      match load with
+      | Load -> path, (mda : a)
+      | Don't_load -> path, (() : a)
+    end
+  | Mod_unbound reason ->
+      report_module_unbound ~errors ~loc env reason
+  | Mod_persistent -> begin
+      match load with
+      | Don't_load ->
+          check_pers_mod ~loc s;
+          path, (() : a)
+      | Load -> begin
+          match find_pers_mod s with
+          | mda ->
+              use_module ~use ~loc s path mda;
+              path, (mda : a)
+          | exception Not_found ->
+              may_lookup_error errors loc env (Unbound_module (Lident s))
+        end
+    end
+
+let lookup_ident_value ~errors ~use ~loc name env =
+  match IdTbl.find_name wrap_value ~mark:use name env.values with
+  | (path, Val_bound vda) ->
+      use_value ~use ~loc name path vda;
+      path, vda.vda_description
+  | (_, Val_unbound reason) ->
+      report_value_unbound ~errors ~loc env reason (Lident name)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_value (Lident name, No_hint))
+
+let lookup_ident_type ~errors ~use ~loc s env =
+  match IdTbl.find_name wrap_identity ~mark:use s env.types with
+  | (path, data) as res ->
+      use_type ~use ~loc s path data;
+      res
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_type (Lident s))
+
+let lookup_ident_modtype ~errors ~use ~loc s env =
+  match IdTbl.find_name wrap_identity ~mark:use s env.modtypes with
+  | (path, data) as res ->
+      use_modtype ~use ~loc s path data;
+      res
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_modtype (Lident s))
+
+let lookup_ident_class ~errors ~use ~loc s env =
+  match IdTbl.find_name wrap_identity ~mark:use s env.classes with
+  | (path, clda) ->
+      use_class ~use ~loc s path clda;
+      path, clda.clda_declaration
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_class (Lident s))
+
+let lookup_ident_cltype ~errors ~use ~loc s env =
+  match IdTbl.find_name wrap_identity ~mark:use s env.cltypes with
+  | (path, data) as res ->
+      use_cltype ~use ~loc s path data;
+      res
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_cltype (Lident s))
+
+let lookup_all_ident_labels ~errors ~use ~loc s env =
+  match TycompTbl.find_all ~mark:use s env.labels with
+  | [] -> may_lookup_error errors loc env (Unbound_label (Lident s))
+  | lbls -> begin
+      List.map
+        (fun (lbl, use_fn) ->
+           let use_fn () =
+             use_label ~use ~loc env lbl;
+             use_fn ()
+           in
+           (lbl, use_fn))
+        lbls
+    end
+
+(* Drop all extension constructors *)
+let drop_exts cstrs =
+  List.filter (fun (cda, _) -> not (is_ext cda)) cstrs
+
+(* Only keep the latest extension constructor *)
+let rec filter_shadowed_constructors cstrs =
+  match cstrs with
+  | (cda, _) as hd :: tl ->
+      if is_ext cda then hd :: drop_exts tl
+      else hd :: filter_shadowed_constructors tl
+  | [] -> []
+
+let lookup_all_ident_constructors ~errors ~use ~loc usage s env =
+  match TycompTbl.find_all ~mark:use s env.constrs with
+  | [] -> may_lookup_error errors loc env (Unbound_constructor (Lident s))
+  | cstrs ->
+      let cstrs = filter_shadowed_constructors cstrs in
+      List.map
+        (fun (cda, use_fn) ->
+           let use_fn () =
+             use_constructor ~use ~loc usage env cda;
+             use_fn ()
+           in
+           (cda.cda_description, use_fn))
+        cstrs
+
+let rec lookup_module_components ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s ->
+      let path, data = lookup_ident_module Load ~errors ~use ~loc s env in
+      path, data.mda_components
+  | Ldot(l, s) ->
+      let path, data = lookup_dot_module ~errors ~use ~loc l s env in
+      path, data.mda_components
+  | Lapply(l1, l2) ->
+      let p1, f, arg = lookup_functor_components ~errors ~use ~loc l1 env in
+      let p2, md = lookup_module ~errors ~use ~loc l2 env in
+      !check_functor_application ~errors ~loc env md.md_type p2 arg p1;
+      let comps = !components_of_functor_appl' ~loc f env p1 p2 in
+      (Papply(p1, p2), comps)
+
+and lookup_structure_components ~errors ~use ~loc lid env =
+  let path, comps = lookup_module_components ~errors ~use ~loc lid env in
+  match get_components_res comps with
+  | Ok (Structure_comps comps) -> path, comps
+  | Ok (Functor_comps _) ->
+      may_lookup_error errors loc env (Functor_used_as_structure lid)
+  | Error No_components_abstract ->
+      may_lookup_error errors loc env (Abstract_used_as_structure lid)
+  | Error (No_components_alias p) ->
+      may_lookup_error errors loc env (Cannot_scrape_alias(lid, p))
+
+and lookup_functor_components ~errors ~use ~loc lid env =
+  let path, comps = lookup_module_components ~errors ~use ~loc lid env in
+  match get_components_res comps with
+  | Ok (Functor_comps fcomps) -> begin
+      match fcomps.fcomp_arg with
+      | Unit -> (* PR#7611 *)
+          may_lookup_error errors loc env (Generative_used_as_applicative lid)
+      | Named (_, arg) -> path, fcomps, arg
+    end
+  | Ok (Structure_comps _) ->
+      may_lookup_error errors loc env (Structure_used_as_functor lid)
+  | Error No_components_abstract ->
+      may_lookup_error errors loc env (Abstract_used_as_functor lid)
+  | Error (No_components_alias p) ->
+      may_lookup_error errors loc env (Cannot_scrape_alias(lid, p))
+
+and lookup_module ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s ->
+      let path, data = lookup_ident_module Load ~errors ~use ~loc s env in
+      let md = EnvLazy.force subst_modtype_maker data.mda_declaration in
+      path, md
+  | Ldot(l, s) ->
+      let path, data = lookup_dot_module ~errors ~use ~loc l s env in
+      let md = EnvLazy.force subst_modtype_maker data.mda_declaration in
+      path, md
+  | Lapply(l1, l2) ->
+      let p1, fc, arg = lookup_functor_components ~errors ~use ~loc l1 env in
+      let p2, md2 = lookup_module ~errors ~use ~loc l2 env in
+      !check_functor_application ~errors ~loc env md2.md_type p2 arg p1;
+      let md = md (modtype_of_functor_appl fc p1 p2) in
+      Papply(p1, p2), md
+
+and lookup_dot_module ~errors ~use ~loc l s env =
+  let p, comps = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_modules with
+  | mda ->
+      let path = Pdot(p, s) in
+      use_module ~use ~loc s path mda;
+      (path, mda)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_module (Ldot(l, s)))
+
+let lookup_dot_value ~errors ~use ~loc l s env =
+  let (path, comps) =
+    lookup_structure_components ~errors ~use ~loc l env
+  in
+  match NameMap.find s comps.comp_values with
+  | vda ->
+      let path = Pdot(path, s) in
+      use_value ~use ~loc s path vda;
+      (path, vda.vda_description)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_value (Ldot(l, s), No_hint))
+
+let lookup_dot_type ~errors ~use ~loc l s env =
+  let (p, comps) = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_types with
+  | tda ->
+      let path = Pdot(p, s) in
+      use_type ~use ~loc s path tda;
+      (path, tda)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_type (Ldot(l, s)))
+
+let lookup_dot_modtype ~errors ~use ~loc l s env =
+  let (p, comps) = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_modtypes with
+  | desc ->
+      let path = Pdot(p, s) in
+      use_modtype ~use ~loc s path desc;
+      (path, desc)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_modtype (Ldot(l, s)))
+
+let lookup_dot_class ~errors ~use ~loc l s env =
+  let (p, comps) = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_classes with
+  | clda ->
+      let path = Pdot(p, s) in
+      use_class ~use ~loc s path clda;
+      (path, clda.clda_declaration)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_class (Ldot(l, s)))
+
+let lookup_dot_cltype ~errors ~use ~loc l s env =
+  let (p, comps) = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_cltypes with
+  | desc ->
+      let path = Pdot(p, s) in
+      use_cltype ~use ~loc s path desc;
+      (path, desc)
+  | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_cltype (Ldot(l, s)))
+
+let lookup_all_dot_labels ~errors ~use ~loc l s env =
+  let (_, comps) = lookup_structure_components ~errors ~use ~loc l env in
+  match NameMap.find s comps.comp_labels with
+  | [] | exception Not_found ->
+      may_lookup_error errors loc env (Unbound_label (Ldot(l, s)))
+  | lbls ->
+      List.map
+        (fun lbl ->
+           let use_fun () = use_label ~use ~loc env lbl in
+           (lbl, use_fun))
+        lbls
+
+let lookup_all_dot_constructors ~errors ~use ~loc usage l s env =
+  match l with
+  | Longident.Lident "*predef*" ->
+      (* Hack to support compilation of default arguments *)
+      lookup_all_ident_constructors
+        ~errors ~use ~loc usage s initial_safe_string
+  | _ ->
+      let (_, comps) = lookup_structure_components ~errors ~use ~loc l env in
+      match NameMap.find s comps.comp_constrs with
+      | [] | exception Not_found ->
+          may_lookup_error errors loc env (Unbound_constructor (Ldot(l, s)))
+      | cstrs ->
+          List.map
+            (fun cda ->
+               let use_fun () = use_constructor ~use ~loc usage env cda in
+               (cda.cda_description, use_fun))
+            cstrs
+
+(* General forms of the lookup functions *)
+
+let lookup_module_path ~errors ~use ~loc ~load lid env : Path.t =
+  match lid with
+  | Lident s ->
+      if !Clflags.transparent_modules && not load then
+        fst (lookup_ident_module Don't_load ~errors ~use ~loc s env)
+      else
+        fst (lookup_ident_module Load ~errors ~use ~loc s env)
+  | Ldot(l, s) -> fst (lookup_dot_module ~errors ~use ~loc l s env)
+  | Lapply(l1, l2) ->
+      let (p1, _, arg) = lookup_functor_components ~errors ~use ~loc l1 env in
+      let p2, md2 = lookup_module ~errors ~use ~loc l2 env in
+      !check_functor_application ~errors ~loc env md2.md_type p2 arg p1;
+      Papply(p1, p2)
+
+let lookup_value ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_ident_value ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_dot_value ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_type_full ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_ident_type ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_dot_type ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_type ~errors ~use ~loc lid env =
+  let (path, tda) = lookup_type_full ~errors ~use ~loc lid env in
+  path, tda.tda_declaration
+
+let lookup_modtype ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_ident_modtype ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_dot_modtype ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_class ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_ident_class ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_dot_class ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_cltype ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_ident_cltype ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_dot_cltype ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_all_labels ~errors ~use ~loc lid env =
+  match lid with
+  | Lident s -> lookup_all_ident_labels ~errors ~use ~loc s env
+  | Ldot(l, s) -> lookup_all_dot_labels ~errors ~use ~loc l s env
+  | Lapply _ -> assert false
+
+let lookup_label ~errors ~use ~loc lid env =
+  match lookup_all_labels ~errors ~use ~loc lid env with
+  | [] -> assert false
+  | (desc, use) :: _ -> use (); desc
+
+let lookup_all_labels_from_type ~use ~loc ty_path env =
+  match find_type_descrs ty_path env with
+  | exception Not_found -> []
+  | (_, lbls) ->
+      List.map
+        (fun lbl ->
+           let use_fun () = use_label ~use ~loc env lbl in
+           (lbl, use_fun))
+        lbls
+
+let lookup_all_constructors ~errors ~use ~loc usage lid env =
+  match lid with
+  | Lident s -> lookup_all_ident_constructors ~errors ~use ~loc usage s env
+  | Ldot(l, s) -> lookup_all_dot_constructors ~errors ~use ~loc usage l s env
+  | Lapply _ -> assert false
+
+let lookup_constructor ~errors ~use ~loc usage lid env =
+  match lookup_all_constructors ~errors ~use ~loc usage lid env with
+  | [] -> assert false
+  | (desc, use) :: _ -> use (); desc
+
+let lookup_all_constructors_from_type ~use ~loc usage ty_path env =
+  match find_type_descrs ty_path env with
+  | exception Not_found -> []
+  | (cstrs, _) ->
+      List.map
+        (fun cstr ->
+           let use_fun () =
+             use_constructor_desc ~use ~loc usage env cstr
+           in
+           (cstr, use_fun))
+        cstrs
+
+(* Lookup functions that do not mark the item as used or
+   warn if it has alerts, and raise [Not_found] rather
+   than report errors *)
+
+let find_module_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_module ~errors:false ~use:false ~loc lid env
+
+let find_value_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_value ~errors:false ~use:false ~loc lid env
+
+let find_type_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_type ~errors:false ~use:false ~loc lid env
+
+let find_modtype_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_modtype ~errors:false ~use:false ~loc lid env
+
+let find_class_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_class ~errors:false ~use:false ~loc lid env
+
+let find_cltype_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_cltype ~errors:false ~use:false ~loc lid env
+
+let find_constructor_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_constructor ~errors:false ~use:false ~loc Positive lid env
+
+let find_label_by_name lid env =
+  let loc = Location.(in_file !input_name) in
+  lookup_label ~errors:false ~use:false ~loc lid env
+
+(* Ordinary lookup functions *)
+
+let lookup_module_path ?(use=true) ~loc ~load lid env =
+  lookup_module_path ~errors:true ~use ~loc ~load lid env
+
+let lookup_module ?(use=true) ~loc lid env =
+  lookup_module ~errors:true ~use ~loc lid env
+
+let lookup_value ?(use=true) ~loc lid env =
+  check_value_name (Longident.last lid) loc;
+  lookup_value ~errors:true ~use ~loc lid env
+
+let lookup_type ?(use=true) ~loc lid env =
+  lookup_type ~errors:true ~use ~loc lid env
+
+let lookup_modtype ?(use=true) ~loc lid env =
+  lookup_modtype ~errors:true ~use ~loc lid env
+
+let lookup_class ?(use=true) ~loc lid env =
+  lookup_class ~errors:true ~use ~loc lid env
+
+let lookup_cltype ?(use=true) ~loc lid env =
+  lookup_cltype ~errors:true ~use ~loc lid env
+
+let lookup_all_constructors ?(use=true) ~loc usage lid env =
+  match lookup_all_constructors ~errors:true ~use ~loc usage lid env with
+  | exception Error(Lookup_error(loc', env', err)) ->
+      (Error(loc', env', err) : _ result)
+  | cstrs -> Ok cstrs
+
+let lookup_constructor ?(use=true) ~loc lid env =
+  lookup_constructor ~errors:true ~use ~loc lid env
+
+let lookup_all_constructors_from_type ?(use=true) ~loc usage ty_path env =
+  lookup_all_constructors_from_type ~use ~loc usage ty_path env
+
+let lookup_all_labels ?(use=true) ~loc lid env =
+  match lookup_all_labels ~errors:true ~use ~loc lid env with
+  | exception Error(Lookup_error(loc', env', err)) ->
+      (Error(loc', env', err) : _ result)
+  | lbls -> Ok lbls
+
+let lookup_label ?(use=true) ~loc lid env =
+  lookup_label ~errors:true ~use ~loc lid env
+
+let lookup_all_labels_from_type ?(use=true) ~loc ty_path env =
+  lookup_all_labels_from_type ~use ~loc ty_path env
+
+let lookup_instance_variable ?(use=true) ~loc name env =
+  match IdTbl.find_name wrap_value ~mark:use name env.values with
+  | (path, Val_bound vda) -> begin
+      let desc = vda.vda_description in
+      match desc.val_kind with
+      | Val_ivar(mut, cl_num) ->
+          use_value ~use ~loc name path vda;
+          path, mut, cl_num, desc.val_type
+      | _ ->
+          lookup_error loc env (Not_an_instance_variable name)
+    end
+  | (_, Val_unbound Val_unbound_instance_variable) ->
+      lookup_error loc env (Masked_instance_variable (Lident name))
+  | (_, Val_unbound Val_unbound_self) ->
+      lookup_error loc env (Not_an_instance_variable name)
+  | (_, Val_unbound Val_unbound_ancestor) ->
+      lookup_error loc env (Not_an_instance_variable name)
+  | (_, Val_unbound Val_unbound_ghost_recursive _) ->
+      lookup_error loc env (Unbound_instance_variable name)
+  | exception Not_found ->
+      lookup_error loc env (Unbound_instance_variable name)
+
+(* Checking if a name is bound *)
+
+let bound_module name env =
+  match IdTbl.find_name wrap_module ~mark:false name env.modules with
+  | _ -> true
+  | exception Not_found ->
+      if Current_unit_name.is name then false
+      else begin
+        match find_pers_mod name with
+        | _ -> true
+        | exception Not_found -> false
+      end
+
+let bound wrap proj name env =
+  match IdTbl.find_name wrap ~mark:false name (proj env) with
+  | _ -> true
+  | exception Not_found -> false
+
+let bound_value name env =
+  bound wrap_value (fun env -> env.values) name env
+
+let bound_type name env =
+  bound wrap_identity (fun env -> env.types) name env
+
+let bound_modtype name env =
+  bound wrap_identity (fun env -> env.modtypes) name env
+
+let bound_class name env =
+  bound wrap_identity (fun env -> env.classes) name env
+
+let bound_cltype name env =
+  bound wrap_identity (fun env -> env.cltypes) name env
+
+(* Folding on environments *)
+
+let find_all wrap proj1 proj2 f lid env acc =
+  match lid with
+  | None ->
+      IdTbl.fold_name wrap
+        (fun name (p, data) acc -> f name p data acc)
+        (proj1 env) acc
+  | Some l ->
+      let p, desc =
+        lookup_module_components
+          ~errors:false ~use:false ~loc:Location.none l env
+      in
+      begin match get_components desc with
+      | Structure_comps c ->
+          NameMap.fold
+            (fun s data acc -> f s (Pdot (p, s)) (wrap data) acc)
+            (proj2 c) acc
+      | Functor_comps _ ->
+          acc
+      end
+
+let find_all_simple_list proj1 proj2 f lid env acc =
+  match lid with
+  | None ->
+      TycompTbl.fold_name
+        (fun data acc -> f data acc)
+        (proj1 env) acc
+  | Some l ->
+      let (_p, desc) =
+        lookup_module_components
+          ~errors:false ~use:false ~loc:Location.none l env
+      in
+      begin match get_components desc with
+      | Structure_comps c ->
+          NameMap.fold
+            (fun _s comps acc ->
+               match comps with
+               | [] -> acc
+               | data :: _ -> f data acc)
+            (proj2 c) acc
+      | Functor_comps _ ->
+          acc
+      end
+
+let fold_modules f lid env acc =
+  match lid with
+  | None ->
+      IdTbl.fold_name wrap_module
+        (fun name (p, entry) acc ->
+           match entry with
+           | Mod_unbound _ -> acc
+           | Mod_local mda ->
+               let md =
+                 EnvLazy.force subst_modtype_maker mda.mda_declaration
+               in
+               f name p md acc
+           | Mod_persistent ->
+               match Persistent_env.find_in_cache !persistent_env name with
+               | None -> acc
+               | Some mda ->
+                   let md =
+                     EnvLazy.force subst_modtype_maker mda.mda_declaration
+                   in
+                   f name p md acc)
+        env.modules
+        acc
+  | Some l ->
+      let p, desc =
+        lookup_module_components
+          ~errors:false ~use:false ~loc:Location.none l env
+      in
+      begin match get_components desc with
+      | Structure_comps c ->
+          NameMap.fold
+            (fun s mda acc ->
+               let md =
+                 EnvLazy.force subst_modtype_maker mda.mda_declaration
+               in
+               f s (Pdot (p, s)) md acc)
+            c.comp_modules
+            acc
+      | Functor_comps _ ->
+          acc
+      end
+
+let fold_values f =
+  find_all wrap_value (fun env -> env.values) (fun sc -> sc.comp_values)
+    (fun k p ve acc ->
+       match ve with
+       | Val_unbound _ -> acc
+       | Val_bound vda -> f k p vda.vda_description acc)
+and fold_constructors f =
+  find_all_simple_list (fun env -> env.constrs) (fun sc -> sc.comp_constrs)
+    (fun cda acc -> f cda.cda_description acc)
+and fold_labels f =
+  find_all_simple_list (fun env -> env.labels) (fun sc -> sc.comp_labels) f
+and fold_types f =
+  find_all wrap_identity
+    (fun env -> env.types) (fun sc -> sc.comp_types)
+    (fun k p tda acc -> f k p tda.tda_declaration acc)
+and fold_modtypes f =
+  find_all wrap_identity
+    (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes) f
+and fold_classes f =
+  find_all wrap_identity (fun env -> env.classes) (fun sc -> sc.comp_classes)
+    (fun k p clda acc -> f k p clda.clda_declaration acc)
+and fold_cltypes f =
+  find_all wrap_identity
+    (fun env -> env.cltypes) (fun sc -> sc.comp_cltypes) f
+
+let filter_non_loaded_persistent f env =
+  let to_remove =
+    IdTbl.fold_name wrap_module
+      (fun name (_, entry) acc ->
+         match entry with
+         | Mod_local _ -> acc
+         | Mod_unbound _ -> acc
+         | Mod_persistent ->
+             match Persistent_env.find_in_cache !persistent_env name with
+             | Some _ -> acc
+             | None ->
+                 if f (Ident.create_persistent name) then
+                   acc
+                 else
+                   String.Set.add name acc)
+      env.modules
+      String.Set.empty
+  in
+  let remove_ids tbl ids =
+    String.Set.fold
+      (fun name tbl -> IdTbl.remove (Ident.create_persistent name) tbl)
+      ids
+      tbl
+  in
+  let rec filter_summary summary ids =
+    if String.Set.is_empty ids then
+      summary
+    else
+      match summary with
+      | Env_empty -> summary
+      | Env_value (s, id, vd) ->
+          Env_value (filter_summary s ids, id, vd)
+      | Env_type (s, id, td) ->
+          Env_type (filter_summary s ids, id, td)
+      | Env_extension (s, id, ec) ->
+          Env_extension (filter_summary s ids, id, ec)
+      | Env_module (s, id, mp, md) ->
+          Env_module (filter_summary s ids, id, mp, md)
+      | Env_modtype (s, id, md) ->
+          Env_modtype (filter_summary s ids, id, md)
+      | Env_class (s, id, cd) ->
+          Env_class (filter_summary s ids, id, cd)
+      | Env_cltype (s, id, ctd) ->
+          Env_cltype (filter_summary s ids, id, ctd)
+      | Env_open (s, p) ->
+          Env_open (filter_summary s ids, p)
+      | Env_functor_arg (s, id) ->
+          Env_functor_arg (filter_summary s ids, id)
+      | Env_constraints (s, cstrs) ->
+          Env_constraints (filter_summary s ids, cstrs)
+      | Env_copy_types s ->
+          Env_copy_types (filter_summary s ids)
+      | Env_persistent (s, id) ->
+          if String.Set.mem (Ident.name id) ids then
+            filter_summary s (String.Set.remove (Ident.name id) ids)
+          else
+            Env_persistent (filter_summary s ids, id)
+      | Env_value_unbound (s, n, r) ->
+          Env_value_unbound (filter_summary s ids, n, r)
+      | Env_module_unbound (s, n, r) ->
+          Env_module_unbound (filter_summary s ids, n, r)
+  in
+  { env with
+    modules = remove_ids env.modules to_remove;
+    summary = filter_summary env.summary to_remove;
+  }
+
+(* Return the environment summary *)
+
+let summary env =
+  if Path.Map.is_empty env.local_constraints then env.summary
+  else Env_constraints (env.summary, env.local_constraints)
+
+let last_env = s_ref empty
+let last_reduced_env = s_ref empty
+
+let keep_only_summary env =
+  if !last_env == env then !last_reduced_env
+  else begin
+    let new_env =
+      {
+       empty with
+       summary = env.summary;
+       local_constraints = env.local_constraints;
+       flags = env.flags;
+      }
+    in
+    last_env := env;
+    last_reduced_env := new_env;
+    new_env
+  end
+
+
+let env_of_only_summary env_from_summary env =
+  let new_env = env_from_summary env.summary Subst.identity in
+  { new_env with
+    local_constraints = env.local_constraints;
+    flags = env.flags;
+  }
+
+(* Error report *)
+
+open Format
+
+(* Forward declarations *)
+
+let print_longident =
+  ref ((fun _ _ -> assert false) : formatter -> Longident.t -> unit)
+
+let print_path =
+  ref ((fun _ _ -> assert false) : formatter -> Path.t -> unit)
+
+let spellcheck ppf extract env lid =
+  let choices ~path name = Misc.spellcheck (extract path env) name in
+  match lid with
+    | Longident.Lapply _ -> ()
+    | Longident.Lident s ->
+       Misc.did_you_mean ppf (fun () -> choices ~path:None s)
+    | Longident.Ldot (r, s) ->
+       Misc.did_you_mean ppf (fun () -> choices ~path:(Some r) s)
+
+let spellcheck_name ppf extract env name =
+  Misc.did_you_mean ppf
+    (fun () -> Misc.spellcheck (extract env) name)
+
+let extract_values path env =
+  fold_values (fun name _ _ acc -> name :: acc) path env []
+let extract_types path env =
+  fold_types (fun name _ _ acc -> name :: acc) path env []
+let extract_modules path env =
+  fold_modules (fun name _ _ acc -> name :: acc) path env []
+let extract_constructors path env =
+  fold_constructors (fun desc acc -> desc.cstr_name :: acc) path env []
+let extract_labels path env =
+  fold_labels (fun desc acc -> desc.lbl_name :: acc) path env []
+let extract_classes path env =
+  fold_classes (fun name _ _ acc -> name :: acc) path env []
+let extract_modtypes path env =
+  fold_modtypes (fun name _ _ acc -> name :: acc) path env []
+let extract_cltypes path env =
+  fold_cltypes (fun name _ _ acc -> name :: acc) path env []
+let extract_instance_variables env =
+  fold_values
+    (fun name _ descr acc ->
+       match descr.val_kind with
+       | Val_ivar _ -> name :: acc
+       | _ -> acc) None env []
+
+let report_lookup_error _loc env ppf = function
+  | Unbound_value(lid, hint) -> begin
+      fprintf ppf "Unbound value %a" !print_longident lid;
+      spellcheck ppf extract_values env lid;
+      match hint with
+      | No_hint -> ()
+      | Missing_rec def_loc ->
+          let (_, line, _) =
+            Location.get_pos_info def_loc.Location.loc_start
+          in
+          fprintf ppf
+            "@.@[%s@ %s %i@]"
+            "Hint: If this is a recursive definition,"
+            "you should add the 'rec' keyword on line"
+            line
+    end
+  | Unbound_type lid ->
+      fprintf ppf "Unbound type constructor %a" !print_longident lid;
+      spellcheck ppf extract_types env lid;
+  | Unbound_module lid ->
+      fprintf ppf "Unbound module %a" !print_longident lid;
+      spellcheck ppf extract_modules env lid;
+  | Unbound_constructor lid ->
+      fprintf ppf "Unbound constructor %a" !print_longident lid;
+      spellcheck ppf extract_constructors env lid;
+  | Unbound_label lid ->
+      fprintf ppf "Unbound record field %a" !print_longident lid;
+      spellcheck ppf extract_labels env lid;
+  | Unbound_class lid ->
+      fprintf ppf "Unbound class %a" !print_longident lid;
+      spellcheck ppf extract_classes env lid;
+  | Unbound_modtype lid ->
+      fprintf ppf "Unbound module type %a" !print_longident lid;
+      spellcheck ppf extract_modtypes env lid;
+  | Unbound_cltype lid ->
+      fprintf ppf "Unbound class type %a" !print_longident lid;
+      spellcheck ppf extract_cltypes env lid;
+  | Unbound_instance_variable s ->
+      fprintf ppf "Unbound instance variable %s" s;
+      spellcheck_name ppf extract_instance_variables env s;
+  | Not_an_instance_variable s ->
+      fprintf ppf "The value %s is not an instance variable" s;
+      spellcheck_name ppf extract_instance_variables env s;
+  | Masked_instance_variable lid ->
+      fprintf ppf
+        "The instance variable %a@ \
+         cannot be accessed from the definition of another instance variable"
+        !print_longident lid
+  | Masked_self_variable lid ->
+      fprintf ppf
+        "The self variable %a@ \
+         cannot be accessed from the definition of an instance variable"
+        !print_longident lid
+  | Masked_ancestor_variable lid ->
+      fprintf ppf
+        "The ancestor variable %a@ \
+         cannot be accessed from the definition of an instance variable"
+        !print_longident lid
+  | Illegal_reference_to_recursive_module ->
+     fprintf ppf "Illegal recursive module reference"
+  | Structure_used_as_functor lid ->
+      fprintf ppf "@[The module %a is a structure, it cannot be applied@]"
+        !print_longident lid
+  | Abstract_used_as_functor lid ->
+      fprintf ppf "@[The module %a is abstract, it cannot be applied@]"
+        !print_longident lid
+  | Functor_used_as_structure lid ->
+      fprintf ppf "@[The module %a is a functor, \
+                   it cannot have any components@]" !print_longident lid
+  | Abstract_used_as_structure lid ->
+      fprintf ppf "@[The module %a is abstract, \
+                   it cannot have any components@]" !print_longident lid
+  | Generative_used_as_applicative lid ->
+      fprintf ppf "@[The functor %a is generative,@ it@ cannot@ be@ \
+                   applied@ in@ type@ expressions@]" !print_longident lid
+  | Cannot_scrape_alias(lid, p) ->
+      fprintf ppf
+        "The module %a is an alias for module %a, which is missing"
+        !print_longident lid !print_path p
+
+let report_error ppf = function
+  | Missing_module(_, path1, path2) ->
+      fprintf ppf "@[@[<hov>";
+      if Path.same path1 path2 then
+        fprintf ppf "Internal path@ %s@ is dangling." (Path.name path1)
+      else
+        fprintf ppf "Internal path@ %s@ expands to@ %s@ which is dangling."
+          (Path.name path1) (Path.name path2);
+      fprintf ppf "@]@ @[%s@ %s@ %s.@]@]"
+        "The compiled interface for module" (Ident.name (Path.head path2))
+        "was not found"
+  | Illegal_value_name(_loc, name) ->
+      fprintf ppf "'%s' is not a valid value identifier."
+        name
+  | Lookup_error(loc, t, err) -> report_lookup_error loc t ppf err
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error err ->
+          let loc =
+            match err with
+            | Missing_module (loc, _, _)
+            | Illegal_value_name (loc, _)
+            | Lookup_error(loc, _, _) -> loc
+          in
+          let error_of_printer =
+            if loc = Location.none
+            then Location.error_of_printer_file
+            else Location.error_of_printer ~loc ?sub:None
+          in
+          Some (error_of_printer report_error err)
+      | _ ->
+          None
+    )
+
+(* helper for merlin *)
+
+let check_state_consistency () =
+  let missing modname =
+    match Load_path.find_uncap (modname ^ ".cmi") with
+    | _ -> false
+    | exception Not_found -> true
+  and found _modname filename md =
+    match !(Cmi_cache.(get_cached_entry filename).Cmi_cache.cmi_cache) with
+    | Cmi_cache_store md' -> md == md'
+    | _ -> false
+    | exception Not_found -> false
+  in
+  Persistent_env.forall ~found ~missing !persistent_env
+
+let with_cmis f =
+  Persistent_env.with_cmis !persistent_env f ()
+
+let add_merlin_extension_module id mty env = add_module id Mp_present mty env
+
+(* Update short paths *)
+
+let rec index l x =
+  match l with
+    [] -> raise Not_found
+  | a :: l -> if x == a then 0 else 1 + index l x
+
+let rec uniq = function
+    [] -> true
+  | a :: l -> not (List.memq a l) && uniq l
+
+let short_paths_type_desc decl =
+  let open Short_paths.Desc.Type in
+  match decl.type_manifest with
+  | None -> Fresh
+  | Some ty ->
+    let ty = repr ty in
+    if ty.level <> generic_level then Fresh
+    else begin
+      match decl.type_private, decl.type_kind with
+      | Private, Type_abstract -> Fresh
+      | _, _ -> begin
+        let params = List.map repr decl.type_params in
+        match ty with
+        | {desc = Tconstr (path, args, _)} ->
+            let args = List.map repr args in
+            if List.length params = List.length args
+               && List.for_all2 (==) params args
+            then Alias path
+            else if List.length params <= List.length args
+                    || not (uniq args) then Fresh
+            else begin
+              match List.map (index params) args with
+              | exception Not_found -> Fresh
+              | ns -> Subst(path, ns)
+            end
+        | ty -> begin
+            match index params ty with
+            | exception Not_found -> Fresh
+            | n -> Nth n
+          end
+      end
+    end
+
+let short_paths_class_type_desc clty =
+  let open Short_paths.Desc.Class_type in
+  match clty.clty_type with
+  | Cty_signature _ | Cty_arrow _ -> Fresh
+  | Cty_constr(path, args, _) ->
+      let params = List.map repr clty.clty_params in
+      let args = List.map repr args in
+      if List.length params = List.length args
+      && List.for_all2 (==) params args
+      then Alias path
+      else if List.length params <= List.length args
+             || not (uniq args) then Fresh
+      else begin
+        match List.map (index params) args with
+        | exception Not_found -> Fresh
+        | ns -> Subst(path, ns)
+      end
+
+let short_paths_module_type_desc mty =
+  let open Short_paths.Desc.Module_type in
+  match mty with
+  | None -> Fresh
+  | Some (Mty_ident path) -> Alias path
+  | Some (Mty_signature _ | Mty_functor _) -> Fresh
+  | Some (Mty_alias _) -> assert false
+
+let deprecated_of_alerts alerts =
+  if
+    String.Map.exists (fun key _ ->
+      match key with
+      | "deprecated" | "ocaml.deprecated" -> true
+      | _ -> false
+    ) alerts
+  then
+    Short_paths.Desc.Deprecated
+  else
+    Short_paths.Desc.Not_deprecated
+
+let deprecated_of_attributes attrs =
+  deprecated_of_alerts (Builtin_attributes.alerts_of_attrs attrs)
+
+let rec short_paths_module_desc env mpath mty comp =
+  let open Short_paths.Desc.Module in
+  match mty with
+  | Mty_alias path -> Alias path
+  | Mty_ident path -> begin
+      match find_modtype_expansion path env with
+      | exception Not_found -> Fresh (Signature (lazy []))
+      | mty -> short_paths_module_desc env mpath mty comp
+    end
+  | Mty_signature _ ->
+      let components =
+        lazy (short_paths_module_components_desc env mpath comp)
+      in
+      Fresh (Signature components)
+  | Mty_functor _ ->
+      let apply path =
+        short_paths_functor_components_desc env mpath comp path
+      in
+      Fresh (Functor apply)
+
+and short_paths_module_components_desc env mpath comp =
+  match get_components comp with
+  | Functor_comps _ -> assert false
+  | Structure_comps c ->
+      let comps =
+        String.Map.fold (fun name { tda_declaration = decl; _ } acc ->
+          let desc = short_paths_type_desc decl in
+          let depr = deprecated_of_attributes decl.type_attributes in
+          let item = Short_paths.Desc.Module.Type(name, desc, depr) in
+          item :: acc
+        ) c.comp_types []
+      in
+      let comps =
+        String.Map.fold (fun name clty  acc ->
+          let desc = short_paths_class_type_desc clty in
+          let depr = deprecated_of_attributes clty.clty_attributes in
+          let item = Short_paths.Desc.Module.Class_type(name, desc, depr) in
+          item :: acc
+        ) c.comp_cltypes comps
+      in
+      let comps =
+        String.Map.fold (fun name mtd acc ->
+          let desc = short_paths_module_type_desc mtd.mtd_type in
+          let depr = deprecated_of_attributes mtd.mtd_attributes in
+          let item = Short_paths.Desc.Module.Module_type(name, desc, depr) in
+          item :: acc
+        ) c.comp_modtypes comps
+      in
+      let comps =
+        String.Map.fold (fun name { mda_declaration; mda_components; _ } acc ->
+          let mty = EnvLazy.force subst_modtype_maker mda_declaration in
+          let mpath = Pdot(mpath, name) in
+          let desc =
+            short_paths_module_desc env mpath mty.md_type mda_components
+          in
+          let depr = deprecated_of_alerts mda_components.alerts in
+          let item = Short_paths.Desc.Module.Module(name, desc, depr) in
+          item :: acc
+        ) c.comp_modules comps
+      in
+      comps
+
+and short_paths_functor_components_desc env mpath comp path =
+  match get_components comp with
+  | Structure_comps _ -> assert false
+  | Functor_comps f ->
+      let mty =
+        try
+          Hashtbl.find f.fcomp_subst_cache path
+        with Not_found ->
+          let mty =
+            let subst =
+              match f.fcomp_arg with
+              | Unit 
+              | Named (None, _) -> Subst.identity
+              | Named (Some id, _) -> Subst.add_module id path Subst.identity
+            in
+            Subst.modtype (Rescope (Path.scope (Papply (mpath, path))))
+              subst f.fcomp_res
+          in
+          Hashtbl.add f.fcomp_subst_cache path mty;
+          mty
+      in
+      let loc = Location.(in_file !input_name) in
+      let comps = components_of_functor_appl ~loc f env mpath path in
+      let mpath = Papply(mpath, path) in
+      short_paths_module_desc env mpath mty comps
+
+let short_paths_additions_desc env additions =
+  List.fold_left
+    (fun acc add ->
+       match add with
+       | Type(id, decl) ->
+           let desc = short_paths_type_desc decl in
+           let source = Short_paths.Desc.Local in
+           let depr = deprecated_of_attributes decl.type_attributes in
+           Short_paths.Desc.Type(id, desc, source, depr) :: acc
+       | Class_type(id, clty) ->
+           let desc = short_paths_class_type_desc clty in
+           let source = Short_paths.Desc.Local in
+           let depr = deprecated_of_attributes clty.clty_attributes in
+           Short_paths.Desc.Class_type(id, desc, source, depr) :: acc
+       | Module_type(id, mtd) ->
+           let desc = short_paths_module_type_desc mtd.mtd_type in
+           let source = Short_paths.Desc.Local in
+           let depr = deprecated_of_attributes mtd.mtd_attributes in
+           Short_paths.Desc.Module_type(id, desc, source, depr) :: acc
+       | Module(id, md, comps) ->
+           let desc =
+             short_paths_module_desc env (Pident id) md.md_type comps
+           in
+           let source = Short_paths.Desc.Local in
+           let depr = deprecated_of_alerts comps.alerts in
+           Short_paths.Desc.Module(id, desc, source, depr) :: acc
+       | Type_open(root, decls) ->
+           String.Map.fold
+             (fun name { tda_declaration = decl; _ } acc ->
+                let id = Ident.create_local name in
+                let path = Pdot(root, name) in
+                let desc = Short_paths.Desc.Type.Alias path in
+                let source = Short_paths.Desc.Open in
+                let depr = deprecated_of_attributes decl.type_attributes in
+                Short_paths.Desc.Type(id, desc, source, depr) :: acc)
+             decls acc
+       | Class_type_open(root, decls) ->
+           String.Map.fold
+             (fun name clty acc ->
+                let id = Ident.create_local name in
+                let path = Pdot(root, name) in
+                let desc = Short_paths.Desc.Class_type.Alias path in
+                let source = Short_paths.Desc.Open in
+                let depr = deprecated_of_attributes clty.clty_attributes in
+                Short_paths.Desc.Class_type(id, desc, source, depr) :: acc)
+             decls acc
+       | Module_type_open(root, decls) ->
+           String.Map.fold
+             (fun name mtd acc ->
+                let id = Ident.create_local name in
+                let path = Pdot(root, name) in
+                let desc = Short_paths.Desc.Module_type.Alias path in
+                let source = Short_paths.Desc.Open in
+                let depr = deprecated_of_attributes mtd.mtd_attributes in
+                Short_paths.Desc.Module_type(id, desc, source, depr) :: acc)
+             decls acc
+       | Module_open(root, decls) ->
+           String.Map.fold
+             (fun name { mda_components = comps; _ } acc ->
+                let id = Ident.create_local name in
+                let path = Pdot(root, name) in
+                let desc = Short_paths.Desc.Module.Alias path in
+                let source = Short_paths.Desc.Open in
+                let depr = deprecated_of_alerts comps.alerts in
+                Short_paths.Desc.Module(id, desc, source, depr) :: acc)
+             decls acc)
+    [] additions
+
+let () =
+  short_paths_module_components_desc' := short_paths_module_components_desc
+
+let update_short_paths env =
+  let env, short_paths =
+    match env.short_paths with
+    | None ->
+      let basis = Persistent_env.short_paths_basis !persistent_env in
+      let short_paths = Short_paths.initial basis in
+      let env = { env with short_paths = Some short_paths } in
+      env, short_paths
+    | Some short_paths -> env, short_paths
+  in
+  match env.short_paths_additions with
+  | [] -> env
+  | _ :: _ as additions ->
+    let short_paths =
+      Short_paths.add short_paths
+        (lazy (short_paths_additions_desc env additions))
+    in
+    { env with short_paths = Some short_paths;
+               short_paths_additions = []; }
+
+let short_paths env =
+  match env.short_paths with
+  | None ->
+    let basis = Persistent_env.short_paths_basis !persistent_env in
+    Short_paths.initial basis
+  | Some short_paths -> short_paths
+
+
+let fold_type_decls = fold_types
diff --git a/src/ocaml/typing/410+multicore/env.mli b/src/ocaml/typing/410+multicore/env.mli
new file mode 100644
index 00000000..c88b40a2
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/env.mli
@@ -0,0 +1,487 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Environment handling *)
+
+open Types
+open Misc
+
+type value_unbound_reason =
+  | Val_unbound_instance_variable
+  | Val_unbound_self
+  | Val_unbound_ancestor
+  | Val_unbound_ghost_recursive of Location.t
+
+type module_unbound_reason =
+  | Mod_unbound_illegal_recursion
+
+type summary =
+    Env_empty
+  | Env_value of summary * Ident.t * value_description
+  | Env_type of summary * Ident.t * type_declaration
+  | Env_extension of summary * Ident.t * extension_constructor
+  | Env_module of summary * Ident.t * module_presence * module_declaration
+  | Env_modtype of summary * Ident.t * modtype_declaration
+  | Env_class of summary * Ident.t * class_declaration
+  | Env_cltype of summary * Ident.t * class_type_declaration
+  | Env_open of summary * Path.t
+  (** The string set argument of [Env_open] represents a list of module names
+      to skip, i.e. that won't be imported in the toplevel namespace. *)
+  | Env_functor_arg of summary * Ident.t
+  | Env_constraints of summary * type_declaration Path.Map.t
+  | Env_copy_types of summary
+  | Env_persistent of summary * Ident.t
+  | Env_value_unbound of summary * string * value_unbound_reason
+  | Env_module_unbound of summary * string * module_unbound_reason
+
+type address =
+  | Aident of Ident.t
+  | Adot of address * int
+
+type t
+
+val empty: t
+val initial_safe_string: t
+val initial_unsafe_string: t
+val diff: t -> t -> Ident.t list
+val copy_local: from:t -> t -> t
+
+type type_descriptions =
+    constructor_description list * label_description list
+
+(* For short-paths *)
+type iter_cont
+val iter_types:
+    (Path.t -> Path.t * type_declaration -> unit) ->
+    t -> iter_cont
+val run_iter_cont: iter_cont list -> (Path.t * iter_cont) list
+val same_types: t -> t -> bool
+val used_persistent: unit -> Concr.t
+val find_shadowed_types: Path.t -> t -> Path.t list
+val without_cmis: ('a -> 'b) -> 'a -> 'b
+(* [without_cmis f arg] applies [f] to [arg], but does not
+   allow opening cmis during its execution *)
+
+(* Lookup by paths *)
+
+val find_value: Path.t -> t -> value_description
+val find_type: Path.t -> t -> type_declaration
+val find_type_descrs: Path.t -> t -> type_descriptions
+val find_module: Path.t -> t -> module_declaration
+val find_modtype: Path.t -> t -> modtype_declaration
+val find_class: Path.t -> t -> class_declaration
+val find_cltype: Path.t -> t -> class_type_declaration
+
+val find_ident_constructor: Ident.t -> t -> constructor_description
+val find_ident_label: Ident.t -> t -> label_description
+
+val find_type_expansion:
+    Path.t -> t -> type_expr list * type_expr * int
+val find_type_expansion_opt:
+    Path.t -> t -> type_expr list * type_expr * int
+(* Find the manifest type information associated to a type for the sake
+   of the compiler's type-based optimisations. *)
+val find_modtype_expansion: Path.t -> t -> module_type
+
+val find_hash_type: Path.t -> t -> type_declaration
+(* Find the "#t" type given the path for "t" *)
+
+val find_value_address: Path.t -> t -> address
+val find_module_address: Path.t -> t -> address
+val find_class_address: Path.t -> t -> address
+val find_constructor_address: Path.t -> t -> address
+
+val add_functor_arg: Ident.t -> t -> t
+val is_functor_arg: Path.t -> t -> bool
+
+val normalize_module_path: Location.t option -> t -> Path.t -> Path.t
+(* Normalize the path to a concrete module.
+   If the option is None, allow returning dangling paths.
+   Otherwise raise a Missing_module error, and may add forgotten
+   head as required global. *)
+
+val normalize_type_path: Location.t option -> t -> Path.t -> Path.t
+(* Normalize the prefix part of the type path *)
+
+val normalize_path_prefix: Location.t option -> t -> Path.t -> Path.t
+(* Normalize the prefix part of other kinds of paths
+   (value/modtype/etc) *)
+
+
+val reset_required_globals: unit -> unit
+val get_required_globals: unit -> Ident.t list
+val add_required_global: Ident.t -> unit
+
+val has_local_constraints: t -> bool
+
+(* Mark definitions as used *)
+val mark_value_used: string -> value_description -> unit
+val mark_module_used: string -> Location.t -> unit
+val mark_type_used: string -> type_declaration -> unit
+
+type constructor_usage = Positive | Pattern | Privatize
+val mark_constructor_used:
+    constructor_usage -> string -> constructor_declaration -> unit
+val mark_extension_used:
+    constructor_usage -> string -> extension_constructor -> unit
+
+(* Lookup by long identifiers *)
+
+(* Lookup errors *)
+
+type unbound_value_hint =
+  | No_hint
+  | Missing_rec of Location.t
+
+type lookup_error =
+  | Unbound_value of Longident.t * unbound_value_hint
+  | Unbound_type of Longident.t
+  | Unbound_constructor of Longident.t
+  | Unbound_label of Longident.t
+  | Unbound_module of Longident.t
+  | Unbound_class of Longident.t
+  | Unbound_modtype of Longident.t
+  | Unbound_cltype of Longident.t
+  | Unbound_instance_variable of string
+  | Not_an_instance_variable of string
+  | Masked_instance_variable of Longident.t
+  | Masked_self_variable of Longident.t
+  | Masked_ancestor_variable of Longident.t
+  | Structure_used_as_functor of Longident.t
+  | Abstract_used_as_functor of Longident.t
+  | Functor_used_as_structure of Longident.t
+  | Abstract_used_as_structure of Longident.t
+  | Generative_used_as_applicative of Longident.t
+  | Illegal_reference_to_recursive_module
+  | Cannot_scrape_alias of Longident.t * Path.t
+
+val lookup_error: Location.t -> t -> lookup_error -> 'a
+
+(* The [lookup_foo] functions will emit proper error messages (by
+   raising [Error]) if the identifier cannot be found, whereas the
+   [find_foo_by_name] functions will raise [Not_found] instead.
+
+   The [~use] parameters of the [lookup_foo] functions control
+   whether this lookup should be counted as a use for usage
+   warnings and alerts.
+
+   [Longident.t]s in the program source should be looked up using
+   [lookup_foo ~use:true] exactly one time -- otherwise warnings may be
+   emitted the wrong number of times. *)
+
+val lookup_value:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * value_description
+val lookup_type:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * type_declaration
+val lookup_module:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * module_declaration
+val lookup_modtype:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * modtype_declaration
+val lookup_class:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * class_declaration
+val lookup_cltype:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  Path.t * class_type_declaration
+
+val lookup_module_path:
+  ?use:bool -> loc:Location.t -> load:bool -> Longident.t -> t -> Path.t
+
+val lookup_constructor:
+  ?use:bool -> loc:Location.t -> constructor_usage -> Longident.t -> t ->
+  constructor_description
+val lookup_all_constructors:
+  ?use:bool -> loc:Location.t -> constructor_usage -> Longident.t -> t ->
+  ((constructor_description * (unit -> unit)) list,
+   Location.t * t * lookup_error) result
+val lookup_all_constructors_from_type:
+  ?use:bool -> loc:Location.t -> constructor_usage -> Path.t -> t ->
+  (constructor_description * (unit -> unit)) list
+
+val lookup_label:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  label_description
+val lookup_all_labels:
+  ?use:bool -> loc:Location.t -> Longident.t -> t ->
+  ((label_description * (unit -> unit)) list,
+   Location.t * t * lookup_error) result
+val lookup_all_labels_from_type:
+  ?use:bool -> loc:Location.t -> Path.t -> t ->
+  (label_description * (unit -> unit)) list
+
+val lookup_instance_variable:
+  ?use:bool -> loc:Location.t -> string -> t ->
+  Path.t * Asttypes.mutable_flag * string * type_expr
+
+val find_value_by_name:
+  Longident.t -> t -> Path.t * value_description
+val find_type_by_name:
+  Longident.t -> t -> Path.t * type_declaration
+val find_module_by_name:
+  Longident.t -> t -> Path.t * module_declaration
+val find_modtype_by_name:
+  Longident.t -> t -> Path.t * modtype_declaration
+val find_class_by_name:
+  Longident.t -> t -> Path.t * class_declaration
+val find_cltype_by_name:
+  Longident.t -> t -> Path.t * class_type_declaration
+
+val find_constructor_by_name:
+  Longident.t -> t -> constructor_description
+val find_label_by_name:
+  Longident.t -> t -> label_description
+
+(* Check if a name is bound *)
+
+val bound_value: string -> t -> bool
+val bound_module: string -> t -> bool
+val bound_type: string -> t -> bool
+val bound_modtype: string -> t -> bool
+val bound_class: string -> t -> bool
+val bound_cltype: string -> t -> bool
+
+val make_copy_of_types: t -> (t -> t)
+
+(* Insertion by identifier *)
+
+val add_value:
+    ?check:(string -> Warnings.t) -> Ident.t -> value_description -> t -> t
+val add_type: check:bool -> Ident.t -> type_declaration -> t -> t
+val add_extension: check:bool -> Ident.t -> extension_constructor -> t -> t
+val add_module:
+  ?arg:bool -> Ident.t -> module_presence -> module_type -> t -> t
+val add_module_declaration: ?arg:bool -> check:bool -> Ident.t ->
+  module_presence -> module_declaration -> t -> t
+val add_modtype: Ident.t -> modtype_declaration -> t -> t
+val add_class: Ident.t -> class_declaration -> t -> t
+val add_cltype: Ident.t -> class_type_declaration -> t -> t
+val add_local_type: Path.t -> type_declaration -> t -> t
+
+(* Insertion of persistent signatures *)
+
+(* [add_persistent_structure id env] is an environment such that
+   module [id] points to the persistent structure contained in the
+   external compilation unit with the same name.
+
+   The compilation unit itself is looked up in the load path when the
+   contents of the module is accessed. *)
+val add_persistent_structure : Ident.t -> t -> t
+
+(* Returns the set of persistent structures found in the given
+   directory. *)
+val persistent_structures_of_dir : Load_path.Dir.t -> Misc.String.Set.t
+
+(* [filter_non_loaded_persistent f env] removes all the persistent
+   structures that are not yet loaded and for which [f] returns
+   [false]. *)
+val filter_non_loaded_persistent : (Ident.t -> bool) -> t -> t
+
+(* Insertion of all fields of a signature. *)
+
+val add_item: signature_item -> t -> t
+val add_signature: signature -> t -> t
+
+(* Insertion of all fields of a signature, relative to the given path.
+   Used to implement open. Returns None if the path refers to a functor,
+   not a structure. *)
+val open_signature:
+    ?used_slot:bool ref ->
+    ?loc:Location.t -> ?toplevel:bool ->
+    Asttypes.override_flag -> Path.t ->
+      t -> t option
+
+val open_pers_signature: string -> t -> t
+
+(* Insertion by name *)
+
+val enter_value:
+    ?check:(string -> Warnings.t) ->
+    string -> value_description -> t -> Ident.t * t
+val enter_type: scope:int -> string -> type_declaration -> t -> Ident.t * t
+val enter_extension:
+  scope:int -> string -> extension_constructor -> t -> Ident.t * t
+val enter_module:
+  scope:int -> ?arg:bool -> string -> module_presence ->
+  module_type -> t -> Ident.t * t
+val enter_module_declaration:
+  scope:int -> ?arg:bool -> string -> module_presence ->
+  module_declaration -> t -> Ident.t * t
+val enter_modtype:
+  scope:int -> string -> modtype_declaration -> t -> Ident.t * t
+val enter_class: scope:int -> string -> class_declaration -> t -> Ident.t * t
+val enter_cltype:
+  scope:int -> string -> class_type_declaration -> t -> Ident.t * t
+
+(* Same as [add_signature] but refreshes (new stamp) and rescopes bound idents
+   in the process. *)
+val enter_signature: scope:int -> signature -> t -> signature * t
+
+val enter_unbound_value : string -> value_unbound_reason -> t -> t
+
+val enter_unbound_module : string -> module_unbound_reason -> t -> t
+
+(* Initialize the cache of in-core module interfaces. *)
+val reset_cache: unit -> unit
+
+(* To be called before each toplevel phrase. *)
+val reset_cache_toplevel: unit -> unit
+
+(* Remember the name of the current compilation unit. *)
+val set_unit_name: string -> unit
+val get_unit_name: unit -> string
+
+(* Read, save a signature to/from a file *)
+val read_signature: modname -> filepath -> signature
+        (* Arguments: module name, file name. Results: signature. *)
+val save_signature:
+  alerts:alerts -> signature -> modname -> filepath
+  -> Cmi_format.cmi_infos
+        (* Arguments: signature, module name, file name. *)
+val save_signature_with_imports:
+  alerts:alerts -> signature -> modname -> filepath -> crcs
+  -> Cmi_format.cmi_infos
+        (* Arguments: signature, module name, file name,
+           imported units with their CRCs. *)
+
+(* Return the CRC of the interface of the given compilation unit *)
+val crc_of_unit: modname -> Digest.t
+
+(* Return the set of compilation units imported, with their CRC *)
+val imports: unit -> crcs
+
+(* may raise Persistent_env.Consistbl.Inconsistency *)
+val import_crcs: source:string -> crcs -> unit
+
+(* [is_imported_opaque md] returns true if [md] is an opaque imported module  *)
+val is_imported_opaque: modname -> bool
+
+(* Summaries -- compact representation of an environment, to be
+   exported in debugging information. *)
+
+val summary: t -> summary
+
+(* Return an equivalent environment where all fields have been reset,
+   except the summary. The initial environment can be rebuilt from the
+   summary, using Envaux.env_of_only_summary. *)
+
+val keep_only_summary : t -> t
+val env_of_only_summary : (summary -> Subst.t -> t) -> t -> t
+
+(* Update the short paths table *)
+val update_short_paths : t -> t
+
+(* Return the short paths table *)
+val short_paths : t -> Short_paths.t
+
+(* Error report *)
+
+type error =
+  | Missing_module of Location.t * Path.t * Path.t
+  | Illegal_value_name of Location.t * string
+  | Lookup_error of Location.t * t * lookup_error
+
+exception Error of error
+
+open Format
+
+val report_error: formatter -> error -> unit
+
+val report_lookup_error: Location.t -> t -> formatter -> lookup_error -> unit
+
+val in_signature: bool -> t -> t
+
+val is_in_signature: t -> bool
+
+val set_value_used_callback:
+    string -> value_description -> (unit -> unit) -> unit
+val set_type_used_callback:
+    string -> type_declaration -> ((unit -> unit) -> unit) -> unit
+
+(* Forward declaration to break mutual recursion with Includemod. *)
+val check_functor_application:
+      (errors:bool -> loc:Location.t -> t -> module_type ->
+         Path.t -> module_type -> Path.t -> unit) ref
+(* Forward declaration to break mutual recursion with Typemod. *)
+val check_well_formed_module:
+    (t -> Location.t -> string -> module_type -> unit) ref
+(* Forward declaration to break mutual recursion with Typecore. *)
+val add_delayed_check_forward: ((unit -> unit) -> unit) ref
+(* Forward declaration to break mutual recursion with Mtype. *)
+val strengthen:
+    (aliasable:bool -> t -> module_type -> Path.t -> module_type) ref
+(* Forward declaration to break mutual recursion with Ctype. *)
+val same_constr: (t -> type_expr -> type_expr -> bool) ref
+(* Forward declaration to break mutual recursion with Printtyp. *)
+val print_longident: (Format.formatter -> Longident.t -> unit) ref
+(* Forward declaration to break mutual recursion with Printtyp. *)
+val print_path: (Format.formatter -> Path.t -> unit) ref
+
+(* Forward declaration to break mutual recursion with Printtyp *)
+val shorten_module_path : (t -> Path.t -> Path.t) ref
+
+(** Folding over all identifiers (for analysis purpose) *)
+
+val fold_values:
+  (string -> Path.t -> value_description -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_types:
+  (string -> Path.t -> type_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_type_decls:
+  (string -> Path.t -> type_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_constructors:
+  (constructor_description -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_labels:
+  (label_description -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+
+(** Persistent structures are only traversed if they are already loaded. *)
+val fold_modules:
+  (string -> Path.t -> module_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+
+val fold_modtypes:
+  (string -> Path.t -> modtype_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_classes:
+  (string -> Path.t -> class_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+val fold_cltypes:
+  (string -> Path.t -> class_type_declaration -> 'a -> 'a) ->
+  Longident.t option -> t -> 'a -> 'a
+
+(** Utilities *)
+val scrape_alias: t -> module_type -> module_type
+val check_value_name: string -> Location.t -> unit
+
+val print_address : Format.formatter -> address -> unit
+
+val unbound_class : Path.t
+
+(** merlin: manage internal state *)
+
+val check_state_consistency: unit -> bool
+
+val with_cmis : (unit -> 'a) -> 'a
+
+(* helper for merlin *)
+
+val add_merlin_extension_module: Ident.t -> module_type -> t -> t
diff --git a/src/ocaml/typing/410+multicore/ident.ml b/src/ocaml/typing/410+multicore/ident.ml
new file mode 100644
index 00000000..ddf98c74
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/ident.ml
@@ -0,0 +1,361 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Local_store.Compiler
+
+let lowest_scope  = 0
+let highest_scope = 100000000
+
+type t =
+  | Local of { name: string; stamp: int }
+  | Scoped of { name: string; stamp: int; scope: int }
+  | Global of string
+  | Predef of { name: string; stamp: int }
+      (* the stamp is here only for fast comparison, but the name of
+         predefined identifiers is always unique. *)
+
+(* A stamp of 0 denotes a persistent identifier *)
+
+let currentstamp = s_ref 0
+let predefstamp = s_ref 0
+
+let create_scoped ~scope s =
+  incr currentstamp;
+  Scoped { name = s; stamp = !currentstamp; scope }
+
+let create_local s =
+  incr currentstamp;
+  Local { name = s; stamp = !currentstamp }
+
+let create_predef s =
+  incr predefstamp;
+  Predef { name = s; stamp = !predefstamp }
+
+let create_persistent s =
+  Global s
+
+let name = function
+  | Local { name; _ }
+  | Scoped { name; _ }
+  | Global name
+  | Predef { name; _ } -> name
+
+let rename = function
+  | Local { name; stamp = _ }
+  | Scoped { name; stamp = _; scope = _ } ->
+      incr currentstamp;
+      Local { name; stamp = !currentstamp }
+  | id ->
+      Misc.fatal_errorf "Ident.rename %s" (name id)
+
+let unique_name = function
+  | Local { name; stamp }
+  | Scoped { name; stamp } -> name ^ "_" ^ Int.to_string stamp
+  | Global name ->
+      (* we're adding a fake stamp, because someone could have named his unit
+         [Foo_123] and since we're using unique_name to produce symbol names,
+         we might clash with an ident [Local { "Foo"; 123 }]. *)
+      name ^ "_0"
+  | Predef { name; _ } ->
+      (* we know that none of the predef names (currently) finishes in
+         "_<some number>", and that their name is unique. *)
+      name
+
+let unique_toplevel_name = function
+  | Local { name; stamp }
+  | Scoped { name; stamp } -> name ^ "/" ^ Int.to_string stamp
+  | Global name
+  | Predef { name; _ } -> name
+
+let persistent = function
+  | Global _ -> true
+  | _ -> false
+
+let equal i1 i2 =
+  match i1, i2 with
+  | Local { name = name1; _ }, Local { name = name2; _ }
+  | Scoped { name = name1; _ }, Scoped { name = name2; _ }
+  | Global name1, Global name2 ->
+      name1 = name2
+  | Predef { stamp = s1; _ }, Predef { stamp = s2 } ->
+      (* if they don't have the same stamp, they don't have the same name *)
+      s1 = s2
+  | _ ->
+      false
+
+let same i1 i2 = i1 = i2
+  (* Possibly more efficient version (with a real compiler, at least):
+       if i1.stamp <> 0
+       then i1.stamp = i2.stamp
+       else i2.stamp = 0 && i1.name = i2.name *)
+
+let compare i1 i2 = Stdlib.compare i1 i2
+
+let stamp = function
+  | Local { stamp; _ }
+  | Scoped { stamp; _ } -> stamp
+  | _ -> 0
+
+let scope = function
+  | Scoped { scope; _ } -> scope
+  | Local _ -> highest_scope
+  | Global _ | Predef _ -> lowest_scope
+
+let reinit_level = ref (-1)
+
+let reinit () =
+  if !reinit_level < 0
+  then reinit_level := !currentstamp
+  else currentstamp := !reinit_level
+
+let global = function
+  | Local _
+  | Scoped _ -> false
+  | Global _
+  | Predef _ -> true
+
+let is_predef = function
+  | Predef _ -> true
+  | _ -> false
+
+let print ~with_scope ppf =
+  let open Format in
+  function
+  | Global name -> fprintf ppf "%s!" name
+  | Predef { name; stamp = n } ->
+      fprintf ppf "%s/%i!" name n
+  | Local { name; stamp = n } ->
+      fprintf ppf "%s/%i" name n
+  | Scoped { name; stamp = n; scope } ->
+      fprintf ppf "%s/%i%s" name n
+        (if with_scope then sprintf "[%i]" scope else "")
+
+let print_with_scope ppf id = print ~with_scope:true ppf id
+
+let print ppf id = print ~with_scope:false ppf id
+
+type 'a tbl =
+    Empty
+  | Node of 'a tbl * 'a data * 'a tbl * int
+
+and 'a data =
+  { ident: t;
+    data: 'a;
+    previous: 'a data option }
+
+let empty = Empty
+
+(* Inline expansion of height for better speed
+ * let height = function
+ *     Empty -> 0
+ *   | Node(_,_,_,h) -> h
+ *)
+
+let mknode l d r =
+  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
+  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
+  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))
+
+let balance l d r =
+  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
+  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
+  if hl > hr + 1 then
+    match l with
+    | Node (ll, ld, lr, _)
+      when (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
+           (match lr with Empty -> 0 | Node(_,_,_,h) -> h) ->
+        mknode ll ld (mknode lr d r)
+    | Node (ll, ld, Node(lrl, lrd, lrr, _), _) ->
+        mknode (mknode ll ld lrl) lrd (mknode lrr d r)
+    | _ -> assert false
+  else if hr > hl + 1 then
+    match r with
+    | Node (rl, rd, rr, _)
+      when (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
+           (match rl with Empty -> 0 | Node(_,_,_,h) -> h) ->
+        mknode (mknode l d rl) rd rr
+    | Node (Node (rll, rld, rlr, _), rd, rr, _) ->
+        mknode (mknode l d rll) rld (mknode rlr rd rr)
+    | _ -> assert false
+  else
+    mknode l d r
+
+let rec add id data = function
+    Empty ->
+      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
+  | Node(l, k, r, h) ->
+      let c = compare (name id) (name k.ident) in
+      if c = 0 then
+        Node(l, {ident = id; data = data; previous = Some k}, r, h)
+      else if c < 0 then
+        balance (add id data l) k r
+      else
+        balance l k (add id data r)
+
+let rec min_binding = function
+    Empty -> raise Not_found
+  | Node (Empty, d, _, _) -> d
+  | Node (l, _, _, _) -> min_binding l
+
+let rec remove_min_binding = function
+    Empty -> invalid_arg "Map.remove_min_elt"
+  | Node (Empty, _, r, _) -> r
+  | Node (l, d, r, _) -> balance (remove_min_binding l) d r
+
+let merge t1 t2 =
+  match (t1, t2) with
+    (Empty, t) -> t
+  | (t, Empty) -> t
+  | (_, _) ->
+      let d = min_binding t2 in
+      balance t1 d (remove_min_binding t2)
+
+let rec remove id = function
+    Empty ->
+      Empty
+  | (Node (l, k, r, h) as m) ->
+      let c = compare (name id) (name k.ident) in
+      if c = 0 then
+        match k.previous with
+        | None -> merge l r
+        | Some k -> Node (l, k, r, h)
+      else if c < 0 then
+        let ll = remove id l in if l == ll then m else balance ll k r
+      else
+        let rr = remove id r in if r == rr then m else balance l k rr
+
+let rec find_previous id = function
+    None ->
+      raise Not_found
+  | Some k ->
+      if same id k.ident then k.data else find_previous id k.previous
+
+let rec find_same id = function
+    Empty ->
+      raise Not_found
+  | Node(l, k, r, _) ->
+      let c = compare (name id) (name k.ident) in
+      if c = 0 then
+        if same id k.ident
+        then k.data
+        else find_previous id k.previous
+      else
+        find_same id (if c < 0 then l else r)
+
+let rec find_name n = function
+    Empty ->
+      raise Not_found
+  | Node(l, k, r, _) ->
+      let c = compare n (name k.ident) in
+      if c = 0 then
+        k.ident, k.data
+      else
+        find_name n (if c < 0 then l else r)
+
+let rec get_all = function
+  | None -> []
+  | Some k -> (k.ident, k.data) :: get_all k.previous
+
+let rec find_all n = function
+    Empty ->
+      []
+  | Node(l, k, r, _) ->
+      let c = compare n (name k.ident) in
+      if c = 0 then
+        (k.ident, k.data) :: get_all k.previous
+      else
+        find_all n (if c < 0 then l else r)
+
+let rec fold_aux f stack accu = function
+    Empty ->
+      begin match stack with
+        [] -> accu
+      | a :: l -> fold_aux f l accu a
+      end
+  | Node(l, k, r, _) ->
+      fold_aux f (l :: stack) (f k accu) r
+
+let fold_name f tbl accu = fold_aux (fun k -> f k.ident k.data) [] accu tbl
+
+let rec fold_data f d accu =
+  match d with
+    None -> accu
+  | Some k -> f k.ident k.data (fold_data f k.previous accu)
+
+let fold_all f tbl accu =
+  fold_aux (fun k -> fold_data f (Some k)) [] accu tbl
+
+(* let keys tbl = fold_name (fun k _ accu -> k::accu) tbl [] *)
+
+let rec iter f = function
+    Empty -> ()
+  | Node(l, k, r, _) ->
+      iter f l; f k.ident k.data; iter f r
+
+(* Idents for sharing keys *)
+
+(* They should be 'totally fresh' -> neg numbers *)
+let key_name = ""
+
+let make_key_generator () =
+  let c = ref 1 in
+  function
+  | Local _
+  | Scoped _ ->
+      let stamp = !c in
+      decr c ;
+      Local { name = key_name; stamp = stamp }
+  | global_id ->
+      Misc.fatal_errorf "Ident.make_key_generator () %s" (name global_id)
+
+let compare x y =
+  match x, y with
+  | Local x, Local y ->
+      let c = x.stamp - y.stamp in
+      if c <> 0 then c
+      else compare x.name y.name
+  | Local _, _ -> 1
+  | _, Local _ -> (-1)
+  | Scoped x, Scoped y ->
+      let c = x.stamp - y.stamp in
+      if c <> 0 then c
+      else compare x.name y.name
+  | Scoped _, _ -> 1
+  | _, Scoped _ -> (-1)
+  | Global x, Global y -> compare x y
+  | Global _, _ -> 1
+  | _, Global _ -> (-1)
+  | Predef { stamp = s1; _ }, Predef { stamp = s2; _ } -> compare s1 s2
+
+let output oc id = output_string oc (unique_name id)
+let hash i = (Char.code (name i).[0]) lxor (stamp i)
+
+let original_equal = equal
+include Identifiable.Make (struct
+  type nonrec t = t
+  let compare = compare
+  let output = output
+  let print = print
+  let hash = hash
+  let equal = same
+end)
+let equal = original_equal
+
+let rename_no_exn = function
+  | Local { name; stamp = _ }
+  | Scoped { name; stamp = _; scope = _ } ->
+      incr currentstamp;
+      Local { name; stamp = !currentstamp }
+  | id -> id
diff --git a/src/ocaml/typing/410+multicore/ident.mli b/src/ocaml/typing/410+multicore/ident.mli
new file mode 100644
index 00000000..08ae2b13
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/ident.mli
@@ -0,0 +1,86 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Identifiers (unique names) *)
+
+type t
+
+include Identifiable.S with type t := t
+(* Notes:
+   - [equal] compares identifiers by name
+   - [compare x y] is 0 if [same x y] is true.
+   - [compare] compares identifiers by binding location
+*)
+
+val print_with_scope : Format.formatter -> t -> unit
+        (** Same as {!print} except that it will also add a "[n]" suffix
+            if the scope of the argument is [n]. *)
+
+
+val create_scoped: scope:int -> string -> t
+val create_local: string -> t
+val create_persistent: string -> t
+val create_predef: string -> t
+
+val rename: t -> t
+        (** Creates an identifier with the same name as the input, a fresh
+            stamp, and no scope.
+            @raises [Fatal_error] if called on a persistent / predef ident. *)
+
+val name: t -> string
+val unique_name: t -> string
+val unique_toplevel_name: t -> string
+val persistent: t -> bool
+val same: t -> t -> bool
+        (** Compare identifiers by binding location.
+            Two identifiers are the same either if they are both
+            non-persistent and have been created by the same call to
+            [create_*], or if they are both persistent and have the same
+            name. *)
+
+val compare: t -> t -> int
+
+val global: t -> bool
+val is_predef: t -> bool
+
+val scope: t -> int
+val stamp: t -> int
+
+val lowest_scope : int
+val highest_scope: int
+
+val reinit: unit -> unit
+
+type 'a tbl
+        (* Association tables from identifiers to type 'a. *)
+
+val empty: 'a tbl
+val add: t -> 'a -> 'a tbl -> 'a tbl
+val find_same: t -> 'a tbl -> 'a
+val find_name: string -> 'a tbl -> t * 'a
+val find_all: string -> 'a tbl -> (t * 'a) list
+val fold_name: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
+val fold_all: (t -> 'a -> 'b -> 'b) -> 'a tbl -> 'b -> 'b
+val iter: (t -> 'a -> unit) -> 'a tbl -> unit
+val remove: t -> 'a tbl -> 'a tbl
+
+(* Idents for sharing keys *)
+
+val make_key_generator : unit -> (t -> t)
+
+(* merlin *)
+
+val rename_no_exn: t -> t
+        (** Like [rename], but does not fail on persistent/predef idents. *)
diff --git a/src/ocaml/typing/410+multicore/includeclass.ml b/src/ocaml/typing/410+multicore/includeclass.ml
new file mode 100644
index 00000000..483088d6
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includeclass.ml
@@ -0,0 +1,116 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Jerome Vouillon, projet Cristal, INRIA Rocquencourt          *)
+(*                                                                        *)
+(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the class language *)
+
+open Types
+
+let class_types env cty1 cty2 =
+  Ctype.match_class_types env cty1 cty2
+
+let class_type_declarations ~loc env cty1 cty2 =
+  Builtin_attributes.check_alerts_inclusion
+    ~def:cty1.clty_loc
+    ~use:cty2.clty_loc
+    loc
+    cty1.clty_attributes cty2.clty_attributes
+    (Path.last cty1.clty_path);
+  Ctype.match_class_declarations env
+    cty1.clty_params cty1.clty_type
+    cty2.clty_params cty2.clty_type
+
+let class_declarations env cty1 cty2 =
+  match cty1.cty_new, cty2.cty_new with
+    None, Some _ ->
+      [Ctype.CM_Virtual_class]
+  | _ ->
+      Ctype.match_class_declarations env
+        cty1.cty_params cty1.cty_type
+        cty2.cty_params cty2.cty_type
+
+open Format
+open Ctype
+
+(*
+let rec hide_params = function
+    Tcty_arrow ("*", _, cty) -> hide_params cty
+  | cty -> cty
+*)
+
+let include_err ppf =
+  function
+  | CM_Virtual_class ->
+      fprintf ppf "A class cannot be changed from virtual to concrete"
+  | CM_Parameter_arity_mismatch _ ->
+      fprintf ppf
+        "The classes do not have the same number of type parameters"
+  | CM_Type_parameter_mismatch (env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+          fprintf ppf "A type parameter has type")
+        (function ppf ->
+          fprintf ppf "but is expected to have type")
+  | CM_Class_type_mismatch (env, cty1, cty2) ->
+      Printtyp.wrap_printing_env ~error:true env (fun () ->
+        fprintf ppf
+          "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
+          Printtyp.class_type cty1
+          "is not matched by the class type"
+          Printtyp.class_type cty2)
+  | CM_Parameter_mismatch (env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+          fprintf ppf "A parameter has type")
+        (function ppf ->
+          fprintf ppf "but is expected to have type")
+  | CM_Val_type_mismatch (lab, env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+          fprintf ppf "The instance variable %s@ has type" lab)
+        (function ppf ->
+          fprintf ppf "but is expected to have type")
+  | CM_Meth_type_mismatch (lab, env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+          fprintf ppf "The method %s@ has type" lab)
+        (function ppf ->
+          fprintf ppf "but is expected to have type")
+  | CM_Non_mutable_value lab ->
+      fprintf ppf
+       "@[The non-mutable instance variable %s cannot become mutable@]" lab
+  | CM_Non_concrete_value lab ->
+      fprintf ppf
+       "@[The virtual instance variable %s cannot become concrete@]" lab
+  | CM_Missing_value lab ->
+      fprintf ppf "@[The first class type has no instance variable %s@]" lab
+  | CM_Missing_method lab ->
+      fprintf ppf "@[The first class type has no method %s@]" lab
+  | CM_Hide_public lab ->
+     fprintf ppf "@[The public method %s cannot be hidden@]" lab
+  | CM_Hide_virtual (k, lab) ->
+      fprintf ppf "@[The virtual %s %s cannot be hidden@]" k lab
+  | CM_Public_method lab ->
+      fprintf ppf "@[The public method %s cannot become private@]" lab
+  | CM_Virtual_method lab ->
+      fprintf ppf "@[The virtual method %s cannot become concrete@]" lab
+  | CM_Private_method lab ->
+      fprintf ppf "@[The private method %s cannot become public@]" lab
+
+let report_error ppf = function
+  |  [] -> ()
+  | err :: errs ->
+      let print_errs ppf errs =
+         List.iter (fun err -> fprintf ppf "@ %a" include_err err) errs in
+      fprintf ppf "@[<v>%a%a@]" include_err err print_errs errs
diff --git a/src/ocaml/typing/410+multicore/includeclass.mli b/src/ocaml/typing/410+multicore/includeclass.mli
new file mode 100644
index 00000000..ebfa9789
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includeclass.mli
@@ -0,0 +1,32 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Jerome Vouillon, projet Cristal, INRIA Rocquencourt          *)
+(*                                                                        *)
+(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the class language *)
+
+open Types
+open Ctype
+open Format
+
+val class_types:
+        Env.t -> class_type -> class_type -> class_match_failure list
+val class_type_declarations:
+  loc:Location.t ->
+  Env.t -> class_type_declaration -> class_type_declaration ->
+  class_match_failure list
+val class_declarations:
+  Env.t -> class_declaration -> class_declaration ->
+  class_match_failure list
+
+val report_error: formatter -> class_match_failure list -> unit
diff --git a/src/ocaml/typing/410+multicore/includecore.ml b/src/ocaml/typing/410+multicore/includecore.ml
new file mode 100644
index 00000000..87f02b8c
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includecore.ml
@@ -0,0 +1,511 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the core language *)
+
+open Asttypes
+open Path
+open Types
+open Typedtree
+
+(* Inclusion between value descriptions *)
+
+exception Dont_match
+
+let value_descriptions ~loc env name
+    (vd1 : Types.value_description)
+    (vd2 : Types.value_description) =
+  Builtin_attributes.check_alerts_inclusion
+    ~def:vd1.val_loc
+    ~use:vd2.val_loc
+    loc
+    vd1.val_attributes vd2.val_attributes
+    name;
+  if Ctype.moregeneral env true vd1.val_type vd2.val_type then begin
+    match (vd1.val_kind, vd2.val_kind) with
+        (Val_prim p1, Val_prim p2) ->
+          if p1 = p2 then Tcoerce_none else raise Dont_match
+      | (Val_prim p, _) ->
+          let pc = {pc_desc = p; pc_type = vd2.Types.val_type;
+                  pc_env = env; pc_loc = vd1.Types.val_loc; } in
+          Tcoerce_primitive pc
+      | (_, Val_prim _) -> raise Dont_match
+      | (_, _) -> Tcoerce_none
+  end else
+    raise Dont_match
+
+(* Inclusion between "private" annotations *)
+
+let private_flags decl1 decl2 =
+  match decl1.type_private, decl2.type_private with
+  | Private, Public ->
+      decl2.type_kind = Type_abstract &&
+      (decl2.type_manifest = None || decl1.type_kind <> Type_abstract)
+  | _, _ -> true
+
+(* Inclusion between manifest types (particularly for private row types) *)
+
+let is_absrow env ty =
+  match ty.desc with
+    Tconstr(Pident _, _, _) ->
+      begin match Ctype.expand_head env ty with
+        {desc=Tobject _|Tvariant _} -> true
+      | _ -> false
+      end
+  | _ -> false
+
+let type_manifest env ty1 params1 ty2 params2 priv2 =
+  let ty1' = Ctype.expand_head env ty1 and ty2' = Ctype.expand_head env ty2 in
+  match ty1'.desc, ty2'.desc with
+    Tvariant row1, Tvariant row2 when is_absrow env (Btype.row_more row2) ->
+      let row1 = Btype.row_repr row1 and row2 = Btype.row_repr row2 in
+      Ctype.equal env true (ty1::params1) (row2.row_more::params2) &&
+      begin match row1.row_more with
+        {desc=Tvar _|Tconstr _|Tnil} -> true
+      | _ -> false
+      end &&
+      let r1, r2, pairs =
+        Ctype.merge_row_fields row1.row_fields row2.row_fields in
+      (not row2.row_closed ||
+       row1.row_closed && Ctype.filter_row_fields false r1 = []) &&
+      List.for_all
+        (fun (_,f) -> match Btype.row_field_repr f with
+          Rabsent | Reither _ -> true | Rpresent _ -> false)
+        r2 &&
+      let to_equal = ref (List.combine params1 params2) in
+      List.for_all
+        (fun (_, f1, f2) ->
+          match Btype.row_field_repr f1, Btype.row_field_repr f2 with
+            Rpresent(Some t1),
+            (Rpresent(Some t2) | Reither(false, [t2], _, _)) ->
+              to_equal := (t1,t2) :: !to_equal; true
+          | Rpresent None, (Rpresent None | Reither(true, [], _, _)) -> true
+          | Reither(c1,tl1,_,_), Reither(c2,tl2,_,_)
+            when List.length tl1 = List.length tl2 && c1 = c2 ->
+              to_equal := List.combine tl1 tl2 @ !to_equal; true
+          | Rabsent, (Reither _ | Rabsent) -> true
+          | _ -> false)
+        pairs &&
+      let tl1, tl2 = List.split !to_equal in
+      Ctype.equal env true tl1 tl2
+  | Tobject (fi1, _), Tobject (fi2, _)
+    when is_absrow env (snd(Ctype.flatten_fields fi2)) ->
+      let (fields2,rest2) = Ctype.flatten_fields fi2 in
+      Ctype.equal env true (ty1::params1) (rest2::params2) &&
+      let (fields1,rest1) = Ctype.flatten_fields fi1 in
+      (match rest1 with {desc=Tnil|Tvar _|Tconstr _} -> true | _ -> false) &&
+      let pairs, _miss1, miss2 = Ctype.associate_fields fields1 fields2 in
+      miss2 = [] &&
+      let tl1, tl2 =
+        List.split (List.map (fun (_,_,t1,_,t2) -> t1, t2) pairs) in
+      Ctype.equal env true (params1 @ tl1) (params2 @ tl2)
+  | _ ->
+      let rec check_super ty1 =
+        Ctype.equal env true (ty1 :: params1) (ty2 :: params2) ||
+        priv2 = Private &&
+        try check_super
+              (Ctype.try_expand_once_opt env (Ctype.expand_head env ty1))
+        with Ctype.Cannot_expand -> false
+      in check_super ty1
+
+(* Inclusion between type declarations *)
+
+type position = Ctype.Unification_trace.position = First | Second
+
+let choose ord first second =
+  match ord with
+  | First -> first
+  | Second -> second
+
+let choose_other ord first second =
+  match ord with
+  | First -> choose Second first second
+  | Second -> choose First first second
+
+type label_mismatch =
+  | Type
+  | Mutability of position
+
+type record_mismatch =
+  | Label_mismatch of Types.label_declaration
+                      * Types.label_declaration
+                      * label_mismatch
+  | Label_names of int * Ident.t * Ident.t
+  | Label_missing of position * Ident.t
+  | Unboxed_float_representation of position
+
+type constructor_mismatch =
+  | Type
+  | Arity
+  | Inline_record of record_mismatch
+  | Kind of position
+  | Explicit_return_type of position
+
+type variant_mismatch =
+  | Constructor_mismatch of Types.constructor_declaration
+                            * Types.constructor_declaration
+                            * constructor_mismatch
+  | Constructor_names of int * Ident.t * Ident.t
+  | Constructor_missing of position * Ident.t
+
+type extension_constructor_mismatch =
+  | Constructor_privacy
+  | Constructor_mismatch of Ident.t
+                            * Types.extension_constructor
+                            * Types.extension_constructor
+                            * constructor_mismatch
+
+type type_mismatch =
+  | Arity
+  | Privacy
+  | Kind
+  | Constraint
+  | Manifest
+  | Variance
+  | Record_mismatch of record_mismatch
+  | Variant_mismatch of variant_mismatch
+  | Unboxed_representation of position
+  | Immediate of Type_immediacy.Violation.t
+
+let report_label_mismatch first second ppf err =
+  let pr fmt = Format.fprintf ppf fmt in
+  match (err : label_mismatch) with
+  | Type -> pr "The types are not equal."
+  | Mutability ord ->
+      pr "%s is mutable and %s is not."
+        (String.capitalize_ascii  (choose ord first second))
+        (choose_other ord first second)
+
+let report_record_mismatch first second decl ppf err =
+  let pr fmt = Format.fprintf ppf fmt in
+  match err with
+  | Label_mismatch (l1, l2, err) ->
+      pr
+        "@[<hv>Fields do not match:@;<1 2>%a@ is not compatible with:\
+         @;<1 2>%a@ %a"
+        Printtyp.label l1
+        Printtyp.label l2
+        (report_label_mismatch first second) err
+  | Label_names (n, name1, name2) ->
+      pr "@[<hv>Fields number %i have different names, %s and %s.@]"
+        n (Ident.name name1) (Ident.name name2)
+  | Label_missing (ord, s) ->
+      pr "@[<hv>The field %s is only present in %s %s.@]"
+        (Ident.name s) (choose ord first second) decl
+  | Unboxed_float_representation ord ->
+      pr "@[<hv>Their internal representations differ:@ %s %s %s.@]"
+        (choose ord first second) decl
+        "uses unboxed float representation"
+
+let report_constructor_mismatch first second decl ppf err =
+  let pr fmt  = Format.fprintf ppf fmt in
+  match (err : constructor_mismatch) with
+  | Type -> pr "The types are not equal."
+  | Arity -> pr "They have different arities."
+  | Inline_record err -> report_record_mismatch first second decl ppf err
+  | Kind ord ->
+      pr "%s uses inline records and %s doesn't."
+        (String.capitalize_ascii (choose ord first second))
+        (choose_other ord first second)
+  | Explicit_return_type ord ->
+      pr "%s has explicit return type and %s doesn't."
+        (String.capitalize_ascii (choose ord first second))
+        (choose_other ord first second)
+
+let report_variant_mismatch first second decl ppf err =
+  let pr fmt = Format.fprintf ppf fmt in
+  match (err : variant_mismatch) with
+  | Constructor_mismatch (c1, c2, err) ->
+      pr
+        "@[<hv>Constructors do not match:@;<1 2>%a@ is not compatible with:\
+         @;<1 2>%a@ %a"
+        Printtyp.constructor c1
+        Printtyp.constructor c2
+        (report_constructor_mismatch first second decl) err
+  | Constructor_names (n, name1, name2) ->
+      pr "Constructors number %i have different names, %s and %s."
+        n (Ident.name name1) (Ident.name name2)
+  | Constructor_missing (ord, s) ->
+      pr "The constructor %s is only present in %s %s."
+        (Ident.name s) (choose ord first second) decl
+
+let report_extension_constructor_mismatch first second decl ppf err =
+  let pr fmt = Format.fprintf ppf fmt in
+  match (err : extension_constructor_mismatch) with
+  | Constructor_privacy -> pr "A private type would be revealed."
+  | Constructor_mismatch (id, ext1, ext2, err) ->
+      pr "@[<hv>Constructors do not match:@;<1 2>%a@ is not compatible with:\
+          @;<1 2>%a@ %a@]"
+        (Printtyp.extension_only_constructor id) ext1
+        (Printtyp.extension_only_constructor id) ext2
+        (report_constructor_mismatch first second decl) err
+
+let report_type_mismatch0 first second decl ppf err =
+  let pr fmt = Format.fprintf ppf fmt in
+  match err with
+  | Arity -> pr "They have different arities."
+  | Privacy -> pr "A private type would be revealed."
+  | Kind -> pr "Their kinds differ."
+  | Constraint -> pr "Their constraints differ."
+  | Manifest -> ()
+  | Variance -> pr "Their variances do not agree."
+  | Record_mismatch err -> report_record_mismatch first second decl ppf err
+  | Variant_mismatch err -> report_variant_mismatch first second decl ppf err
+  | Unboxed_representation ord ->
+      pr "Their internal representations differ:@ %s %s %s."
+         (choose ord first second) decl
+         "uses unboxed representation"
+  | Immediate violation ->
+      let first = StringLabels.capitalize_ascii first in
+      match violation with
+      | Type_immediacy.Violation.Not_always_immediate ->
+          pr "%s is not an immediate type." first
+      | Type_immediacy.Violation.Not_always_immediate_on_64bits ->
+          pr "%s is not a type that is always immediate on 64 bit platforms."
+            first
+
+let report_type_mismatch first second decl ppf err =
+  if err = Manifest then () else
+  Format.fprintf ppf "@ %a" (report_type_mismatch0 first second decl) err
+
+let rec compare_constructor_arguments ~loc env params1 params2 arg1 arg2 =
+  match arg1, arg2 with
+  | Types.Cstr_tuple arg1, Types.Cstr_tuple arg2 ->
+      if List.length arg1 <> List.length arg2 then
+        Some (Arity : constructor_mismatch)
+      else if
+        (* Ctype.equal must be called on all arguments at once, cf. PR#7378 *)
+        Ctype.equal env true (params1 @ arg1) (params2 @ arg2)
+      then None else Some Type
+  | Types.Cstr_record l1, Types.Cstr_record l2 ->
+      Option.map
+        (fun rec_err -> Inline_record rec_err)
+        (compare_records env ~loc params1 params2 0 l1 l2)
+  | Types.Cstr_record _, _ -> Some (Kind First : constructor_mismatch)
+  | _, Types.Cstr_record _ -> Some (Kind Second : constructor_mismatch)
+
+and compare_constructors ~loc env params1 params2 res1 res2 args1 args2 =
+  match res1, res2 with
+  | Some r1, Some r2 ->
+      if Ctype.equal env true [r1] [r2] then
+        compare_constructor_arguments ~loc env [r1] [r2] args1 args2
+      else Some Type
+  | Some _, None -> Some (Explicit_return_type First)
+  | None, Some _ -> Some (Explicit_return_type Second)
+  | None, None ->
+      compare_constructor_arguments ~loc env params1 params2 args1 args2
+
+and compare_variants ~loc env params1 params2 n
+    (cstrs1 : Types.constructor_declaration list)
+    (cstrs2 : Types.constructor_declaration list) =
+  match cstrs1, cstrs2 with
+  | [], []   -> None
+  | [], c::_ -> Some (Constructor_missing (Second, c.Types.cd_id))
+  | c::_, [] -> Some (Constructor_missing (First, c.Types.cd_id))
+  | cd1::rem1, cd2::rem2 ->
+      if Ident.name cd1.cd_id <> Ident.name cd2.cd_id then
+        Some (Constructor_names (n, cd1.cd_id, cd2.cd_id))
+      else begin
+        Builtin_attributes.check_alerts_inclusion
+          ~def:cd1.cd_loc
+          ~use:cd2.cd_loc
+          loc
+          cd1.cd_attributes cd2.cd_attributes
+          (Ident.name cd1.cd_id);
+        match compare_constructors ~loc env params1 params2
+                cd1.cd_res cd2.cd_res cd1.cd_args cd2.cd_args with
+        | Some r ->
+            Some ((Constructor_mismatch (cd1, cd2, r)) : variant_mismatch)
+        | None -> compare_variants ~loc env params1 params2 (n+1) rem1 rem2
+      end
+
+and compare_labels env params1 params2
+      (ld1 : Types.label_declaration)
+      (ld2 : Types.label_declaration) =
+      if ld1.ld_mutable <> ld2.ld_mutable
+      then
+        let ord = if ld1.ld_mutable = Asttypes.Mutable then First else Second in
+        Some (Mutability  ord)
+      else
+        if Ctype.equal env true (ld1.ld_type::params1) (ld2.ld_type::params2)
+        then None
+        else Some (Type : label_mismatch)
+
+and compare_records ~loc env params1 params2 n
+    (labels1 : Types.label_declaration list)
+    (labels2 : Types.label_declaration list) =
+  match labels1, labels2 with
+  | [], []           -> None
+  | [], l::_ -> Some (Label_missing (Second, l.Types.ld_id))
+  | l::_, [] -> Some (Label_missing (First, l.Types.ld_id))
+  | ld1::rem1, ld2::rem2 ->
+      if Ident.name ld1.ld_id <> Ident.name ld2.ld_id
+      then Some (Label_names (n, ld1.ld_id, ld2.ld_id))
+      else begin
+        Builtin_attributes.check_deprecated_mutable_inclusion
+          ~def:ld1.ld_loc
+          ~use:ld2.ld_loc
+          loc
+          ld1.ld_attributes ld2.ld_attributes
+          (Ident.name ld1.ld_id);
+        match compare_labels env params1 params2 ld1 ld2 with
+        | Some r -> Some (Label_mismatch (ld1, ld2, r))
+        (* add arguments to the parameters, cf. PR#7378 *)
+        | None -> compare_records ~loc env
+                    (ld1.ld_type::params1) (ld2.ld_type::params2)
+                    (n+1)
+                    rem1 rem2
+      end
+
+let compare_records_with_representation ~loc env params1 params2 n
+      labels1 labels2 rep1 rep2
+  =
+  match compare_records ~loc env params1 params2 n labels1 labels2 with
+  | None when rep1 <> rep2 ->
+      let pos = if rep2 = Record_float then Second else First in
+      Some (Unboxed_float_representation pos)
+  | err -> err
+
+let type_declarations ?(equality = false) ~loc env ~mark name
+      decl1 path decl2 =
+  Builtin_attributes.check_alerts_inclusion
+    ~def:decl1.type_loc
+    ~use:decl2.type_loc
+    loc
+    decl1.type_attributes decl2.type_attributes
+    name;
+  if decl1.type_arity <> decl2.type_arity then Some Arity else
+  if not (private_flags decl1 decl2) then Some Privacy else
+  let err = match (decl1.type_manifest, decl2.type_manifest) with
+      (_, None) ->
+        if Ctype.equal env true decl1.type_params decl2.type_params
+        then None else Some Constraint
+    | (Some ty1, Some ty2) ->
+        if type_manifest env ty1 decl1.type_params ty2 decl2.type_params
+            decl2.type_private
+        then None else Some Manifest
+    | (None, Some ty2) ->
+        let ty1 =
+          Btype.newgenty (Tconstr(path, decl2.type_params, ref Mnil))
+        in
+        if Ctype.equal env true decl1.type_params decl2.type_params then
+          if Ctype.equal env false [ty1] [ty2] then None
+          else Some Manifest
+        else Some Constraint
+  in
+  if err <> None then err else
+  let err =
+    match (decl2.type_kind, decl1.type_unboxed.unboxed,
+           decl2.type_unboxed.unboxed) with
+    | Type_abstract, _, _ -> None
+    | _, true, false -> Some (Unboxed_representation First)
+    | _, false, true -> Some (Unboxed_representation Second)
+    | _ -> None
+  in
+  if err <> None then err else
+  let err = match (decl1.type_kind, decl2.type_kind) with
+      (_, Type_abstract) -> None
+    | (Type_variant cstrs1, Type_variant cstrs2) ->
+        if mark then begin
+          let mark usage name cstrs =
+            List.iter
+              (fun cstr ->
+                 Env.mark_constructor_used usage name cstr)
+              cstrs
+          in
+          let usage =
+            if decl2.type_private = Public then Env.Positive
+            else Env.Privatize
+          in
+          mark usage name cstrs1;
+          if equality then mark Env.Positive (Path.name path) cstrs2
+        end;
+        Option.map
+          (fun var_err -> Variant_mismatch var_err)
+          (compare_variants ~loc env decl1.type_params decl2.type_params 1
+             cstrs1 cstrs2)
+    | (Type_record(labels1,rep1), Type_record(labels2,rep2)) ->
+        Option.map (fun rec_err -> Record_mismatch rec_err)
+          (compare_records_with_representation ~loc env
+             decl1.type_params decl2.type_params 1
+             labels1 labels2
+             rep1 rep2)
+    | (Type_open, Type_open) -> None
+    | (_, _) -> Some Kind
+  in
+  if err <> None then err else
+  let abstr = decl2.type_kind = Type_abstract && decl2.type_manifest = None in
+  (* If attempt to assign a non-immediate type (e.g. string) to a type that
+   * must be immediate, then we error *)
+  let err =
+    if not abstr then
+      None
+    else
+      match
+        Type_immediacy.coerce decl1.type_immediate ~as_:decl2.type_immediate
+      with
+      | Ok () -> None
+      | Error violation -> Some (Immediate violation)
+  in
+  if err <> None then err else
+  let need_variance =
+    abstr || decl1.type_private = Private || decl1.type_kind = Type_open in
+  if not need_variance then None else
+  let abstr = abstr || decl2.type_private = Private in
+  let opn = decl2.type_kind = Type_open && decl2.type_manifest = None in
+  let constrained ty = not (Btype.(is_Tvar (repr ty))) in
+  if List.for_all2
+      (fun ty (v1,v2) ->
+        let open Variance in
+        let imp a b = not a || b in
+        let (co1,cn1) = get_upper v1 and (co2,cn2) = get_upper v2 in
+        (if abstr then (imp co1 co2 && imp cn1 cn2)
+         else if opn || constrained ty then (co1 = co2 && cn1 = cn2)
+         else true) &&
+        let (p1,n1,i1,j1) = get_lower v1 and (p2,n2,i2,j2) = get_lower v2 in
+        imp abstr (imp p2 p1 && imp n2 n1 && imp i2 i1 && imp j2 j1))
+      decl2.type_params (List.combine decl1.type_variance decl2.type_variance)
+  then None else Some Variance
+
+(* Inclusion between extension constructors *)
+
+let extension_constructors ~loc env ~mark id ext1 ext2 =
+  if mark then begin
+    let usage =
+      if ext2.ext_private = Public then Env.Positive
+      else Env.Privatize
+    in
+    Env.mark_extension_used usage (Ident.name id) ext1
+  end;
+  let ty1 =
+    Btype.newgenty (Tconstr(ext1.ext_type_path, ext1.ext_type_params, ref Mnil))
+  in
+  let ty2 =
+    Btype.newgenty (Tconstr(ext2.ext_type_path, ext2.ext_type_params, ref Mnil))
+  in
+  if not (Ctype.equal env true (ty1 :: ext1.ext_type_params)
+                               (ty2 :: ext2.ext_type_params))
+  then Some (Constructor_mismatch (id, ext1, ext2, Type))
+  else
+    let r =
+      compare_constructors ~loc env ext1.ext_type_params ext2.ext_type_params
+        ext1.ext_ret_type ext2.ext_ret_type
+        ext1.ext_args ext2.ext_args
+    in
+    match r with
+    | Some r -> Some (Constructor_mismatch (id, ext1, ext2, r))
+    | None -> match ext1.ext_private, ext2.ext_private with
+        Private, Public -> Some Constructor_privacy
+      | _, _ -> None
diff --git a/src/ocaml/typing/410+multicore/includecore.mli b/src/ocaml/typing/410+multicore/includecore.mli
new file mode 100644
index 00000000..560d0ac1
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includecore.mli
@@ -0,0 +1,90 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the core language *)
+
+open Typedtree
+open Types
+
+exception Dont_match
+
+type position = Ctype.Unification_trace.position = First | Second
+
+type label_mismatch =
+  | Type
+  | Mutability of position
+
+type record_mismatch =
+  | Label_mismatch of label_declaration * label_declaration * label_mismatch
+  | Label_names of int * Ident.t * Ident.t
+  | Label_missing of position * Ident.t
+  | Unboxed_float_representation of position
+
+type constructor_mismatch =
+  | Type
+  | Arity
+  | Inline_record of record_mismatch
+  | Kind of position
+  | Explicit_return_type of position
+
+type variant_mismatch =
+  | Constructor_mismatch of constructor_declaration
+                            * constructor_declaration
+                            * constructor_mismatch
+  | Constructor_names of int * Ident.t * Ident.t
+  | Constructor_missing of position * Ident.t
+
+type extension_constructor_mismatch =
+  | Constructor_privacy
+  | Constructor_mismatch of Ident.t
+                            * extension_constructor
+                            * extension_constructor
+                            * constructor_mismatch
+
+type type_mismatch =
+  | Arity
+  | Privacy
+  | Kind
+  | Constraint
+  | Manifest
+  | Variance
+  | Record_mismatch of record_mismatch
+  | Variant_mismatch of variant_mismatch
+  | Unboxed_representation of position
+  | Immediate of Type_immediacy.Violation.t
+
+val value_descriptions:
+  loc:Location.t -> Env.t -> string ->
+  value_description -> value_description -> module_coercion
+
+val type_declarations:
+  ?equality:bool ->
+  loc:Location.t ->
+  Env.t -> mark:bool -> string ->
+  type_declaration -> Path.t -> type_declaration -> type_mismatch option
+
+val extension_constructors:
+  loc:Location.t -> Env.t -> mark:bool -> Ident.t ->
+  extension_constructor -> extension_constructor ->
+  extension_constructor_mismatch option
+(*
+val class_types:
+        Env.t -> class_type -> class_type -> bool
+*)
+
+val report_type_mismatch:
+    string -> string -> string -> Format.formatter -> type_mismatch -> unit
+val report_extension_constructor_mismatch: string -> string -> string ->
+  Format.formatter -> extension_constructor_mismatch -> unit
diff --git a/src/ocaml/typing/410+multicore/includemod.ml b/src/ocaml/typing/410+multicore/includemod.ml
new file mode 100644
index 00000000..d92b0fe0
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includemod.ml
@@ -0,0 +1,877 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the module language *)
+
+open Misc
+open Typedtree
+open Types
+
+type symptom =
+    Missing_field of Ident.t * Location.t * string (* kind *)
+  | Value_descriptions of Ident.t * value_description * value_description
+  | Type_declarations of Ident.t * type_declaration
+        * type_declaration * Includecore.type_mismatch
+  | Extension_constructors of Ident.t * extension_constructor
+        * extension_constructor * Includecore.extension_constructor_mismatch
+  | Module_types of module_type * module_type
+  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
+  | Modtype_permutation of Types.module_type * Typedtree.module_coercion
+  | Interface_mismatch of string * string
+  | Class_type_declarations of
+      Ident.t * class_type_declaration * class_type_declaration *
+      Ctype.class_match_failure list
+  | Class_declarations of
+      Ident.t * class_declaration * class_declaration *
+      Ctype.class_match_failure list
+  | Unbound_modtype_path of Path.t
+  | Unbound_module_path of Path.t
+  | Invalid_module_alias of Path.t
+
+type pos =
+  | Module of Ident.t
+  | Modtype of Ident.t
+  | Arg of functor_parameter
+  | Body of functor_parameter
+type error = pos list * Env.t * symptom
+
+exception Error of error list
+exception Apply_error of Location.t * Path.t * Path.t * error list
+
+type mark =
+  | Mark_both
+  | Mark_positive
+  | Mark_negative
+  | Mark_neither
+
+let negate_mark = function
+  | Mark_both -> Mark_both
+  | Mark_positive -> Mark_negative
+  | Mark_negative -> Mark_positive
+  | Mark_neither -> Mark_neither
+
+let mark_positive = function
+  | Mark_both | Mark_positive -> true
+  | Mark_negative | Mark_neither -> false
+
+(* All functions "blah env x1 x2" check that x1 is included in x2,
+   i.e. that x1 is the type of an implementation that fulfills the
+   specification x2. If not, Error is raised with a backtrace of the error. *)
+
+(* Inclusion between value descriptions *)
+
+let value_descriptions ~loc env ~mark cxt subst id vd1 vd2 =
+  Cmt_format.record_value_dependency vd1 vd2;
+  if mark_positive mark then
+    Env.mark_value_used (Ident.name id) vd1;
+  let vd2 = Subst.value_description subst vd2 in
+  try
+    Includecore.value_descriptions ~loc env (Ident.name id) vd1 vd2
+  with Includecore.Dont_match ->
+    raise(Error[cxt, env, Value_descriptions(id, vd1, vd2)])
+
+(* Inclusion between type declarations *)
+
+let type_declarations ~loc env ~mark ?old_env:_ cxt subst id decl1 decl2 =
+  let mark = mark_positive mark in
+  if mark then
+    Env.mark_type_used (Ident.name id) decl1;
+  let decl2 = Subst.type_declaration subst decl2 in
+  match
+    Includecore.type_declarations ~loc env ~mark
+      (Ident.name id) decl1 (Path.Pident id) decl2
+  with
+  | None -> ()
+  | Some err ->
+      raise(Error[cxt, env, Type_declarations(id, decl1, decl2, err)])
+
+(* Inclusion between extension constructors *)
+
+let extension_constructors ~loc env ~mark cxt subst id ext1 ext2 =
+  let mark = mark_positive mark in
+  let ext2 = Subst.extension_constructor subst ext2 in
+  match Includecore.extension_constructors ~loc env ~mark id ext1 ext2 with
+  | None -> ()
+  | Some err ->
+      raise(Error[cxt, env, Extension_constructors(id, ext1, ext2, err)])
+
+(* Inclusion between class declarations *)
+
+let class_type_declarations ~loc ~old_env:_ env cxt subst id decl1 decl2 =
+  let decl2 = Subst.cltype_declaration subst decl2 in
+  match Includeclass.class_type_declarations ~loc env decl1 decl2 with
+    []     -> ()
+  | reason ->
+      raise(Error[cxt, env,
+                  Class_type_declarations(id, decl1, decl2, reason)])
+
+let class_declarations ~old_env:_ env cxt subst id decl1 decl2 =
+  let decl2 = Subst.class_declaration subst decl2 in
+  match Includeclass.class_declarations env decl1 decl2 with
+    []     -> ()
+  | reason ->
+      raise(Error[cxt, env, Class_declarations(id, decl1, decl2, reason)])
+
+(* Expand a module type identifier when possible *)
+
+exception Dont_match
+
+let may_expand_module_path env path =
+  try ignore (Env.find_modtype_expansion path env); true
+  with Not_found -> false
+
+let expand_module_path env cxt path =
+  try
+    Env.find_modtype_expansion path env
+  with Not_found ->
+    raise(Error[cxt, env, Unbound_modtype_path path])
+
+let expand_module_alias env cxt path =
+  try (Env.find_module path env).md_type
+  with Not_found ->
+    raise(Error[cxt, env, Unbound_module_path path])
+
+(*
+let rec normalize_module_path env cxt path =
+  match expand_module_alias env cxt path with
+    Mty_alias path' -> normalize_module_path env cxt path'
+  | _ -> path
+*)
+
+(* Extract name, kind and ident from a signature item *)
+
+type field_desc =
+    Field_value of string
+  | Field_type of string
+  | Field_typext of string
+  | Field_module of string
+  | Field_modtype of string
+  | Field_class of string
+  | Field_classtype of string
+
+let kind_of_field_desc = function
+  | Field_value _ -> "value"
+  | Field_type _ -> "type"
+  | Field_typext _ -> "extension constructor"
+  | Field_module _ -> "module"
+  | Field_modtype _ -> "module type"
+  | Field_class _ -> "class"
+  | Field_classtype _ -> "class type"
+
+(** Map indexed by both field types and names.
+    This avoids name clashes between different sorts of fields
+    such as values and types. *)
+module FieldMap = Map.Make(struct
+    type t = field_desc
+    let compare = Stdlib.compare
+  end)
+
+let item_ident_name = function
+    Sig_value(id, d, _) -> (id, d.val_loc, Field_value(Ident.name id))
+  | Sig_type(id, d, _, _) -> (id, d.type_loc, Field_type(Ident.name id))
+  | Sig_typext(id, d, _, _) -> (id, d.ext_loc, Field_typext(Ident.name id))
+  | Sig_module(id, _, d, _, _) -> (id, d.md_loc, Field_module(Ident.name id))
+  | Sig_modtype(id, d, _) -> (id, d.mtd_loc, Field_modtype(Ident.name id))
+  | Sig_class(id, d, _, _) -> (id, d.cty_loc, Field_class(Ident.name id))
+  | Sig_class_type(id, d, _, _) ->
+      (id, d.clty_loc, Field_classtype(Ident.name id))
+
+let is_runtime_component = function
+  | Sig_value(_,{val_kind = Val_prim _}, _)
+  | Sig_type(_,_,_,_)
+  | Sig_module(_,Mp_absent,_,_,_)
+  | Sig_modtype(_,_,_)
+  | Sig_class_type(_,_,_,_) -> false
+  | Sig_value(_,_,_)
+  | Sig_typext(_,_,_,_)
+  | Sig_module(_,Mp_present,_,_,_)
+  | Sig_class(_,_,_,_) -> true
+
+(* Print a coercion *)
+
+let rec print_list pr ppf = function
+    [] -> ()
+  | [a] -> pr ppf a
+  | a :: l -> pr ppf a; Format.fprintf ppf ";@ "; print_list pr ppf l
+let print_list pr ppf l =
+  Format.fprintf ppf "[@[%a@]]" (print_list pr) l
+
+let rec print_coercion ppf c =
+  let pr fmt = Format.fprintf ppf fmt in
+  match c with
+    Tcoerce_none -> pr "id"
+  | Tcoerce_structure (fl, nl) ->
+      pr "@[<2>struct@ %a@ %a@]"
+        (print_list print_coercion2) fl
+        (print_list print_coercion3) nl
+  | Tcoerce_functor (inp, out) ->
+      pr "@[<2>functor@ (%a)@ (%a)@]"
+        print_coercion inp
+        print_coercion out
+  | Tcoerce_primitive {pc_desc; pc_env = _; pc_type}  ->
+      pr "prim %s@ (%a)" pc_desc.Primitive.prim_name
+        Printtyp.raw_type_expr pc_type
+  | Tcoerce_alias (_, p, c) ->
+      pr "@[<2>alias %a@ (%a)@]"
+        Printtyp.path p
+        print_coercion c
+and print_coercion2 ppf (n, c) =
+  Format.fprintf ppf "@[%d,@ %a@]" n print_coercion c
+and print_coercion3 ppf (i, n, c) =
+  Format.fprintf ppf "@[%s, %d,@ %a@]"
+    (Ident.unique_name i) n print_coercion c
+
+(* Simplify a structure coercion *)
+
+let simplify_structure_coercion cc id_pos_list =
+  let rec is_identity_coercion pos = function
+  | [] ->
+      true
+  | (n, c) :: rem ->
+      n = pos && c = Tcoerce_none && is_identity_coercion (pos + 1) rem in
+  if is_identity_coercion 0 cc
+  then Tcoerce_none
+  else Tcoerce_structure (cc, id_pos_list)
+
+(* Inclusion between module types.
+   Return the restriction that transforms a value of the smaller type
+   into a value of the bigger type. *)
+
+let rec modtypes ~loc env ~mark cxt subst mty1 mty2 =
+  try
+    try_modtypes ~loc env ~mark cxt subst mty1 mty2
+  with
+    Dont_match ->
+      raise(Error[cxt, env,
+                  Module_types(mty1, Subst.modtype Make_local subst mty2)])
+  | Error reasons as err ->
+      match mty1, mty2 with
+        Mty_alias _, _
+      | _, Mty_alias _ -> raise err
+      | _ ->
+          raise(Error((cxt, env,
+                       Module_types(mty1, Subst.modtype Make_local subst mty2))
+                      :: reasons))
+
+and try_modtypes ~loc env ~mark cxt subst mty1 mty2 =
+  match mty1, mty2 with
+  | Mty_alias p1, Mty_alias p2 ->
+      if Env.is_functor_arg p2 env then
+        raise (Error[cxt, env, Invalid_module_alias p2]);
+      if not (Path.same p1 p2) then begin
+        let p1 = Env.normalize_module_path None env p1
+        and p2 = Env.normalize_module_path None env
+            (Subst.module_path subst p2)
+        in
+        if not (Path.same p1 p2) then raise Dont_match
+      end;
+      Tcoerce_none
+  | (Mty_alias p1, _) -> begin
+      let p1 = try
+        Env.normalize_module_path (Some Location.none) env p1
+      with Env.Error (Env.Missing_module (_, _, path)) ->
+        raise (Error[cxt, env, Unbound_module_path path])
+      in
+      let mty1 =
+        Mtype.strengthen ~aliasable:true env
+          (expand_module_alias env cxt p1) p1
+      in
+      modtypes ~loc env ~mark cxt subst mty1 mty2
+    end
+  | (Mty_ident p1, _) when may_expand_module_path env p1 ->
+      try_modtypes ~loc env ~mark cxt subst
+        (expand_module_path env cxt p1) mty2
+  | (_, Mty_ident _) ->
+      try_modtypes2 ~loc env ~mark cxt mty1 (Subst.modtype Keep subst mty2)
+  | (Mty_signature sig1, Mty_signature sig2) ->
+      signatures ~loc env ~mark cxt subst sig1 sig2
+  | (Mty_functor(Unit, res1), Mty_functor(Unit, res2)) ->
+    begin
+      match modtypes ~loc env ~mark (Body Unit::cxt) subst res1 res2 with
+      | Tcoerce_none -> Tcoerce_none
+      | cc -> Tcoerce_functor (Tcoerce_none, cc)
+    end
+  | (Mty_functor(Named (param1, arg1) as arg, res1),
+     Mty_functor(Named (param2, arg2), res2)) ->
+      let arg2' = Subst.modtype Keep subst arg2 in
+      let cc_arg =
+        modtypes ~loc env ~mark:(negate_mark mark)
+          (Arg arg::cxt) Subst.identity arg2' arg1
+      in
+      let env, subst =
+        match param1, param2 with
+        | Some p1, Some p2 ->
+            Env.add_module p1 Mp_present arg2' env,
+            Subst.add_module p2 (Path.Pident p1) subst
+        | None, Some p2 ->
+            Env.add_module p2 Mp_present arg2' env, subst
+        | Some p1, None ->
+            Env.add_module p1 Mp_present arg2' env, subst
+        | None, None ->
+            env, subst
+      in
+      let cc_res = modtypes ~loc env ~mark (Body arg::cxt) subst res1 res2 in
+      begin match (cc_arg, cc_res) with
+          (Tcoerce_none, Tcoerce_none) -> Tcoerce_none
+        | _ -> Tcoerce_functor(cc_arg, cc_res)
+      end
+  | (_, _) ->
+      raise Dont_match
+
+and try_modtypes2 ~loc env ~mark cxt mty1 mty2 =
+  (* mty2 is an identifier *)
+  match (mty1, mty2) with
+    (Mty_ident p1, Mty_ident p2)
+    when Path.same (Env.normalize_path_prefix None env p1)
+                   (Env.normalize_path_prefix None env p2) ->
+      Tcoerce_none
+  | (_, Mty_ident p2) when may_expand_module_path env p2 ->
+      try_modtypes ~loc env ~mark cxt Subst.identity
+        mty1 (expand_module_path env cxt p2)
+  | (_, _) ->
+      raise Dont_match
+
+(* Inclusion between signatures *)
+
+and signatures ~loc env ~mark cxt subst sig1 sig2 =
+  (* Environment used to check inclusion of components *)
+  let new_env =
+    Env.add_signature sig1 (Env.in_signature true env) in
+  (* Keep ids for module aliases *)
+  let (id_pos_list,_) =
+    List.fold_left
+      (fun (l,pos) -> function
+          Sig_module (id, Mp_present, _, _, _) ->
+            ((id,pos,Tcoerce_none)::l , pos+1)
+        | item -> (l, if is_runtime_component item then pos+1 else pos))
+      ([], 0) sig1 in
+  (* Build a table of the components of sig1, along with their positions.
+     The table is indexed by kind and name of component *)
+  let rec build_component_table pos tbl = function
+      [] -> pos, tbl
+    | (Sig_value (_, _, Hidden)
+      |Sig_type (_, _, _, Hidden)
+      |Sig_typext (_, _, _, Hidden)
+      |Sig_module (_, _, _, _, Hidden)
+      |Sig_modtype (_, _, Hidden)
+      |Sig_class (_, _, _, Hidden)
+      |Sig_class_type (_, _, _, Hidden)
+      ) as item :: rem ->
+        let pos = if is_runtime_component item then pos + 1 else pos in
+        build_component_table pos tbl rem (* do not pair private items. *)
+    | item :: rem ->
+        let (id, _loc, name) = item_ident_name item in
+        let pos, nextpos =
+          if is_runtime_component item then pos, pos + 1
+          else -1, pos
+        in
+        build_component_table nextpos
+                              (FieldMap.add name (id, item, pos) tbl) rem in
+  let len1, comps1 =
+    build_component_table 0 FieldMap.empty sig1 in
+  let len2 =
+    List.fold_left
+      (fun n i -> if is_runtime_component i then n + 1 else n)
+      0
+      sig2
+  in
+  (* Pair each component of sig2 with a component of sig1,
+     identifying the names along the way.
+     Return a coercion list indicating, for all run-time components
+     of sig2, the position of the matching run-time components of sig1
+     and the coercion to be applied to it. *)
+  let rec pair_components subst paired unpaired = function
+      [] ->
+        begin match unpaired with
+            [] ->
+              let cc =
+                signature_components ~loc env ~mark new_env cxt subst
+                  (List.rev paired)
+              in
+              if len1 = len2 then (* see PR#5098 *)
+                simplify_structure_coercion cc id_pos_list
+              else
+                Tcoerce_structure (cc, id_pos_list)
+          | _  -> raise(Error unpaired)
+        end
+    | item2 :: rem ->
+        let (id2, loc, name2) = item_ident_name item2 in
+        let name2, report =
+          match item2, name2 with
+            Sig_type (_, {type_manifest=None}, _, _), Field_type s
+            when Btype.is_row_name s ->
+              (* Do not report in case of failure,
+                 as the main type will generate an error *)
+              Field_type (String.sub s 0 (String.length s - 4)), false
+          | _ -> name2, true
+        in
+        begin try
+          let (id1, item1, pos1) = FieldMap.find name2 comps1 in
+          let new_subst =
+            match item2 with
+              Sig_type _ ->
+                Subst.add_type id2 (Path.Pident id1) subst
+            | Sig_module _ ->
+                Subst.add_module id2 (Path.Pident id1) subst
+            | Sig_modtype _ ->
+                Subst.add_modtype id2 (Mty_ident (Path.Pident id1)) subst
+            | Sig_value _ | Sig_typext _
+            | Sig_class _ | Sig_class_type _ ->
+                subst
+          in
+          pair_components new_subst
+            ((item1, item2, pos1) :: paired) unpaired rem
+        with Not_found ->
+          let unpaired =
+            if report then
+              (cxt, env, Missing_field (id2, loc, kind_of_field_desc name2)) ::
+              unpaired
+            else unpaired in
+          pair_components subst paired unpaired rem
+        end in
+  (* Do the pairing and checking, and return the final coercion *)
+  pair_components subst [] [] sig2
+
+(* Inclusion between signature components *)
+
+and signature_components ~loc old_env ~mark env cxt subst paired =
+  let comps_rec rem =
+    signature_components ~loc old_env ~mark env cxt subst rem
+  in
+  match paired with
+    [] -> []
+  | (Sig_value(id1, valdecl1, _), Sig_value(_id2, valdecl2, _), pos) :: rem ->
+      let cc =
+        value_descriptions ~loc env ~mark cxt subst id1 valdecl1 valdecl2
+      in
+      begin match valdecl2.val_kind with
+        Val_prim _ -> comps_rec rem
+      | _ -> (pos, cc) :: comps_rec rem
+      end
+  | (Sig_type(id1, tydecl1, _, _), Sig_type(_id2, tydecl2, _, _), _pos) :: rem
+    ->
+      type_declarations ~loc ~old_env env ~mark cxt subst id1 tydecl1 tydecl2;
+      comps_rec rem
+  | (Sig_typext(id1, ext1, _, _), Sig_typext(_id2, ext2, _, _), pos)
+    :: rem ->
+      extension_constructors ~loc env ~mark cxt subst id1 ext1 ext2;
+      (pos, Tcoerce_none) :: comps_rec rem
+  | (Sig_module(id1, pres1, mty1, _, _),
+     Sig_module(_id2, pres2, mty2, _, _), pos) :: rem -> begin
+      let cc = module_declarations ~loc env ~mark cxt subst id1 mty1 mty2 in
+      let rem = comps_rec rem in
+      match pres1, pres2, mty1.md_type with
+      | Mp_present, Mp_present, _ -> (pos, cc) :: rem
+      | _, Mp_absent, _ -> rem
+      | Mp_absent, Mp_present, Mty_alias p1 ->
+          (pos, Tcoerce_alias (env, p1, cc)) :: rem
+      | Mp_absent, Mp_present, _ -> assert false
+    end
+  | (Sig_modtype(id1, info1, _), Sig_modtype(_id2, info2, _), _pos) :: rem ->
+      modtype_infos ~loc env ~mark cxt subst id1 info1 info2;
+      comps_rec rem
+  | (Sig_class(id1, decl1, _, _), Sig_class(_id2, decl2, _, _), pos) :: rem ->
+      class_declarations ~old_env env cxt subst id1 decl1 decl2;
+      (pos, Tcoerce_none) :: comps_rec rem
+  | (Sig_class_type(id1, info1, _, _),
+     Sig_class_type(_id2, info2, _, _), _pos) :: rem ->
+      class_type_declarations ~loc ~old_env env cxt subst id1 info1 info2;
+      comps_rec rem
+  | _ ->
+      assert false
+
+and module_declarations ~loc env ~mark cxt subst id1 md1 md2 =
+  Builtin_attributes.check_alerts_inclusion
+    ~def:md1.md_loc
+    ~use:md2.md_loc
+    loc
+    md1.md_attributes md2.md_attributes
+    (Ident.name id1);
+  let p1 = Path.Pident id1 in
+  if mark_positive mark then
+    Env.mark_module_used (Ident.name id1) md1.md_loc;
+  modtypes ~loc env ~mark (Module id1::cxt) subst
+    (Mtype.strengthen ~aliasable:true env md1.md_type p1) md2.md_type
+
+(* Inclusion between module type specifications *)
+
+and modtype_infos ~loc env ~mark cxt subst id info1 info2 =
+  Builtin_attributes.check_alerts_inclusion
+    ~def:info1.mtd_loc
+    ~use:info2.mtd_loc
+    loc
+    info1.mtd_attributes info2.mtd_attributes
+    (Ident.name id);
+  let info2 = Subst.modtype_declaration Keep subst info2 in
+  let cxt' = Modtype id :: cxt in
+  try
+    match (info1.mtd_type, info2.mtd_type) with
+      (None, None) -> ()
+    | (Some _, None) -> ()
+    | (Some mty1, Some mty2) ->
+        check_modtype_equiv ~loc env ~mark cxt' mty1 mty2
+    | (None, Some mty2) ->
+        check_modtype_equiv ~loc env ~mark cxt' (Mty_ident(Path.Pident id)) mty2
+  with Error reasons ->
+    raise(Error((cxt, env, Modtype_infos(id, info1, info2)) :: reasons))
+
+and check_modtype_equiv ~loc env ~mark cxt mty1 mty2 =
+  match
+    (modtypes ~loc env ~mark cxt Subst.identity mty1 mty2,
+     modtypes ~loc env ~mark:(negate_mark mark) cxt Subst.identity mty2 mty1)
+  with
+    (Tcoerce_none, Tcoerce_none) -> ()
+  | (c1, _c2) ->
+      (* Format.eprintf "@[c1 = %a@ c2 = %a@]@."
+        print_coercion _c1 print_coercion _c2; *)
+      raise(Error [cxt, env, Modtype_permutation (mty1, c1)])
+
+(* Simplified inclusion check between module types (for Env) *)
+
+let can_alias env path =
+  let rec no_apply = function
+    | Path.Pident _ -> true
+    | Path.Pdot(p, _) -> no_apply p
+    | Path.Papply _ -> false
+  in
+  no_apply path && not (Env.is_functor_arg path env)
+
+let check_modtype_inclusion ~loc env mty1 path1 mty2 =
+  let aliasable = can_alias env path1 in
+  ignore(modtypes ~loc env ~mark:Mark_both [] Subst.identity
+           (Mtype.strengthen ~aliasable env mty1 path1) mty2)
+
+let () =
+  Env.check_functor_application :=
+    (fun ~errors ~loc env mty1 path1 mty2 path2 ->
+       try
+         check_modtype_inclusion ~loc env mty1 path1 mty2
+       with Error errs ->
+         if errors then
+           raise (Apply_error(loc, path1, path2, errs))
+         else
+           raise Not_found)
+
+(* Check that an implementation of a compilation unit meets its
+   interface. *)
+
+let compunit env ?(mark=Mark_both) impl_name impl_sig intf_name intf_sig =
+  try
+    signatures ~loc:(Location.in_file impl_name) env ~mark []
+      Subst.identity impl_sig intf_sig
+  with Error reasons ->
+    raise(Error(([], Env.empty,Interface_mismatch(impl_name, intf_name))
+                :: reasons))
+
+(* Hide the context and substitution parameters to the outside world *)
+
+let modtypes ~loc env ?(mark=Mark_both) mty1 mty2 =
+  modtypes ~loc env ~mark [] Subst.identity mty1 mty2
+let signatures env ?(mark=Mark_both) sig1 sig2 =
+  signatures ~loc:Location.none env ~mark [] Subst.identity sig1 sig2
+let type_declarations ~loc env ?(mark=Mark_both) id decl1 decl2 =
+  type_declarations ~loc env ~mark [] Subst.identity id decl1 decl2
+
+(*
+let modtypes env m1 m2 =
+  let c = modtypes env m1 m2 in
+  Format.eprintf "@[<2>modtypes@ %a@ %a =@ %a@]@."
+    Printtyp.modtype m1 Printtyp.modtype m2
+    print_coercion c;
+  c
+*)
+
+(* Error report *)
+
+module Illegal_permutation = struct
+  (** Extraction of information in case of illegal permutation
+      in a module type *)
+
+  (** When examining coercions, we only have runtime component indices,
+      we use thus a limited version of {!pos}. *)
+  type coerce_pos =
+    | Item of int
+    | InArg
+    | InBody
+
+  let either f x g y = match f x with
+    | None -> g y
+    | Some _ as v -> v
+
+  (** We extract a lone transposition from a full tree of permutations. *)
+  let rec transposition_under path = function
+    | Tcoerce_structure(c,_) ->
+        either
+          (not_fixpoint path 0) c
+          (first_non_id path 0) c
+    | Tcoerce_functor(arg,res) ->
+        either
+          (transposition_under (InArg::path)) arg
+          (transposition_under (InBody::path)) res
+    | Tcoerce_none -> None
+    | Tcoerce_alias _ | Tcoerce_primitive _ ->
+        (* these coercions are not inversible, and raise an error earlier when
+           checking for module type equivalence *)
+        assert false
+  (* we search the first point which is not invariant at the current level *)
+  and not_fixpoint path pos = function
+    | [] -> None
+    | (n, _) :: q ->
+        if n = pos then
+          not_fixpoint path (pos+1) q
+        else
+          Some(List.rev path, pos, n)
+  (* we search the first item with a non-identity inner coercion *)
+  and first_non_id path pos = function
+    | [] -> None
+    | (_,Tcoerce_none) :: q -> first_non_id path (pos + 1) q
+    | (_,c) :: q ->
+        either
+          (transposition_under (Item pos :: path)) c
+          (first_non_id path (pos + 1)) q
+
+  let transposition c =
+    match transposition_under [] c with
+    | None -> raise Not_found
+    | Some x -> x
+
+  let rec runtime_item k = function
+    | [] -> raise Not_found
+    | item :: q ->
+        if not(is_runtime_component item) then
+          runtime_item k q
+        else if k = 0 then
+          item
+        else
+          runtime_item (k-1) q
+
+  (* Find module type at position [path] and convert the [coerce_pos] path to
+     a [pos] path *)
+  let rec find env ctx path mt = match mt, path with
+    | (Mty_ident p | Mty_alias p), _ ->
+        begin match (Env.find_modtype p env).mtd_type with
+        | None -> raise Not_found
+        | Some mt -> find env ctx path mt
+        end
+    | Mty_signature s , [] -> List.rev ctx, s
+    | Mty_signature s, Item k :: q ->
+        begin match runtime_item k s with
+        | Sig_module (id, _, md,_,_) -> find env (Module id :: ctx) q md.md_type
+        | _ -> raise Not_found
+        end
+    | Mty_functor(Named (_,mt) as arg,_), InArg :: q ->
+        find env (Arg arg :: ctx) q mt
+    | Mty_functor(arg, mt), InBody :: q ->
+        find env (Body arg :: ctx) q mt
+    | _ -> raise Not_found
+
+  let find env path mt = find env [] path mt
+  let item mt k = item_ident_name (runtime_item k mt)
+
+  let pp_item ppf (id,_,kind) =
+    Format.fprintf ppf "%s %S" (kind_of_field_desc kind) (Ident.name id)
+
+  let pp ctx_printer env ppf (mty,c) =
+    try
+      let p, k, l = transposition c in
+      let ctx, mt = find env p mty in
+      Format.fprintf ppf
+        "@[<hv 2>Illegal permutation of runtime components in a module type.@ \
+         @[For example,@ %a@[the %a@ and the %a are not in the same order@ \
+         in the expected and actual module types.@]@]"
+        ctx_printer ctx pp_item (item mt k) pp_item (item mt l)
+    with Not_found -> (* this should not happen *)
+      Format.fprintf ppf
+        "Illegal permutation of runtime components in a module type."
+
+end
+
+open Format
+
+let show_loc msg ppf loc =
+  let pos = loc.Location.loc_start in
+  if List.mem pos.Lexing.pos_fname [""; "_none_"; "//toplevel//"] then ()
+  else fprintf ppf "@\n@[<2>%a:@ %s@]" Location.print_loc loc msg
+
+let show_locs ppf (loc1, loc2) =
+  show_loc "Expected declaration" ppf loc2;
+  show_loc "Actual declaration" ppf loc1
+
+let path_of_context = function
+    Module id :: rem ->
+      let rec subm path = function
+        | [] -> path
+        | Module id :: rem -> subm (Path.Pdot (path, Ident.name id)) rem
+        | _ -> assert false
+      in subm (Path.Pident id) rem
+  | _ -> assert false
+
+
+let rec context ppf = function
+    Module id :: rem ->
+      fprintf ppf "@[<2>module %a%a@]" Printtyp.ident id args rem
+  | Modtype id :: rem ->
+      fprintf ppf "@[<2>module type %a =@ %a@]"
+        Printtyp.ident id context_mty rem
+  | Body x :: rem ->
+      fprintf ppf "functor (%s) ->@ %a" (argname x) context_mty rem
+  | Arg x :: rem ->
+      fprintf ppf "functor (%s : %a) -> ..." (argname x) context_mty rem
+  | [] ->
+      fprintf ppf "<here>"
+and context_mty ppf = function
+    (Module _ | Modtype _) :: _ as rem ->
+      fprintf ppf "@[<2>sig@ %a@;<1 -2>end@]" context rem
+  | cxt -> context ppf cxt
+and args ppf = function
+    Body x :: rem ->
+      fprintf ppf "(%s)%a" (argname x) args rem
+  | Arg x :: rem ->
+      fprintf ppf "(%s :@ %a) : ..." (argname  x) context_mty rem
+  | cxt ->
+      fprintf ppf " :@ %a" context_mty cxt
+and argname = function
+  | Unit -> ""
+  | Named (None, _) -> "_"
+  | Named (Some id, _) -> Ident.name id
+
+let alt_context ppf cxt =
+  if cxt = [] then () else
+  if List.for_all (function Module _ -> true | _ -> false) cxt then
+    fprintf ppf "in module %a,@ " Printtyp.path (path_of_context cxt)
+  else
+    fprintf ppf "@[<hv 2>at position@ %a,@]@ " context cxt
+
+let context ppf cxt =
+  if cxt = [] then () else
+  if List.for_all (function Module _ -> true | _ -> false) cxt then
+    fprintf ppf "In module %a:@ " Printtyp.path (path_of_context cxt)
+  else
+    fprintf ppf "@[<hv 2>At position@ %a@]@ " context cxt
+
+let include_err env ppf = function
+  | Missing_field (id, loc, kind) ->
+      fprintf ppf "The %s `%a' is required but not provided"
+        kind Printtyp.ident id;
+      show_loc "Expected declaration" ppf loc
+  | Value_descriptions(id, d1, d2) ->
+      fprintf ppf
+        "@[<hv 2>Values do not match:@ %a@;<1 -2>is not included in@ %a@]"
+        !Oprint.out_sig_item (Printtyp.tree_of_value_description id d1)
+        !Oprint.out_sig_item (Printtyp.tree_of_value_description id d2);
+      show_locs ppf (d1.val_loc, d2.val_loc)
+  | Type_declarations(id, d1, d2, err) ->
+      fprintf ppf "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]%a%a@]"
+        "Type declarations do not match"
+        !Oprint.out_sig_item
+        (Printtyp.tree_of_type_declaration id d1 Trec_first)
+        "is not included in"
+        !Oprint.out_sig_item
+        (Printtyp.tree_of_type_declaration id d2 Trec_first)
+        (Includecore.report_type_mismatch
+           "the first" "the second" "declaration") err
+        show_locs (d1.type_loc, d2.type_loc)
+  | Extension_constructors(id, x1, x2, err) ->
+      fprintf ppf "@[<v>@[<hv>%s:@;<1 2>%a@ %s@;<1 2>%a@]@ %a%a@]"
+        "Extension declarations do not match"
+        !Oprint.out_sig_item
+        (Printtyp.tree_of_extension_constructor id x1 Text_first)
+        "is not included in"
+        !Oprint.out_sig_item
+        (Printtyp.tree_of_extension_constructor id x2 Text_first)
+        (Includecore.report_extension_constructor_mismatch
+           "the first" "the second" "declaration") err
+        show_locs (x1.ext_loc, x2.ext_loc)
+  | Module_types(mty1, mty2)->
+      fprintf ppf
+       "@[<hv 2>Modules do not match:@ \
+        %a@;<1 -2>is not included in@ %a@]"
+      !Oprint.out_module_type (Printtyp.tree_of_modtype mty1)
+      !Oprint.out_module_type (Printtyp.tree_of_modtype mty2)
+  | Modtype_infos(id, d1, d2) ->
+      fprintf ppf
+       "@[<hv 2>Module type declarations do not match:@ \
+        %a@;<1 -2>does not match@ %a@]"
+      !Oprint.out_sig_item (Printtyp.tree_of_modtype_declaration id d1)
+      !Oprint.out_sig_item (Printtyp.tree_of_modtype_declaration id d2)
+  | Modtype_permutation (mty,c) ->
+      Illegal_permutation.pp alt_context env ppf (mty,c)
+  | Interface_mismatch(impl_name, intf_name) ->
+      fprintf ppf "@[The implementation %s@ does not match the interface %s:"
+       impl_name intf_name
+  | Class_type_declarations(id, d1, d2, reason) ->
+      fprintf ppf
+       "@[<hv 2>Class type declarations do not match:@ \
+        %a@;<1 -2>does not match@ %a@]@ %a"
+       !Oprint.out_sig_item
+       (Printtyp.tree_of_cltype_declaration id d1 Trec_first)
+       !Oprint.out_sig_item
+       (Printtyp.tree_of_cltype_declaration id d2 Trec_first)
+      Includeclass.report_error reason
+  | Class_declarations(id, d1, d2, reason) ->
+      fprintf ppf
+       "@[<hv 2>Class declarations do not match:@ \
+        %a@;<1 -2>does not match@ %a@]@ %a"
+      !Oprint.out_sig_item (Printtyp.tree_of_class_declaration id d1 Trec_first)
+      !Oprint.out_sig_item (Printtyp.tree_of_class_declaration id d2 Trec_first)
+      Includeclass.report_error reason
+  | Unbound_modtype_path path ->
+      fprintf ppf "Unbound module type %a" Printtyp.path path
+  | Unbound_module_path path ->
+      fprintf ppf "Unbound module %a" Printtyp.path path
+  | Invalid_module_alias path ->
+      fprintf ppf "Module %a cannot be aliased" Printtyp.path path
+
+let include_err ppf (cxt, env, err) =
+  Printtyp.wrap_printing_env ~error:true env (fun () ->
+    fprintf ppf "@[<v>%a%a@]" context (List.rev cxt) (include_err env) err)
+
+let buffer = ref Bytes.empty
+let is_big obj =
+  let size = !Clflags.error_size in
+  size > 0 &&
+  begin
+    if Bytes.length !buffer < size then buffer := Bytes.create size;
+    try ignore (Marshal.to_buffer !buffer 0 size obj []); false
+    with _ -> true
+  end
+
+let report_error ppf errs =
+  if errs = [] then () else
+  let (errs , err) = split_last errs in
+  let pe = ref true in
+  let include_err' ppf (_,_,obj as err) =
+    if not (is_big obj) then fprintf ppf "%a@ " include_err err
+    else if !pe then (fprintf ppf "...@ "; pe := false)
+  in
+  let print_errs ppf = List.iter (include_err' ppf) in
+  Printtyp.Conflicts.reset();
+  fprintf ppf "@[<v>%a%a%t@]" print_errs errs include_err err
+    Printtyp.Conflicts.print_explanations
+
+let report_apply_error p1 p2 ppf errs =
+  fprintf ppf "@[The type of %a does not match %a's parameter@ %a@]"
+    Printtyp.path p1 Printtyp.path p2 report_error errs
+
+(* We could do a better job to split the individual error items
+   as sub-messages of the main interface mismatch on the whole unit. *)
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error err -> Some (Location.error_of_printer_file report_error err)
+      | Apply_error(loc, p1, p2, err) ->
+          Some (Location.error_of_printer ~loc (report_apply_error p1 p2) err)
+      | _ -> None
+    )
diff --git a/src/ocaml/typing/410+multicore/includemod.mli b/src/ocaml/typing/410+multicore/includemod.mli
new file mode 100644
index 00000000..4de7eee1
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/includemod.mli
@@ -0,0 +1,89 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Inclusion checks for the module language *)
+
+open Typedtree
+open Types
+open Format
+
+(** Type describing which arguments of an inclusion to consider as used
+    for the usage warnings. [Mark_both] is the default. *)
+type mark =
+  | Mark_both
+      (** Mark definitions used from both arguments *)
+  | Mark_positive
+      (** Mark definitions used from the positive (first) argument *)
+  | Mark_negative
+      (** Mark definitions used from the negative (second) argument *)
+  | Mark_neither
+      (** Do not mark definitions used from either argument *)
+
+val modtypes:
+  loc:Location.t -> Env.t -> ?mark:mark ->
+  module_type -> module_type -> module_coercion
+
+val check_modtype_inclusion :
+  loc:Location.t -> Env.t -> Types.module_type -> Path.t -> Types.module_type ->
+  unit
+(** [check_modtype_inclusion ~loc env mty1 path1 mty2] checks that the
+    functor application F(M) is well typed, where mty2 is the type of
+    the argument of F and path1/mty1 is the path/unstrenghened type of M. *)
+
+val signatures: Env.t -> ?mark:mark ->
+  signature -> signature -> module_coercion
+
+val compunit:
+      Env.t -> ?mark:mark -> string -> signature ->
+      string -> signature -> module_coercion
+
+val type_declarations:
+  loc:Location.t -> Env.t -> ?mark:mark ->
+  Ident.t -> type_declaration -> type_declaration -> unit
+
+val print_coercion: formatter -> module_coercion -> unit
+
+type symptom =
+    Missing_field of Ident.t * Location.t * string (* kind *)
+  | Value_descriptions of Ident.t * value_description * value_description
+  | Type_declarations of Ident.t * type_declaration
+        * type_declaration * Includecore.type_mismatch
+  | Extension_constructors of Ident.t * extension_constructor
+        * extension_constructor * Includecore.extension_constructor_mismatch
+  | Module_types of module_type * module_type
+  | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
+  | Modtype_permutation of Types.module_type * Typedtree.module_coercion
+  | Interface_mismatch of string * string
+  | Class_type_declarations of
+      Ident.t * class_type_declaration * class_type_declaration *
+      Ctype.class_match_failure list
+  | Class_declarations of
+      Ident.t * class_declaration * class_declaration *
+      Ctype.class_match_failure list
+  | Unbound_modtype_path of Path.t
+  | Unbound_module_path of Path.t
+  | Invalid_module_alias of Path.t
+
+type pos =
+  | Module of Ident.t
+  | Modtype of Ident.t
+  | Arg of functor_parameter
+  | Body of functor_parameter
+type error = pos list * Env.t * symptom
+
+exception Error of error list
+
+val report_error: formatter -> error list -> unit
+val expand_module_alias: Env.t -> pos list -> Path.t -> Types.module_type
diff --git a/src/ocaml/typing/410+multicore/mtype.ml b/src/ocaml/typing/410+multicore/mtype.ml
new file mode 100644
index 00000000..38894e13
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/mtype.ml
@@ -0,0 +1,527 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Operations on module types *)
+
+open Asttypes
+open Path
+open Types
+
+
+let rec scrape env mty =
+  match mty with
+    Mty_ident p ->
+      begin try
+        scrape env (Env.find_modtype_expansion p env)
+      with Not_found ->
+        mty
+      end
+  | _ -> mty
+
+let freshen ~scope mty =
+  Subst.modtype (Rescope scope) Subst.identity mty
+
+let rec strengthen ~aliasable env mty p =
+  match scrape env mty with
+    Mty_signature sg ->
+      Mty_signature(strengthen_sig ~aliasable env sg p)
+  | Mty_functor(Named (Some param, arg), res)
+    when !Clflags.applicative_functors ->
+      Mty_functor(Named (Some param, arg),
+        strengthen ~aliasable:false env res (Papply(p, Pident param)))
+  | Mty_functor(Named (None, arg), res)
+    when !Clflags.applicative_functors ->
+      let param = Ident.create_scoped ~scope:(Path.scope p) "Arg" in
+      Mty_functor(Named (Some param, arg),
+        strengthen ~aliasable:false env res (Papply(p, Pident param)))
+  | mty ->
+      mty
+
+and strengthen_sig ~aliasable env sg p =
+  match sg with
+    [] -> []
+  | (Sig_value(_, _, _) as sigelt) :: rem ->
+      sigelt :: strengthen_sig ~aliasable env rem p
+  | Sig_type(id, {type_kind=Type_abstract}, _, _) ::
+    (Sig_type(id', {type_private=Private}, _, _) :: _ as rem)
+    when Ident.name id = Ident.name id' ^ "#row" ->
+      strengthen_sig ~aliasable env rem p
+  | Sig_type(id, decl, rs, vis) :: rem ->
+      let newdecl =
+        match decl.type_manifest, decl.type_private, decl.type_kind with
+          Some _, Public, _ -> decl
+        | Some _, Private, (Type_record _ | Type_variant _) -> decl
+        | _ ->
+            let manif =
+              Some(Btype.newgenty(Tconstr(Pdot(p, Ident.name id),
+                                          decl.type_params, ref Mnil))) in
+            if decl.type_kind = Type_abstract then
+              { decl with type_private = Public; type_manifest = manif }
+            else
+              { decl with type_manifest = manif }
+      in
+      Sig_type(id, newdecl, rs, vis) :: strengthen_sig ~aliasable env rem p
+  | (Sig_typext _ as sigelt) :: rem ->
+      sigelt :: strengthen_sig ~aliasable env rem p
+  | Sig_module(id, pres, md, rs, vis) :: rem ->
+      let str =
+        strengthen_decl ~aliasable env md (Pdot(p, Ident.name id))
+      in
+      Sig_module(id, pres, str, rs, vis)
+      :: strengthen_sig ~aliasable
+        (Env.add_module_declaration ~check:false id pres md env) rem p
+      (* Need to add the module in case it defines manifest module types *)
+  | Sig_modtype(id, decl, vis) :: rem ->
+      let newdecl =
+        match decl.mtd_type with
+          None ->
+            {decl with mtd_type = Some(Mty_ident(Pdot(p,Ident.name id)))}
+        | Some _ ->
+            decl
+      in
+      Sig_modtype(id, newdecl, vis) ::
+      strengthen_sig ~aliasable (Env.add_modtype id decl env) rem p
+      (* Need to add the module type in case it is manifest *)
+  | (Sig_class _ as sigelt) :: rem ->
+      sigelt :: strengthen_sig ~aliasable env rem p
+  | (Sig_class_type _ as sigelt) :: rem ->
+      sigelt :: strengthen_sig ~aliasable env rem p
+
+and strengthen_decl ~aliasable env md p =
+  match md.md_type with
+  | Mty_alias _ -> md
+  | _ when aliasable -> {md with md_type = Mty_alias p}
+  | mty -> {md with md_type = strengthen ~aliasable env mty p}
+
+let () = Env.strengthen := strengthen
+
+let rec make_aliases_absent pres mty =
+  match mty with
+  | Mty_alias _ -> Mp_absent, mty
+  | Mty_signature sg ->
+      pres, Mty_signature(make_aliases_absent_sig sg)
+  | Mty_functor(arg, res) ->
+      let _, res = make_aliases_absent Mp_present res in
+      pres, Mty_functor(arg, res)
+  | mty ->
+      pres, mty
+
+and make_aliases_absent_sig sg =
+  match sg with
+    [] -> []
+  | Sig_module(id, pres, md, rs, priv) :: rem ->
+      let pres, md_type = make_aliases_absent pres md.md_type in
+      let md = { md with md_type } in
+      Sig_module(id, pres, md, rs, priv) :: make_aliases_absent_sig rem
+  | sigelt :: rem ->
+      sigelt :: make_aliases_absent_sig rem
+
+let scrape_for_type_of env pres mty =
+  let rec loop env path mty =
+    match mty, path with
+    | Mty_alias path, _ -> begin
+        try
+          let md = Env.find_module path env in
+          loop env (Some path) md.md_type
+        with Not_found -> mty
+      end
+    | mty, Some path ->
+        strengthen ~aliasable:false env mty path
+    | _ -> mty
+  in
+  make_aliases_absent pres (loop env None mty)
+
+(* In nondep_supertype, env is only used for the type it assigns to id.
+   Hence there is no need to keep env up-to-date by adding the bindings
+   traversed. *)
+
+type variance = Co | Contra | Strict
+
+let rec nondep_mty_with_presence env va ids pres mty =
+  match mty with
+    Mty_ident p ->
+      begin match Path.find_free_opt ids p with
+      | Some id ->
+          let expansion =
+            try Env.find_modtype_expansion p env
+            with Not_found ->
+              raise (Ctype.Nondep_cannot_erase id)
+          in
+          nondep_mty_with_presence env va ids pres expansion
+      | None -> pres, mty
+      end
+  | Mty_alias p ->
+      begin match Path.find_free_opt ids p with
+      | Some id ->
+          let expansion =
+            try Env.find_module p env
+            with Not_found ->
+              raise (Ctype.Nondep_cannot_erase id)
+          in
+          nondep_mty_with_presence env va ids Mp_present expansion.md_type
+      | None -> pres, mty
+      end
+  | Mty_signature sg ->
+      let mty = Mty_signature(nondep_sig env va ids sg) in
+      pres, mty
+  | Mty_functor(Unit, res) ->
+      pres, Mty_functor(Unit, nondep_mty env va ids res)
+  | Mty_functor(Named (param, arg), res) ->
+      let var_inv =
+        match va with Co -> Contra | Contra -> Co | Strict -> Strict in
+      let res_env =
+        match param with
+        | None -> env
+        | Some param -> Env.add_module ~arg:true param Mp_present arg env
+      in
+      let mty =
+        Mty_functor(Named (param, nondep_mty env var_inv ids arg),
+                    nondep_mty res_env va ids res)
+      in
+      pres, mty
+
+and nondep_mty env va ids mty =
+  snd (nondep_mty_with_presence env va ids Mp_present mty)
+
+and nondep_sig_item env va ids = function
+  | Sig_value(id, d, vis) ->
+      Sig_value(id,
+                {d with val_type = Ctype.nondep_type env ids d.val_type},
+                vis)
+  | Sig_type(id, d, rs, vis) ->
+      Sig_type(id, Ctype.nondep_type_decl env ids (va = Co) d, rs, vis)
+  | Sig_typext(id, ext, es, vis) ->
+      Sig_typext(id, Ctype.nondep_extension_constructor env ids ext, es, vis)
+  | Sig_module(id, pres, md, rs, vis) ->
+      let pres, mty = nondep_mty_with_presence env va ids pres md.md_type in
+      Sig_module(id, pres, {md with md_type = mty}, rs, vis)
+  | Sig_modtype(id, d, vis) ->
+      begin try
+        Sig_modtype(id, nondep_modtype_decl env ids d, vis)
+      with Ctype.Nondep_cannot_erase _ as exn ->
+        match va with
+          Co -> Sig_modtype(id, {mtd_type=None; mtd_loc=Location.none;
+                                 mtd_attributes=[]}, vis)
+        | _  -> raise exn
+      end
+  | Sig_class(id, d, rs, vis) ->
+      Sig_class(id, Ctype.nondep_class_declaration env ids d, rs, vis)
+  | Sig_class_type(id, d, rs, vis) ->
+      Sig_class_type(id, Ctype.nondep_cltype_declaration env ids d, rs, vis)
+
+and nondep_sig env va ids sg =
+  List.map (nondep_sig_item env va ids) sg
+
+and nondep_modtype_decl env ids mtd =
+  {mtd with mtd_type = Option.map (nondep_mty env Strict ids) mtd.mtd_type}
+
+let nondep_supertype env ids = nondep_mty env Co ids
+let nondep_sig_item env ids = nondep_sig_item env Co ids
+
+let enrich_typedecl env p id decl =
+  match decl.type_manifest with
+    Some _ -> decl
+  | None ->
+      try
+        let orig_decl = Env.find_type p env in
+        if decl.type_arity <> orig_decl.type_arity then
+          decl
+        else
+          let orig_ty =
+            Ctype.reify_univars
+              (Btype.newgenty(Tconstr(p, orig_decl.type_params, ref Mnil)))
+          in
+          let new_ty =
+            Ctype.reify_univars
+              (Btype.newgenty(Tconstr(Pident id, decl.type_params, ref Mnil)))
+          in
+          let env = Env.add_type ~check:false id decl env in
+          Ctype.mcomp env orig_ty new_ty;
+          let orig_ty =
+            Btype.newgenty(Tconstr(p, decl.type_params, ref Mnil))
+          in
+          {decl with type_manifest = Some orig_ty}
+      with Not_found | Ctype.Unify _ ->
+        (* - Not_found: type which was not present in the signature, so we don't
+           have anything to do.
+           - Unify: the current declaration is not compatible with the one we
+           got from the signature. We should just fail now, but then, we could
+           also have failed if the arities of the two decls were different,
+           which we didn't. *)
+        decl
+
+let rec enrich_modtype env p mty =
+  match mty with
+    Mty_signature sg ->
+      Mty_signature(List.map (enrich_item env p) sg)
+  | _ ->
+      mty
+
+and enrich_item env p = function
+    Sig_type(id, decl, rs, priv) ->
+      Sig_type(id,
+                enrich_typedecl env (Pdot(p, Ident.name id)) id decl, rs, priv)
+  | Sig_module(id, pres, md, rs, priv) ->
+      Sig_module(id, pres,
+                  {md with
+                   md_type = enrich_modtype env
+                       (Pdot(p, Ident.name id)) md.md_type},
+                 rs,
+                 priv)
+  | item -> item
+
+let rec type_paths env p mty =
+  match scrape env mty with
+    Mty_ident _ -> []
+  | Mty_alias _ -> []
+  | Mty_signature sg -> type_paths_sig env p sg
+  | Mty_functor _ -> []
+
+and type_paths_sig env p sg =
+  match sg with
+    [] -> []
+  | Sig_type(id, _decl, _, _) :: rem ->
+      Pdot(p, Ident.name id) :: type_paths_sig env p rem
+  | Sig_module(id, pres, md, _, _) :: rem ->
+      type_paths env (Pdot(p, Ident.name id)) md.md_type @
+      type_paths_sig (Env.add_module_declaration ~check:false id pres md env)
+        p rem
+  | Sig_modtype(id, decl, _) :: rem ->
+      type_paths_sig (Env.add_modtype id decl env) p rem
+  | (Sig_value _ | Sig_typext _ | Sig_class _ | Sig_class_type _) :: rem ->
+      type_paths_sig env p rem
+
+
+let rec no_code_needed_mod env pres mty =
+  match pres with
+  | Mp_absent -> true
+  | Mp_present -> begin
+      match scrape env mty with
+        Mty_ident _ -> false
+      | Mty_signature sg -> no_code_needed_sig env sg
+      | Mty_functor _ -> false
+      | Mty_alias _ -> false
+    end
+
+and no_code_needed_sig env sg =
+  match sg with
+    [] -> true
+  | Sig_value(_id, decl, _) :: rem ->
+      begin match decl.val_kind with
+      | Val_prim _ -> no_code_needed_sig env rem
+      | _ -> false
+      end
+  | Sig_module(id, pres, md, _, _) :: rem ->
+      no_code_needed_mod env pres md.md_type &&
+      no_code_needed_sig
+        (Env.add_module_declaration ~check:false id pres md env) rem
+  | (Sig_type _ | Sig_modtype _ | Sig_class_type _) :: rem ->
+      no_code_needed_sig env rem
+  | (Sig_typext _ | Sig_class _) :: _ ->
+      false
+
+let no_code_needed env mty = no_code_needed_mod env Mp_present mty
+
+(* Check whether a module type may return types *)
+
+let rec contains_type env = function
+    Mty_ident path ->
+      begin try match (Env.find_modtype path env).mtd_type with
+      | None -> raise Exit (* PR#6427 *)
+      | Some mty -> contains_type env mty
+      with Not_found -> raise Exit
+      end
+  | Mty_signature sg ->
+      contains_type_sig env sg
+  | Mty_functor (_, body) ->
+      contains_type env body
+  | Mty_alias _ ->
+      ()
+
+and contains_type_sig env = List.iter (contains_type_item env)
+
+and contains_type_item env = function
+    Sig_type (_,({type_manifest = None} |
+                 {type_kind = Type_abstract; type_private = Private}),_, _)
+  | Sig_modtype _
+  | Sig_typext (_, {ext_args = Cstr_record _}, _, _) ->
+      (* We consider that extension constructors with an inlined
+         record create a type (the inlined record), even though
+         it would be technically safe to ignore that considering
+         the current constraints which guarantee that this type
+         is kept local to expressions.  *)
+      raise Exit
+  | Sig_module (_, _, {md_type = mty}, _, _) ->
+      contains_type env mty
+  | Sig_value _
+  | Sig_type _
+  | Sig_typext _
+  | Sig_class _
+  | Sig_class_type _ ->
+      ()
+
+let contains_type env mty =
+  try contains_type env mty; false with Exit -> true
+
+
+(* Remove module aliases from a signature *)
+
+let rec get_prefixes = function
+  | Pident _ -> Path.Set.empty
+  | Pdot (p, _)
+  | Papply (p, _) -> Path.Set.add p (get_prefixes p)
+
+let rec get_arg_paths = function
+  | Pident _ -> Path.Set.empty
+  | Pdot (p, _) -> get_arg_paths p
+  | Papply (p1, p2) ->
+      Path.Set.add p2
+        (Path.Set.union (get_prefixes p2)
+           (Path.Set.union (get_arg_paths p1) (get_arg_paths p2)))
+
+let rec rollback_path subst p =
+  try Pident (Path.Map.find p subst)
+  with Not_found ->
+    match p with
+      Pident _ | Papply _ -> p
+    | Pdot (p1, s) ->
+        let p1' = rollback_path subst p1 in
+        if Path.same p1 p1' then p else rollback_path subst (Pdot (p1', s))
+
+let rec collect_ids subst bindings p =
+    begin match rollback_path subst p with
+      Pident id ->
+        let ids =
+          try collect_ids subst bindings (Ident.find_same id bindings)
+          with Not_found -> Ident.Set.empty
+        in
+        Ident.Set.add id ids
+    | _ -> Ident.Set.empty
+    end
+
+let collect_arg_paths mty =
+  let open Btype in
+  let paths = ref Path.Set.empty
+  and subst = ref Path.Map.empty
+  and bindings = ref Ident.empty in
+  (* let rt = Ident.create "Root" in
+     and prefix = ref (Path.Pident rt) in *)
+  let it_path p = paths := Path.Set.union (get_arg_paths p) !paths
+  and it_signature_item it si =
+    type_iterators.it_signature_item it si;
+    match si with
+    | Sig_module (id, _, {md_type=Mty_alias p}, _, _) ->
+        bindings := Ident.add id p !bindings
+    | Sig_module (id, _, {md_type=Mty_signature sg}, _, _) ->
+        List.iter
+          (function Sig_module (id', _, _, _, _) ->
+              subst :=
+                Path.Map.add (Pdot (Pident id, Ident.name id')) id' !subst
+            | _ -> ())
+          sg
+    | _ -> ()
+  in
+  let it = {type_iterators with it_path; it_signature_item} in
+  it.it_module_type it mty;
+  it.it_module_type unmark_iterators mty;
+  Path.Set.fold (fun p -> Ident.Set.union (collect_ids !subst !bindings p))
+    !paths Ident.Set.empty
+
+type remove_alias_args =
+    { mutable modified: bool;
+      exclude: Ident.t -> Path.t -> bool;
+      scrape: Env.t -> module_type -> module_type }
+
+let rec remove_aliases_mty env args pres mty =
+  let args' = {args with modified = false} in
+  let res =
+    match args.scrape env mty with
+      Mty_signature sg ->
+        Mp_present, Mty_signature (remove_aliases_sig env args' sg)
+    | Mty_alias _ ->
+        let mty' = Env.scrape_alias env mty in
+        if mty' = mty then begin
+          pres, mty
+        end else begin
+          args'.modified <- true;
+          remove_aliases_mty env args' Mp_present mty'
+        end
+    | mty ->
+        Mp_present, mty
+  in
+  if args'.modified then begin
+    args.modified <- true;
+    res
+  end else begin
+    pres, mty
+  end
+
+and remove_aliases_sig env args sg =
+  match sg with
+    [] -> []
+  | Sig_module(id, pres, md, rs, priv) :: rem  ->
+      let pres, mty =
+        match md.md_type with
+          Mty_alias p when args.exclude id p ->
+            pres, md.md_type
+        | mty ->
+            remove_aliases_mty env args pres mty
+      in
+      Sig_module(id, pres, {md with md_type = mty} , rs, priv) ::
+      remove_aliases_sig (Env.add_module id pres mty env) args rem
+  | Sig_modtype(id, mtd, priv) :: rem ->
+      Sig_modtype(id, mtd, priv) ::
+      remove_aliases_sig (Env.add_modtype id mtd env) args rem
+  | it :: rem ->
+      it :: remove_aliases_sig env args rem
+
+let scrape_for_functor_arg env mty =
+  let exclude _id p =
+    try ignore (Env.find_module p env); true with Not_found -> false
+  in
+  let _, mty =
+    remove_aliases_mty env {modified=false; exclude; scrape} Mp_present mty
+  in
+  mty
+
+let scrape_for_type_of ~remove_aliases env mty =
+  if remove_aliases then begin
+    let excl = collect_arg_paths mty in
+    let exclude id _p = Ident.Set.mem id excl in
+    let scrape _ mty = mty in
+    let _, mty =
+      remove_aliases_mty env {modified=false; exclude; scrape} Mp_present mty
+    in
+    mty
+  end else begin
+    let _, mty = scrape_for_type_of env Mp_present mty in
+    mty
+  end
+
+(* Lower non-generalizable type variables *)
+
+let lower_nongen nglev mty =
+  let open Btype in
+  let it_type_expr it ty =
+    let ty = repr ty in
+    match ty with
+      {desc=Tvar _; level} ->
+        if level < generic_level && level > nglev then set_level ty nglev
+    | _ ->
+        type_iterators.it_type_expr it ty
+  in
+  let it = {type_iterators with it_type_expr} in
+  it.it_module_type it mty;
+  it.it_module_type unmark_iterators mty
diff --git a/src/ocaml/typing/410+multicore/mtype.mli b/src/ocaml/typing/410+multicore/mtype.mli
new file mode 100644
index 00000000..68d290b3
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/mtype.mli
@@ -0,0 +1,55 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Operations on module types *)
+
+open Types
+
+val scrape: Env.t -> module_type -> module_type
+        (* Expand toplevel module type abbreviations
+           till hitting a "hard" module type (signature, functor,
+           or abstract module type ident. *)
+val scrape_for_functor_arg: Env.t -> module_type -> module_type
+        (* Remove aliases in a functor argument type *)
+val scrape_for_type_of:
+  remove_aliases:bool -> Env.t -> module_type -> module_type
+        (* Process type for module type of *)
+val freshen: scope:int -> module_type -> module_type
+        (* Return an alpha-equivalent copy of the given module type
+           where bound identifiers are fresh. *)
+val strengthen: aliasable:bool -> Env.t -> module_type -> Path.t -> module_type
+        (* Strengthen abstract type components relative to the
+           given path. *)
+val strengthen_decl:
+  aliasable:bool -> Env.t -> module_declaration -> Path.t -> module_declaration
+val nondep_supertype: Env.t -> Ident.t list -> module_type -> module_type
+        (* Return the smallest supertype of the given type
+           in which none of the given idents appears.
+           @raise [Ctype.Nondep_cannot_erase] if no such type exists. *)
+val nondep_sig_item: Env.t -> Ident.t list -> signature_item -> signature_item
+        (* Returns the signature item with its type updated
+           to be the smallest supertype of its initial type
+           in which none of the given idents appears.
+           @raise [Ctype.Nondep_cannot_erase] if no such type exists. *)
+val no_code_needed: Env.t -> module_type -> bool
+val no_code_needed_sig: Env.t -> signature -> bool
+        (* Determine whether a module needs no implementation code,
+           i.e. consists only of type definitions. *)
+val enrich_modtype: Env.t -> Path.t -> module_type -> module_type
+val enrich_typedecl: Env.t -> Path.t -> Ident.t -> type_declaration ->
+  type_declaration
+val type_paths: Env.t -> Path.t -> module_type -> Path.t list
+val contains_type: Env.t -> module_type -> bool
+val lower_nongen: int -> module_type -> unit
diff --git a/src/ocaml/typing/410+multicore/oprint.ml b/src/ocaml/typing/410+multicore/oprint.ml
new file mode 100644
index 00000000..d757cac1
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/oprint.ml
@@ -0,0 +1,827 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Projet Cristal, INRIA Rocquencourt                   *)
+(*                                                                        *)
+(*   Copyright 2002 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Format
+open Outcometree
+
+exception Ellipsis
+
+let cautious f ppf arg =
+  try f ppf arg with
+    Ellipsis -> fprintf ppf "..."
+
+let print_lident ppf = function
+  | "::" -> pp_print_string ppf "(::)"
+  | s -> pp_print_string ppf s
+
+let rec print_ident ppf =
+  function
+    Oide_ident s -> print_lident ppf s.printed_name
+  | Oide_dot (id, s) ->
+      print_ident ppf id; pp_print_char ppf '.'; print_lident ppf s
+  | Oide_apply (id1, id2) ->
+      fprintf ppf "%a(%a)" print_ident id1 print_ident id2
+
+let out_ident = ref print_ident
+
+(* Check a character matches the [identchar_latin1] class from the lexer *)
+let is_ident_char c =
+  match c with
+  | 'A'..'Z' | 'a'..'z' | '_' | '\192'..'\214' | '\216'..'\246'
+  | '\248'..'\255' | '\'' | '0'..'9' -> true
+  | _ -> false
+
+let all_ident_chars s =
+  let rec loop s len i =
+    if i < len then begin
+      if is_ident_char s.[i] then loop s len (i+1)
+      else false
+    end else begin
+      true
+    end
+  in
+  let len = String.length s in
+  loop s len 0
+
+(*
+let parenthesized_ident name =
+  (List.mem name ["or"; "mod"; "land"; "lor"; "lxor"; "lsl"; "lsr"; "asr"])
+  || not (all_ident_chars name)
+*)
+
+let parenthesized_ident = function
+  | "or" | "mod" | "land" | "lor" | "lxor" | "lsl" | "lsr" | "asr" -> true
+  | "[]" | "()" -> false
+  | name -> not (all_ident_chars name)
+
+let value_ident ppf name =
+  if parenthesized_ident name then
+    fprintf ppf "( %s )" name
+  else
+    pp_print_string ppf name
+
+(* Values *)
+
+let valid_float_lexeme s =
+  let l = String.length s in
+  let rec loop i =
+    if i >= l then s ^ "." else
+    match s.[i] with
+    | '0' .. '9' | '-' -> loop (i+1)
+    | _ -> s
+  in loop 0
+
+let float_repres f =
+  match classify_float f with
+    FP_nan -> "nan"
+  | FP_infinite ->
+      if f < 0.0 then "neg_infinity" else "infinity"
+  | _ ->
+      let float_val =
+        let s1 = Printf.sprintf "%.12g" f in
+        if f = float_of_string s1 then s1 else
+        let s2 = Printf.sprintf "%.15g" f in
+        if f = float_of_string s2 then s2 else
+        Printf.sprintf "%.18g" f
+      in valid_float_lexeme float_val
+
+let parenthesize_if_neg ppf fmt v isneg =
+  if isneg then pp_print_char ppf '(';
+  fprintf ppf fmt v;
+  if isneg then pp_print_char ppf ')'
+
+let escape_string s =
+  (* Escape only C0 control characters (bytes <= 0x1F), DEL(0x7F), '\\'
+     and '"' *)
+   let n = ref 0 in
+  for i = 0 to String.length s - 1 do
+    n := !n +
+      (match String.unsafe_get s i with
+       | '\"' | '\\' | '\n' | '\t' | '\r' | '\b' -> 2
+       | '\x00' .. '\x1F'
+       | '\x7F' -> 4
+       | _ -> 1)
+  done;
+  if !n = String.length s then s else begin
+    let s' = Bytes.create !n in
+    n := 0;
+    for i = 0 to String.length s - 1 do
+      begin match String.unsafe_get s i with
+      | ('\"' | '\\') as c ->
+          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n c
+      | '\n' ->
+          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'n'
+      | '\t' ->
+          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 't'
+      | '\r' ->
+          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'r'
+      | '\b' ->
+          Bytes.unsafe_set s' !n '\\'; incr n; Bytes.unsafe_set s' !n 'b'
+      | '\x00' .. '\x1F' | '\x7F' as c ->
+          let a = Char.code c in
+          Bytes.unsafe_set s' !n '\\';
+          incr n;
+          Bytes.unsafe_set s' !n (Char.chr (48 + a / 100));
+          incr n;
+          Bytes.unsafe_set s' !n (Char.chr (48 + (a / 10) mod 10));
+          incr n;
+          Bytes.unsafe_set s' !n (Char.chr (48 + a mod 10));
+      | c -> Bytes.unsafe_set s' !n c
+      end;
+      incr n
+    done;
+    Bytes.to_string s'
+  end
+
+
+let print_out_string ppf s =
+  let not_escaped =
+    (* let the user dynamically choose if strings should be escaped: *)
+    match Sys.getenv_opt "OCAMLTOP_UTF_8" with
+    | None -> true
+    | Some x ->
+        match bool_of_string_opt x with
+        | None -> true
+        | Some f -> f in
+  if not_escaped then
+    fprintf ppf "\"%s\"" (escape_string s)
+  else
+    fprintf ppf "%S" s
+
+let print_out_value ppf tree =
+  let rec print_tree_1 ppf =
+    function
+    | Oval_constr (name, [param]) ->
+        fprintf ppf "@[<1>%a@ %a@]" print_ident name print_constr_param param
+    | Oval_constr (name, (_ :: _ as params)) ->
+        fprintf ppf "@[<1>%a@ (%a)@]" print_ident name
+          (print_tree_list print_tree_1 ",") params
+    | Oval_variant (name, Some param) ->
+        fprintf ppf "@[<2>`%s@ %a@]" name print_constr_param param
+    | tree -> print_simple_tree ppf tree
+  and print_constr_param ppf = function
+    | Oval_int i -> parenthesize_if_neg ppf "%i" i (i < 0)
+    | Oval_int32 i -> parenthesize_if_neg ppf "%lil" i (i < 0l)
+    | Oval_int64 i -> parenthesize_if_neg ppf "%LiL" i (i < 0L)
+    | Oval_nativeint i -> parenthesize_if_neg ppf "%nin" i (i < 0n)
+    | Oval_float f ->
+        parenthesize_if_neg ppf "%s" (float_repres f)
+                                     (f < 0.0 || 1. /. f = neg_infinity)
+    | Oval_string (_,_, Ostr_bytes) as tree ->
+      pp_print_char ppf '(';
+      print_simple_tree ppf tree;
+      pp_print_char ppf ')';
+    | tree -> print_simple_tree ppf tree
+  and print_simple_tree ppf =
+    function
+      Oval_int i -> fprintf ppf "%i" i
+    | Oval_int32 i -> fprintf ppf "%lil" i
+    | Oval_int64 i -> fprintf ppf "%LiL" i
+    | Oval_nativeint i -> fprintf ppf "%nin" i
+    | Oval_float f -> pp_print_string ppf (float_repres f)
+    | Oval_char c -> fprintf ppf "%C" c
+    | Oval_string (s, maxlen, kind) ->
+       begin try
+         let len = String.length s in
+         let s = if len > maxlen then String.sub s 0 maxlen else s in
+         begin match kind with
+         | Ostr_bytes -> fprintf ppf "Bytes.of_string %S" s
+         | Ostr_string -> print_out_string ppf s
+         end;
+         (if len > maxlen then
+            fprintf ppf
+              "... (* string length %d; truncated *)" len
+         )
+          with
+          Invalid_argument _ (* "String.create" *)-> fprintf ppf "<huge string>"
+        end
+    | Oval_list tl ->
+        fprintf ppf "@[<1>[%a]@]" (print_tree_list print_tree_1 ";") tl
+    | Oval_array tl ->
+        fprintf ppf "@[<2>[|%a|]@]" (print_tree_list print_tree_1 ";") tl
+    | Oval_constr (name, []) -> print_ident ppf name
+    | Oval_variant (name, None) -> fprintf ppf "`%s" name
+    | Oval_stuff s -> pp_print_string ppf s
+    | Oval_record fel ->
+        fprintf ppf "@[<1>{%a}@]" (cautious (print_fields true)) fel
+    | Oval_ellipsis -> raise Ellipsis
+    | Oval_printer f -> f ppf
+    | Oval_tuple tree_list ->
+        fprintf ppf "@[<1>(%a)@]" (print_tree_list print_tree_1 ",") tree_list
+    | tree -> fprintf ppf "@[<1>(%a)@]" (cautious print_tree_1) tree
+  and print_fields first ppf =
+    function
+      [] -> ()
+    | (name, tree) :: fields ->
+        if not first then fprintf ppf ";@ ";
+        fprintf ppf "@[<1>%a@ =@ %a@]" print_ident name (cautious print_tree_1)
+          tree;
+        print_fields false ppf fields
+  and print_tree_list print_item sep ppf tree_list =
+    let rec print_list first ppf =
+      function
+        [] -> ()
+      | tree :: tree_list ->
+          if not first then fprintf ppf "%s@ " sep;
+          print_item ppf tree;
+          print_list false ppf tree_list
+    in
+    cautious (print_list true) ppf tree_list
+  in
+  cautious print_tree_1 ppf tree
+
+let out_value = ref print_out_value
+
+(* Types *)
+
+let rec print_list_init pr sep ppf =
+  function
+    [] -> ()
+  | a :: l -> sep ppf; pr ppf a; print_list_init pr sep ppf l
+
+let rec print_list pr sep ppf =
+  function
+    [] -> ()
+  | [a] -> pr ppf a
+  | a :: l -> pr ppf a; sep ppf; print_list pr sep ppf l
+
+let pr_present =
+  print_list (fun ppf s -> fprintf ppf "`%s" s) (fun ppf -> fprintf ppf "@ ")
+
+let pr_var = Pprintast.tyvar
+
+let pr_vars =
+  print_list pr_var (fun ppf -> fprintf ppf "@ ")
+
+let rec print_out_type ppf =
+  function
+  | Otyp_alias (ty, s) ->
+      fprintf ppf "@[%a@ as %a@]" print_out_type ty pr_var s
+  | Otyp_poly (sl, ty) ->
+      fprintf ppf "@[<hov 2>%a.@ %a@]"
+        pr_vars sl
+        print_out_type ty
+  | ty ->
+      print_out_type_1 ppf ty
+
+and print_out_type_1 ppf =
+  function
+    Otyp_arrow (lab, ty1, ty2) ->
+      pp_open_box ppf 0;
+      if lab <> "" then (pp_print_string ppf lab; pp_print_char ppf ':');
+      print_out_type_2 ppf ty1;
+      pp_print_string ppf " ->";
+      pp_print_space ppf ();
+      print_out_type_1 ppf ty2;
+      pp_close_box ppf ()
+  | ty -> print_out_type_2 ppf ty
+and print_out_type_2 ppf =
+  function
+    Otyp_tuple tyl ->
+      fprintf ppf "@[<0>%a@]" (print_typlist print_simple_out_type " *") tyl
+  | ty -> print_simple_out_type ppf ty
+and print_simple_out_type ppf =
+  function
+    Otyp_class (ng, id, tyl) ->
+      fprintf ppf "@[%a%s#%a@]" print_typargs tyl (if ng then "_" else "")
+        print_ident id
+  | Otyp_constr (id, tyl) ->
+      pp_open_box ppf 0;
+      print_typargs ppf tyl;
+      print_ident ppf id;
+      pp_close_box ppf ()
+  | Otyp_object (fields, rest) ->
+      fprintf ppf "@[<2>< %a >@]" (print_fields rest) fields
+  | Otyp_stuff s -> pp_print_string ppf s
+  | Otyp_var (ng, s) -> pr_var ppf (if ng then "_" ^ s else s)
+  | Otyp_variant (non_gen, row_fields, closed, tags) ->
+      let print_present ppf =
+        function
+          None | Some [] -> ()
+        | Some l -> fprintf ppf "@;<1 -2>> @[<hov>%a@]" pr_present l
+      in
+      let print_fields ppf =
+        function
+          Ovar_fields fields ->
+            print_list print_row_field (fun ppf -> fprintf ppf "@;<1 -2>| ")
+              ppf fields
+        | Ovar_typ typ ->
+           print_simple_out_type ppf typ
+      in
+      fprintf ppf "%s@[<hov>[%s@[<hv>@[<hv>%a@]%a@]@ ]@]"
+        (if non_gen then "_" else "")
+        (if closed then if tags = None then " " else "< "
+         else if tags = None then "> " else "? ")
+        print_fields row_fields
+        print_present tags
+  | Otyp_alias _ | Otyp_poly _ | Otyp_arrow _ | Otyp_tuple _ as ty ->
+      pp_open_box ppf 1;
+      pp_print_char ppf '(';
+      print_out_type ppf ty;
+      pp_print_char ppf ')';
+      pp_close_box ppf ()
+  | Otyp_abstract | Otyp_open
+  | Otyp_sum _ | Otyp_manifest (_, _) -> ()
+  | Otyp_record lbls -> print_record_decl ppf lbls
+  | Otyp_module (p, n, tyl) ->
+      fprintf ppf "@[<1>(module %a" print_ident p;
+      let first = ref true in
+      List.iter2
+        (fun s t ->
+          let sep = if !first then (first := false; "with") else "and" in
+          fprintf ppf " %s type %s = %a" sep s print_out_type t
+        )
+        n tyl;
+      fprintf ppf ")@]"
+  | Otyp_attribute (t, attr) ->
+      fprintf ppf "@[<1>(%a [@@%s])@]" print_out_type t attr.oattr_name
+and print_record_decl ppf lbls =
+  fprintf ppf "{%a@;<1 -2>}"
+    (print_list_init print_out_label (fun ppf -> fprintf ppf "@ ")) lbls
+and print_fields rest ppf =
+  function
+    [] ->
+      begin match rest with
+        Some non_gen -> fprintf ppf "%s.." (if non_gen then "_" else "")
+      | None -> ()
+      end
+  | [s, t] ->
+      fprintf ppf "%s : %a" s print_out_type t;
+      begin match rest with
+        Some _ -> fprintf ppf ";@ "
+      | None -> ()
+      end;
+      print_fields rest ppf []
+  | (s, t) :: l ->
+      fprintf ppf "%s : %a;@ %a" s print_out_type t (print_fields rest) l
+and print_row_field ppf (l, opt_amp, tyl) =
+  let pr_of ppf =
+    if opt_amp then fprintf ppf " of@ &@ "
+    else if tyl <> [] then fprintf ppf " of@ "
+    else fprintf ppf ""
+  in
+  fprintf ppf "@[<hv 2>`%s%t%a@]" l pr_of (print_typlist print_out_type " &")
+    tyl
+and print_typlist print_elem sep ppf =
+  function
+    [] -> ()
+  | [ty] -> print_elem ppf ty
+  | ty :: tyl ->
+      print_elem ppf ty;
+      pp_print_string ppf sep;
+      pp_print_space ppf ();
+      print_typlist print_elem sep ppf tyl
+and print_typargs ppf =
+  function
+    [] -> ()
+  | [ty1] -> print_simple_out_type ppf ty1; pp_print_space ppf ()
+  | tyl ->
+      pp_open_box ppf 1;
+      pp_print_char ppf '(';
+      print_typlist print_out_type "," ppf tyl;
+      pp_print_char ppf ')';
+      pp_close_box ppf ();
+      pp_print_space ppf ()
+and print_out_label ppf (name, mut, arg) =
+  fprintf ppf "@[<2>%s%s :@ %a@];" (if mut then "mutable " else "") name
+    print_out_type arg
+
+let out_label = ref print_out_label
+
+let out_type = ref print_out_type
+
+(* Class types *)
+
+let print_type_parameter ppf s =
+  if s = "_" then fprintf ppf "_" else pr_var ppf s
+
+let type_parameter ppf (ty, (co, cn)) =
+  fprintf ppf "%s%a"
+    (if not cn then "+" else if not co then "-" else "")
+    print_type_parameter ty
+
+let print_out_class_params ppf =
+  function
+    [] -> ()
+  | tyl ->
+      fprintf ppf "@[<1>[%a]@]@ "
+        (print_list type_parameter (fun ppf -> fprintf ppf ", "))
+        tyl
+
+let rec print_out_class_type ppf =
+  function
+    Octy_constr (id, tyl) ->
+      let pr_tyl ppf =
+        function
+          [] -> ()
+        | tyl ->
+            fprintf ppf "@[<1>[%a]@]@ " (print_typlist !out_type ",") tyl
+      in
+      fprintf ppf "@[%a%a@]" pr_tyl tyl print_ident id
+  | Octy_arrow (lab, ty, cty) ->
+      fprintf ppf "@[%s%a ->@ %a@]" (if lab <> "" then lab ^ ":" else "")
+        print_out_type_2 ty print_out_class_type cty
+  | Octy_signature (self_ty, csil) ->
+      let pr_param ppf =
+        function
+          Some ty -> fprintf ppf "@ @[(%a)@]" !out_type ty
+        | None -> ()
+      in
+      fprintf ppf "@[<hv 2>@[<2>object%a@]@ %a@;<1 -2>end@]" pr_param self_ty
+        (print_list print_out_class_sig_item (fun ppf -> fprintf ppf "@ "))
+        csil
+and print_out_class_sig_item ppf =
+  function
+    Ocsg_constraint (ty1, ty2) ->
+      fprintf ppf "@[<2>constraint %a =@ %a@]" !out_type ty1
+        !out_type ty2
+  | Ocsg_method (name, priv, virt, ty) ->
+      fprintf ppf "@[<2>method %s%s%s :@ %a@]"
+        (if priv then "private " else "") (if virt then "virtual " else "")
+        name !out_type ty
+  | Ocsg_value (name, mut, vr, ty) ->
+      fprintf ppf "@[<2>val %s%s%s :@ %a@]"
+        (if mut then "mutable " else "")
+        (if vr then "virtual " else "")
+        name !out_type ty
+
+let out_class_type = ref print_out_class_type
+
+(* Signature *)
+
+let out_module_type = ref (fun _ -> failwith "Oprint.out_module_type")
+let out_sig_item = ref (fun _ -> failwith "Oprint.out_sig_item")
+let out_signature = ref (fun _ -> failwith "Oprint.out_signature")
+let out_type_extension = ref (fun _ -> failwith "Oprint.out_type_extension")
+
+(* For anonymous functor arguments, the logic to choose between
+   the long-form
+     functor (_ : S) -> ...
+   and the short-form
+     S -> ...
+   is as follows: if we are already printing long-form functor arguments,
+   we use the long form unless all remaining functor arguments can use
+   the short form. (Otherwise use the short form.)
+
+   For example,
+     functor (X : S1) (_ : S2) (Y : S3) (_ : S4) (_ : S5) -> sig end
+   will get printed as
+     functor (X : S1) (_ : S2) (Y : S3) -> S4 -> S5 -> sig end
+
+   but
+     functor (_ : S1) (_ : S2) (Y : S3) (_ : S4) (_ : S5) -> sig end
+   gets printed as
+     S1 -> S2 -> functor (Y : S3) -> S4 -> S5 -> sig end
+*)
+
+(* take a module type that may be a functor type,
+   and return the longest prefix list of arguments
+   that should be printed in long form. *)
+let collect_functor_arguments mty =
+  let rec collect_args acc = function
+    | Omty_functor (param, mty_res) ->
+       collect_args (param :: acc) mty_res
+    | non_functor -> (acc, non_functor)
+  in
+  let rec uncollect_anonymous_suffix acc rest = match acc with
+      | Some (None, mty_arg) :: acc ->
+          uncollect_anonymous_suffix acc
+            (Omty_functor (Some (None, mty_arg), rest))
+      | _ :: _ | [] ->
+         (acc, rest)
+  in
+  let (acc, non_functor) = collect_args [] mty in
+  let (acc, rest) = uncollect_anonymous_suffix acc non_functor in
+  (List.rev acc, rest)
+
+let rec print_out_module_type ppf mty =
+  print_out_functor ppf mty
+and print_out_functor ppf = function
+  | Omty_functor _ as t ->
+     let rec print_functor ppf = function
+       | Omty_functor (Some (None, mty_arg), mty_res) ->
+          fprintf ppf "%a ->@ %a"
+            print_simple_out_module_type mty_arg
+            print_functor mty_res
+       | Omty_functor _ as non_anonymous_functor ->
+          let (args, rest) = collect_functor_arguments non_anonymous_functor in
+          let print_arg ppf = function
+            | None ->
+               fprintf ppf "()"
+            | Some (param, mty) ->
+               fprintf ppf "(%s : %a)"
+                 (Option.value param ~default:"_")
+                 print_out_module_type mty
+          in
+          fprintf ppf "@[<2>functor@ %a@]@ ->@ %a"
+            (pp_print_list ~pp_sep:pp_print_space print_arg) args
+            print_functor rest
+       | non_functor ->
+          print_simple_out_module_type ppf non_functor
+     in
+     fprintf ppf "@[<2>%a@]" print_functor t
+  | t -> print_simple_out_module_type ppf t
+and print_simple_out_module_type ppf =
+  function
+    Omty_abstract -> ()
+  | Omty_ident id -> fprintf ppf "%a" print_ident id
+  | Omty_signature sg ->
+     begin match sg with
+       | [] -> fprintf ppf "sig end"
+       | sg ->
+          fprintf ppf "@[<hv 2>sig@ %a@;<1 -2>end@]" print_out_signature sg
+     end
+  | Omty_alias id -> fprintf ppf "(module %a)" print_ident id
+  | Omty_functor _ as non_simple ->
+     fprintf ppf "(%a)" print_out_module_type non_simple
+and print_out_signature ppf =
+  function
+    [] -> ()
+  | [item] -> !out_sig_item ppf item
+  | Osig_typext(ext, Oext_first) :: items ->
+      (* Gather together the extension constructors *)
+      let rec gather_extensions acc items =
+        match items with
+            Osig_typext(ext, Oext_next) :: items ->
+              gather_extensions
+                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
+                items
+          | _ -> (List.rev acc, items)
+      in
+      let exts, items =
+        gather_extensions
+          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
+          items
+      in
+      let te =
+        { otyext_name = ext.oext_type_name;
+          otyext_params = ext.oext_type_params;
+          otyext_constructors = exts;
+          otyext_private = ext.oext_private }
+      in
+        fprintf ppf "%a@ %a" !out_type_extension te print_out_signature items
+  | item :: items ->
+      fprintf ppf "%a@ %a" !out_sig_item item print_out_signature items
+and print_out_sig_item ppf =
+  function
+    Osig_class (vir_flag, name, params, clt, rs) ->
+      fprintf ppf "@[<2>%s%s@ %a%s@ :@ %a@]"
+        (if rs = Orec_next then "and" else "class")
+        (if vir_flag then " virtual" else "") print_out_class_params params
+        name !out_class_type clt
+  | Osig_class_type (vir_flag, name, params, clt, rs) ->
+      fprintf ppf "@[<2>%s%s@ %a%s@ =@ %a@]"
+        (if rs = Orec_next then "and" else "class type")
+        (if vir_flag then " virtual" else "") print_out_class_params params
+        name !out_class_type clt
+  | Osig_typext (ext, Oext_exception) ->
+      fprintf ppf "@[<2>exception %a@]"
+        print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)
+  | Osig_typext (ext, _es) ->
+      print_out_extension_constructor ppf ext
+  | Osig_modtype (name, Omty_abstract) ->
+      fprintf ppf "@[<2>module type %s@]" name
+  | Osig_modtype (name, mty) ->
+      fprintf ppf "@[<2>module type %s =@ %a@]" name !out_module_type mty
+  | Osig_module (name, Omty_alias id, _) ->
+      fprintf ppf "@[<2>module %s =@ %a@]" name print_ident id
+  | Osig_module (name, mty, rs) ->
+      fprintf ppf "@[<2>%s %s :@ %a@]"
+        (match rs with Orec_not -> "module"
+                     | Orec_first -> "module rec"
+                     | Orec_next -> "and")
+        name !out_module_type mty
+  | Osig_type(td, rs) ->
+        print_out_type_decl
+          (match rs with
+           | Orec_not   -> "type nonrec"
+           | Orec_first -> "type"
+           | Orec_next  -> "and")
+          ppf td
+  | Osig_value vd ->
+      let kwd = if vd.oval_prims = [] then "val" else "external" in
+      let pr_prims ppf =
+        function
+          [] -> ()
+        | s :: sl ->
+            fprintf ppf "@ = \"%s\"" s;
+            List.iter (fun s -> fprintf ppf "@ \"%s\"" s) sl
+      in
+      fprintf ppf "@[<2>%s %a :@ %a%a%a@]" kwd value_ident vd.oval_name
+        !out_type vd.oval_type pr_prims vd.oval_prims
+        (fun ppf -> List.iter (fun a -> fprintf ppf "@ [@@@@%s]" a.oattr_name))
+        vd.oval_attributes
+  | Osig_ellipsis ->
+      fprintf ppf "..."
+
+and print_out_type_decl kwd ppf td =
+  let print_constraints ppf =
+    List.iter
+      (fun (ty1, ty2) ->
+         fprintf ppf "@ @[<2>constraint %a =@ %a@]" !out_type ty1
+           !out_type ty2)
+      td.otype_cstrs
+  in
+  let type_defined ppf =
+    match td.otype_params with
+      [] -> pp_print_string ppf td.otype_name
+    | [param] -> fprintf ppf "@[%a@ %s@]" type_parameter param td.otype_name
+    | _ ->
+        fprintf ppf "@[(@[%a)@]@ %s@]"
+          (print_list type_parameter (fun ppf -> fprintf ppf ",@ "))
+          td.otype_params
+          td.otype_name
+  in
+  let print_manifest ppf =
+    function
+      Otyp_manifest (ty, _) -> fprintf ppf " =@ %a" !out_type ty
+    | _ -> ()
+  in
+  let print_name_params ppf =
+    fprintf ppf "%s %t%a" kwd type_defined print_manifest td.otype_type
+  in
+  let ty =
+    match td.otype_type with
+      Otyp_manifest (_, ty) -> ty
+    | _ -> td.otype_type
+  in
+  let print_private ppf = function
+    Asttypes.Private -> fprintf ppf " private"
+  | Asttypes.Public -> ()
+  in
+  let print_immediate ppf =
+    match td.otype_immediate with
+    | Unknown -> ()
+    | Always -> fprintf ppf " [%@%@immediate]"
+    | Always_on_64bits -> fprintf ppf " [%@%@immediate64]"
+  in
+  let print_unboxed ppf =
+    if td.otype_unboxed then fprintf ppf " [%@%@unboxed]" else ()
+  in
+  let print_out_tkind ppf = function
+  | Otyp_abstract -> ()
+  | Otyp_record lbls ->
+      fprintf ppf " =%a %a"
+        print_private td.otype_private
+        print_record_decl lbls
+  | Otyp_sum constrs ->
+      let variants fmt constrs =
+        if constrs = [] then fprintf fmt "|" else
+        fprintf fmt "%a" (print_list print_out_constr
+          (fun ppf -> fprintf ppf "@ | ")) constrs in
+      fprintf ppf " =%a@;<1 2>%a"
+        print_private td.otype_private variants constrs
+  | Otyp_open ->
+      fprintf ppf " =%a .."
+        print_private td.otype_private
+  | ty ->
+      fprintf ppf " =%a@;<1 2>%a"
+        print_private td.otype_private
+        !out_type ty
+  in
+  fprintf ppf "@[<2>@[<hv 2>%t%a@]%t%t%t@]"
+    print_name_params
+    print_out_tkind ty
+    print_constraints
+    print_immediate
+    print_unboxed
+
+and print_out_constr ppf (name, tyl,ret_type_opt) =
+  let name =
+    match name with
+    | "::" -> "(::)"   (* #7200 *)
+    | s -> s
+  in
+  match ret_type_opt with
+  | None ->
+      begin match tyl with
+      | [] ->
+          pp_print_string ppf name
+      | _ ->
+          fprintf ppf "@[<2>%s of@ %a@]" name
+            (print_typlist print_simple_out_type " *") tyl
+      end
+  | Some ret_type ->
+      begin match tyl with
+      | [] ->
+          fprintf ppf "@[<2>%s :@ %a@]" name print_simple_out_type  ret_type
+      | _ ->
+          fprintf ppf "@[<2>%s :@ %a -> %a@]" name
+            (print_typlist print_simple_out_type " *")
+            tyl print_simple_out_type ret_type
+      end
+
+and print_out_extension_constructor ppf ext =
+  let print_extended_type ppf =
+      match ext.oext_type_params with
+        [] -> fprintf ppf "%s" ext.oext_type_name
+      | [ty_param] ->
+        fprintf ppf "@[%a@ %s@]"
+          print_type_parameter
+          ty_param
+          ext.oext_type_name
+      | _ ->
+        fprintf ppf "@[(@[%a)@]@ %s@]"
+          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
+          ext.oext_type_params
+          ext.oext_type_name
+  in
+  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
+    print_extended_type
+    (if ext.oext_private = Asttypes.Private then " private" else "")
+    print_out_constr (ext.oext_name, ext.oext_args, ext.oext_ret_type)
+
+and print_out_type_extension ppf te =
+  let print_extended_type ppf =
+    match te.otyext_params with
+      [] -> fprintf ppf "%s" te.otyext_name
+    | [param] ->
+      fprintf ppf "@[%a@ %s@]"
+        print_type_parameter param
+        te.otyext_name
+    | _ ->
+        fprintf ppf "@[(@[%a)@]@ %s@]"
+          (print_list print_type_parameter (fun ppf -> fprintf ppf ",@ "))
+          te.otyext_params
+          te.otyext_name
+  in
+  fprintf ppf "@[<hv 2>type %t +=%s@;<1 2>%a@]"
+    print_extended_type
+    (if te.otyext_private = Asttypes.Private then " private" else "")
+    (print_list print_out_constr (fun ppf -> fprintf ppf "@ | "))
+    te.otyext_constructors
+
+let out_constr = ref print_out_constr
+let _ = out_module_type := print_out_module_type
+let _ = out_signature := print_out_signature
+let _ = out_sig_item := print_out_sig_item
+let _ = out_type_extension := print_out_type_extension
+
+(* Phrases *)
+
+let print_out_exception ppf exn outv =
+  match exn with
+    Sys.Break -> fprintf ppf "Interrupted.@."
+  | Out_of_memory -> fprintf ppf "Out of memory during evaluation.@."
+  | Stack_overflow ->
+      fprintf ppf "Stack overflow during evaluation (looping recursion?).@."
+  | _ -> match Printexc.use_printers exn with
+        | None -> fprintf ppf "@[Exception:@ %a.@]@." !out_value outv
+        | Some s -> fprintf ppf "@[Exception:@ %s@]@." s
+
+let rec print_items ppf =
+  function
+    [] -> ()
+  | (Osig_typext(ext, Oext_first), None) :: items ->
+      (* Gather together extension constructors *)
+      let rec gather_extensions acc items =
+        match items with
+            (Osig_typext(ext, Oext_next), None) :: items ->
+              gather_extensions
+                ((ext.oext_name, ext.oext_args, ext.oext_ret_type) :: acc)
+                items
+          | _ -> (List.rev acc, items)
+      in
+      let exts, items =
+        gather_extensions
+          [(ext.oext_name, ext.oext_args, ext.oext_ret_type)]
+          items
+      in
+      let te =
+        { otyext_name = ext.oext_type_name;
+          otyext_params = ext.oext_type_params;
+          otyext_constructors = exts;
+          otyext_private = ext.oext_private }
+      in
+        fprintf ppf "@[%a@]" !out_type_extension te;
+        if items <> [] then fprintf ppf "@ %a" print_items items
+  | (tree, valopt) :: items ->
+      begin match valopt with
+        Some v ->
+          fprintf ppf "@[<2>%a =@ %a@]" !out_sig_item tree
+            !out_value v
+      | None -> fprintf ppf "@[%a@]" !out_sig_item tree
+      end;
+      if items <> [] then fprintf ppf "@ %a" print_items items
+
+let print_out_phrase ppf =
+  function
+    Ophr_eval (outv, ty) ->
+      fprintf ppf "@[- : %a@ =@ %a@]@." !out_type ty !out_value outv
+  | Ophr_signature [] -> ()
+  | Ophr_signature items -> fprintf ppf "@[<v>%a@]@." print_items items
+  | Ophr_exception (exn, outv) -> print_out_exception ppf exn outv
+
+let out_phrase = ref print_out_phrase
diff --git a/src/ocaml/typing/410+multicore/oprint.mli b/src/ocaml/typing/410+multicore/oprint.mli
new file mode 100644
index 00000000..2eaaa264
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/oprint.mli
@@ -0,0 +1,32 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Projet Cristal, INRIA Rocquencourt                   *)
+(*                                                                        *)
+(*   Copyright 2002 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Format
+open Outcometree
+
+val out_ident : (formatter -> out_ident -> unit) ref
+val out_value : (formatter -> out_value -> unit) ref
+val out_label : (formatter -> string * bool * out_type -> unit) ref
+val out_type : (formatter -> out_type -> unit) ref
+val out_constr :
+  (formatter -> string * out_type list * out_type option -> unit) ref
+val out_class_type : (formatter -> out_class_type -> unit) ref
+val out_module_type : (formatter -> out_module_type -> unit) ref
+val out_sig_item : (formatter -> out_sig_item -> unit) ref
+val out_signature : (formatter -> out_sig_item list -> unit) ref
+val out_type_extension : (formatter -> out_type_extension -> unit) ref
+val out_phrase : (formatter -> out_phrase -> unit) ref
+
+val parenthesized_ident : string -> bool
diff --git a/src/ocaml/typing/410+multicore/outcometree.mli b/src/ocaml/typing/410+multicore/outcometree.mli
new file mode 100644
index 00000000..bb53d235
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/outcometree.mli
@@ -0,0 +1,148 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*      Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt          *)
+(*                                                                        *)
+(*   Copyright 2001 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Module [Outcometree]: results displayed by the toplevel *)
+
+(* These types represent messages that the toplevel displays as normal
+   results or errors. The real displaying is customisable using the hooks:
+      [Toploop.print_out_value]
+      [Toploop.print_out_type]
+      [Toploop.print_out_sig_item]
+      [Toploop.print_out_phrase] *)
+
+(** An [out_name] is a string representation of an identifier which can be
+    rewritten on the fly to avoid name collisions *)
+type out_name = { mutable printed_name: string }
+
+type out_ident =
+  | Oide_apply of out_ident * out_ident
+  | Oide_dot of out_ident * string
+  | Oide_ident of out_name
+
+type out_string =
+  | Ostr_string
+  | Ostr_bytes
+
+type out_attribute =
+  { oattr_name: string }
+
+type out_value =
+  | Oval_array of out_value list
+  | Oval_char of char
+  | Oval_constr of out_ident * out_value list
+  | Oval_ellipsis
+  | Oval_float of float
+  | Oval_int of int
+  | Oval_int32 of int32
+  | Oval_int64 of int64
+  | Oval_nativeint of nativeint
+  | Oval_list of out_value list
+  | Oval_printer of (Format.formatter -> unit)
+  | Oval_record of (out_ident * out_value) list
+  | Oval_string of string * int * out_string (* string, size-to-print, kind *)
+  | Oval_stuff of string
+  | Oval_tuple of out_value list
+  | Oval_variant of string * out_value option
+
+type out_type =
+  | Otyp_abstract
+  | Otyp_open
+  | Otyp_alias of out_type * string
+  | Otyp_arrow of string * out_type * out_type
+  | Otyp_class of bool * out_ident * out_type list
+  | Otyp_constr of out_ident * out_type list
+  | Otyp_manifest of out_type * out_type
+  | Otyp_object of (string * out_type) list * bool option
+  | Otyp_record of (string * bool * out_type) list
+  | Otyp_stuff of string
+  | Otyp_sum of (string * out_type list * out_type option) list
+  | Otyp_tuple of out_type list
+  | Otyp_var of bool * string
+  | Otyp_variant of
+      bool * out_variant * bool * (string list) option
+  | Otyp_poly of string list * out_type
+  | Otyp_module of out_ident * string list * out_type list
+  | Otyp_attribute of out_type * out_attribute
+
+and out_variant =
+  | Ovar_fields of (string * bool * out_type list) list
+  | Ovar_typ of out_type
+
+type out_class_type =
+  | Octy_constr of out_ident * out_type list
+  | Octy_arrow of string * out_type * out_class_type
+  | Octy_signature of out_type option * out_class_sig_item list
+and out_class_sig_item =
+  | Ocsg_constraint of out_type * out_type
+  | Ocsg_method of string * bool * bool * out_type
+  | Ocsg_value of string * bool * bool * out_type
+
+type out_module_type =
+  | Omty_abstract
+  | Omty_functor of (string option * out_module_type) option * out_module_type
+  | Omty_ident of out_ident
+  | Omty_signature of out_sig_item list
+  | Omty_alias of out_ident
+and out_sig_item =
+  | Osig_class of
+      bool * string * (string * (bool * bool)) list * out_class_type *
+        out_rec_status
+  | Osig_class_type of
+      bool * string * (string * (bool * bool)) list * out_class_type *
+        out_rec_status
+  | Osig_typext of out_extension_constructor * out_ext_status
+  | Osig_modtype of string * out_module_type
+  | Osig_module of string * out_module_type * out_rec_status
+  | Osig_type of out_type_decl * out_rec_status
+  | Osig_value of out_val_decl
+  | Osig_ellipsis
+and out_type_decl =
+  { otype_name: string;
+    otype_params: (string * (bool * bool)) list;
+    otype_type: out_type;
+    otype_private: Asttypes.private_flag;
+    otype_immediate: Type_immediacy.t;
+    otype_unboxed: bool;
+    otype_cstrs: (out_type * out_type) list }
+and out_extension_constructor =
+  { oext_name: string;
+    oext_type_name: string;
+    oext_type_params: string list;
+    oext_args: out_type list;
+    oext_ret_type: out_type option;
+    oext_private: Asttypes.private_flag }
+and out_type_extension =
+  { otyext_name: string;
+    otyext_params: string list;
+    otyext_constructors: (string * out_type list * out_type option) list;
+    otyext_private: Asttypes.private_flag }
+and out_val_decl =
+  { oval_name: string;
+    oval_type: out_type;
+    oval_prims: string list;
+    oval_attributes: out_attribute list }
+and out_rec_status =
+  | Orec_not
+  | Orec_first
+  | Orec_next
+and out_ext_status =
+  | Oext_first
+  | Oext_next
+  | Oext_exception
+
+type out_phrase =
+  | Ophr_eval of out_value * out_type
+  | Ophr_signature of (out_sig_item * out_value option) list
+  | Ophr_exception of (exn * out_value)
diff --git a/src/ocaml/typing/410+multicore/parmatch.ml b/src/ocaml/typing/410+multicore/parmatch.ml
new file mode 100644
index 00000000..563178bf
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/parmatch.ml
@@ -0,0 +1,2695 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Detection of partial matches and unused match cases. *)
+
+open Misc
+open Asttypes
+open Types
+open Typedtree
+
+(*************************************)
+(* Utilities for building patterns   *)
+(*************************************)
+
+let make_pat desc ty tenv =
+  {pat_desc = desc; pat_loc = Location.none; pat_extra = [];
+   pat_type = ty ; pat_env = tenv;
+   pat_attributes = [];
+  }
+
+let omega = make_pat Tpat_any Ctype.none Env.empty
+
+let extra_pat =
+  make_pat
+    (Tpat_var (Ident.create_local "+", mknoloc "+"))
+    Ctype.none Env.empty
+
+let rec omegas i =
+  if i <= 0 then [] else omega :: omegas (i-1)
+
+let omega_list l = List.map (fun _ -> omega) l
+
+module Pattern_head : sig
+  type desc =
+    | Any
+    | Construct of constructor_description
+    | Constant of constant
+    | Tuple of int
+    | Record of label_description list
+    | Variant of
+        { tag: label; has_arg: bool;
+          cstr_row: row_desc ref;
+          type_row : unit -> row_desc; }
+          (* the row of the type may evolve if [close_variant] is called,
+             hence the (unit -> ...) delay *)
+    | Array of int
+    | Lazy
+
+  type t
+
+  val desc : t -> desc
+  val env : t -> Env.t
+  val loc : t -> Location.t
+  val typ : t -> Types.type_expr
+
+  (** [deconstruct p] returns the head of [p] and the list of sub patterns.
+
+      @raises [Invalid_arg _] if [p] is an or- or an exception-pattern.  *)
+  val deconstruct : pattern -> t * pattern list
+
+  (** reconstructs a pattern, putting wildcards as sub-patterns. *)
+  val to_omega_pattern : t -> pattern
+
+  val make
+    :  loc:Location.t
+    -> typ:Types.type_expr
+    -> env:Env.t
+    -> desc
+    -> t
+
+  val omega : t
+
+end = struct
+  type desc =
+    | Any
+    | Construct of constructor_description
+    | Constant of constant
+    | Tuple of int
+    | Record of label_description list
+    | Variant of
+        { tag: label;
+          has_arg: bool;
+          cstr_row: row_desc ref;
+          type_row: unit -> row_desc; }
+    | Array of int
+    | Lazy
+
+  type t = {
+    desc: desc;
+    typ : Types.type_expr;
+    loc : Location.t;
+    env : Env.t;
+    attributes : attributes;
+  }
+
+  let desc { desc } = desc
+  let env { env } = env
+  let loc { loc } = loc
+  let typ { typ } = typ
+
+  let deconstruct q =
+    let rec deconstruct_desc = function
+      | Tpat_any
+      | Tpat_var _ -> Any, []
+      | Tpat_constant c -> Constant c, []
+      | Tpat_alias (p,_,_) -> deconstruct_desc p.pat_desc
+      | Tpat_tuple args ->
+          Tuple (List.length args), args
+      | Tpat_construct (_, c, args) ->
+          Construct c, args
+      | Tpat_variant (tag, arg, cstr_row) ->
+          let has_arg, pats =
+            match arg with
+            | None -> false, []
+            | Some a -> true, [a]
+          in
+          let type_row () =
+            match Ctype.expand_head q.pat_env q.pat_type with
+              | {desc = Tvariant type_row} -> Btype.row_repr type_row
+              | _ -> assert false
+          in
+          Variant {tag; has_arg; cstr_row; type_row}, pats
+      | Tpat_array args ->
+          Array (List.length args), args
+      | Tpat_record (largs, _) ->
+          let lbls = List.map (fun (_,lbl,_) -> lbl) largs in
+          let pats = List.map (fun (_,_,pat) -> pat) largs in
+          Record lbls, pats
+      | Tpat_lazy p ->
+          Lazy, [p]
+      | Tpat_or _ -> invalid_arg "Parmatch.Pattern_head.deconstruct: (P | Q)"
+      | Tpat_exception _ ->
+          invalid_arg "Parmatch.Pattern_head.deconstruct: (exception P)"
+    in
+    let desc, pats = deconstruct_desc q.pat_desc in
+    { desc; typ = q.pat_type; loc = q.pat_loc;
+      env = q.pat_env; attributes = q.pat_attributes }, pats
+
+  let to_omega_pattern t =
+    let pat_desc =
+      match t.desc with
+      | Any -> Tpat_any
+      | Lazy -> Tpat_lazy omega
+      | Constant c -> Tpat_constant c
+      | Tuple n -> Tpat_tuple (omegas n)
+      | Array n -> Tpat_array (omegas n)
+      | Construct c ->
+          let lid_loc = Location.mkloc (Longident.Lident c.cstr_name) t.loc in
+          Tpat_construct (lid_loc, c, omegas c.cstr_arity)
+      | Variant { tag; has_arg; cstr_row } ->
+          let arg_opt = if has_arg then Some omega else None in
+          Tpat_variant (tag, arg_opt, cstr_row)
+      | Record lbls ->
+          let lst =
+            List.map (fun lbl ->
+              let lid_loc =
+                Location.mkloc (Longident.Lident lbl.lbl_name) t.loc
+              in
+              (lid_loc, lbl, omega)
+            ) lbls
+          in
+          Tpat_record (lst, Closed)
+    in
+    { pat_desc; pat_type = t.typ; pat_loc = t.loc; pat_extra = [];
+      pat_env = t.env; pat_attributes = t.attributes }
+
+  let make ~loc ~typ ~env desc =
+    { desc; loc; typ; env; attributes = [] }
+
+  let omega =
+    { desc = Any
+    ; loc = Location.none
+    ; typ = Ctype.none
+    ; env = Env.empty
+    ; attributes = []
+    }
+end
+
+(*
+  Normalize a pattern ->
+   all arguments are omega (simple pattern) and no more variables
+*)
+
+let normalize_pat p = Pattern_head.(to_omega_pattern @@ fst @@ deconstruct p)
+
+(*******************)
+(* Coherence check *)
+(*******************)
+
+(* For some of the operations we do in this module, we would like (because it
+   simplifies matters) to assume that patterns appearing on a given column in a
+   pattern matrix are /coherent/ (think "of the same type").
+   Unfortunately that is not always true.
+
+   Consider the following (well-typed) example:
+   {[
+     type _ t = S : string t | U : unit t
+
+     let f (type a) (t1 : a t) (t2 : a t) (a : a) =
+       match t1, t2, a with
+       | U, _, () -> ()
+       | _, S, "" -> ()
+   ]}
+
+   Clearly the 3rd column contains incoherent patterns.
+
+   On the example above, most of the algorithms will explore the pattern matrix
+   as illustrated by the following tree:
+
+   {v
+                                                   S
+                                                -------> | "" |
+                             U     | S, "" | __/         | () |
+                         --------> | _, () |   \ not S
+        | U, _, () | __/                        -------> | () |
+        | _, S, "" |   \
+                        ---------> | S, "" | ----------> | "" |
+                          not U                    S
+   v}
+
+   where following an edge labelled by a pattern P means "assuming the value I
+   am matching on is filtered by [P] on the column I am currently looking at,
+   then the following submatrix is still reachable".
+
+   Notice that at any point of that tree, if the first column of a matrix is
+   incoherent, then the branch leading to it can only be taken if the scrutinee
+   is ill-typed.
+   In the example above the only case where we have a matrix with an incoherent
+   first column is when we consider [t1, t2, a] to be [U, S, ...]. However such
+   a value would be ill-typed, so we can never actually get there.
+
+   Checking the first column at each step of the recursion and making the
+   conscious decision of "aborting" the algorithm whenever the first column
+   becomes incoherent, allows us to retain the initial assumption in later
+   stages of the algorithms.
+
+   ---
+
+   N.B. two patterns can be considered coherent even though they might not be of
+   the same type.
+
+   That's in part because we only care about the "head" of patterns and leave
+   checking coherence of subpatterns for the next steps of the algorithm:
+   ('a', 'b') and (1, ()) will be deemed coherent because they are both a tuples
+   of arity 2 (we'll notice at a later stage the incoherence of 'a' and 1).
+
+   But also because it can be hard/costly to determine exactly whether two
+   patterns are of the same type or not (eg. in the example above with _ and S,
+   but see also the module [Coherence_illustration] in
+   testsuite/tests/basic-more/robustmatch.ml).
+
+   For the moment our weak, loosely-syntactic, coherence check seems to be
+   enough and we leave it to each user to consider (and document!) what happens
+   when an "incoherence" is not detected by this check.
+*)
+
+(* Given the first column of a simplified matrix, this function first looks for
+   a "discriminating" pattern on that column (i.e. a non-omega one) and then
+   check that every other head pattern in the column is coherent with that one.
+*)
+let all_coherent column =
+  let coherent_heads hp1 hp2 =
+    match Pattern_head.desc hp1, Pattern_head.desc hp2 with
+    | Construct c, Construct c' ->
+      c.cstr_consts = c'.cstr_consts
+      && c.cstr_nonconsts = c'.cstr_nonconsts
+    | Constant c1, Constant c2 -> begin
+        match c1, c2 with
+        | Const_char _, Const_char _
+        | Const_int _, Const_int _
+        | Const_int32 _, Const_int32 _
+        | Const_int64 _, Const_int64 _
+        | Const_nativeint _, Const_nativeint _
+        | Const_float _, Const_float _
+        | Const_string _, Const_string _ -> true
+        | ( Const_char _
+          | Const_int _
+          | Const_int32 _
+          | Const_int64 _
+          | Const_nativeint _
+          | Const_float _
+          | Const_string _), _ -> false
+      end
+    | Tuple l1, Tuple l2 -> l1 = l2
+    | Record (lbl1 :: _), Record (lbl2 :: _) ->
+      Array.length lbl1.lbl_all = Array.length lbl2.lbl_all
+    | Any, _
+    | _, Any
+    | Record [], Record []
+    | Variant _, Variant _
+    | Array _, Array _
+    | Lazy, Lazy -> true
+    | _, _ -> false
+  in
+  match
+    List.find (fun head_pat ->
+      match Pattern_head.desc head_pat with
+      | Any -> false
+      | _ -> true
+    ) column
+  with
+  | exception Not_found ->
+    (* only omegas on the column: the column is coherent. *)
+    true
+  | discr_pat ->
+    List.for_all (coherent_heads discr_pat) column
+
+let first_column simplified_matrix =
+  List.map (fun ((head, _args), _rest) -> head) simplified_matrix
+
+(***********************)
+(* Compatibility check *)
+(***********************)
+
+(* Patterns p and q compatible means:
+   there exists value V that matches both, However....
+
+  The case of extension types is dubious, as constructor rebind permits
+  that different constructors are the same (and are thus compatible).
+
+  Compilation must take this into account, consider:
+
+  type t = ..
+  type t += A|B
+  type t += C=A
+
+  let f x y = match x,y with
+  | true,A  -> '1'
+  | _,C     -> '2'
+  | false,A -> '3'
+  | _,_     -> '_'
+
+  As C is bound to A the value of f false A is '2' (and not '3' as it would
+  be in the absence of rebinding).
+
+  Not considering rebinding, patterns "false,A" and "_,C" are incompatible
+  and the compiler can swap the second and third clause, resulting in the
+  (more efficiently compiled) matching
+
+  match x,y with
+  | true,A  -> '1'
+  | false,A -> '3'
+  | _,C     -> '2'
+  | _,_     -> '_'
+
+  This is not correct: when C is bound to A, "f false A" returns '2' (not '3')
+
+
+  However, diagnostics do not take constructor rebinding into account.
+  Notice, that due to module abstraction constructor rebinding is hidden.
+
+  module X : sig type t = .. type t += A|B end = struct
+    type t = ..
+    type t += A
+    type t += B=A
+  end
+
+  open X
+
+  let f x = match x with
+  | A -> '1'
+  | B -> '2'
+  | _ -> '_'
+
+  The second clause above will NOT (and cannot) be flagged as useless.
+
+  Finally, there are two compatibility functions:
+   compat p q      ---> 'syntactic compatibility, used for diagnostics.
+   may_compat p q --->   a safe approximation of possible compat,
+                         for compilation
+
+*)
+
+
+let is_absent tag row = Btype.row_field tag !row = Rabsent
+
+let is_absent_pat d =
+  match Pattern_head.desc d with
+  | Variant { tag; cstr_row; _ } -> is_absent tag cstr_row
+  | _ -> false
+
+let const_compare x y =
+  match x,y with
+  | Const_float f1, Const_float f2 ->
+      Stdlib.compare (float_of_string f1) (float_of_string f2)
+  | Const_string (s1, _), Const_string (s2, _) ->
+      String.compare s1 s2
+  | (Const_int _
+    |Const_char _
+    |Const_string (_, _)
+    |Const_float _
+    |Const_int32 _
+    |Const_int64 _
+    |Const_nativeint _
+    ), _ -> Stdlib.compare x y
+
+let records_args l1 l2 =
+  (* Invariant: fields are already sorted by Typecore.type_label_a_list *)
+  let rec combine r1 r2 l1 l2 = match l1,l2 with
+  | [],[] -> List.rev r1, List.rev r2
+  | [],(_,_,p2)::rem2 -> combine (omega::r1) (p2::r2) [] rem2
+  | (_,_,p1)::rem1,[] -> combine (p1::r1) (omega::r2) rem1 []
+  | (_,lbl1,p1)::rem1, ( _,lbl2,p2)::rem2 ->
+      if lbl1.lbl_pos < lbl2.lbl_pos then
+        combine (p1::r1) (omega::r2) rem1 l2
+      else if lbl1.lbl_pos > lbl2.lbl_pos then
+        combine (omega::r1) (p2::r2) l1 rem2
+      else (* same label on both sides *)
+        combine (p1::r1) (p2::r2) rem1 rem2 in
+  combine [] [] l1 l2
+
+
+
+module Compat
+    (Constr:sig
+      val equal :
+          Types.constructor_description ->
+            Types.constructor_description ->
+              bool
+    end) = struct
+
+  let rec compat p q = match p.pat_desc,q.pat_desc with
+(* Variables match any value *)
+  | ((Tpat_any|Tpat_var _),_)
+  | (_,(Tpat_any|Tpat_var _)) -> true
+(* Structural induction *)
+  | Tpat_alias (p,_,_),_      -> compat p q
+  | _,Tpat_alias (q,_,_)      -> compat p q
+  | Tpat_or (p1,p2,_),_ ->
+      (compat p1 q || compat p2 q)
+  | _,Tpat_or (q1,q2,_) ->
+      (compat p q1 || compat p q2)
+(* Constructors, with special case for extension *)
+  | Tpat_construct (_, c1,ps1), Tpat_construct (_, c2,ps2) ->
+      Constr.equal c1 c2 && compats ps1 ps2
+(* More standard stuff *)
+  | Tpat_variant(l1,op1, _), Tpat_variant(l2,op2,_) ->
+      l1=l2 && ocompat op1 op2
+  | Tpat_constant c1, Tpat_constant c2 ->
+      const_compare c1 c2 = 0
+  | Tpat_tuple ps, Tpat_tuple qs -> compats ps qs
+  | Tpat_lazy p, Tpat_lazy q -> compat p q
+  | Tpat_record (l1,_),Tpat_record (l2,_) ->
+      let ps,qs = records_args l1 l2 in
+      compats ps qs
+  | Tpat_array ps, Tpat_array qs ->
+      List.length ps = List.length qs &&
+      compats ps qs
+  | _,_  -> false
+
+  and ocompat op oq = match op,oq with
+  | None,None -> true
+  | Some p,Some q -> compat p q
+  | (None,Some _)|(Some _,None) -> false
+
+  and compats ps qs = match ps,qs with
+  | [], [] -> true
+  | p::ps, q::qs -> compat p q && compats ps qs
+  | _,_    -> false
+
+end
+
+module SyntacticCompat =
+  Compat
+    (struct
+      let equal c1 c2 =  Types.equal_tag c1.cstr_tag c2.cstr_tag
+    end)
+
+let compat =  SyntacticCompat.compat
+and compats = SyntacticCompat.compats
+
+(* Due to (potential) rebinding, two extension constructors
+   of the same arity type may equal *)
+
+exception Empty (* Empty pattern *)
+
+(****************************************)
+(* Utilities for retrieving type paths  *)
+(****************************************)
+
+(* May need a clean copy, cf. PR#4745 *)
+let clean_copy ty =
+  if ty.level = Btype.generic_level then ty
+  else Subst.type_expr Subst.identity ty
+
+let get_constructor_type_path ty tenv =
+  let ty = Ctype.repr (Ctype.expand_head tenv (clean_copy ty)) in
+  match ty.desc with
+  | Tconstr (path,_,_) -> path
+  | _ -> assert false
+
+(****************************)
+(* Utilities for matching   *)
+(****************************)
+
+(* Check top matching *)
+let simple_match d h =
+  match Pattern_head.desc d, Pattern_head.desc h with
+  | Construct c1, Construct c2 ->
+      Types.equal_tag c1.cstr_tag c2.cstr_tag
+  | Variant { tag = t1; _ }, Variant { tag = t2 } ->
+      t1 = t2
+  | Constant c1, Constant c2 -> const_compare c1 c2 = 0
+  | Lazy, Lazy -> true
+  | Record _, Record _ -> true
+  | Tuple len1, Tuple len2
+  | Array len1, Array len2 -> len1 = len2
+  | _, Any -> true
+  | _, _ -> false
+
+
+
+(* extract record fields as a whole *)
+let record_arg ph = match Pattern_head.desc ph with
+| Any -> []
+| Record args -> args
+| _ -> fatal_error "Parmatch.as_record"
+
+
+let extract_fields lbls arg =
+  let get_field pos arg =
+    match List.find (fun (lbl,_) -> pos = lbl.lbl_pos) arg with
+    | _, p -> p
+    | exception Not_found -> omega
+  in
+  List.map (fun lbl -> get_field lbl.lbl_pos arg) lbls
+
+(* Build argument list when p2 >= p1, where p1 is a simple pattern *)
+let simple_match_args discr head args = match Pattern_head.desc head with
+| Constant _ -> []
+| Construct _
+| Variant _
+| Tuple _
+| Array _
+| Lazy -> args
+| Record lbls ->  extract_fields (record_arg discr) (List.combine lbls args)
+| Any ->
+    begin match Pattern_head.desc discr with
+    | Construct cstr -> omegas cstr.cstr_arity
+    | Variant { has_arg = true }
+    | Lazy -> [omega]
+    | Record lbls ->  omega_list lbls
+    | Array len
+    | Tuple len -> omegas len
+    | Variant { has_arg = false }
+    | Any
+    | Constant _ -> []
+    end
+
+(* Consider a pattern matrix whose first column has been simplified to contain
+   only _ or a head constructor
+     | p1, r1...
+     | p2, r2...
+     | p3, r3...
+     | ...
+
+   We build a normalized /discriminating/ pattern from a pattern [q] by folding
+   over the first column of the matrix, "refining" [q] as we go:
+
+   - when we encounter a row starting with [Tuple] or [Lazy] then we
+   can stop and return that head, as we cannot refine any further. Indeed,
+   these constructors are alone in their signature, so they will subsume
+   whatever other head we might find, as well as the head we're threading
+   along.
+
+   - when we find a [Record] then it is a bit more involved: it is also alone
+   in its signature, however it might only be matching a subset of the
+   record fields. We use these fields to refine our accumulator and keep going
+   as another row might match on different fields.
+
+   - rows starting with a wildcard do not bring any information, so we ignore
+   them and keep going
+
+   - if we encounter anything else (i.e. any other constructor), then we just
+   stop and return our accumulator.
+*)
+let discr_pat q pss =
+  let rec refine_pat acc = function
+    | [] -> acc
+    | ((head, _), _) :: rows ->
+      match Pattern_head.desc head with
+      | Any -> refine_pat acc rows
+      | Tuple _ | Lazy -> head
+      | Record lbls ->
+        (* N.B. we could make this case "simpler" by refining the record case
+           using [all_record_args].
+           In which case we wouldn't need to fold over the first column for
+           records.
+           However it makes the witness we generate for the exhaustivity warning
+           less pretty. *)
+        let fields =
+          List.fold_right (fun lbl r ->
+            if List.exists (fun l -> l.lbl_pos = lbl.lbl_pos) r then
+              r
+            else
+              lbl :: r
+          ) lbls (record_arg acc)
+        in
+        let d =
+          let open Pattern_head in
+          make ~loc:(loc head) ~typ:(typ head) ~env:(env head) (Record fields)
+        in
+        refine_pat d rows
+      | _ -> acc
+  in
+  let q, _ = Pattern_head.deconstruct q in
+  match Pattern_head.desc q with
+  (* short-circuiting: clearly if we have anything other than [Record] or
+     [Any] to start with, we're not going to be able refine at all. So
+     there's no point going over the matrix. *)
+  | Any | Record _ -> refine_pat q pss
+  | _ -> q
+
+(*
+   In case a matching value is found, set actual arguments
+   of the matching pattern.
+*)
+
+let rec read_args xs r = match xs,r with
+| [],_ -> [],r
+| _::xs, arg::rest ->
+   let args,rest = read_args xs rest in
+   arg::args,rest
+| _,_ ->
+    fatal_error "Parmatch.read_args"
+
+let do_set_args ~erase_mutable q r = match q with
+| {pat_desc = Tpat_tuple omegas} ->
+    let args,rest = read_args omegas r in
+    make_pat (Tpat_tuple args) q.pat_type q.pat_env::rest
+| {pat_desc = Tpat_record (omegas,closed)} ->
+    let args,rest = read_args omegas r in
+    make_pat
+      (Tpat_record
+         (List.map2 (fun (lid, lbl,_) arg ->
+           if
+             erase_mutable &&
+             (match lbl.lbl_mut with
+             | Mutable -> true | Immutable -> false)
+           then
+             lid, lbl, omega
+           else
+             lid, lbl, arg)
+            omegas args, closed))
+      q.pat_type q.pat_env::
+    rest
+| {pat_desc = Tpat_construct (lid, c,omegas)} ->
+    let args,rest = read_args omegas r in
+    make_pat
+      (Tpat_construct (lid, c,args))
+      q.pat_type q.pat_env::
+    rest
+| {pat_desc = Tpat_variant (l, omega, row)} ->
+    let arg, rest =
+      match omega, r with
+        Some _, a::r -> Some a, r
+      | None, r -> None, r
+      | _ -> assert false
+    in
+    make_pat
+      (Tpat_variant (l, arg, row)) q.pat_type q.pat_env::
+    rest
+| {pat_desc = Tpat_lazy _omega} ->
+    begin match r with
+      arg::rest ->
+        make_pat (Tpat_lazy arg) q.pat_type q.pat_env::rest
+    | _ -> fatal_error "Parmatch.do_set_args (lazy)"
+    end
+| {pat_desc = Tpat_array omegas} ->
+    let args,rest = read_args omegas r in
+    make_pat
+      (Tpat_array args) q.pat_type q.pat_env::
+    rest
+| {pat_desc=Tpat_constant _|Tpat_any} ->
+    q::r (* case any is used in matching.ml *)
+| _ -> fatal_error "Parmatch.set_args"
+
+let set_args q r = do_set_args ~erase_mutable:false q r
+and set_args_erase_mutable q r = do_set_args ~erase_mutable:true q r
+
+(* Given a matrix of non-empty rows
+   p1 :: r1...
+   p2 :: r2...
+   p3 :: r3...
+
+   Simplify the first column [p1 p2 p3] by splitting all or-patterns.
+   The result is a list of pairs
+     ((pattern head, arguments), rest of row)
+
+   For example,
+     x :: r1
+     (Some _) as y :: r2
+     (None as x) as y :: r3
+     (Some x | (None as x)) :: r4
+   becomes
+     ((   _ , [ ] ), r1)
+     (( Some, [_] ), r2)
+     (( None, [ ] ), r3)
+     (( Some, [x] ), r4)
+     (( None, [ ] ), r4)
+ *)
+let simplify_head_pat ~add_column p ps k =
+  let rec simplify_head_pat p ps k =
+    match p.pat_desc with
+    | Tpat_alias (p,_,_) ->
+        (* We have to handle aliases here, because there can be or-patterns
+           underneath, that [Pattern_head.deconstruct] won't handle. *)
+        simplify_head_pat p ps k
+    | Tpat_or (p1,p2,_) -> simplify_head_pat p1 ps (simplify_head_pat p2 ps k)
+    | _ -> add_column (Pattern_head.deconstruct p) ps k
+  in simplify_head_pat p ps k
+
+let rec simplify_first_col = function
+  | [] -> []
+  | [] :: _ -> assert false (* the rows are non-empty! *)
+  | (p::ps) :: rows ->
+      let add_column p ps k = (p, ps) :: k in
+      simplify_head_pat ~add_column p ps (simplify_first_col rows)
+
+
+(* Builds the specialized matrix of [pss] according to the discriminating
+   pattern head [d].
+   See section 3.1 of http://moscova.inria.fr/~maranget/papers/warn/warn.pdf
+
+   NOTES:
+   - we are polymorphic on the type of matrices we work on, in particular a row
+   might not simply be a [pattern list]. That's why we have the [extend_row]
+   parameter.
+*)
+let build_specialized_submatrix ~extend_row discr pss =
+  let rec filter_rec = function
+    | ((head, args), ps) :: pss ->
+        if simple_match discr head
+        then extend_row (simple_match_args discr head args) ps :: filter_rec pss
+        else filter_rec pss
+    | _ -> [] in
+  filter_rec pss
+
+(* The "default" and "specialized" matrices of a given matrix.
+   See section 3.1 of http://moscova.inria.fr/~maranget/papers/warn/warn.pdf .
+*)
+type 'matrix specialized_matrices = {
+  default : 'matrix;
+  constrs : (Pattern_head.t * 'matrix) list;
+}
+
+(* Consider a pattern matrix whose first column has been simplified
+   to contain only _ or a head constructor
+     | p1, r1...
+     | p2, r2...
+     | p3, r3...
+     | ...
+
+   We split this matrix into a list of /specialized/ sub-matrices, one for
+   each head constructor appearing in the first column. For each row whose
+   first column starts with a head constructor, remove this head
+   column, prepend one column for each argument of the constructor,
+   and add the resulting row in the sub-matrix corresponding to this
+   head constructor.
+
+   Rows whose left column is omega (the Any pattern _) may match any
+   head constructor, so they are added to all sub-matrices.
+
+   In the case where all the rows in the matrix have an omega on their first
+   column, then there is only one /specialized/ sub-matrix, formed of all these
+   omega rows.
+   This matrix is also called the /default/ matrix.
+
+   See the documentation of [build_specialized_submatrix] for an explanation of
+   the [extend_row] parameter.
+*)
+let build_specialized_submatrices ~extend_row discr rows =
+  let extend_group discr p args r rs =
+    let r = extend_row (simple_match_args discr p args) r in
+    (discr, r :: rs)
+  in
+
+  (* insert a row of head [p] and rest [r] into the right group *)
+  let rec insert_constr head args r = function
+    | [] ->
+      (* if no group matched this row, it has a head constructor that
+         was never seen before; add a new sub-matrix for this head *)
+      [extend_group head head args r []]
+    | (q0,rs) as bd::env ->
+      if simple_match q0 head
+      then extend_group q0 head args r rs :: env
+      else bd :: insert_constr head args r env
+  in
+
+  (* insert a row of head omega into all groups *)
+  let insert_omega r env =
+    List.map (fun (q0,rs) -> extend_group q0 Pattern_head.omega [] r rs) env
+  in
+
+  let rec form_groups constr_groups omega_tails = function
+    | [] -> (constr_groups, omega_tails)
+    | ((head, args), tail) :: rest ->
+        match Pattern_head.desc head with
+        | Any ->
+            (* note that calling insert_omega here would be wrong
+               as some groups may not have been formed yet, if the
+               first row with this head pattern comes after in the list *)
+            form_groups constr_groups (tail :: omega_tails) rest
+        | _ ->
+            form_groups
+              (insert_constr head args tail constr_groups) omega_tails rest
+  in
+
+  let constr_groups, omega_tails =
+    let initial_constr_group =
+      match Pattern_head.desc discr with
+      | Record _ | Tuple _ | Lazy ->
+        (* [discr] comes from [discr_pat], and in this case subsumes any of the
+           patterns we could find on the first column of [rows]. So it is better
+           to use it for our initial environment than any of the normalized
+           pattern we might obtain from the first column. *)
+        [discr,[]]
+      | _ -> []
+    in
+    form_groups initial_constr_group [] rows
+  in
+  {
+    default = omega_tails;
+    constrs =
+      (* insert omega rows in all groups *)
+      List.fold_right insert_omega omega_tails constr_groups;
+  }
+
+(* Variant related functions *)
+
+let set_last a =
+  let rec loop = function
+    | [] -> assert false
+    | [_] -> [a]
+    | x::l -> x :: loop l
+  in
+  function
+  | (_, []) -> (Pattern_head.deconstruct a, [])
+  | (first, row) -> (first, loop row)
+
+(* mark constructor lines for failure when they are incomplete *)
+let mark_partial =
+  let zero = make_pat (Tpat_constant (Const_int 0)) Ctype.none Env.empty in
+  List.map (fun ((hp, _), _ as ps) ->
+    match Pattern_head.desc hp with
+    | Any -> ps
+    | _ -> set_last zero ps
+  )
+
+let close_variant env row =
+  let row = Btype.row_repr row in
+  let nm =
+    List.fold_left
+      (fun nm (_tag,f) ->
+        match Btype.row_field_repr f with
+        | Reither(_, _, false, e) ->
+            (* m=false means that this tag is not explicitly matched *)
+            Btype.set_row_field e Rabsent;
+            None
+        | Rabsent | Reither (_, _, true, _) | Rpresent _ -> nm)
+      row.row_name row.row_fields in
+  if not row.row_closed || nm != row.row_name then begin
+    (* this unification cannot fail *)
+    Ctype.unify env row.row_more
+      (Btype.newgenty
+         (Tvariant {row with row_fields = []; row_more = Btype.newgenvar();
+                    row_closed = true; row_name = nm}))
+  end
+
+(*
+  Check whether the first column of env makes up a complete signature or
+  not. We work on the discriminating pattern heads of each sub-matrix: they
+  are not omega/Any.
+*)
+let full_match closing env =  match env with
+| [] -> false
+| (discr, _) :: _ ->
+  match Pattern_head.desc discr with
+  | Any -> assert false
+  | Construct { cstr_tag = Cstr_extension _ ; _ } -> false
+  | Construct c -> List.length env = c.cstr_consts + c.cstr_nonconsts
+  | Variant { type_row; _ } ->
+      let fields =
+        List.map
+          (fun (d, _) ->
+            match Pattern_head.desc d with
+            | Variant { tag } -> tag
+            | _ -> assert false)
+          env
+      in
+      let row = type_row () in
+      if closing && not (Btype.row_fixed row) then
+        (* closing=true, we are considering the variant as closed *)
+        List.for_all
+          (fun (tag,f) ->
+            match Btype.row_field_repr f with
+              Rabsent | Reither(_, _, false, _) -> true
+            | Reither (_, _, true, _)
+                (* m=true, do not discard matched tags, rather warn *)
+            | Rpresent _ -> List.mem tag fields)
+          row.row_fields
+      else
+        row.row_closed &&
+        List.for_all
+          (fun (tag,f) ->
+            Btype.row_field_repr f = Rabsent || List.mem tag fields)
+          row.row_fields
+  | Constant Const_char _ ->
+      List.length env = 256
+  | Constant _
+  | Array _ -> false
+  | Tuple _
+  | Record _
+  | Lazy -> true
+
+(* Written as a non-fragile matching, PR#7451 originated from a fragile matching
+   below. *)
+let should_extend ext env = match ext with
+| None -> false
+| Some ext -> begin match env with
+  | [] -> assert false
+  | (p,_)::_ ->
+      begin match Pattern_head.desc p with
+      | Construct {cstr_tag=(Cstr_constant _|Cstr_block _|Cstr_unboxed)} ->
+          let path =
+            get_constructor_type_path (Pattern_head.typ p) (Pattern_head.env p)
+          in
+          Path.same path ext
+      | Construct {cstr_tag=(Cstr_extension _)} -> false
+      | Constant _ | Tuple _ | Variant _ | Record _ | Array _ | Lazy -> false
+      | Any -> assert false
+      end
+end
+
+module ConstructorTagHashtbl = Hashtbl.Make(
+  struct
+    type t = Types.constructor_tag
+    let hash = Hashtbl.hash
+    let equal = Types.equal_tag
+  end
+)
+
+(* complement constructor tags *)
+let complete_tags nconsts nconstrs tags =
+  let seen_const = Array.make nconsts false
+  and seen_constr = Array.make nconstrs false in
+  List.iter
+    (function
+      | Cstr_constant i -> seen_const.(i) <- true
+      | Cstr_block i -> seen_constr.(i) <- true
+      | _  -> assert false)
+    tags ;
+  let r = ConstructorTagHashtbl.create (nconsts+nconstrs) in
+  for i = 0 to nconsts-1 do
+    if not seen_const.(i) then
+      ConstructorTagHashtbl.add r (Cstr_constant i) ()
+  done ;
+  for i = 0 to nconstrs-1 do
+    if not seen_constr.(i) then
+      ConstructorTagHashtbl.add r (Cstr_block i) ()
+  done ;
+  r
+
+(* build a pattern from a constructor description *)
+let pat_of_constr ex_pat cstr =
+  {ex_pat with pat_desc =
+   Tpat_construct (mknoloc (Longident.Lident cstr.cstr_name),
+                   cstr, omegas cstr.cstr_arity)}
+
+let orify x y = make_pat (Tpat_or (x, y, None)) x.pat_type x.pat_env
+
+let rec orify_many = function
+| [] -> assert false
+| [x] -> x
+| x :: xs -> orify x (orify_many xs)
+
+(* build an or-pattern from a constructor list *)
+let pat_of_constrs ex_pat cstrs =
+  let ex_pat = Pattern_head.to_omega_pattern ex_pat in
+  if cstrs = [] then raise Empty else
+  orify_many (List.map (pat_of_constr ex_pat) cstrs)
+
+let pats_of_type ?(always=false) env ty =
+  let ty' = Ctype.expand_head env ty in
+  match ty'.desc with
+  | Tconstr (path, _, _) ->
+      begin try match (Env.find_type path env).type_kind with
+      | Type_variant cl when always || List.length cl = 1 ||
+        List.for_all (fun cd -> cd.Types.cd_res <> None) cl ->
+          let cstrs = fst (Env.find_type_descrs path env) in
+          List.map (pat_of_constr (make_pat Tpat_any ty env)) cstrs
+      | Type_record _ ->
+          let labels = snd (Env.find_type_descrs path env) in
+          let fields =
+            List.map (fun ld ->
+              mknoloc (Longident.Lident "?pat_of_label?"), ld, omega)
+              labels
+          in
+          [make_pat (Tpat_record (fields, Closed)) ty env]
+      | _ -> [omega]
+      with Not_found -> [omega]
+      end
+  | Ttuple tl ->
+      [make_pat (Tpat_tuple (omegas (List.length tl))) ty env]
+  | _ -> [omega]
+
+let rec get_variant_constructors env ty =
+  match (Ctype.repr ty).desc with
+  | Tconstr (path,_,_) -> begin
+      try match Env.find_type path env with
+      | {type_kind=Type_variant _} ->
+          fst (Env.find_type_descrs path env)
+      | {type_manifest = Some _} ->
+          get_variant_constructors env
+            (Ctype.expand_head_once env (clean_copy ty))
+      | _ -> fatal_error "Parmatch.get_variant_constructors"
+      with Not_found ->
+        fatal_error "Parmatch.get_variant_constructors"
+    end
+  | _ -> fatal_error "Parmatch.get_variant_constructors"
+
+(* Sends back a pattern that complements constructor tags all_tag *)
+let complete_constrs p all_tags =
+  let c = match Pattern_head.desc p with Construct c -> c | _ -> assert false in
+  let not_tags = complete_tags c.cstr_consts c.cstr_nonconsts all_tags in
+  let constrs = get_variant_constructors (Pattern_head.env p) c.cstr_res in
+  let others =
+    List.filter
+      (fun cnstr -> ConstructorTagHashtbl.mem not_tags cnstr.cstr_tag)
+      constrs in
+  let const, nonconst =
+    List.partition (fun cnstr -> cnstr.cstr_arity = 0) others in
+  const @ nonconst
+
+let build_other_constrs env p =
+  match Pattern_head.desc p with
+  | Construct { cstr_tag = Cstr_constant _ | Cstr_block _ } ->
+      let get_tag q =
+        match Pattern_head.desc q with
+        | Construct c -> c.cstr_tag
+        | _ -> fatal_error "Parmatch.get_tag" in
+      let all_tags =  List.map (fun (p,_) -> get_tag p) env in
+      pat_of_constrs p (complete_constrs p all_tags)
+  | _ -> extra_pat
+
+let complete_constrs p all_tags =
+  (* This wrapper is here for [Matching], which (indirectly) calls this function
+     from [combine_constructor], and nowhere else.
+     So we know patterns have been fully simplified. *)
+  complete_constrs (fst @@ Pattern_head.deconstruct p) all_tags
+
+(* Auxiliary for build_other *)
+
+let build_other_constant proj make first next p env =
+  let all = List.map (fun (p, _) -> proj (Pattern_head.desc p)) env in
+  let rec try_const i =
+    if List.mem i all
+    then try_const (next i)
+    else make_pat (make i) (Pattern_head.typ p) (Pattern_head.env p)
+  in try_const first
+
+(*
+  Builds a pattern that is incompatible with all patterns in
+  the first column of env
+*)
+
+let some_private_tag = "<some private tag>"
+
+let build_other ext env =
+  match env with
+  | [] -> omega
+  | (d, _) :: _ ->
+      match Pattern_head.desc d with
+      | Construct { cstr_tag = Cstr_extension _ } ->
+          (* let c = {c with cstr_name = "*extension*"} in *) (* PR#7330 *)
+          make_pat
+            (Tpat_var (Ident.create_local "*extension*",
+                       {txt="*extension*"; loc = Pattern_head.loc d}))
+            Ctype.none Env.empty
+      | Construct _ ->
+          begin match ext with
+          | Some ext ->
+              if Path.same ext
+                   (get_constructor_type_path
+                      (Pattern_head.typ d) (Pattern_head.env d))
+              then
+                extra_pat
+              else
+                build_other_constrs env d
+          | _ ->
+              build_other_constrs env d
+          end
+      | Variant { cstr_row; type_row } ->
+          let tags =
+            List.map
+              (fun (d, _) ->
+                match Pattern_head.desc d with
+                | Variant { tag } -> tag
+                | _ -> assert false)
+              env
+            in
+            let make_other_pat tag const =
+              let arg = if const then None else Some omega in
+              make_pat (Tpat_variant(tag, arg, cstr_row))
+                (Pattern_head.typ d) (Pattern_head.env d)
+            in
+            let row = type_row () in
+            begin match
+              List.fold_left
+                (fun others (tag,f) ->
+                  if List.mem tag tags then others else
+                  match Btype.row_field_repr f with
+                    Rabsent (* | Reither _ *) -> others
+                  (* This one is called after erasing pattern info *)
+                  | Reither (c, _, _, _) -> make_other_pat tag c :: others
+                  | Rpresent arg -> make_other_pat tag (arg = None) :: others)
+                [] row.row_fields
+            with
+              [] ->
+                let tag =
+                  if Btype.row_fixed row then some_private_tag else
+                  let rec mktag tag =
+                    if List.mem tag tags then mktag (tag ^ "'") else tag in
+                  mktag "AnyOtherTag"
+                in make_other_pat tag true
+            | pat::other_pats ->
+                List.fold_left
+                  (fun p_res pat ->
+                    make_pat (Tpat_or (pat, p_res, None))
+                      (Pattern_head.typ d) (Pattern_head.env d))
+                  pat other_pats
+            end
+      | Constant Const_char _ ->
+          let all_chars =
+            List.map
+              (fun (p,_) -> match Pattern_head.desc p with
+              | Constant (Const_char c) -> c
+              | _ -> assert false)
+              env
+          in
+          let rec find_other i imax =
+            if i > imax then raise Not_found
+            else
+              let ci = Char.chr i in
+              if List.mem ci all_chars then
+                find_other (i+1) imax
+              else
+                make_pat (Tpat_constant (Const_char ci))
+                  (Pattern_head.typ d) (Pattern_head.env d)
+          in
+          let rec try_chars = function
+            | [] -> omega
+            | (c1,c2) :: rest ->
+                try
+                  find_other (Char.code c1) (Char.code c2)
+                with
+                | Not_found -> try_chars rest
+          in
+          try_chars
+            [ 'a', 'z' ; 'A', 'Z' ; '0', '9' ;
+              ' ', '~' ; Char.chr 0 , Char.chr 255]
+      | Constant Const_int _ ->
+          build_other_constant
+            (function Constant(Const_int i) -> i | _ -> assert false)
+            (function i -> Tpat_constant(Const_int i))
+            0 succ d env
+      | Constant Const_int32 _ ->
+          build_other_constant
+            (function Constant(Const_int32 i) -> i | _ -> assert false)
+            (function i -> Tpat_constant(Const_int32 i))
+            0l Int32.succ d env
+      | Constant Const_int64 _ ->
+          build_other_constant
+            (function Constant(Const_int64 i) -> i | _ -> assert false)
+            (function i -> Tpat_constant(Const_int64 i))
+            0L Int64.succ d env
+      | Constant Const_nativeint _ ->
+          build_other_constant
+            (function Constant(Const_nativeint i) -> i | _ -> assert false)
+            (function i -> Tpat_constant(Const_nativeint i))
+            0n Nativeint.succ d env
+      | Constant Const_string _ ->
+          build_other_constant
+            (function Constant(Const_string (s, _)) -> String.length s
+                    | _ -> assert false)
+            (function i -> Tpat_constant(Const_string(String.make i '*', None)))
+            0 succ d env
+      | Constant Const_float _ ->
+          build_other_constant
+            (function Constant(Const_float f) -> float_of_string f
+                    | _ -> assert false)
+            (function f -> Tpat_constant(Const_float (string_of_float f)))
+            0.0 (fun f -> f +. 1.0) d env
+      | Array _ ->
+          let all_lengths =
+            List.map
+              (fun (p,_) -> match Pattern_head.desc p with
+              | Array len -> len
+              | _ -> assert false)
+              env in
+          let rec try_arrays l =
+            if List.mem l all_lengths then try_arrays (l+1)
+            else
+              make_pat
+                (Tpat_array (omegas l))
+                (Pattern_head.typ d) (Pattern_head.env d) in
+          try_arrays 0
+      | _ -> omega
+
+let rec has_instance p = match p.pat_desc with
+  | Tpat_variant (l,_,r) when is_absent l r -> false
+  | Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_,None,_) -> true
+  | Tpat_alias (p,_,_) | Tpat_variant (_,Some p,_) -> has_instance p
+  | Tpat_or (p1,p2,_) -> has_instance p1 || has_instance p2
+  | Tpat_construct (_,_,ps) | Tpat_tuple ps | Tpat_array ps ->
+      has_instances ps
+  | Tpat_record (lps,_) -> has_instances (List.map (fun (_,_,x) -> x) lps)
+  | Tpat_lazy p
+    -> has_instance p
+  | Tpat_exception _ -> assert false
+
+
+and has_instances = function
+  | [] -> true
+  | q::rem -> has_instance q && has_instances rem
+
+(*
+  Core function :
+  Is the last row of pattern matrix pss + qs satisfiable ?
+  That is :
+    Does there exists at least one value vector, es such that :
+     1- for all ps in pss ps # es (ps and es are not compatible)
+     2- qs <= es                  (es matches qs)
+
+   ---
+
+   In two places in the following function, we check the coherence of the first
+   column of (pss + qs).
+   If it is incoherent, then we exit early saying that (pss + qs) is not
+   satisfiable (which is equivalent to saying "oh, we shouldn't have considered
+   that branch, no good result came come from here").
+
+   But what happens if we have a coherent but ill-typed column?
+   - we might end up returning [false], which is equivalent to noticing the
+   incompatibility: clearly this is fine.
+   - if we end up returning [true] then we're saying that [qs] is useful while
+   it is not. This is sad but not the end of the world, we're just allowing dead
+   code to survive.
+*)
+let rec satisfiable pss qs = match pss with
+| [] -> has_instances qs
+| _  ->
+    match qs with
+    | [] -> false
+    | {pat_desc = Tpat_or(q1,q2,_)}::qs ->
+        satisfiable pss (q1::qs) || satisfiable pss (q2::qs)
+    | {pat_desc = Tpat_alias(q,_,_)}::qs ->
+          satisfiable pss (q::qs)
+    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
+        let pss = simplify_first_col pss in
+        if not (all_coherent (first_column pss)) then
+          false
+        else begin
+          let { default; constrs } =
+            let q0 = discr_pat omega pss in
+            build_specialized_submatrices ~extend_row:(@) q0 pss in
+          if not (full_match false constrs) then
+            satisfiable default qs
+          else
+            List.exists
+              (fun (p,pss) ->
+                 not (is_absent_pat p) &&
+                 satisfiable pss
+                   (simple_match_args p Pattern_head.omega [] @ qs))
+              constrs
+        end
+    | {pat_desc=Tpat_variant (l,_,r)}::_ when is_absent l r -> false
+    | q::qs ->
+        let pss = simplify_first_col pss in
+        let hq, qargs = Pattern_head.deconstruct q in
+        if not (all_coherent (hq :: first_column pss)) then
+          false
+        else begin
+          let q0 = discr_pat q pss in
+          satisfiable (build_specialized_submatrix ~extend_row:(@) q0 pss)
+            (simple_match_args q0 hq qargs @ qs)
+        end
+
+(* While [satisfiable] only checks whether the last row of [pss + qs] is
+   satisfiable, this function returns the (possibly empty) list of vectors [es]
+   which verify:
+     1- for all ps in pss, ps # es (ps and es are not compatible)
+     2- qs <= es                   (es matches qs)
+
+   This is done to enable GADT handling
+
+   For considerations regarding the coherence check, see the comment on
+   [satisfiable] above.  *)
+let rec list_satisfying_vectors pss qs =
+  match pss with
+  | [] -> if has_instances qs then [qs] else []
+  | _  ->
+      match qs with
+      | [] -> []
+      | {pat_desc = Tpat_or(q1,q2,_)}::qs ->
+          list_satisfying_vectors pss (q1::qs) @
+          list_satisfying_vectors pss (q2::qs)
+      | {pat_desc = Tpat_alias(q,_,_)}::qs ->
+          list_satisfying_vectors pss (q::qs)
+      | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
+          let pss = simplify_first_col pss in
+          if not (all_coherent (first_column pss)) then
+            []
+          else begin
+            let q0 = discr_pat omega pss in
+            let wild default_matrix p =
+              List.map (fun qs -> p::qs)
+                (list_satisfying_vectors default_matrix qs)
+            in
+            match build_specialized_submatrices ~extend_row:(@) q0 pss with
+            | { default; constrs = [] } ->
+                (* first column of pss is made of variables only *)
+                wild default omega
+            | { default; constrs = ((p,_)::_ as constrs) } ->
+                let for_constrs () =
+                  List.flatten (
+                    List.map (fun (p,pss) ->
+                      if is_absent_pat p then
+                        []
+                      else
+                        let witnesses =
+                          list_satisfying_vectors pss
+                            (simple_match_args p Pattern_head.omega [] @ qs)
+                        in
+                        let p = Pattern_head.to_omega_pattern p in
+                        List.map (set_args p) witnesses
+                    ) constrs
+                  )
+                in
+                if full_match false constrs then for_constrs () else
+                begin match Pattern_head.desc p with
+                | Construct _ ->
+                    (* activate this code for checking non-gadt constructors *)
+                    wild default (build_other_constrs constrs p)
+                    @ for_constrs ()
+                | _ ->
+                    wild default omega
+                end
+          end
+      | {pat_desc=Tpat_variant (l,_,r)}::_ when is_absent l r -> []
+      | q::qs ->
+          let hq, qargs = Pattern_head.deconstruct q in
+          let pss = simplify_first_col pss in
+          if not (all_coherent (hq :: first_column pss)) then
+            []
+          else begin
+            let q0 = discr_pat q pss in
+            List.map (set_args (Pattern_head.to_omega_pattern q0))
+              (list_satisfying_vectors
+                 (build_specialized_submatrix ~extend_row:(@) q0 pss)
+                 (simple_match_args q0 hq qargs @ qs))
+          end
+
+(******************************************)
+(* Look for a row that matches some value *)
+(******************************************)
+
+(*
+  Useful for seeing if the example of
+  non-matched value can indeed be matched
+  (by a guarded clause)
+*)
+
+let rec do_match pss qs = match qs with
+| [] ->
+    begin match pss  with
+    | []::_ -> true
+    | _ -> false
+    end
+| q::qs -> match q with
+  | {pat_desc = Tpat_or (q1,q2,_)} ->
+      do_match pss (q1::qs) || do_match pss (q2::qs)
+  | {pat_desc = Tpat_any} ->
+      let rec remove_first_column = function
+        | (_::ps)::rem -> ps::remove_first_column rem
+        | _ -> []
+      in
+      do_match (remove_first_column pss) qs
+  | _ ->
+      (* [q] is generated by us, it doesn't come from the source. So we know
+         it's not of the form [P as name].
+         Therefore there is no risk of [deconstruct] raising. *)
+      let q0, qargs = Pattern_head.deconstruct q in
+      let pss = simplify_first_col pss in
+      (* [pss] will (or won't) match [q0 :: qs] regardless of the coherence of
+         its first column. *)
+      do_match
+        (build_specialized_submatrix ~extend_row:(@) q0 pss)
+        (qargs @ qs)
+
+
+type 'a exhaust_result =
+  | No_matching_value
+  | Witnesses of 'a list
+
+let rappend r1 r2 =
+  match r1, r2 with
+  | No_matching_value, _ -> r2
+  | _, No_matching_value -> r1
+  | Witnesses l1, Witnesses l2 -> Witnesses (l1 @ l2)
+
+let rec try_many  f = function
+  | [] -> No_matching_value
+  | (p,pss)::rest ->
+      rappend (f (p, pss)) (try_many f rest)
+
+(*
+let print_pat pat =
+  let rec string_of_pat pat =
+    match pat.pat_desc with
+        Tpat_var _ -> "v"
+      | Tpat_any -> "_"
+      | Tpat_alias (p, x) -> Printf.sprintf "(%s) as ?"  (string_of_pat p)
+      | Tpat_constant n -> "0"
+      | Tpat_construct (_, lid, _) ->
+        Printf.sprintf "%s" (String.concat "." (Longident.flatten lid.txt))
+      | Tpat_lazy p ->
+        Printf.sprintf "(lazy %s)" (string_of_pat p)
+      | Tpat_or (p1,p2,_) ->
+        Printf.sprintf "(%s | %s)" (string_of_pat p1) (string_of_pat p2)
+      | Tpat_tuple list ->
+        Printf.sprintf "(%s)" (String.concat "," (List.map string_of_pat list))
+      | Tpat_variant (_, _, _) -> "variant"
+      | Tpat_record (_, _) -> "record"
+      | Tpat_array _ -> "array"
+  in
+  Printf.fprintf stderr "PAT[%s]\n%!" (string_of_pat pat)
+*)
+
+(*
+  Now another satisfiable function that additionally
+  supplies an example of a matching value.
+
+  This function should be called for exhaustiveness check only.
+*)
+let rec exhaust (ext:Path.t option) pss n = match pss with
+| []    ->  Witnesses [omegas n]
+| []::_ ->  No_matching_value
+| pss   ->
+    let pss = simplify_first_col pss in
+    if not (all_coherent (first_column pss)) then
+      (* We're considering an ill-typed branch, we won't actually be able to
+         produce a well typed value taking that branch. *)
+      No_matching_value
+    else begin
+      (* Assuming the first column is ill-typed but considered coherent, we
+         might end up producing an ill-typed witness of non-exhaustivity
+         corresponding to the current branch.
+
+         If [exhaust] has been called by [do_check_partial], then the witnesses
+         produced get typechecked and the ill-typed ones are discarded.
+
+         If [exhaust] has been called by [do_check_fragile], then it is possible
+         we might fail to warn the user that the matching is fragile. See for
+         example testsuite/tests/warnings/w04_failure.ml. *)
+      let q0 = discr_pat omega pss in
+      match build_specialized_submatrices ~extend_row:(@) q0 pss with
+      | { default; constrs = [] } ->
+          (* first column of pss is made of variables only *)
+          begin match exhaust ext default (n-1) with
+          | Witnesses r ->
+              let q0 = Pattern_head.to_omega_pattern q0 in
+              Witnesses (List.map (fun row -> q0::row) r)
+          | r -> r
+        end
+      | { default; constrs } ->
+          let try_non_omega (p,pss) =
+            if is_absent_pat p then
+              No_matching_value
+            else
+              match
+                exhaust
+                  ext pss
+                  (List.length (simple_match_args p Pattern_head.omega [])
+                   + n - 1)
+              with
+              | Witnesses r ->
+                  let p = Pattern_head.to_omega_pattern p in
+                  Witnesses (List.map (set_args p) r)
+              | r       -> r in
+          let before = try_many try_non_omega constrs in
+          if
+            full_match false constrs && not (should_extend ext constrs)
+          then
+            before
+          else
+            let r =  exhaust ext default (n-1) in
+            match r with
+            | No_matching_value -> before
+            | Witnesses r ->
+                try
+                  let p = build_other ext constrs in
+                  let dug = List.map (fun tail -> p :: tail) r in
+                  match before with
+                  | No_matching_value -> Witnesses dug
+                  | Witnesses x -> Witnesses (x @ dug)
+                with
+        (* cannot occur, since constructors don't make a full signature *)
+                | Empty -> fatal_error "Parmatch.exhaust"
+  end
+
+let exhaust ext pss n =
+  let ret = exhaust ext pss n in
+  match ret with
+    No_matching_value -> No_matching_value
+  | Witnesses lst ->
+      let singletons =
+        List.map
+          (function
+              [x] -> x
+            | _ -> assert false)
+          lst
+      in
+      Witnesses [orify_many singletons]
+
+(*
+   Another exhaustiveness check, enforcing variant typing.
+   Note that it does not check exact exhaustiveness, but whether a
+   matching could be made exhaustive by closing all variant types.
+   When this is true of all other columns, the current column is left
+   open (even if it means that the whole matching is not exhaustive as
+   a result).
+   When this is false for the matrix minus the current column, and the
+   current column is composed of variant tags, we close the variant
+   (even if it doesn't help in making the matching exhaustive).
+*)
+
+let rec pressure_variants tdefs = function
+  | []    -> false
+  | []::_ -> true
+  | pss   ->
+      let pss = simplify_first_col pss in
+      if not (all_coherent (first_column pss)) then
+        true
+      else begin
+        let q0 = discr_pat omega pss in
+        match build_specialized_submatrices ~extend_row:(@) q0 pss with
+        | { default; constrs = [] } -> pressure_variants tdefs default
+        | { default; constrs } ->
+            let rec try_non_omega = function
+              | (_p,pss) :: rem ->
+                  let ok = pressure_variants tdefs pss in
+                  (* The order below matters : we want [pressure_variants] to be
+                    called on all the specialized submatrices because we might
+                    close some variant in any of them regardless of whether [ok]
+                    is true for [pss] or not *)
+                  try_non_omega rem && ok
+              | [] -> true
+            in
+            if full_match (tdefs=None) constrs then
+              try_non_omega constrs
+            else if tdefs = None then
+              pressure_variants None default
+            else
+              let full = full_match true constrs in
+              let ok =
+                if full then
+                  try_non_omega constrs
+                else begin
+                  let { constrs = partial_constrs; _ } =
+                    build_specialized_submatrices ~extend_row:(@) q0
+                      (mark_partial pss)
+                  in
+                  try_non_omega partial_constrs
+                end
+              in
+              begin match constrs, tdefs with
+              | [], _
+              | _, None -> ()
+              | (d, _) :: _, Some env ->
+                match Pattern_head.desc d with
+                | Variant { type_row; _ } ->
+                  let row = type_row () in
+                  if Btype.row_fixed row
+                  || pressure_variants None default then ()
+                  else close_variant env row
+                | _ -> ()
+              end;
+              ok
+      end
+
+
+(* Yet another satisfiable function *)
+
+(*
+   This time every_satisfiable pss qs checks the
+   utility of every expansion of qs.
+   Expansion means expansion of or-patterns inside qs
+*)
+
+type answer =
+  | Used                                (* Useful pattern *)
+  | Unused                              (* Useless pattern *)
+  | Upartial of Typedtree.pattern list  (* Mixed, with list of useless ones *)
+
+
+
+(* this row type enable column processing inside the matrix
+    - left  ->  elements not to be processed,
+    - right ->  elements to be processed
+*)
+type usefulness_row =
+  {no_ors : pattern list ; ors : pattern list ; active : pattern list}
+
+(*
+let pretty_row {ors=ors ; no_ors=no_ors; active=active} =
+  pretty_line ors ; prerr_string " *" ;
+  pretty_line no_ors ; prerr_string " *" ;
+  pretty_line active
+
+let pretty_rows rs =
+  prerr_endline "begin matrix" ;
+  List.iter
+    (fun r ->
+      pretty_row r ;
+      prerr_endline "")
+    rs ;
+  prerr_endline "end matrix"
+*)
+
+(* Initial build *)
+let make_row ps = {ors=[] ; no_ors=[]; active=ps}
+
+let make_rows pss = List.map make_row pss
+
+
+(* Useful to detect and expand  or pats inside as pats *)
+let rec unalias p = match p.pat_desc with
+| Tpat_alias (p,_,_) -> unalias p
+| _ -> p
+
+
+let is_var p = match (unalias p).pat_desc with
+| Tpat_any|Tpat_var _ -> true
+| _                   -> false
+
+let is_var_column rs =
+  List.for_all
+    (fun r -> match r.active with
+    | p::_ -> is_var p
+    | []   -> assert false)
+    rs
+
+(* Standard or-args for left-to-right matching *)
+let rec or_args p = match p.pat_desc with
+| Tpat_or (p1,p2,_) -> p1,p2
+| Tpat_alias (p,_,_)  -> or_args p
+| _                 -> assert false
+
+(* Just remove current column *)
+let remove r = match r.active with
+| _::rem -> {r with active=rem}
+| []     -> assert false
+
+let remove_column rs = List.map remove rs
+
+(* Current column has been processed *)
+let push_no_or r = match r.active with
+| p::rem -> { r with no_ors = p::r.no_ors ; active=rem}
+| [] -> assert false
+
+let push_or r = match r.active with
+| p::rem -> { r with ors = p::r.ors ; active=rem}
+| [] -> assert false
+
+let push_or_column rs = List.map push_or rs
+and push_no_or_column rs = List.map push_no_or rs
+
+let rec simplify_first_usefulness_col = function
+  | [] -> []
+  | row :: rows ->
+    match row.active with
+    | [] -> assert false (* the rows are non-empty! *)
+    | p :: ps ->
+      let add_column p ps k =
+        (p, { row with active = ps }) :: k in
+      simplify_head_pat ~add_column p ps
+        (simplify_first_usefulness_col rows)
+
+(* Back to normal matrices *)
+let make_vector r = List.rev r.no_ors
+
+let make_matrix rs = List.map make_vector rs
+
+
+(* Standard union on answers *)
+let union_res r1 r2 = match r1, r2 with
+| (Unused,_)
+| (_, Unused) -> Unused
+| Used,_    -> r2
+| _, Used   -> r1
+| Upartial u1, Upartial u2 -> Upartial (u1@u2)
+
+(* propose or pats for expansion *)
+let extract_elements qs =
+  let rec do_rec seen = function
+    | [] -> []
+    | q::rem ->
+        {no_ors= List.rev_append seen rem @ qs.no_ors ;
+        ors=[] ;
+        active = [q]}::
+        do_rec (q::seen) rem in
+  do_rec [] qs.ors
+
+(* idem for matrices *)
+let transpose rs = match rs with
+| [] -> assert false
+| r::rem ->
+    let i = List.map (fun x -> [x]) r in
+    List.fold_left
+      (List.map2 (fun r x -> x::r))
+      i rem
+
+let extract_columns pss qs = match pss with
+| [] -> List.map (fun _ -> []) qs.ors
+| _  ->
+  let rows = List.map extract_elements pss in
+  transpose rows
+
+(* Core function
+   The idea is to first look for or patterns (recursive case), then
+   check or-patterns argument usefulness (terminal case)
+*)
+
+let rec every_satisfiables pss qs = match qs.active with
+| []     ->
+    (* qs is now partitionned,  check usefulness *)
+    begin match qs.ors with
+    | [] -> (* no or-patterns *)
+        if satisfiable (make_matrix pss) (make_vector qs) then
+          Used
+        else
+          Unused
+    | _  -> (* n or-patterns -> 2n expansions *)
+        List.fold_right2
+          (fun pss qs r -> match r with
+          | Unused -> Unused
+          | _ ->
+              match qs.active with
+              | [q] ->
+                  let q1,q2 = or_args q in
+                  let r_loc = every_both pss qs q1 q2 in
+                  union_res r r_loc
+              | _   -> assert false)
+          (extract_columns pss qs) (extract_elements qs)
+          Used
+    end
+| q::rem ->
+    let uq = unalias q in
+    begin match uq.pat_desc with
+    | Tpat_any | Tpat_var _ ->
+        if is_var_column pss then
+(* forget about ``all-variable''  columns now *)
+          every_satisfiables (remove_column pss) (remove qs)
+        else
+(* otherwise this is direct food for satisfiable *)
+          every_satisfiables (push_no_or_column pss) (push_no_or qs)
+    | Tpat_or (q1,q2,_) ->
+        if
+          q1.pat_loc.Location.loc_ghost &&
+          q2.pat_loc.Location.loc_ghost
+        then
+(* syntactically generated or-pats should not be expanded *)
+          every_satisfiables (push_no_or_column pss) (push_no_or qs)
+        else
+(* this is a real or-pattern *)
+          every_satisfiables (push_or_column pss) (push_or qs)
+    | Tpat_variant (l,_,r) when is_absent l r -> (* Ah Jacques... *)
+        Unused
+    | _ ->
+(* standard case, filter matrix *)
+        let pss = simplify_first_usefulness_col pss in
+        let huq, args = Pattern_head.deconstruct uq in
+        (* The handling of incoherent matrices is kept in line with
+           [satisfiable] *)
+        if not (all_coherent (huq :: first_column pss)) then
+          Unused
+        else begin
+          let q0 = discr_pat q pss in
+          every_satisfiables
+            (build_specialized_submatrix q0 pss
+              ~extend_row:(fun ps r -> { r with active = ps @ r.active }))
+            {qs with active=simple_match_args q0 huq args @ rem}
+        end
+    end
+
+(*
+  This function ``every_both'' performs the usefulness check
+  of or-pat q1|q2.
+  The trick is to call every_satisfied twice with
+  current active columns restricted to q1 and q2,
+  That way,
+  - others orpats in qs.ors will not get expanded.
+  - all matching work performed on qs.no_ors is not performed again.
+  *)
+and every_both pss qs q1 q2 =
+  let qs1 = {qs with active=[q1]}
+  and qs2 =  {qs with active=[q2]} in
+  let r1 = every_satisfiables pss qs1
+  and r2 =  every_satisfiables (if compat q1 q2 then qs1::pss else pss) qs2 in
+  match r1 with
+  | Unused ->
+      begin match r2 with
+      | Unused -> Unused
+      | Used   -> Upartial [q1]
+      | Upartial u2 -> Upartial (q1::u2)
+      end
+  | Used ->
+      begin match r2 with
+      | Unused -> Upartial [q2]
+      | _      -> r2
+      end
+  | Upartial u1 ->
+      begin match r2 with
+      | Unused -> Upartial (u1@[q2])
+      | Used   -> r1
+      | Upartial u2 -> Upartial (u1 @ u2)
+      end
+
+
+
+
+(* le_pat p q  means, forall V,  V matches q implies V matches p *)
+let rec le_pat p q =
+  match (p.pat_desc, q.pat_desc) with
+  | (Tpat_var _|Tpat_any),_ -> true
+  | Tpat_alias(p,_,_), _ -> le_pat p q
+  | _, Tpat_alias(q,_,_) -> le_pat p q
+  | Tpat_constant(c1), Tpat_constant(c2) -> const_compare c1 c2 = 0
+  | Tpat_construct(_,c1,ps), Tpat_construct(_,c2,qs) ->
+      Types.equal_tag c1.cstr_tag c2.cstr_tag && le_pats ps qs
+  | Tpat_variant(l1,Some p1,_), Tpat_variant(l2,Some p2,_) ->
+      (l1 = l2 && le_pat p1 p2)
+  | Tpat_variant(l1,None,_r1), Tpat_variant(l2,None,_) ->
+      l1 = l2
+  | Tpat_variant(_,_,_), Tpat_variant(_,_,_) -> false
+  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
+  | Tpat_lazy p, Tpat_lazy q -> le_pat p q
+  | Tpat_record (l1,_), Tpat_record (l2,_) ->
+      let ps,qs = records_args l1 l2 in
+      le_pats ps qs
+  | Tpat_array(ps), Tpat_array(qs) ->
+      List.length ps = List.length qs && le_pats ps qs
+(* In all other cases, enumeration is performed *)
+  | _,_  -> not (satisfiable [[p]] [q])
+
+and le_pats ps qs =
+  match ps,qs with
+    p::ps, q::qs -> le_pat p q && le_pats ps qs
+  | _, _         -> true
+
+let get_mins le ps =
+  let rec select_rec r = function
+      [] -> r
+    | p::ps ->
+        if List.exists (fun p0 -> le p0 p) ps
+        then select_rec r ps
+        else select_rec (p::r) ps in
+  select_rec [] (select_rec [] ps)
+
+(*
+  lub p q is a pattern that matches all values matched by p and q
+  may raise Empty, when p and q are not compatible
+*)
+
+let rec lub p q = match p.pat_desc,q.pat_desc with
+| Tpat_alias (p,_,_),_      -> lub p q
+| _,Tpat_alias (q,_,_)      -> lub p q
+| (Tpat_any|Tpat_var _),_ -> q
+| _,(Tpat_any|Tpat_var _) -> p
+| Tpat_or (p1,p2,_),_     -> orlub p1 p2 q
+| _,Tpat_or (q1,q2,_)     -> orlub q1 q2 p (* Thanks god, lub is commutative *)
+| Tpat_constant c1, Tpat_constant c2 when const_compare c1 c2 = 0 -> p
+| Tpat_tuple ps, Tpat_tuple qs ->
+    let rs = lubs ps qs in
+    make_pat (Tpat_tuple rs) p.pat_type p.pat_env
+| Tpat_lazy p, Tpat_lazy q ->
+    let r = lub p q in
+    make_pat (Tpat_lazy r) p.pat_type p.pat_env
+| Tpat_construct (lid, c1,ps1), Tpat_construct (_,c2,ps2)
+      when  Types.equal_tag c1.cstr_tag c2.cstr_tag  ->
+        let rs = lubs ps1 ps2 in
+        make_pat (Tpat_construct (lid, c1,rs))
+          p.pat_type p.pat_env
+| Tpat_variant(l1,Some p1,row), Tpat_variant(l2,Some p2,_)
+          when  l1=l2 ->
+            let r=lub p1 p2 in
+            make_pat (Tpat_variant (l1,Some r,row)) p.pat_type p.pat_env
+| Tpat_variant (l1,None,_row), Tpat_variant(l2,None,_)
+              when l1 = l2 -> p
+| Tpat_record (l1,closed),Tpat_record (l2,_) ->
+    let rs = record_lubs l1 l2 in
+    make_pat (Tpat_record (rs, closed)) p.pat_type p.pat_env
+| Tpat_array ps, Tpat_array qs
+      when List.length ps = List.length qs ->
+        let rs = lubs ps qs in
+        make_pat (Tpat_array rs) p.pat_type p.pat_env
+| _,_  ->
+    raise Empty
+
+and orlub p1 p2 q =
+  try
+    let r1 = lub p1 q in
+    try
+      {q with pat_desc=(Tpat_or (r1,lub p2 q,None))}
+  with
+  | Empty -> r1
+with
+| Empty -> lub p2 q
+
+and record_lubs l1 l2 =
+  let rec lub_rec l1 l2 = match l1,l2 with
+  | [],_ -> l2
+  | _,[] -> l1
+  | (lid1, lbl1,p1)::rem1, (lid2, lbl2,p2)::rem2 ->
+      if lbl1.lbl_pos < lbl2.lbl_pos then
+        (lid1, lbl1,p1)::lub_rec rem1 l2
+      else if lbl2.lbl_pos < lbl1.lbl_pos  then
+        (lid2, lbl2,p2)::lub_rec l1 rem2
+      else
+        (lid1, lbl1,lub p1 p2)::lub_rec rem1 rem2 in
+  lub_rec l1 l2
+
+and lubs ps qs = match ps,qs with
+| p::ps, q::qs -> lub p q :: lubs ps qs
+| _,_ -> []
+
+
+(******************************)
+(* Exported variant closing   *)
+(******************************)
+
+(* Apply pressure to variants *)
+
+let pressure_variants tdefs patl =
+  let add_row pss p_opt =
+    match p_opt with
+    | None -> pss
+    | Some p -> [p; omega] :: pss
+  in
+  let val_pss, exn_pss =
+    List.fold_right (fun pat (vpss, epss)->
+      let (vp, ep) = split_pattern pat in
+      add_row vpss vp, add_row epss ep
+    ) patl ([], [])
+  in
+  ignore (pressure_variants (Some tdefs) val_pss);
+  ignore (pressure_variants (Some tdefs) exn_pss)
+
+(*****************************)
+(* Utilities for diagnostics *)
+(*****************************)
+
+(*
+  Build up a working pattern matrix by forgetting
+  about guarded patterns
+*)
+
+let rec initial_matrix = function
+    [] -> []
+  | {c_guard=Some _} :: rem -> initial_matrix rem
+  | {c_guard=None; c_lhs=p} :: rem -> [p] :: initial_matrix rem
+
+(*
+   Build up a working pattern matrix by keeping
+   only the patterns which are guarded
+*)
+let rec initial_only_guarded = function
+  | [] -> []
+  | { c_guard = None; _} :: rem ->
+      initial_only_guarded rem
+  | { c_lhs = pat; _ } :: rem ->
+      [pat] :: initial_only_guarded rem
+
+
+(************************)
+(* Exhaustiveness check *)
+(************************)
+
+(* conversion from Typedtree.pattern to Parsetree.pattern list *)
+module Conv = struct
+  open Parsetree
+  let mkpat desc = Ast_helper.Pat.mk desc
+
+  let name_counter = ref 0
+  let fresh name =
+    let current = !name_counter in
+    name_counter := !name_counter + 1;
+    "#$" ^ name ^ Int.to_string current
+
+  let conv typed =
+    let constrs = Hashtbl.create 7 in
+    let labels = Hashtbl.create 7 in
+    let rec loop pat =
+      match pat.pat_desc with
+        Tpat_or (pa,pb,_) ->
+          mkpat (Ppat_or (loop pa, loop pb))
+      | Tpat_var (_, ({txt="*extension*"} as nm)) -> (* PR#7330 *)
+          mkpat (Ppat_var nm)
+      | Tpat_any
+      | Tpat_var _ ->
+          mkpat Ppat_any
+      | Tpat_constant c ->
+          mkpat (Ppat_constant (Untypeast.constant c))
+      | Tpat_alias (p,_,_) -> loop p
+      | Tpat_tuple lst ->
+          mkpat (Ppat_tuple (List.map loop lst))
+      | Tpat_construct (cstr_lid, cstr, lst) ->
+          let id = fresh cstr.cstr_name in
+          let lid = { cstr_lid with txt = Longident.Lident id } in
+          Hashtbl.add constrs id cstr;
+          let arg =
+            match List.map loop lst with
+            | []  -> None
+            | [p] -> Some p
+            | lst -> Some (mkpat (Ppat_tuple lst))
+          in
+          mkpat (Ppat_construct(lid, arg))
+      | Tpat_variant(label,p_opt,_row_desc) ->
+          let arg = Option.map loop p_opt in
+          mkpat (Ppat_variant(label, arg))
+      | Tpat_record (subpatterns, _closed_flag) ->
+          let fields =
+            List.map
+              (fun (_, lbl, p) ->
+                let id = fresh lbl.lbl_name in
+                Hashtbl.add labels id lbl;
+                (mknoloc (Longident.Lident id), loop p))
+              subpatterns
+          in
+          mkpat (Ppat_record (fields, Open))
+      | Tpat_array lst ->
+          mkpat (Ppat_array (List.map loop lst))
+      | Tpat_lazy p ->
+          mkpat (Ppat_lazy (loop p))
+      | Tpat_exception _ ->
+          assert false
+    in
+    let ps = loop typed in
+    (ps, constrs, labels)
+end
+
+
+(* Whether the counter-example contains an extension pattern *)
+let contains_extension pat =
+  exists_pattern
+    (function
+     | {pat_desc=Tpat_var (_, {txt="*extension*"})} -> true
+     | _ -> false)
+    pat
+
+(* Build an untyped or-pattern from its expected type *)
+let ppat_of_type env ty =
+  match pats_of_type env ty with
+  | [] -> raise Empty
+  | [{pat_desc = Tpat_any}] ->
+      (Conv.mkpat Parsetree.Ppat_any, Hashtbl.create 0, Hashtbl.create 0)
+  | pats ->
+      Conv.conv (orify_many pats)
+
+let do_check_partial ~pred loc casel pss = match pss with
+| [] ->
+        (*
+          This can occur
+          - For empty matches generated by ocamlp4 (no warning)
+          - when all patterns have guards (then, casel <> [])
+          (specific warning)
+          Then match MUST be considered non-exhaustive,
+          otherwise compilation of PM is broken.
+          *)
+    begin match casel with
+    | [] -> ()
+    | _  ->
+      if Warnings.is_active Warnings.All_clauses_guarded then
+        Location.prerr_warning loc Warnings.All_clauses_guarded
+    end ;
+    Partial
+| ps::_  ->
+    begin match exhaust None pss (List.length ps) with
+    | No_matching_value -> Total
+    | Witnesses [u] ->
+        let v =
+          let (pattern,constrs,labels) = Conv.conv u in
+          let u' = pred constrs labels pattern in
+          (* pretty_pat u;
+          begin match u' with
+            None -> prerr_endline ": impossible"
+          | Some _ -> prerr_endline ": possible"
+          end; *)
+          u'
+        in
+        begin match v with
+          None -> Total
+        | Some v ->
+            if Warnings.is_active (Warnings.Partial_match "") then begin
+              let errmsg =
+                try
+                  let buf = Buffer.create 16 in
+                  let fmt = Format.formatter_of_buffer buf in
+                  Printpat.top_pretty fmt v;
+                  if do_match (initial_only_guarded casel) [v] then
+                    Buffer.add_string buf
+                      "\n(However, some guarded clause may match this value.)";
+                  if contains_extension v then
+                    Buffer.add_string buf
+                      "\nMatching over values of extensible variant types \
+                         (the *extension* above)\n\
+                    must include a wild card pattern in order to be exhaustive."
+                  ;
+                  Buffer.contents buf
+                with _ ->
+                  ""
+              in
+                Location.prerr_warning loc (Warnings.Partial_match errmsg)
+            end;
+            Partial
+        end
+    | _ ->
+        fatal_error "Parmatch.check_partial"
+    end
+
+(*****************)
+(* Fragile check *)
+(*****************)
+
+(* Collect all data types in a pattern *)
+
+let rec add_path path = function
+  | [] -> [path]
+  | x::rem as paths ->
+      if Path.same path x then paths
+      else x::add_path path rem
+
+let extendable_path path =
+  not
+    (Path.same path Predef.path_bool ||
+    Path.same path Predef.path_list ||
+    Path.same path Predef.path_unit ||
+    Path.same path Predef.path_option)
+
+let rec collect_paths_from_pat r p = match p.pat_desc with
+| Tpat_construct(_, {cstr_tag=(Cstr_constant _|Cstr_block _|Cstr_unboxed)},ps)
+  ->
+    let path = get_constructor_type_path p.pat_type p.pat_env in
+    List.fold_left
+      collect_paths_from_pat
+      (if extendable_path path then add_path path r else r)
+      ps
+| Tpat_any|Tpat_var _|Tpat_constant _| Tpat_variant (_,None,_) -> r
+| Tpat_tuple ps | Tpat_array ps
+| Tpat_construct (_, {cstr_tag=Cstr_extension _}, ps)->
+    List.fold_left collect_paths_from_pat r ps
+| Tpat_record (lps,_) ->
+    List.fold_left
+      (fun r (_, _, p) -> collect_paths_from_pat r p)
+      r lps
+| Tpat_variant (_, Some p, _) | Tpat_alias (p,_,_) -> collect_paths_from_pat r p
+| Tpat_or (p1,p2,_) ->
+    collect_paths_from_pat (collect_paths_from_pat r p1) p2
+| Tpat_lazy p
+    ->
+    collect_paths_from_pat r p
+| Tpat_exception _ -> assert false
+
+
+(*
+  Actual fragile check
+   1. Collect data types in the patterns of the match.
+   2. One exhaustivity check per datatype, considering that
+      the type is extended.
+*)
+
+let do_check_fragile loc casel pss =
+  let exts =
+    List.fold_left
+      (fun r c -> collect_paths_from_pat r c.c_lhs)
+      [] casel in
+  match exts with
+  | [] -> ()
+  | _ -> match pss with
+    | [] -> ()
+    | ps::_ ->
+        List.iter
+          (fun ext ->
+            match exhaust (Some ext) pss (List.length ps) with
+            | No_matching_value ->
+                Location.prerr_warning
+                  loc
+                  (Warnings.Fragile_match (Path.name ext))
+            | Witnesses _ -> ())
+          exts
+
+(********************************)
+(* Exported unused clause check *)
+(********************************)
+
+let check_unused pred casel =
+  if Warnings.is_active Warnings.Unused_match
+  || List.exists (fun c -> c.c_rhs.exp_desc = Texp_unreachable) casel then
+    let rec do_rec pref = function
+      | [] -> ()
+      | {c_lhs=q; c_guard; c_rhs} :: rem ->
+          let qs = [q] in
+            begin try
+              let pss =
+                  get_mins le_pats (List.filter (compats qs) pref) in
+              (* First look for redundant or partially redundant patterns *)
+              let r = every_satisfiables (make_rows pss) (make_row qs) in
+              let refute = (c_rhs.exp_desc = Texp_unreachable) in
+              (* Do not warn for unused [pat -> .] *)
+              if r = Unused && refute then () else
+              let r =
+                (* Do not refine if either:
+                   - we already know the clause is unused
+                   - the clause under consideration is not a refutation clause
+                     and either:
+                     + there are no other lines
+                     + we do not care whether the types prevent this clause to
+                       be reached.
+                     If the clause under consideration *is* a refutation clause
+                     then we do need to check more carefully whether it can be
+                     refuted or not.  *)
+                let skip =
+                  r = Unused || (not refute && pref = []) ||
+                  not(refute || Warnings.is_active Warnings.Unreachable_case) in
+                if skip then r else
+                (* Then look for empty patterns *)
+                let sfs = list_satisfying_vectors pss qs in
+                if sfs = [] then Unused else
+                let sfs =
+                  List.map (function [u] -> u | _ -> assert false) sfs in
+                let u = orify_many sfs in
+                (*Format.eprintf "%a@." pretty_val u;*)
+                let (pattern,constrs,labels) = Conv.conv u in
+                let pattern = {pattern with Parsetree.ppat_loc = q.pat_loc} in
+                match pred refute constrs labels pattern with
+                  None when not refute ->
+                    Location.prerr_warning q.pat_loc Warnings.Unreachable_case;
+                    Used
+                | _ -> r
+              in
+              match r with
+              | Unused ->
+                  Location.prerr_warning
+                    q.pat_loc Warnings.Unused_match
+              | Upartial ps ->
+                  List.iter
+                    (fun p ->
+                      Location.prerr_warning
+                        p.pat_loc Warnings.Unused_pat)
+                    ps
+              | Used -> ()
+            with Empty | Not_found -> assert false
+            end ;
+
+          if c_guard <> None then
+            do_rec pref rem
+          else
+            do_rec ([q]::pref) rem in
+
+    do_rec [] casel
+
+(*********************************)
+(* Exported irrefutability tests *)
+(*********************************)
+
+let irrefutable pat = le_pat pat omega
+
+let inactive ~partial pat =
+  match partial with
+  | Partial -> false
+  | Total -> begin
+      let rec loop pat =
+        match pat.pat_desc with
+        | Tpat_lazy _ | Tpat_array _ ->
+          false
+        | Tpat_any | Tpat_var _ | Tpat_variant (_, None, _) ->
+            true
+        | Tpat_constant c -> begin
+            match c with
+            | Const_string _ -> Config.safe_string
+            | Const_int _ | Const_char _ | Const_float _
+            | Const_int32 _ | Const_int64 _ | Const_nativeint _ -> true
+          end
+        | Tpat_tuple ps | Tpat_construct (_, _, ps) ->
+            List.for_all (fun p -> loop p) ps
+        | Tpat_alias (p,_,_) | Tpat_variant (_, Some p, _) ->
+            loop p
+        | Tpat_record (ldps,_) ->
+            List.for_all
+              (fun (_, lbl, p) -> lbl.lbl_mut = Immutable && loop p)
+              ldps
+        | Tpat_or (p,q,_) ->
+            loop p && loop q
+        | Tpat_exception _ -> assert false
+      in
+      loop pat
+  end
+
+
+
+
+
+
+
+(*********************************)
+(* Exported exhaustiveness check *)
+(*********************************)
+
+(*
+   Fragile check is performed when required and
+   on exhaustive matches only.
+*)
+
+let check_partial pred loc casel =
+  let pss = initial_matrix casel in
+  let pss = get_mins le_pats pss in
+  let total = do_check_partial ~pred loc casel pss in
+  if
+    total = Total && Warnings.is_active (Warnings.Fragile_match "")
+  then begin
+    do_check_fragile loc casel pss
+  end ;
+  total
+
+(*************************************)
+(* Ambiguous variable in or-patterns *)
+(*************************************)
+
+(* Specification: ambiguous variables in or-patterns.
+
+   The semantics of or-patterns in OCaml is specified with
+   a left-to-right bias: a value [v] matches the pattern [p | q] if it
+   matches [p] or [q], but if it matches both, the environment
+   captured by the match is the environment captured by [p], never the
+   one captured by [q].
+
+   While this property is generally well-understood, one specific case
+   where users expect a different semantics is when a pattern is
+   followed by a when-guard: [| p when g -> e]. Consider for example:
+
+     | ((Const x, _) | (_, Const x)) when is_neutral x -> branch
+
+   The semantics is clear: match the scrutinee against the pattern, if
+   it matches, test the guard, and if the guard passes, take the
+   branch.
+
+   However, consider the input [(Const a, Const b)], where [a] fails
+   the test [is_neutral f], while [b] passes the test [is_neutral
+   b]. With the left-to-right semantics, the clause above is *not*
+   taken by its input: matching [(Const a, Const b)] against the
+   or-pattern succeeds in the left branch, it returns the environment
+   [x -> a], and then the guard [is_neutral a] is tested and fails,
+   the branch is not taken. Most users, however, intuitively expect
+   that any pair that has one side passing the test will take the
+   branch. They assume it is equivalent to the following:
+
+     | (Const x, _) when is_neutral x -> branch
+     | (_, Const x) when is_neutral x -> branch
+
+   while it is not.
+
+   The code below is dedicated to finding these confusing cases: the
+   cases where a guard uses "ambiguous" variables, that are bound to
+   different parts of the scrutinees by different sides of
+   a or-pattern. In other words, it finds the cases where the
+   specified left-to-right semantics is not equivalent to
+   a non-deterministic semantics (any branch can be taken) relatively
+   to a specific guard.
+*)
+
+let pattern_vars p = Ident.Set.of_list (Typedtree.pat_bound_idents p)
+
+(* Row for ambiguous variable search,
+   row is the traditional pattern row,
+   varsets contain a list of head variable sets (varsets)
+
+   A given varset contains all the variables that appeared at the head
+   of a pattern in the row at some point during traversal: they would
+   all be bound to the same value at matching time. On the contrary,
+   two variables of different varsets appeared at different places in
+   the pattern and may be bound to distinct sub-parts of the matched
+   value.
+
+   All rows of a (sub)matrix have rows of the same length,
+   but also varsets of the same length.
+
+   Varsets are populated when simplifying the first column
+   -- the variables of the head pattern are collected in a new varset.
+   For example,
+     { row = x :: r1; varsets = s1 }
+     { row = (Some _) as y :: r2; varsets  = s2 }
+     { row = (None as x) as y :: r3; varsets = s3 }
+     { row = (Some x | (None as x)) :: r4 with varsets = s4 }
+   becomes
+     (_, { row = r1; varsets = {x} :: s1 })
+     (Some _, { row = r2; varsets = {y} :: s2 })
+     (None, { row = r3; varsets = {x, y} :: s3 })
+     (Some x, { row = r4; varsets = {} :: s4 })
+     (None, { row = r4; varsets = {x} :: s4 })
+*)
+type amb_row = { row : pattern list ; varsets : Ident.Set.t list; }
+
+let simplify_head_amb_pat head_bound_variables varsets ~add_column p ps k =
+  let rec simpl head_bound_variables varsets p ps k =
+    match p.pat_desc with
+    | Tpat_alias (p,x,_) ->
+      simpl (Ident.Set.add x head_bound_variables) varsets p ps k
+    | Tpat_var (x,_) ->
+      let rest_of_the_row =
+        { row = ps; varsets = Ident.Set.add x head_bound_variables :: varsets; }
+      in
+      add_column (Pattern_head.deconstruct omega) rest_of_the_row k
+    | Tpat_or (p1,p2,_) ->
+      simpl head_bound_variables varsets p1 ps
+        (simpl head_bound_variables varsets p2 ps k)
+    | _ ->
+      add_column (Pattern_head.deconstruct p)
+        { row = ps; varsets = head_bound_variables :: varsets; } k
+  in simpl head_bound_variables varsets p ps k
+
+(*
+   To accurately report ambiguous variables, one must consider
+   that previous clauses have already matched some values.
+   Consider for example:
+
+     | (Foo x, Foo y) -> ...
+     | ((Foo x, _) | (_, Foo x)) when bar x -> ...
+
+   The second line taken in isolation uses an unstable variable,
+   but the discriminating values, of the shape [(Foo v1, Foo v2)],
+   would all be filtered by the line above.
+
+   To track this information, the matrices we analyze contain both
+   *positive* rows, that describe the rows currently being analyzed
+   (of type Varsets.row, so that their varsets are tracked) and
+   *negative rows*, that describe the cases already matched against.
+
+   The values matched by a signed matrix are the values matched by
+   some of the positive rows but none of the negative rows. In
+   particular, a variable is stable if, for any value not matched by
+   any of the negative rows, the environment captured by any of the
+   matching positive rows is identical.
+*)
+type ('a, 'b) signed = Positive of 'a | Negative of 'b
+
+let rec simplify_first_amb_col = function
+  | [] -> []
+  | (Negative [] | Positive { row = []; _ }) :: _  -> assert false
+  | Negative (n :: ns) :: rem ->
+      let add_column n ns k = (n, Negative ns) :: k in
+      simplify_head_pat
+        ~add_column n ns (simplify_first_amb_col rem)
+  | Positive { row = p::ps; varsets; }::rem ->
+      let add_column p ps k = (p, Positive ps) :: k in
+      simplify_head_amb_pat
+        Ident.Set.empty varsets
+        ~add_column p ps (simplify_first_amb_col rem)
+
+(* Compute stable bindings *)
+
+type stable_vars =
+  | All
+  | Vars of Ident.Set.t
+
+let stable_inter sv1 sv2 = match sv1, sv2 with
+  | All, sv | sv, All -> sv
+  | Vars s1, Vars s2 -> Vars (Ident.Set.inter s1 s2)
+
+let reduce f = function
+| [] -> invalid_arg "reduce"
+| x::xs -> List.fold_left f x xs
+
+let rec matrix_stable_vars m = match m with
+  | [] -> All
+  | ((Positive {row = []; _} | Negative []) :: _) as empty_rows ->
+      let exception Negative_empty_row in
+      (* if at least one empty row is negative, the matrix matches no value *)
+      let get_varsets = function
+        | Negative n ->
+            (* All rows have the same number of columns;
+               if the first row is empty, they all are. *)
+            assert (n = []);
+            raise Negative_empty_row
+        | Positive p ->
+            assert (p.row = []);
+            p.varsets in
+      begin match List.map get_varsets empty_rows with
+      | exception Negative_empty_row -> All
+      | rows_varsets ->
+          let stables_in_varsets =
+            reduce (List.map2 Ident.Set.inter) rows_varsets in
+          (* The stable variables are those stable at any position *)
+          Vars
+            (List.fold_left Ident.Set.union Ident.Set.empty stables_in_varsets)
+      end
+  | m ->
+      let is_negative = function
+        | Negative _ -> true
+        | Positive _ -> false in
+      if List.for_all is_negative m then
+        (* optimization: quit early if there are no positive rows.
+           This may happen often when the initial matrix has many
+           negative cases and few positive cases (a small guarded
+           clause after a long list of clauses) *)
+        All
+      else begin
+        let m = simplify_first_amb_col m in
+        if not (all_coherent (first_column m)) then
+          All
+        else begin
+          (* If the column is ill-typed but deemed coherent, we might
+             spuriously warn about some variables being unstable.
+             As sad as that might be, the warning can be silenced by
+             splitting the or-pattern...  *)
+          let submatrices =
+            let extend_row columns = function
+              | Negative r -> Negative (columns @ r)
+              | Positive r -> Positive { r with row = columns @ r.row } in
+            let q0 = discr_pat omega m in
+            let { default; constrs } =
+              build_specialized_submatrices ~extend_row q0 m in
+            let non_default = List.map snd constrs in
+            if full_match false constrs
+            then non_default
+            else default :: non_default in
+          (* A stable variable must be stable in each submatrix. *)
+          let submat_stable = List.map matrix_stable_vars submatrices in
+          List.fold_left stable_inter All submat_stable
+        end
+      end
+
+let pattern_stable_vars ns p =
+  matrix_stable_vars
+    (List.fold_left (fun m n -> Negative n :: m)
+       [Positive {varsets = []; row = [p]}] ns)
+
+(* All identifier paths that appear in an expression that occurs
+   as a clause right hand side or guard.
+
+  The function is rather complex due to the compilation of
+  unpack patterns by introducing code in rhs expressions
+  and **guards**.
+
+  For pattern (module M:S)  -> e the code is
+  let module M_mod = unpack M .. in e
+
+  Hence M is "free" in e iff M_mod is free in e.
+
+  Not doing so will yield excessive  warning in
+  (module (M:S) } ...) when true -> ....
+  as M is always present in
+  let module M_mod = unpack M .. in true
+*)
+
+let all_rhs_idents exp =
+  let ids = ref Ident.Set.empty in
+(* Very hackish, detect unpack pattern  compilation
+   and perform "indirect check for them" *)
+  let is_unpack exp =
+      List.exists
+        (fun attr -> attr.Parsetree.attr_name.txt = "#modulepat")
+        exp.exp_attributes in
+  let open Tast_iterator in
+  let expr_iter iter exp =
+    (match exp.exp_desc with
+      | Texp_ident (path, _lid, _descr) ->
+        List.iter (fun id -> ids := Ident.Set.add id !ids) (Path.heads path)
+      (* Use default iterator methods for rest of match.*)
+      | _ -> Tast_iterator.default_iterator.expr iter exp);
+
+    if is_unpack exp then begin match exp.exp_desc with
+    | Texp_letmodule
+        (id_mod,_,_,
+         {mod_desc=
+          Tmod_unpack ({exp_desc=Texp_ident (Path.Pident id_exp,_,_)},_)},
+         _) ->
+           assert (Ident.Set.mem id_exp !ids) ;
+           begin match id_mod with
+           | Some id_mod when not (Ident.Set.mem id_mod !ids) ->
+             ids := Ident.Set.remove id_exp !ids
+           | _ -> ()
+           end
+    | _ -> assert false
+    end
+  in
+  let iterator = {Tast_iterator.default_iterator with expr = expr_iter} in
+  iterator.expr iterator exp;
+  !ids
+
+let check_ambiguous_bindings =
+  let open Warnings in
+  let warn0 = Ambiguous_pattern [] in
+  fun cases ->
+    if is_active warn0 then
+      let check_case ns case = match case with
+        | { c_lhs = p; c_guard=None ; _} -> [p]::ns
+        | { c_lhs=p; c_guard=Some g; _} ->
+            let all =
+              Ident.Set.inter (pattern_vars p) (all_rhs_idents g) in
+            if not (Ident.Set.is_empty all) then begin
+              match pattern_stable_vars ns p with
+              | All -> ()
+              | Vars stable ->
+                  let ambiguous = Ident.Set.diff all stable in
+                  if not (Ident.Set.is_empty ambiguous) then begin
+                    let pps =
+                      Ident.Set.elements ambiguous |> List.map Ident.name in
+                    let warn = Ambiguous_pattern pps in
+                    Location.prerr_warning p.pat_loc warn
+                  end
+            end;
+            ns
+      in
+      ignore (List.fold_left check_case [] cases)
+
+let do_complete_partial ?pred pss =
+  (* c/p of [do_check_partial] without the parts concerning the generation of
+     the error message or the warning emiting. *)
+  match pss with
+  | [] -> None, None
+  | ps :: _  ->
+    begin match exhaust None pss (List.length ps) with
+    | No_matching_value -> None, None
+    | Witnesses [u] ->
+      let v =
+        match pred with
+        | Some pred ->
+          let (pattern,constrs,labels) = Conv.conv u in
+          pred constrs labels pattern, Some (constrs, labels)
+        | None -> Some u, None
+      in
+      begin match v with
+      | None, _ -> None, None
+      | Some v, unmangling_tables ->
+        match v.pat_desc with
+        | Tpat_construct (_, {cstr_name="*extension*"}, _) ->
+          (* Matching over values of open types must include a wild card pattern
+            in order to be exhaustive. *)
+          Some omega, unmangling_tables
+        | _ -> Some v, unmangling_tables
+      end
+    | _ ->
+      (* FIXME: Are we sure we'll never get [Rsome lst]? This would be better
+         for us. *)
+      fatal_error "Parmatch.check_partial"
+    end
+
+let complete_partial ~pred pss =
+  let pss = get_mins le_pats pss in
+  do_complete_partial ~pred pss
+
+let return_unused casel =
+  let rec do_rec acc pref = function
+    | [] -> acc
+    | q :: rem ->
+      let qs = [q] in
+      let acc =
+        try
+          let pss = get_mins le_pats (List.filter (compats qs) pref) in
+          let r = every_satisfiables (make_rows pss) (make_row qs) in
+          match r with
+          | Unused -> `Unused q :: acc
+          | Upartial ps -> `Unused_subs (q, ps) :: acc
+          | Used -> acc
+        with Empty | Not_found -> assert false
+      in
+      (* FIXME: we need to know whether there is a guard here, because if there
+         is, we dont want to add [[q]] to [pref]. *)
+      do_rec acc ([q]::pref) rem
+  in
+  do_rec [] [] casel
+
diff --git a/src/ocaml/typing/410+multicore/parmatch.mli b/src/ocaml/typing/410+multicore/parmatch.mli
new file mode 100644
index 00000000..46f5e200
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/parmatch.mli
@@ -0,0 +1,143 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Detection of partial matches and unused match cases. *)
+
+open Asttypes
+open Typedtree
+open Types
+
+val omega : pattern
+(** aka. "Tpat_any" or "_"  *)
+
+val omegas : int -> pattern list
+(** [List.init (fun _ -> omega)] *)
+
+val omega_list : 'a list -> pattern list
+(** [List.map (fun _ -> omega)] *)
+
+val normalize_pat : pattern -> pattern
+(** Keep only the "head" of a pattern: all arguments are replaced by [omega], so
+    are variables. *)
+
+val const_compare : constant -> constant -> int
+(** [const_compare c1 c2] compares the actual values represented by [c1] and
+    [c2], while simply using [Stdlib.compare] would compare the
+    representations.
+
+    cf. MPR#5758 *)
+
+val le_pat : pattern -> pattern -> bool
+(** [le_pat p q]  means: forall V,  V matches q implies V matches p *)
+
+val le_pats : pattern list -> pattern list -> bool
+(** [le_pats (p1 .. pm) (q1 .. qn)] means: forall i <= m, [le_pat pi qi] *)
+
+(** Exported compatibility functor, abstracted over constructor equality *)
+module Compat :
+  functor
+    (_ : sig
+      val equal :
+          Types.constructor_description ->
+            Types.constructor_description ->
+              bool
+     end) -> sig
+       val compat : pattern -> pattern -> bool
+       val compats : pattern list -> pattern list -> bool
+     end
+
+exception Empty
+
+val lub : pattern -> pattern -> pattern
+(** [lub p q] is a pattern that matches all values matched by [p] and [q].
+    May raise [Empty], when [p] and [q] are not compatible. *)
+
+val lubs : pattern list -> pattern list -> pattern list
+(** [lubs [p1; ...; pn] [q1; ...; qk]], where [n < k], is
+    [[lub p1 q1; ...; lub pk qk]].  *)
+
+val get_mins : ('a -> 'a -> bool) -> 'a list -> 'a list
+
+(** Those two functions recombine one pattern and its arguments:
+    For instance:
+      (_,_)::p1::p2::rem -> (p1, p2)::rem
+    The second one will replace mutable arguments by '_'
+*)
+val set_args : pattern -> pattern list -> pattern list
+val set_args_erase_mutable : pattern -> pattern list -> pattern list
+
+val pat_of_constr : pattern -> constructor_description -> pattern
+val complete_constrs :
+    pattern -> constructor_tag list -> constructor_description  list
+
+(** [ppat_of_type] builds an untyped or-pattern from its expected type.
+     May raise [Empty] when [type_expr] is an empty variant *)
+val ppat_of_type :
+    Env.t -> type_expr ->
+    Parsetree.pattern *
+    (string, constructor_description) Hashtbl.t *
+    (string, label_description) Hashtbl.t
+
+val pressure_variants: Env.t -> pattern list -> unit
+
+(** [check_partial pred loc caselist] and [check_unused refute pred caselist]
+    are called with a function [pred] which will be given counter-example
+    candidates: they may be partially ill-typed, and have to be type-checked
+    to extract a valid counter-example.
+    [pred] returns a valid counter-example or [None].
+    [refute] indicates that [check_unused] was called on a refutation clause.
+ *)
+val check_partial:
+    ((string, constructor_description) Hashtbl.t ->
+     (string, label_description) Hashtbl.t ->
+     Parsetree.pattern -> pattern option) ->
+    Location.t -> case list -> partial
+val check_unused:
+    (bool ->
+     (string, constructor_description) Hashtbl.t ->
+     (string, label_description) Hashtbl.t ->
+     Parsetree.pattern -> pattern option) ->
+    case list -> unit
+
+(* Irrefutability tests *)
+val irrefutable : pattern -> bool
+
+(** An inactive pattern is a pattern, matching against which can be duplicated,
+    erased or delayed without change in observable behavior of the program.
+    Patterns containing (lazy _) subpatterns or reads of mutable fields are
+    active. *)
+val inactive : partial:partial -> pattern -> bool
+
+(* Ambiguous bindings *)
+val check_ambiguous_bindings : case list -> unit
+
+(* The tag used for open polymorphic variant types with an abstract row *)
+val some_private_tag : label
+
+(*******************)
+(* Merlin specific *)
+(*******************)
+
+val complete_partial :
+  pred:((label, constructor_description) Hashtbl.t ->
+    (label, label_description) Hashtbl.t ->
+    Parsetree.pattern -> pattern option) ->
+  pattern list list ->
+  pattern option *
+    ((label, constructor_description) Hashtbl.t *
+    (label, label_description) Hashtbl.t)
+    option
+val return_unused: pattern list ->
+  [ `Unused of pattern | `Unused_subs of pattern * pattern list ] list
diff --git a/src/ocaml/typing/410+multicore/path.ml b/src/ocaml/typing/410+multicore/path.ml
new file mode 100644
index 00000000..da5764f1
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/path.ml
@@ -0,0 +1,146 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t =
+    Pident of Ident.t
+  | Pdot of t * string
+  | Papply of t * t
+
+let rec same p1 p2 =
+  p1 == p2
+  || match (p1, p2) with
+    (Pident id1, Pident id2) -> Ident.same id1 id2
+  | (Pdot(p1, s1), Pdot(p2, s2)) -> s1 = s2 && same p1 p2
+  | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
+       same fun1 fun2 && same arg1 arg2
+  | (_, _) -> false
+
+let rec compare p1 p2 =
+  if p1 == p2 then 0
+  else match (p1, p2) with
+    (Pident id1, Pident id2) -> Ident.compare id1 id2
+  | (Pdot(p1, s1), Pdot(p2, s2)) ->
+      let h = compare p1 p2 in
+      if h <> 0 then h else String.compare s1 s2
+  | (Papply(fun1, arg1), Papply(fun2, arg2)) ->
+      let h = compare fun1 fun2 in
+      if h <> 0 then h else compare arg1 arg2
+  | ((Pident _ | Pdot _), (Pdot _ | Papply _)) -> -1
+  | ((Pdot _ | Papply _), (Pident _ | Pdot _)) -> 1
+
+let rec find_free_opt ids = function
+    Pident id -> List.find_opt (Ident.same id) ids
+  | Pdot(p, _s) -> find_free_opt ids p
+  | Papply(p1, p2) ->
+      match find_free_opt ids p1 with
+      | None -> find_free_opt ids p2
+      | Some _ as res -> res
+
+let exists_free ids p =
+  match find_free_opt ids p with
+  | None -> false
+  | _ -> true
+
+let rec scope = function
+    Pident id -> Ident.scope id
+  | Pdot(p, _s) -> scope p
+  | Papply(p1, p2) -> max (scope p1) (scope p2)
+
+let kfalse _ = false
+
+let rec name ?(paren=kfalse) = function
+    Pident id -> Ident.name id
+  | Pdot(p, s) ->
+      name ~paren p ^ if paren s then ".( " ^ s ^ " )" else "." ^ s
+  | Papply(p1, p2) -> name ~paren p1 ^ "(" ^ name ~paren p2 ^ ")"
+
+let rec print ppf = function
+  | Pident id -> Ident.print_with_scope ppf id
+  | Pdot(p, s) -> Format.fprintf ppf "%a.%s" print p s
+  | Papply(p1, p2) -> Format.fprintf ppf "%a(%a)" print p1 print p2
+
+let rec head = function
+    Pident id -> id
+  | Pdot(p, _s) -> head p
+  | Papply _ -> assert false
+
+let flatten =
+  let rec flatten acc = function
+    | Pident id -> `Ok (id, acc)
+    | Pdot (p, s) -> flatten (s :: acc) p
+    | Papply _ -> `Contains_apply
+  in
+  fun t -> flatten [] t
+
+let heads p =
+  let rec heads p acc = match p with
+    | Pident id -> id :: acc
+    | Pdot (p, _s) -> heads p acc
+    | Papply(p1, p2) ->
+        heads p1 (heads p2 acc)
+  in heads p []
+
+let rec last = function
+  | Pident id -> Ident.name id
+  | Pdot(_, s) -> s
+  | Papply(_, p) -> last p
+
+let is_uident s =
+  assert (s <> "");
+  match s.[0] with
+  | 'A'..'Z' -> true
+  | _ -> false
+
+type typath =
+  | Regular of t
+  | Ext of t * string
+  | LocalExt of Ident.t
+  | Cstr of t * string
+
+let constructor_typath = function
+  | Pident id when is_uident (Ident.name id) -> LocalExt id
+  | Pdot(ty_path, s) when is_uident s ->
+      if is_uident (last ty_path) then Ext (ty_path, s)
+      else Cstr (ty_path, s)
+  | p -> Regular p
+
+let is_constructor_typath p =
+  match constructor_typath p with
+  | Regular _ -> false
+  | _ -> true
+
+module T = struct
+  type nonrec t = t
+  let compare = compare
+end
+module Set = Set.Make(T)
+module Map = Map.Make(T)
+
+let to_string_list p =
+  let rec aux acc = function
+    | Pident id -> Ident.name id :: acc
+    | Pdot (p, str) -> aux (str :: acc) p
+    | _ -> assert false
+  in
+  aux [] p
+
+module Nopos = struct
+  type nopos = t =
+    | Pident of Ident.t
+    | Pdot of t * string
+    | Papply of t * t
+
+  let view p = p
+end
diff --git a/src/ocaml/typing/410+multicore/path.mli b/src/ocaml/typing/410+multicore/path.mli
new file mode 100644
index 00000000..fe9103d1
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/path.mli
@@ -0,0 +1,64 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Access paths *)
+
+type t =
+    Pident of Ident.t
+  | Pdot of t * string
+  | Papply of t * t
+
+val same: t -> t -> bool
+val compare: t -> t -> int
+val find_free_opt: Ident.t list -> t -> Ident.t option
+val exists_free: Ident.t list -> t -> bool
+val scope: t -> int
+val flatten : t -> [ `Contains_apply | `Ok of Ident.t * string list ]
+
+val name: ?paren:(string -> bool) -> t -> string
+    (* [paren] tells whether a path suffix needs parentheses *)
+val head: t -> Ident.t
+
+val print: Format.formatter -> t -> unit
+
+val heads: t -> Ident.t list
+
+val last: t -> string
+
+val is_uident: string -> bool
+
+type typath =
+  | Regular of t
+  | Ext of t * string
+  | LocalExt of Ident.t
+  | Cstr of t * string
+
+val constructor_typath: t -> typath
+val is_constructor_typath: t -> bool
+
+module Map : Map.S with type key = t
+module Set : Set.S with type elt = t
+
+(* merlin specific *)
+val to_string_list : t -> string list
+
+module Nopos : sig
+  type nopos = t =
+    | Pident of Ident.t
+    | Pdot of t * string
+    | Papply of t * t
+
+  val view : t -> nopos
+end
diff --git a/src/ocaml/typing/410+multicore/persistent_env.ml b/src/ocaml/typing/410+multicore/persistent_env.ml
new file mode 100644
index 00000000..205cb3df
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/persistent_env.ml
@@ -0,0 +1,425 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Xavier Leroy, projet Gallium, INRIA Rocquencourt                     *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*                                                                        *)
+(*   Copyright 2019 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Persistent structure descriptions *)
+
+open Misc
+open Cmi_format
+
+module Consistbl = Consistbl.Make (Misc.String)
+
+let add_delayed_check_forward = ref (fun _ -> assert false)
+
+type error =
+  | Illegal_renaming of modname * modname * filepath
+  | Inconsistent_import of modname * filepath * filepath
+  | Need_recursive_types of modname
+  | Depend_on_unsafe_string_unit of modname
+
+exception Error of error
+let error err = raise (Error err)
+
+module Persistent_signature = struct
+  type t =
+    { filename : string;
+      cmi : Cmi_format.cmi_infos;
+      cmi_cache : exn ref }
+
+  let load = ref (fun ~unit_name ->
+      match Load_path.find_uncap (unit_name ^ ".cmi") with
+      | filename ->
+        let {Cmi_cache. cmi; cmi_cache} = Cmi_cache.read filename in
+        Some { filename; cmi; cmi_cache }
+      | exception Not_found -> None)
+end
+
+type can_load_cmis =
+  | Can_load_cmis
+  | Cannot_load_cmis of EnvLazy.log
+
+type pers_struct = {
+  ps_name: string;
+  ps_crcs: (string * Digest.t option) list;
+  ps_filename: string;
+  ps_flags: pers_flags list;
+}
+
+module String = Misc.String
+
+(* If a .cmi file is missing (or invalid), we
+   store it as Missing in the cache. *)
+type 'a pers_struct_info =
+  | Missing
+  | Found of pers_struct * 'a
+
+type 'a t = {
+  persistent_structures : (string, 'a pers_struct_info) Hashtbl.t;
+  imported_units: String.Set.t ref;
+  imported_opaque_units: String.Set.t ref;
+  crc_units: Consistbl.t;
+  can_load_cmis: can_load_cmis ref;
+  short_paths_basis: Short_paths.Basis.t ref;
+}
+
+let empty () = {
+  persistent_structures = Hashtbl.create 17;
+  imported_units = ref String.Set.empty;
+  imported_opaque_units = ref String.Set.empty;
+  crc_units = Consistbl.create ();
+  can_load_cmis = ref Can_load_cmis;
+  short_paths_basis = ref (Short_paths.Basis.create ());
+}
+
+let clear penv =
+  let {
+    persistent_structures;
+    imported_units;
+    imported_opaque_units;
+    crc_units;
+    can_load_cmis;
+    short_paths_basis;
+  } = penv in
+  Hashtbl.clear persistent_structures;
+  imported_units := String.Set.empty;
+  imported_opaque_units := String.Set.empty;
+  Consistbl.clear crc_units;
+  can_load_cmis := Can_load_cmis;
+  short_paths_basis := Short_paths.Basis.create ();
+  ()
+
+let clear_missing {persistent_structures; _} =
+  let missing_entries =
+    Hashtbl.fold
+      (fun name r acc -> if r = Missing then name :: acc else acc)
+      persistent_structures []
+  in
+  List.iter (Hashtbl.remove persistent_structures) missing_entries
+
+let add_import {imported_units; _} s =
+  imported_units := String.Set.add s !imported_units
+
+let add_imported_opaque {imported_opaque_units; _} s =
+  imported_opaque_units := String.Set.add s !imported_opaque_units
+
+let find_in_cache {persistent_structures; _} s =
+  match Hashtbl.find persistent_structures s with
+  | exception Not_found -> None
+  | Missing -> None
+  | Found (_ps, pm) -> Some pm
+
+let import_crcs penv ~source crcs =
+  let {crc_units; _} = penv in
+  let import_crc (name, crco) =
+    match crco with
+    | None -> ()
+    | Some crc ->
+        add_import penv name;
+        Consistbl.check crc_units name crc source
+  in List.iter import_crc crcs
+
+let check_consistency penv ps =
+  try import_crcs penv ~source:ps.ps_filename ps.ps_crcs
+  with Consistbl.Inconsistency(name, source, auth) ->
+    error (Inconsistent_import(name, auth, source))
+
+let can_load_cmis penv =
+  !(penv.can_load_cmis)
+let set_can_load_cmis penv setting =
+  penv.can_load_cmis := setting
+let short_paths_basis penv =
+  !(penv.short_paths_basis)
+
+let without_cmis penv f x =
+  let log = EnvLazy.log () in
+  let res =
+    Misc.(protect_refs
+            [R (penv.can_load_cmis, Cannot_load_cmis log)]
+            (fun () -> f x))
+  in
+  EnvLazy.backtrack log;
+  res
+
+let fold {persistent_structures; _} f x =
+  Hashtbl.fold (fun modname pso x -> match pso with
+      | Missing -> x
+      | Found (_, pm) -> f modname pm x)
+    persistent_structures x
+
+let register_pers_for_short_paths penv ps components =
+  let deps, alias_deps =
+    List.fold_left
+      (fun (deps, alias_deps) (name, digest) ->
+         Short_paths.Basis.add (short_paths_basis penv) name;
+         match digest with
+         | None -> deps, name :: alias_deps
+         | Some _ -> name :: deps, alias_deps)
+      ([], []) ps.ps_crcs
+  in
+  let desc =
+    Short_paths.Desc.Module.(Fresh (Signature components))
+  in
+  let is_deprecated =
+    List.exists
+      (function
+        | Alerts alerts ->
+          String.Map.mem "deprecated" alerts ||
+          String.Map.mem "ocaml.deprecated" alerts
+        | _ -> false)
+      ps.ps_flags
+  in
+  let deprecated =
+    if is_deprecated then Short_paths.Desc.Deprecated
+    else Short_paths.Desc.Not_deprecated
+  in
+  Short_paths.Basis.load (short_paths_basis penv) ps.ps_name
+    deps alias_deps desc deprecated
+
+
+(* Reading persistent structures from .cmi files *)
+
+let save_pers_struct penv crc ps pm =
+  let {persistent_structures; crc_units; _} = penv in
+  let modname = ps.ps_name in
+  Hashtbl.add persistent_structures modname (Found (ps, pm));
+  List.iter
+    (function
+        | Rectypes -> ()
+        | Alerts _ -> ()
+        | Unsafe_string -> ()
+        | Opaque -> add_imported_opaque penv modname)
+    ps.ps_flags;
+  Consistbl.set crc_units modname crc ps.ps_filename;
+  add_import penv modname
+
+let acknowledge_pers_struct penv short_path_comps check modname pers_sig pm =
+  let { Persistent_signature.filename; cmi } = pers_sig in
+  let name = cmi.cmi_name in
+  let crcs = cmi.cmi_crcs in
+  let flags = cmi.cmi_flags in
+  let ps = { ps_name = name;
+             ps_crcs = crcs;
+             ps_filename = filename;
+             ps_flags = flags;
+           } in
+  if ps.ps_name <> modname then
+    error (Illegal_renaming(modname, ps.ps_name, filename));
+  List.iter
+    (function
+        | Rectypes ->
+            if not !Clflags.recursive_types then
+              error (Need_recursive_types(ps.ps_name))
+        | Unsafe_string ->
+            if Config.safe_string then
+              error (Depend_on_unsafe_string_unit(ps.ps_name));
+        | Alerts _ -> ()
+        | Opaque -> add_imported_opaque penv modname)
+    ps.ps_flags;
+  if check then check_consistency penv ps;
+  let {persistent_structures; _} = penv in
+  Hashtbl.add persistent_structures modname (Found (ps, pm));
+  register_pers_for_short_paths penv ps (short_path_comps ps.ps_name pm);
+  ps
+
+let read_pers_struct penv val_of_pers_sig short_path_comps check modname filename =
+  add_import penv modname;
+  let {Cmi_cache. cmi; cmi_cache} = Cmi_cache.read filename in
+  let pers_sig = { Persistent_signature.filename; cmi; cmi_cache } in
+  let pm = val_of_pers_sig pers_sig in
+  let ps =
+    acknowledge_pers_struct penv short_path_comps check modname pers_sig pm
+  in
+  (ps, pm)
+
+let find_pers_struct penv val_of_pers_sig short_path_comps check name =
+  let {persistent_structures; _} = penv in
+  if name = "*predef*" then raise Not_found;
+  match Hashtbl.find persistent_structures name with
+  | Found (ps, pm) -> (ps, pm)
+  | Missing -> raise Not_found
+  | exception Not_found ->
+    match can_load_cmis penv with
+    | Cannot_load_cmis _ -> raise Not_found
+    | Can_load_cmis ->
+        let psig =
+          match !Persistent_signature.load ~unit_name:name with
+          | Some psig -> psig
+          | None ->
+            Hashtbl.add persistent_structures name Missing;
+            raise Not_found
+        in
+        add_import penv name;
+        let pm = val_of_pers_sig psig in
+        let ps = acknowledge_pers_struct penv short_path_comps check name psig pm in
+        (ps, pm)
+
+(* Emits a warning if there is no valid cmi for name *)
+let check_pers_struct penv f1 f2 ~loc name =
+  try
+    ignore (find_pers_struct penv f1 f2 false name)
+  with
+  | Not_found ->
+      let warn = Warnings.No_cmi_file(name, None) in
+        Location.prerr_warning loc warn
+  | Magic_numbers.Cmi.Error err ->
+      let msg = Format.asprintf "%a" Magic_numbers.Cmi.report_error err in
+      let warn = Warnings.No_cmi_file(name, Some msg) in
+        Location.prerr_warning loc warn
+  | Error err ->
+      let msg =
+        match err with
+        | Illegal_renaming(name, ps_name, filename) ->
+            Format.asprintf
+              " %a@ contains the compiled interface for @ \
+               %s when %s was expected"
+              Location.print_filename filename ps_name name
+        | Inconsistent_import _ -> assert false
+        | Need_recursive_types name ->
+            Format.sprintf
+              "%s uses recursive types"
+              name
+        | Depend_on_unsafe_string_unit name ->
+            Printf.sprintf "%s uses -unsafe-string"
+              name
+      in
+      let warn = Warnings.No_cmi_file(name, Some msg) in
+        Location.prerr_warning loc warn
+
+let read penv f1 f2 modname filename =
+  snd (read_pers_struct penv f1 f2 true modname filename)
+
+let find penv f1 f2 name =
+  snd (find_pers_struct penv f1 f2 true name)
+
+let check penv f1 f2 ~loc name =
+  let {persistent_structures; _} = penv in
+  if not (Hashtbl.mem persistent_structures name) then begin
+    (* PR#6843: record the weak dependency ([add_import]) regardless of
+       whether the check succeeds, to help make builds more
+       deterministic. *)
+    add_import penv name;
+    if (Warnings.is_active (Warnings.No_cmi_file("", None))) then
+      !add_delayed_check_forward
+        (fun () -> check_pers_struct penv f1 f2 ~loc name)
+  end
+
+let crc_of_unit penv f1 f2 name =
+  let (ps, _pm) = find_pers_struct penv f1 f2 true name in
+  let crco =
+    try
+      List.assoc name ps.ps_crcs
+    with Not_found ->
+      assert false
+  in
+    match crco with
+      None -> assert false
+    | Some crc -> crc
+
+let imports {imported_units; crc_units; _} =
+  Consistbl.extract (String.Set.elements !imported_units) crc_units
+
+let looked_up {persistent_structures; _} modname =
+  Hashtbl.mem persistent_structures modname
+
+let is_imported {imported_units; _} s =
+  String.Set.mem s !imported_units
+
+let is_imported_opaque {imported_opaque_units; _} s =
+  String.Set.mem s !imported_opaque_units
+
+let make_cmi penv modname sign alerts =
+  let flags =
+    List.concat [
+      if !Clflags.recursive_types then [Cmi_format.Rectypes] else [];
+      if !Clflags.opaque then [Cmi_format.Opaque] else [];
+      (if !Clflags.unsafe_string then [Cmi_format.Unsafe_string] else []);
+      [Alerts alerts];
+    ]
+  in
+  let crcs = imports penv in
+  {
+    cmi_name = modname;
+    cmi_sign = sign;
+    cmi_crcs = crcs;
+    cmi_flags = flags
+  }
+
+let save_cmi penv psig pm =
+  let { Persistent_signature.filename; cmi } = psig in
+  Misc.try_finally (fun () ->
+      let {
+        cmi_name = modname;
+        cmi_sign = _;
+        cmi_crcs = imports;
+        cmi_flags = flags;
+      } = cmi in
+      let crc =
+        output_to_file_via_temporary (* see MPR#7472, MPR#4991 *)
+          ~mode: [Open_binary] filename
+          (fun temp_filename oc -> output_cmi temp_filename oc cmi) in
+      (* Enter signature in persistent table so that imports()
+         will also return its crc *)
+      let ps =
+        { ps_name = modname;
+          ps_crcs = (cmi.cmi_name, Some crc) :: imports;
+          ps_filename = filename;
+          ps_flags = flags;
+        } in
+      save_pers_struct penv crc ps pm
+    )
+    ~exceptionally:(fun () -> remove_file filename)
+
+let report_error ppf =
+  let open Format in
+  function
+  | Illegal_renaming(modname, ps_name, filename) -> fprintf ppf
+      "Wrong file naming: %a@ contains the compiled interface for@ \
+       %s when %s was expected"
+      Location.print_filename filename ps_name modname
+  | Inconsistent_import(name, source1, source2) -> fprintf ppf
+      "@[<hov>The files %a@ and %a@ \
+              make inconsistent assumptions@ over interface %s@]"
+      Location.print_filename source1 Location.print_filename source2 name
+  | Need_recursive_types(import) ->
+      fprintf ppf
+        "@[<hov>Invalid import of %s, which uses recursive types.@ %s@]"
+        import "The compilation flag -rectypes is required"
+  | Depend_on_unsafe_string_unit(import) ->
+      fprintf ppf
+        "@[<hov>Invalid import of %s, compiled with -unsafe-string.@ %s@]"
+        import "This compiler has been configured in strict \
+                                  safe-string mode (-force-safe-string)"
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error err ->
+          Some (Location.error_of_printer_file report_error err)
+      | _ -> None
+    )
+
+(* helper for merlin *)
+
+let with_cmis penv f x =
+  Misc.(protect_refs
+          [R (penv.can_load_cmis, Can_load_cmis)]
+          (fun () -> f x))
+
+let forall ~found ~missing t =
+  Std.Hashtbl.forall t.persistent_structures (fun name -> function
+      | Missing -> missing name
+      | Found (pers_struct, a) ->
+        found name pers_struct.ps_filename a
+    )
diff --git a/src/ocaml/typing/410+multicore/persistent_env.mli b/src/ocaml/typing/410+multicore/persistent_env.mli
new file mode 100644
index 00000000..413c032d
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/persistent_env.mli
@@ -0,0 +1,117 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Xavier Leroy, projet Gallium, INRIA Rocquencourt                     *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*                                                                        *)
+(*   Copyright 2019 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Misc
+
+module Consistbl : module type of struct
+  include Consistbl.Make (String)
+end
+
+type error =
+  | Illegal_renaming of modname * modname * filepath
+  | Inconsistent_import of modname * filepath * filepath
+  | Need_recursive_types of modname
+  | Depend_on_unsafe_string_unit of modname
+
+exception Error of error
+
+val report_error: Format.formatter -> error -> unit
+
+module Persistent_signature : sig
+  type t =
+    { filename : string; (** Name of the file containing the signature. *)
+      cmi : Cmi_format.cmi_infos;
+      cmi_cache : exn ref }
+
+  (** Function used to load a persistent signature. The default is to look for
+      the .cmi file in the load path. This function can be overridden to load
+      it from memory, for instance to build a self-contained toplevel. *)
+  val load : (unit_name:string -> t option) ref
+end
+
+type can_load_cmis =
+  | Can_load_cmis
+  | Cannot_load_cmis of Misc.EnvLazy.log
+
+type 'a t
+
+val empty : unit -> 'a t
+
+val short_paths_basis : 'a t -> Short_paths.Basis.t
+
+val clear : 'a t -> unit
+val clear_missing : 'a t -> unit
+
+val fold : 'a t -> (modname -> 'a -> 'b -> 'b) -> 'b -> 'b
+
+val read : 'a t -> (Persistent_signature.t -> 'a)
+  -> (string -> 'a -> Short_paths.Desc.Module.components Lazy.t)
+  -> modname -> filepath -> 'a
+val find : 'a t -> (Persistent_signature.t -> 'a)
+  -> (string -> 'a -> Short_paths.Desc.Module.components Lazy.t)
+  -> modname -> 'a
+
+val find_in_cache : 'a t -> modname -> 'a option
+
+val check : 'a t -> (Persistent_signature.t -> 'a)
+  -> (string -> 'a -> Short_paths.Desc.Module.components Lazy.t)
+  -> loc:Location.t -> modname -> unit
+
+(* [looked_up penv md] checks if one has already tried
+   to read the signature for [md] in the environment
+   [penv] (it may have failed) *)
+val looked_up : 'a t -> modname -> bool
+
+(* [is_imported penv md] checks if [md] has been successfully
+   imported in the environment [penv] *)
+val is_imported : 'a t -> modname -> bool
+
+(* [is_imported_opaque penv md] checks if [md] has been imported
+   in [penv] as an opaque module *)
+val is_imported_opaque : 'a t -> modname -> bool
+
+val make_cmi : 'a t -> modname -> Types.signature -> alerts
+  -> Cmi_format.cmi_infos
+
+val save_cmi : 'a t -> Persistent_signature.t -> 'a -> unit
+
+val can_load_cmis : 'a t -> can_load_cmis
+val set_can_load_cmis : 'a t -> can_load_cmis -> unit
+val without_cmis : 'a t -> ('b -> 'c) -> 'b -> 'c
+(* [without_cmis penv f arg] applies [f] to [arg], but does not
+    allow [penv] to openi cmis during its execution *)
+
+(* may raise Consistbl.Inconsistency *)
+val import_crcs : 'a t -> source:filepath -> crcs -> unit
+
+(* Return the set of compilation units imported, with their CRC *)
+val imports : 'a t -> crcs
+
+(* Return the CRC of the interface of the given compilation unit *)
+val crc_of_unit: 'a t -> (Persistent_signature.t -> 'a)
+  -> (string -> 'a -> Short_paths.Desc.Module.components Lazy.t)
+  -> modname -> Digest.t
+
+(* Forward declaration to break mutual recursion with Typecore. *)
+val add_delayed_check_forward: ((unit -> unit) -> unit) ref
+
+(* helper for merlin *)
+val with_cmis : 'a t -> ('b -> 'c) -> 'b -> 'c
+
+val forall :
+  found:(modname -> filepath -> 'a -> bool) ->
+  missing:(modname -> bool) ->
+  'a t -> bool
diff --git a/src/ocaml/typing/410+multicore/predef.ml b/src/ocaml/typing/410+multicore/predef.ml
new file mode 100644
index 00000000..24f51dec
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/predef.ml
@@ -0,0 +1,248 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Predefined type constructors (with special typing rules in typecore) *)
+
+open Path
+open Types
+open Btype
+
+let builtin_idents = ref []
+
+let wrap create s =
+  let id = create s in
+  builtin_idents := (s, id) :: !builtin_idents;
+  id
+
+let ident_create = wrap Ident.create_predef
+
+let ident_int = ident_create "int"
+and ident_char = ident_create "char"
+and ident_bytes = ident_create "bytes"
+and ident_float = ident_create "float"
+and ident_bool = ident_create "bool"
+and ident_unit = ident_create "unit"
+and ident_exn = ident_create "exn"
+and ident_array = ident_create "array"
+and ident_list = ident_create "list"
+and ident_option = ident_create "option"
+and ident_nativeint = ident_create "nativeint"
+and ident_int32 = ident_create "int32"
+and ident_int64 = ident_create "int64"
+and ident_lazy_t = ident_create "lazy_t"
+and ident_string = ident_create "string"
+and ident_extension_constructor = ident_create "extension_constructor"
+and ident_floatarray = ident_create "floatarray"
+
+let path_int = Pident ident_int
+and path_char = Pident ident_char
+and path_bytes = Pident ident_bytes
+and path_float = Pident ident_float
+and path_bool = Pident ident_bool
+and path_unit = Pident ident_unit
+and path_exn = Pident ident_exn
+and path_array = Pident ident_array
+and path_list = Pident ident_list
+and path_option = Pident ident_option
+and path_nativeint = Pident ident_nativeint
+and path_int32 = Pident ident_int32
+and path_int64 = Pident ident_int64
+and path_lazy_t = Pident ident_lazy_t
+and path_string = Pident ident_string
+and path_extension_constructor = Pident ident_extension_constructor
+and path_floatarray = Pident ident_floatarray
+
+let type_int = newgenty (Tconstr(path_int, [], ref Mnil))
+and type_char = newgenty (Tconstr(path_char, [], ref Mnil))
+and type_bytes = newgenty (Tconstr(path_bytes, [], ref Mnil))
+and type_float = newgenty (Tconstr(path_float, [], ref Mnil))
+and type_bool = newgenty (Tconstr(path_bool, [], ref Mnil))
+and type_unit = newgenty (Tconstr(path_unit, [], ref Mnil))
+and type_exn = newgenty (Tconstr(path_exn, [], ref Mnil))
+and type_array t = newgenty (Tconstr(path_array, [t], ref Mnil))
+and type_list t = newgenty (Tconstr(path_list, [t], ref Mnil))
+and type_option t = newgenty (Tconstr(path_option, [t], ref Mnil))
+and type_nativeint = newgenty (Tconstr(path_nativeint, [], ref Mnil))
+and type_int32 = newgenty (Tconstr(path_int32, [], ref Mnil))
+and type_int64 = newgenty (Tconstr(path_int64, [], ref Mnil))
+and type_lazy_t t = newgenty (Tconstr(path_lazy_t, [t], ref Mnil))
+and type_string = newgenty (Tconstr(path_string, [], ref Mnil))
+and type_extension_constructor =
+      newgenty (Tconstr(path_extension_constructor, [], ref Mnil))
+and type_floatarray = newgenty (Tconstr(path_floatarray, [], ref Mnil))
+
+let ident_match_failure = ident_create "Match_failure"
+and ident_out_of_memory = ident_create "Out_of_memory"
+and ident_invalid_argument = ident_create "Invalid_argument"
+and ident_failure = ident_create "Failure"
+and ident_not_found = ident_create "Not_found"
+and ident_sys_error = ident_create "Sys_error"
+and ident_end_of_file = ident_create "End_of_file"
+and ident_division_by_zero = ident_create "Division_by_zero"
+and ident_stack_overflow = ident_create "Stack_overflow"
+and ident_sys_blocked_io = ident_create "Sys_blocked_io"
+and ident_assert_failure = ident_create "Assert_failure"
+and ident_undefined_recursive_module =
+        ident_create "Undefined_recursive_module"
+
+let all_predef_exns = [
+  ident_match_failure;
+  ident_out_of_memory;
+  ident_invalid_argument;
+  ident_failure;
+  ident_not_found;
+  ident_sys_error;
+  ident_end_of_file;
+  ident_division_by_zero;
+  ident_stack_overflow;
+  ident_sys_blocked_io;
+  ident_assert_failure;
+  ident_undefined_recursive_module;
+]
+
+let path_match_failure = Pident ident_match_failure
+and path_assert_failure = Pident ident_assert_failure
+and path_undefined_recursive_module = Pident ident_undefined_recursive_module
+
+let decl_abstr =
+  {type_params = [];
+   type_arity = 0;
+   type_kind = Type_abstract;
+   type_loc = Location.none;
+   type_private = Asttypes.Public;
+   type_manifest = None;
+   type_variance = [];
+   type_is_newtype = false;
+   type_expansion_scope = lowest_level;
+   type_attributes = [];
+   type_immediate = Unknown;
+   type_unboxed = unboxed_false_default_false;
+  }
+
+let decl_abstr_imm = {decl_abstr with type_immediate = Always}
+
+let cstr id args =
+  {
+    cd_id = id;
+    cd_args = Cstr_tuple args;
+    cd_res = None;
+    cd_loc = Location.none;
+    cd_attributes = [];
+  }
+
+let ident_false = ident_create "false"
+and ident_true = ident_create "true"
+and ident_void = ident_create "()"
+and ident_nil = ident_create "[]"
+and ident_cons = ident_create "::"
+and ident_none = ident_create "None"
+and ident_some = ident_create "Some"
+let common_initial_env add_type add_extension empty_env =
+  let decl_bool =
+    {decl_abstr with
+     type_kind = Type_variant([cstr ident_false []; cstr ident_true []]);
+     type_immediate = Always}
+  and decl_unit =
+    {decl_abstr with
+     type_kind = Type_variant([cstr ident_void []]);
+     type_immediate = Always}
+  and decl_exn =
+    {decl_abstr with
+     type_kind = Type_open}
+  and decl_array =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_variance = [Variance.full]}
+  and decl_list =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_kind =
+     Type_variant([cstr ident_nil []; cstr ident_cons [tvar; type_list tvar]]);
+     type_variance = [Variance.covariant]}
+  and decl_option =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_kind = Type_variant([cstr ident_none []; cstr ident_some [tvar]]);
+     type_variance = [Variance.covariant]}
+  and decl_lazy_t =
+    let tvar = newgenvar() in
+    {decl_abstr with
+     type_params = [tvar];
+     type_arity = 1;
+     type_variance = [Variance.covariant]}
+  in
+
+  let add_extension id l =
+    add_extension id
+      { ext_type_path = path_exn;
+        ext_type_params = [];
+        ext_args = Cstr_tuple l;
+        ext_ret_type = None;
+        ext_private = Asttypes.Public;
+        ext_loc = Location.none;
+        ext_attributes = [Ast_helper.Attr.mk
+                            (Location.mknoloc "ocaml.warn_on_literal_pattern")
+                            (Parsetree.PStr [])] }
+  in
+  add_extension ident_match_failure
+                         [newgenty (Ttuple[type_string; type_int; type_int])] (
+  add_extension ident_out_of_memory [] (
+  add_extension ident_stack_overflow [] (
+  add_extension ident_invalid_argument [type_string] (
+  add_extension ident_failure [type_string] (
+  add_extension ident_not_found [] (
+  add_extension ident_sys_blocked_io [] (
+  add_extension ident_sys_error [type_string] (
+  add_extension ident_end_of_file [] (
+  add_extension ident_division_by_zero [] (
+  add_extension ident_assert_failure
+                         [newgenty (Ttuple[type_string; type_int; type_int])] (
+  add_extension ident_undefined_recursive_module
+                         [newgenty (Ttuple[type_string; type_int; type_int])] (
+  add_type ident_int64 decl_abstr (
+  add_type ident_int32 decl_abstr (
+  add_type ident_nativeint decl_abstr (
+  add_type ident_lazy_t decl_lazy_t (
+  add_type ident_option decl_option (
+  add_type ident_list decl_list (
+  add_type ident_array decl_array (
+  add_type ident_exn decl_exn (
+  add_type ident_unit decl_unit (
+  add_type ident_bool decl_bool (
+  add_type ident_float decl_abstr (
+  add_type ident_string decl_abstr (
+  add_type ident_char decl_abstr_imm (
+  add_type ident_int decl_abstr_imm (
+  add_type ident_extension_constructor decl_abstr (
+  add_type ident_floatarray decl_abstr (
+    empty_env))))))))))))))))))))))))))))
+
+let build_initial_env add_type add_exception empty_env =
+  let common = common_initial_env add_type add_exception empty_env in
+  let safe_string = add_type ident_bytes decl_abstr common in
+  let decl_bytes_unsafe = {decl_abstr with type_manifest = Some type_string} in
+  let unsafe_string = add_type ident_bytes decl_bytes_unsafe common in
+  (safe_string, unsafe_string)
+
+let builtin_values =
+  List.map (fun id -> (Ident.name id, id)) all_predef_exns
+
+let builtin_idents = List.rev !builtin_idents
diff --git a/src/ocaml/typing/410+multicore/predef.mli b/src/ocaml/typing/410+multicore/predef.mli
new file mode 100644
index 00000000..1edbb63e
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/predef.mli
@@ -0,0 +1,89 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Predefined type constructors (with special typing rules in typecore) *)
+
+open Types
+
+val ident_bytes: Ident.t
+
+val type_int: type_expr
+val type_char: type_expr
+val type_string: type_expr
+val type_bytes: type_expr
+val type_float: type_expr
+val type_bool: type_expr
+val type_unit: type_expr
+val type_exn: type_expr
+val type_array: type_expr -> type_expr
+val type_list: type_expr -> type_expr
+val type_option: type_expr -> type_expr
+val type_nativeint: type_expr
+val type_int32: type_expr
+val type_int64: type_expr
+val type_lazy_t: type_expr -> type_expr
+val type_extension_constructor:type_expr
+val type_floatarray:type_expr
+
+val path_int: Path.t
+val path_char: Path.t
+val path_string: Path.t
+val path_bytes: Path.t
+val path_float: Path.t
+val path_bool: Path.t
+val path_unit: Path.t
+val path_exn: Path.t
+val path_array: Path.t
+val path_list: Path.t
+val path_option: Path.t
+val path_nativeint: Path.t
+val path_int32: Path.t
+val path_int64: Path.t
+val path_lazy_t: Path.t
+val path_extension_constructor: Path.t
+val path_floatarray: Path.t
+
+val path_match_failure: Path.t
+val path_assert_failure : Path.t
+val path_undefined_recursive_module : Path.t
+
+val ident_false : Ident.t
+val ident_true : Ident.t
+val ident_void : Ident.t
+val ident_nil : Ident.t
+val ident_cons : Ident.t
+val ident_none : Ident.t
+val ident_some : Ident.t
+
+(* To build the initial environment. Since there is a nasty mutual
+   recursion between predef and env, we break it by parameterizing
+   over Env.t, Env.add_type and Env.add_extension. *)
+
+val build_initial_env:
+  (Ident.t -> type_declaration -> 'a -> 'a) ->
+  (Ident.t -> extension_constructor -> 'a -> 'a) ->
+  'a -> 'a * 'a
+
+(* To initialize linker tables *)
+
+val builtin_values: (string * Ident.t) list
+val builtin_idents: (string * Ident.t) list
+
+(** All predefined exceptions, exposed as [Ident.t] for flambda (for
+    building value approximations).
+    The [Ident.t] for division by zero is also exported explicitly
+    so flambda can generate code to raise it. *)
+val ident_division_by_zero: Ident.t
+val all_predef_exns : Ident.t list
diff --git a/src/ocaml/typing/410+multicore/primitive.ml b/src/ocaml/typing/410+multicore/primitive.ml
new file mode 100644
index 00000000..0c3372b9
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/primitive.ml
@@ -0,0 +1,227 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Description of primitive functions *)
+
+open Misc
+open Parsetree
+
+type boxed_integer = Pnativeint | Pint32 | Pint64
+
+type native_repr =
+  | Same_as_ocaml_repr
+  | Unboxed_float
+  | Unboxed_integer of boxed_integer
+  | Untagged_int
+
+type description =
+  { prim_name: string;         (* Name of primitive  or C function *)
+    prim_arity: int;           (* Number of arguments *)
+    prim_alloc: bool;          (* Does it allocates or raise? *)
+    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
+    prim_native_repr_args: native_repr list;
+    prim_native_repr_res: native_repr }
+
+type error =
+  | Old_style_float_with_native_repr_attribute
+  | Old_style_noalloc_with_noalloc_attribute
+  | No_native_primitive_with_repr_attribute
+
+exception Error of Location.t * error
+
+let is_ocaml_repr = function
+  | Same_as_ocaml_repr -> true
+  | Unboxed_float
+  | Unboxed_integer _
+  | Untagged_int -> false
+
+let is_unboxed = function
+  | Same_as_ocaml_repr
+  | Untagged_int -> false
+  | Unboxed_float
+  | Unboxed_integer _ -> true
+
+let is_untagged = function
+  | Untagged_int -> true
+  | Same_as_ocaml_repr
+  | Unboxed_float
+  | Unboxed_integer _ -> false
+
+let rec make_native_repr_args arity x =
+  if arity = 0 then
+    []
+  else
+    x :: make_native_repr_args (arity - 1) x
+
+let simple ~name ~arity ~alloc =
+  {prim_name = name;
+   prim_arity = arity;
+   prim_alloc = alloc;
+   prim_native_name = "";
+   prim_native_repr_args = make_native_repr_args arity Same_as_ocaml_repr;
+   prim_native_repr_res = Same_as_ocaml_repr}
+
+let make ~name ~alloc ~native_name ~native_repr_args ~native_repr_res =
+  {prim_name = name;
+   prim_arity = List.length native_repr_args;
+   prim_alloc = alloc;
+   prim_native_name = native_name;
+   prim_native_repr_args = native_repr_args;
+   prim_native_repr_res = native_repr_res}
+
+let parse_declaration valdecl ~native_repr_args ~native_repr_res =
+  let arity = List.length native_repr_args in
+  let name, native_name, old_style_noalloc, old_style_float =
+    match valdecl.pval_prim with
+    | name :: "noalloc" :: name2 :: "float" :: _ -> (name, name2, true, true)
+    | name :: "noalloc" :: name2 :: _ -> (name, name2, true, false)
+    | name :: name2 :: "float" :: _ -> (name, name2, false, true)
+    | name :: "noalloc" :: _ -> (name, "", true, false)
+    | name :: name2 :: _ -> (name, name2, false, false)
+    | name :: _ -> (name, "", false, false)
+    | [] ->
+        fatal_error "Primitive.parse_declaration"
+  in
+  let noalloc_attribute =
+    Attr_helper.has_no_payload_attribute ["noalloc"; "ocaml.noalloc"]
+      valdecl.pval_attributes
+  in
+  if old_style_float &&
+     not (List.for_all is_ocaml_repr native_repr_args &&
+          is_ocaml_repr native_repr_res) then
+    raise (Error (valdecl.pval_loc,
+                  Old_style_float_with_native_repr_attribute));
+  if old_style_noalloc && noalloc_attribute then
+    raise (Error (valdecl.pval_loc,
+                  Old_style_noalloc_with_noalloc_attribute));
+  (* The compiler used to assume "noalloc" with "float", we just make this
+     explicit now (GPR#167): *)
+  let old_style_noalloc = old_style_noalloc || old_style_float in
+  if old_style_float then
+    Location.deprecated valdecl.pval_loc
+      "[@@unboxed] + [@@noalloc] should be used\n\
+       instead of \"float\""
+  else if old_style_noalloc then
+    Location.deprecated valdecl.pval_loc
+      "[@@noalloc] should be used instead of \"noalloc\"";
+  if native_name = "" &&
+     not (List.for_all is_ocaml_repr native_repr_args &&
+          is_ocaml_repr native_repr_res) then
+    raise (Error (valdecl.pval_loc,
+                  No_native_primitive_with_repr_attribute));
+  let noalloc = old_style_noalloc || noalloc_attribute in
+  let native_repr_args, native_repr_res =
+    if old_style_float then
+      (make_native_repr_args arity Unboxed_float, Unboxed_float)
+    else
+      (native_repr_args, native_repr_res)
+  in
+  {prim_name = name;
+   prim_arity = arity;
+   prim_alloc = not noalloc;
+   prim_native_name = native_name;
+   prim_native_repr_args = native_repr_args;
+   prim_native_repr_res = native_repr_res}
+
+open Outcometree
+
+let rec add_native_repr_attributes ty attrs =
+  match ty, attrs with
+  | Otyp_arrow (label, a, b), attr_opt :: rest ->
+    let b = add_native_repr_attributes b rest in
+    let a =
+      match attr_opt with
+      | None -> a
+      | Some attr -> Otyp_attribute (a, attr)
+    in
+    Otyp_arrow (label, a, b)
+  | _, [Some attr] -> Otyp_attribute (ty, attr)
+  | _ ->
+    assert (List.for_all (fun x -> x = None) attrs);
+    ty
+
+let oattr_unboxed = { oattr_name = "unboxed" }
+let oattr_untagged = { oattr_name = "untagged" }
+let oattr_noalloc = { oattr_name = "noalloc" }
+
+let print p osig_val_decl =
+  let prims =
+    if p.prim_native_name <> "" then
+      [p.prim_name; p.prim_native_name]
+    else
+      [p.prim_name]
+  in
+  let for_all f =
+    List.for_all f p.prim_native_repr_args && f p.prim_native_repr_res
+  in
+  let all_unboxed = for_all is_unboxed in
+  let all_untagged = for_all is_untagged in
+  let attrs = if p.prim_alloc then [] else [oattr_noalloc] in
+  let attrs =
+    if all_unboxed then
+      oattr_unboxed :: attrs
+    else if all_untagged then
+      oattr_untagged :: attrs
+    else
+      attrs
+  in
+  let attr_of_native_repr = function
+    | Same_as_ocaml_repr -> None
+    | Unboxed_float
+    | Unboxed_integer _ -> if all_unboxed then None else Some oattr_unboxed
+    | Untagged_int -> if all_untagged then None else Some oattr_untagged
+  in
+  let type_attrs =
+    List.map attr_of_native_repr p.prim_native_repr_args @
+    [attr_of_native_repr p.prim_native_repr_res]
+  in
+  { osig_val_decl with
+    oval_prims = prims;
+    oval_type = add_native_repr_attributes osig_val_decl.oval_type type_attrs;
+    oval_attributes = attrs }
+
+let native_name p =
+  if p.prim_native_name <> ""
+  then p.prim_native_name
+  else p.prim_name
+
+let byte_name p =
+  p.prim_name
+
+let native_name_is_external p =
+  let nat_name = native_name p in
+  nat_name <> "" && nat_name.[0] <> '%'
+
+let report_error ppf err =
+  match err with
+  | Old_style_float_with_native_repr_attribute ->
+    Format.fprintf ppf "Cannot use \"float\" in conjunction with \
+                        [%@unboxed]/[%@untagged]."
+  | Old_style_noalloc_with_noalloc_attribute ->
+    Format.fprintf ppf "Cannot use \"noalloc\" in conjunction with \
+                        [%@%@noalloc]."
+  | No_native_primitive_with_repr_attribute ->
+    Format.fprintf ppf
+      "[@The native code version of the primitive is mandatory@ \
+       when attributes [%@untagged] or [%@unboxed] are present.@]"
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, err) ->
+        Some (Location.error_of_printer ~loc report_error err)
+      | _ ->
+        None
+    )
diff --git a/src/ocaml/typing/410+multicore/primitive.mli b/src/ocaml/typing/410+multicore/primitive.mli
new file mode 100644
index 00000000..ddd39779
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/primitive.mli
@@ -0,0 +1,76 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Description of primitive functions *)
+
+type boxed_integer = Pnativeint | Pint32 | Pint64
+
+(* Representation of arguments/result for the native code version
+   of a primitive *)
+type native_repr =
+  | Same_as_ocaml_repr
+  | Unboxed_float
+  | Unboxed_integer of boxed_integer
+  | Untagged_int
+
+type description = private
+  { prim_name: string;         (* Name of primitive  or C function *)
+    prim_arity: int;           (* Number of arguments *)
+    prim_alloc: bool;          (* Does it allocates or raise? *)
+    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
+    prim_native_repr_args: native_repr list;
+    prim_native_repr_res: native_repr }
+
+(* Invariant [List.length d.prim_native_repr_args = d.prim_arity] *)
+
+val simple
+  :  name:string
+  -> arity:int
+  -> alloc:bool
+  -> description
+
+val make
+  :  name:string
+  -> alloc:bool
+  -> native_name:string
+  -> native_repr_args: native_repr list
+  -> native_repr_res: native_repr
+  -> description
+
+val parse_declaration
+  :  Parsetree.value_description
+  -> native_repr_args:native_repr list
+  -> native_repr_res:native_repr
+  -> description
+
+val print
+  :  description
+  -> Outcometree.out_val_decl
+  -> Outcometree.out_val_decl
+
+val native_name: description -> string
+val byte_name: description -> string
+
+(** [native_name_is_externa] returns [true] iff the [native_name] for the
+    given primitive identifies that the primitive is not implemented in the
+    compiler itself. *)
+val native_name_is_external : description -> bool
+
+type error =
+  | Old_style_float_with_native_repr_attribute
+  | Old_style_noalloc_with_noalloc_attribute
+  | No_native_primitive_with_repr_attribute
+
+exception Error of Location.t * error
diff --git a/src/ocaml/typing/410+multicore/printpat.ml b/src/ocaml/typing/410+multicore/printpat.ml
new file mode 100644
index 00000000..03cd0cd7
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printpat.ml
@@ -0,0 +1,158 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Values as patterns pretty printer *)
+
+open Asttypes
+open Typedtree
+open Types
+open Format
+
+let is_cons = function
+| {cstr_name = "::"} -> true
+| _ -> false
+
+let pretty_const c = match c with
+| Const_int i -> Printf.sprintf "%d" i
+| Const_char c -> Printf.sprintf "%C" c
+| Const_string (s, _) -> Printf.sprintf "%S" s
+| Const_float f -> Printf.sprintf "%s" f
+| Const_int32 i -> Printf.sprintf "%ldl" i
+| Const_int64 i -> Printf.sprintf "%LdL" i
+| Const_nativeint i -> Printf.sprintf "%ndn" i
+
+let rec pretty_val ppf v =
+  match v.pat_extra with
+      (cstr, _loc, _attrs) :: rem ->
+        begin match cstr with
+          | Tpat_unpack ->
+            fprintf ppf "@[(module %a)@]" pretty_val { v with pat_extra = rem }
+          | Tpat_constraint _ ->
+            fprintf ppf "@[(%a : _)@]" pretty_val { v with pat_extra = rem }
+          | Tpat_type _ ->
+            fprintf ppf "@[(# %a)@]" pretty_val { v with pat_extra = rem }
+          | Tpat_open _ ->
+              fprintf ppf "@[(# %a)@]" pretty_val { v with pat_extra = rem }
+        end
+    | [] ->
+  match v.pat_desc with
+  | Tpat_any -> fprintf ppf "_"
+  | Tpat_var (x,_) -> fprintf ppf "%s" (Ident.name x)
+  | Tpat_constant c -> fprintf ppf "%s" (pretty_const c)
+  | Tpat_tuple vs ->
+      fprintf ppf "@[(%a)@]" (pretty_vals ",") vs
+  | Tpat_construct (_, cstr, []) ->
+      fprintf ppf "%s" cstr.cstr_name
+  | Tpat_construct (_, cstr, [w]) ->
+      fprintf ppf "@[<2>%s@ %a@]" cstr.cstr_name pretty_arg w
+  | Tpat_construct (_, cstr, vs) ->
+      let name = cstr.cstr_name in
+      begin match (name, vs) with
+        ("::", [v1;v2]) ->
+          fprintf ppf "@[%a::@,%a@]" pretty_car v1 pretty_cdr v2
+      |  _ ->
+          fprintf ppf "@[<2>%s@ @[(%a)@]@]" name (pretty_vals ",") vs
+      end
+  | Tpat_variant (l, None, _) ->
+      fprintf ppf "`%s" l
+  | Tpat_variant (l, Some w, _) ->
+      fprintf ppf "@[<2>`%s@ %a@]" l pretty_arg w
+  | Tpat_record (lvs,_) ->
+      let filtered_lvs = List.filter
+          (function
+            | (_,_,{pat_desc=Tpat_any}) -> false (* do not show lbl=_ *)
+            | _ -> true) lvs in
+      begin match filtered_lvs with
+      | [] -> fprintf ppf "_"
+      | (_, lbl, _) :: q ->
+          let elision_mark ppf =
+            (* we assume that there is no label repetitions here *)
+             if Array.length lbl.lbl_all > 1 + List.length q then
+               fprintf ppf ";@ _@ "
+             else () in
+          fprintf ppf "@[{%a%t}@]"
+            pretty_lvals filtered_lvs elision_mark
+      end
+  | Tpat_array vs ->
+      fprintf ppf "@[[| %a |]@]" (pretty_vals " ;") vs
+  | Tpat_lazy v ->
+      fprintf ppf "@[<2>lazy@ %a@]" pretty_arg v
+  | Tpat_exception v ->
+      fprintf ppf "@[<2>exception@ %a@]" pretty_arg v
+  | Tpat_alias (v, x,_) ->
+      fprintf ppf "@[(%a@ as %a)@]" pretty_val v Ident.print x
+  | Tpat_or (v,w,_)    ->
+      fprintf ppf "@[(%a|@,%a)@]" pretty_or v pretty_or w
+
+and pretty_car ppf v = match v.pat_desc with
+| Tpat_construct (_,cstr, [_ ; _])
+    when is_cons cstr ->
+      fprintf ppf "(%a)" pretty_val v
+| _ -> pretty_val ppf v
+
+and pretty_cdr ppf v = match v.pat_desc with
+| Tpat_construct (_,cstr, [v1 ; v2])
+    when is_cons cstr ->
+      fprintf ppf "%a::@,%a" pretty_car v1 pretty_cdr v2
+| _ -> pretty_val ppf v
+
+and pretty_arg ppf v = match v.pat_desc with
+| Tpat_construct (_,_,_::_)
+| Tpat_variant (_, Some _, _) -> fprintf ppf "(%a)" pretty_val v
+|  _ -> pretty_val ppf v
+
+and pretty_or ppf v = match v.pat_desc with
+| Tpat_or (v,w,_) ->
+    fprintf ppf "%a|@,%a" pretty_or v pretty_or w
+| _ -> pretty_val ppf v
+
+and pretty_vals sep ppf = function
+  | [] -> ()
+  | [v] -> pretty_val ppf v
+  | v::vs ->
+      fprintf ppf "%a%s@ %a" pretty_val v sep (pretty_vals sep) vs
+
+and pretty_lvals ppf = function
+  | [] -> ()
+  | [_,lbl,v] ->
+      fprintf ppf "%s=%a" lbl.lbl_name pretty_val v
+  | (_, lbl,v)::rest ->
+      fprintf ppf "%s=%a;@ %a"
+        lbl.lbl_name pretty_val v pretty_lvals rest
+
+let top_pretty ppf v =
+  fprintf ppf "@[%a@]@?" pretty_val v
+
+
+let pretty_pat p =
+  top_pretty Format.str_formatter p ;
+  prerr_string (Format.flush_str_formatter ())
+
+type matrix = pattern list list
+
+let pretty_line fmt =
+  List.iter (fun p ->
+    Format.fprintf fmt " <";
+    top_pretty fmt p;
+    Format.fprintf fmt ">";
+  )
+
+let pretty_matrix fmt (pss : matrix) =
+  Format.fprintf fmt "begin matrix\n" ;
+  List.iter (fun ps ->
+    pretty_line fmt ps ;
+    Format.fprintf fmt "\n"
+  ) pss;
+  Format.fprintf fmt "end matrix\n%!"
diff --git a/src/ocaml/typing/410+multicore/printpat.mli b/src/ocaml/typing/410+multicore/printpat.mli
new file mode 100644
index 00000000..48292bf8
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printpat.mli
@@ -0,0 +1,22 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+
+
+val pretty_const : Asttypes.constant -> string
+val top_pretty : Format.formatter -> Typedtree.pattern -> unit
+val pretty_pat : Typedtree.pattern -> unit
+val pretty_line : Format.formatter -> Typedtree.pattern list -> unit
+val pretty_matrix : Format.formatter -> Typedtree.pattern list list -> unit
diff --git a/src/ocaml/typing/410+multicore/printtyp.ml b/src/ocaml/typing/410+multicore/printtyp.ml
new file mode 100644
index 00000000..565f8fbc
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printtyp.ml
@@ -0,0 +1,2111 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*  Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt  *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Printing functions *)
+
+module M = Misc.String.Map
+module S = Misc.String.Set
+
+open Misc
+open Ctype
+open Format
+open Longident
+open Path
+open Asttypes
+open Types
+open Btype
+open Outcometree
+
+(* Print a long identifier *)
+
+let rec longident ppf = function
+  | Lident s -> pp_print_string ppf s
+  | Ldot(p, s) -> fprintf ppf "%a.%s" longident p s
+  | Lapply(p1, p2) -> fprintf ppf "%a(%a)" longident p1 longident p2
+
+let () = Env.print_longident := longident
+
+(* Print an identifier avoiding name collisions *)
+
+module Out_name = struct
+  let create x = { printed_name = x }
+  let print x = x.printed_name
+  let set out_name x = out_name.printed_name <- x
+end
+
+(* printing environment for path shortening and naming *)
+let printing_env = ref Env.empty
+let human_unique n id = Printf.sprintf "%s/%d" (Ident.name id) n
+
+type namespace =
+  | Type
+  | Module
+  | Module_type
+  | Class
+  | Class_type
+  | Other (** Other bypasses the unique name identifier mechanism *)
+
+module Namespace = struct
+
+  let id = function
+    | Type -> 0
+    | Module -> 1
+    | Module_type -> 2
+    | Class -> 3
+    | Class_type -> 4
+    | Other -> 5
+
+  let size = 1 + id Other
+
+  let show =
+    function
+    | Type -> "type"
+    | Module -> "module"
+    | Module_type -> "module type"
+    | Class -> "class"
+    | Class_type -> "class type"
+    | Other -> ""
+
+  let pp ppf x = Format.pp_print_string ppf (show x)
+
+  let lookup =
+    let to_lookup f lid =
+      fst @@ f (Lident lid) !printing_env
+    in
+    function
+    | Type -> to_lookup Env.find_type_by_name
+    | Module -> to_lookup Env.find_module_by_name
+    | Module_type -> to_lookup Env.find_modtype_by_name
+    | Class -> to_lookup Env.find_class_by_name
+    | Class_type -> to_lookup Env.find_cltype_by_name
+    | Other -> fun _ -> raise Not_found
+
+  let location namespace id =
+    let env = !printing_env in
+    let path = Path.Pident id in
+    try Some (
+        match namespace with
+        | Type -> (Env.find_type path env).type_loc
+        | Module -> (Env.find_module path env).md_loc
+        | Module_type -> (Env.find_modtype path env).mtd_loc
+        | Class -> (Env.find_class path env).cty_loc
+        | Class_type -> (Env.find_cltype path env).clty_loc
+        | Other -> Location.none
+      ) with Not_found -> None
+
+  let best_class_namespace = function
+    | Papply _ | Pdot _ -> Module
+    | Pident c ->
+        match location Class c with
+        | Some _ -> Class
+        | None -> Class_type
+
+end
+
+(** {2 Conflicts printing}
+    Conflicts arise when multiple items are attributed the same name,
+    the following module stores the global conflict references and
+    provides the printing functions for explaining the source of
+    the conflicts.
+*)
+module Conflicts = struct
+  type explanation =
+    { kind: namespace; name:string; root_name:string; location:Location.t}
+  let explanations = ref M.empty
+  let collect_explanation namespace n id =
+    let name = human_unique n id in
+    let root_name = Ident.name id in
+    if not (M.mem name !explanations) then
+      match Namespace.location namespace id with
+      | None -> ()
+      | Some location ->
+          let explanation = { kind = namespace; location; name; root_name } in
+          explanations := M.add name explanation !explanations
+
+  let pp_explanation ppf r=
+    Format.fprintf ppf "@[<v 2>%a:@,Definition of %s %s@]"
+      Location.print_loc r.location (Namespace.show r.kind) r.name
+
+  let print_located_explanations ppf l =
+    Format.fprintf ppf "@[<v>%a@]" (Format.pp_print_list pp_explanation) l
+
+  let reset () = explanations := M.empty
+  let list_explanations () =
+    let c = !explanations in
+    reset ();
+    c |> M.bindings |> List.map snd |> List.sort Stdlib.compare
+
+
+  let print_toplevel_hint ppf l =
+    let conj ppf () = Format.fprintf ppf " and@ " in
+    let pp_namespace_plural ppf n = Format.fprintf ppf "%as" Namespace.pp n in
+    let root_names = List.map (fun r -> r.kind, r.root_name) l in
+    let unique_root_names = List.sort_uniq Stdlib.compare root_names in
+    let submsgs = Array.make Namespace.size [] in
+    let () = List.iter (fun (n,_ as x) ->
+        submsgs.(Namespace.id n) <- x :: submsgs.(Namespace.id n)
+      )  unique_root_names in
+    let pp_submsg ppf names =
+      match names with
+      | [] -> ()
+      | [namespace, a] ->
+          Format.fprintf ppf
+        "@ \
+         @[<2>Hint: The %a %s has been defined multiple times@ \
+         in@ this@ toplevel@ session.@ \
+         Some toplevel values still refer to@ old@ versions@ of@ this@ %a.\
+         @ Did you try to redefine them?@]"
+        Namespace.pp namespace a Namespace.pp namespace
+      | (namespace, _) :: _ :: _ ->
+      Format.fprintf ppf
+        "@ \
+         @[<2>Hint: The %a %a have been defined multiple times@ \
+         in@ this@ toplevel@ session.@ \
+         Some toplevel values still refer to@ old@ versions@ of@ those@ %a.\
+         @ Did you try to redefine them?@]"
+        pp_namespace_plural namespace
+        Format.(pp_print_list ~pp_sep:conj pp_print_string) (List.map snd names)
+        pp_namespace_plural namespace in
+    Array.iter (pp_submsg ppf) submsgs
+
+  let print_explanations ppf =
+    let ltop, l =
+      (* isolate toplevel locations, since they are too imprecise *)
+      let from_toplevel a =
+        a.location.Location.loc_start.Lexing.pos_fname = "//toplevel//" in
+      List.partition from_toplevel (list_explanations ())
+    in
+    begin match l with
+    | [] -> ()
+    | l -> Format.fprintf ppf "@ %a" print_located_explanations l
+    end;
+    (* if there are name collisions in a toplevel session,
+       display at least one generic hint by namespace *)
+    print_toplevel_hint ppf ltop
+
+  let exists () = M.cardinal !explanations >0
+end
+
+
+module Naming_context = struct
+
+let enabled = ref true
+let enable b = enabled := b
+
+(** Name mapping *)
+type mapping =
+  | Need_unique_name of int Ident.Map.t
+  (** The same name has already been attributed to multiple types.
+      The [map] argument contains the specific binding time attributed to each
+      types.
+  *)
+  | Uniquely_associated_to of Ident.t * out_name
+    (** For now, the name [Ident.name id] has been attributed to [id],
+        [out_name] is used to expand this name if a conflict arises
+        at a later point
+    *)
+  | Associated_to_pervasives of out_name
+  (** [Associated_to_pervasives out_name] is used when the item
+      [Stdlib.$name] has been associated to the name [$name].
+      Upon a conflict, this name will be expanded to ["Stdlib." ^ name ] *)
+
+let hid_start = 0
+
+let add_hid_id id map =
+  let new_id = 1 + Ident.Map.fold (fun _ -> max) map hid_start in
+  new_id, Ident.Map.add id new_id  map
+
+let find_hid id map =
+  try Ident.Map.find id map, map with
+  Not_found -> add_hid_id id map
+
+let pervasives name = "Stdlib." ^ name
+
+let map = Array.make Namespace.size M.empty
+let get namespace = map.(Namespace.id namespace)
+let set namespace x = map.(Namespace.id namespace) <- x
+
+(* Names used in recursive definitions are not considered when determining
+   if a name is already attributed in the current environment.
+   This is a weaker version of hidden_rec_items used by short-path. *)
+let protected = ref S.empty
+let add_protected id = protected := S.add (Ident.name id) !protected
+let reset_protected () = protected := S.empty
+let with_hidden id f =
+  protect_refs [ R(protected,S.add (Ident.name id) !protected)] f
+
+let pervasives_name namespace name =
+  if not !enabled then Out_name.create name else
+  match M.find name (get namespace) with
+  | Associated_to_pervasives r -> r
+  | Need_unique_name _ -> Out_name.create (pervasives name)
+  | Uniquely_associated_to (id',r) ->
+      let hid, map = add_hid_id id' Ident.Map.empty in
+      Out_name.set r (human_unique hid id');
+      Conflicts.collect_explanation namespace hid id';
+      set namespace @@ M.add name (Need_unique_name map) (get namespace);
+      Out_name.create (pervasives name)
+  | exception Not_found ->
+      let r = Out_name.create name in
+      set namespace @@ M.add name (Associated_to_pervasives r) (get namespace);
+      r
+
+(** Lookup for preexisting named item within the current {!printing_env} *)
+let env_ident namespace name =
+  if S.mem name !protected then None else
+  match Namespace.lookup namespace name with
+  | Pident id -> Some id
+  | _ -> None
+  | exception Not_found -> None
+
+(** Associate a name to the identifier [id] within [namespace] *)
+let ident_name_simple namespace id =
+  if not !enabled then Out_name.create (Ident.name id) else
+  let name = Ident.name id in
+  match M.find name (get namespace) with
+  | Uniquely_associated_to (id',r) when Ident.same id id' ->
+      r
+  | Need_unique_name map ->
+      let hid, m = find_hid id map in
+      Conflicts.collect_explanation namespace hid id;
+      set namespace @@ M.add name (Need_unique_name m) (get namespace);
+      Out_name.create (human_unique hid id)
+  | Uniquely_associated_to (id',r) ->
+      let hid', m = find_hid id' Ident.Map.empty in
+      let hid, m = find_hid id m in
+      Out_name.set r (human_unique hid' id');
+      List.iter (fun (id,hid) -> Conflicts.collect_explanation namespace hid id)
+        [id, hid; id', hid' ];
+      set namespace @@ M.add name (Need_unique_name m) (get namespace);
+      Out_name.create (human_unique hid id)
+  | Associated_to_pervasives r ->
+      Out_name.set r ("Stdlib." ^ Out_name.print r);
+      let hid, m = find_hid id Ident.Map.empty in
+      set namespace @@ M.add name (Need_unique_name m) (get namespace);
+      Out_name.create (human_unique hid id)
+  | exception Not_found ->
+      let r = Out_name.create name in
+      set namespace
+      @@ M.add name (Uniquely_associated_to (id,r) ) (get namespace);
+      r
+
+(** Same as {!ident_name_simple} but lookup to existing named identifiers
+    in the current {!printing_env} *)
+let ident_name namespace id =
+  begin match env_ident namespace (Ident.name id) with
+  | Some id' -> ignore (ident_name_simple namespace id')
+  | None -> ()
+  end;
+  ident_name_simple namespace id
+
+let reset () =
+  Array.iteri ( fun i _ -> map.(i) <- M.empty ) map
+
+end
+let ident_name = Naming_context.ident_name
+let reset_naming_context = Naming_context.reset
+
+let ident ppf id = pp_print_string ppf
+    (Out_name.print (Naming_context.ident_name_simple Other id))
+
+(* Print a path *)
+
+let ident_stdlib = Ident.create_persistent "Stdlib"
+
+let non_shadowed_pervasive = function
+  | Pdot(Pident id, _) -> Ident.same id ident_stdlib
+  | _ -> false
+
+let find_double_underscore s =
+  let len = String.length s in
+  let rec loop i =
+    if i + 1 >= len then
+      None
+    else if s.[i] = '_' && s.[i + 1] = '_' then
+      Some i
+    else
+      loop (i + 1)
+  in
+  loop 0
+
+let rec module_path_is_an_alias_of env path ~alias_of =
+  match Env.find_module path env with
+  | { md_type = Mty_alias path'; _ } ->
+    Path.same path' alias_of ||
+    module_path_is_an_alias_of env path' ~alias_of
+  | _ -> false
+  | exception Not_found -> false
+
+(* Simple heuristic to print Foo__bar.* as Foo.Bar.* when Foo.Bar is an alias
+   for Foo__bar. This pattern is used by the stdlib. *)
+let rec rewrite_double_underscore_paths env p =
+  match p with
+  | Pdot (p, s) ->
+    Pdot (rewrite_double_underscore_paths env p, s)
+  | Papply (a, b) ->
+    Papply (rewrite_double_underscore_paths env a,
+            rewrite_double_underscore_paths env b)
+  | Pident id ->
+    let name = Ident.name id in
+    match find_double_underscore name with
+    | None -> p
+    | Some i ->
+      let better_lid =
+        Ldot
+          (Lident (String.sub name 0 i),
+           String.capitalize_ascii
+             (String.sub name (i + 2) (String.length name - i - 2)))
+      in
+      match Env.find_module_by_name better_lid env with
+      | exception Not_found -> p
+      | p', _ ->
+          if module_path_is_an_alias_of env p' ~alias_of:p then
+            p'
+          else
+          p
+
+let rewrite_double_underscore_paths env p =
+  if env == Env.empty then
+    p
+  else
+    rewrite_double_underscore_paths env p
+
+let rec tree_of_path namespace = function
+  | Pident id ->
+      Oide_ident (ident_name namespace id)
+  | Pdot(_, s) as path when non_shadowed_pervasive path ->
+      Oide_ident (Naming_context.pervasives_name namespace s)
+  | Pdot(Pident t, s)
+    when namespace=Type && not (Path.is_uident (Ident.name t)) ->
+    (* [t.A]: inline record of the constructor [A] from type [t] *)
+    Oide_dot (Oide_ident (ident_name Type t), s)
+  | Pdot(p, s) ->
+      Oide_dot (tree_of_path Module p, s)
+  | Papply(p1, p2) ->
+      Oide_apply (tree_of_path Module p1, tree_of_path Module p2)
+
+let tree_of_path namespace p =
+  tree_of_path namespace (rewrite_double_underscore_paths !printing_env p)
+
+let path ppf p =
+  !Oprint.out_ident ppf (tree_of_path Other p)
+
+let string_of_path p =
+  Format.asprintf "%a" path p
+
+let strings_of_paths namespace p =
+  reset_naming_context ();
+  let trees = List.map (tree_of_path namespace) p in
+  List.map (Format.asprintf "%a" !Oprint.out_ident) trees
+
+let () = Env.print_path := path
+
+(* Print a recursive annotation *)
+
+let tree_of_rec = function
+  | Trec_not -> Orec_not
+  | Trec_first -> Orec_first
+  | Trec_next -> Orec_next
+
+(* Print a raw type expression, with sharing *)
+
+let raw_list pr ppf = function
+    [] -> fprintf ppf "[]"
+  | a :: l ->
+      fprintf ppf "@[<1>[%a%t]@]" pr a
+        (fun ppf -> List.iter (fun x -> fprintf ppf ";@,%a" pr x) l)
+
+let kind_vars = ref []
+let kind_count = ref 0
+
+let rec safe_kind_repr v = function
+    Fvar {contents=Some k}  ->
+      if List.memq k v then "Fvar loop" else
+      safe_kind_repr (k::v) k
+  | Fvar r ->
+      let vid =
+        try List.assq r !kind_vars
+        with Not_found ->
+          let c = incr kind_count; !kind_count in
+          kind_vars := (r,c) :: !kind_vars;
+          c
+      in
+      Printf.sprintf "Fvar {None}@%d" vid
+  | Fpresent -> "Fpresent"
+  | Fabsent -> "Fabsent"
+
+let rec safe_commu_repr v = function
+    Cok -> "Cok"
+  | Cunknown -> "Cunknown"
+  | Clink r ->
+      if List.memq r v then "Clink loop" else
+      safe_commu_repr (r::v) !r
+
+let rec safe_repr v = function
+    {desc = Tlink t} when not (List.memq t v) ->
+      safe_repr (t::v) t
+  | t -> t
+
+let rec list_of_memo = function
+    Mnil -> []
+  | Mcons (_priv, p, _t1, _t2, rem) -> p :: list_of_memo rem
+  | Mlink rem -> list_of_memo !rem
+
+let print_name ppf = function
+    None -> fprintf ppf "None"
+  | Some name -> fprintf ppf "\"%s\"" name
+
+let string_of_label = function
+    Nolabel -> ""
+  | Labelled s -> s
+  | Optional s -> "?"^s
+
+let visited = ref []
+let rec raw_type ppf ty =
+  let ty = safe_repr [] ty in
+  if List.memq ty !visited then fprintf ppf "{id=%d}" ty.id else begin
+    visited := ty :: !visited;
+    fprintf ppf "@[<1>{id=%d;level=%d;desc=@,%a}@]" ty.id ty.level
+      raw_type_desc ty.desc
+  end
+and raw_type_list tl = raw_list raw_type tl
+and raw_type_desc ppf = function
+    Tvar name -> fprintf ppf "Tvar %a" print_name name
+  | Tarrow(l,t1,t2,c) ->
+      fprintf ppf "@[<hov1>Tarrow(\"%s\",@,%a,@,%a,@,%s)@]"
+        (string_of_label l) raw_type t1 raw_type t2
+        (safe_commu_repr [] c)
+  | Ttuple tl ->
+      fprintf ppf "@[<1>Ttuple@,%a@]" raw_type_list tl
+  | Tconstr (p, tl, abbrev) ->
+      fprintf ppf "@[<hov1>Tconstr(@,%a,@,%a,@,%a)@]" path p
+        raw_type_list tl
+        (raw_list path) (list_of_memo !abbrev)
+  | Tobject (t, nm) ->
+      fprintf ppf "@[<hov1>Tobject(@,%a,@,@[<1>ref%t@])@]" raw_type t
+        (fun ppf ->
+          match !nm with None -> fprintf ppf " None"
+          | Some(p,tl) ->
+              fprintf ppf "(Some(@,%a,@,%a))" path p raw_type_list tl)
+  | Tfield (f, k, t1, t2) ->
+      fprintf ppf "@[<hov1>Tfield(@,%s,@,%s,@,%a,@;<0 -1>%a)@]" f
+        (safe_kind_repr [] k)
+        raw_type t1 raw_type t2
+  | Tnil -> fprintf ppf "Tnil"
+  | Tlink t -> fprintf ppf "@[<1>Tlink@,%a@]" raw_type t
+  | Tsubst t -> fprintf ppf "@[<1>Tsubst@,%a@]" raw_type t
+  | Tunivar name -> fprintf ppf "Tunivar %a" print_name name
+  | Tpoly (t, tl) ->
+      fprintf ppf "@[<hov1>Tpoly(@,%a,@,%a)@]"
+        raw_type t
+        raw_type_list tl
+  | Tvariant row ->
+      fprintf ppf
+        "@[<hov1>{@[%s@,%a;@]@ @[%s@,%a;@]@ %s%B;@ %s%a;@ @[<1>%s%t@]}@]"
+        "row_fields="
+        (raw_list (fun ppf (l, f) ->
+          fprintf ppf "@[%s,@ %a@]" l raw_field f))
+        row.row_fields
+        "row_more=" raw_type row.row_more
+        "row_closed=" row.row_closed
+        "row_fixed=" raw_row_fixed row.row_fixed
+        "row_name="
+        (fun ppf ->
+          match row.row_name with None -> fprintf ppf "None"
+          | Some(p,tl) ->
+              fprintf ppf "Some(@,%a,@,%a)" path p raw_type_list tl)
+  | Tpackage (p, _, tl) ->
+      fprintf ppf "@[<hov1>Tpackage(@,%a@,%a)@]" path p
+        raw_type_list tl
+and raw_row_fixed ppf = function
+| None -> fprintf ppf "None"
+| Some Types.Fixed_private -> fprintf ppf "Some Fixed_private"
+| Some Types.Rigid -> fprintf ppf "Some Rigid"
+| Some Types.Univar t -> fprintf ppf "Some(Univar(%a))" raw_type t
+| Some Types.Reified p -> fprintf ppf "Some(Reified(%a))" path p
+
+and raw_field ppf = function
+    Rpresent None -> fprintf ppf "Rpresent None"
+  | Rpresent (Some t) -> fprintf ppf "@[<1>Rpresent(Some@,%a)@]" raw_type t
+  | Reither (c,tl,m,e) ->
+      fprintf ppf "@[<hov1>Reither(%B,@,%a,@,%B,@,@[<1>ref%t@])@]" c
+        raw_type_list tl m
+        (fun ppf ->
+          match !e with None -> fprintf ppf " None"
+          | Some f -> fprintf ppf "@,@[<1>(%a)@]" raw_field f)
+  | Rabsent -> fprintf ppf "Rabsent"
+
+let raw_type_expr ppf t =
+  visited := []; kind_vars := []; kind_count := 0;
+  raw_type ppf t;
+  visited := []; kind_vars := []
+
+let () = Btype.print_raw := raw_type_expr
+
+(* Normalize paths *)
+
+let same_type t t' = repr t == repr t'
+
+let set_printing_env env =
+  printing_env :=
+    if !Clflags.real_paths then Env.empty
+    else env
+
+let wrap_printing_env env f =
+  set_printing_env (Env.update_short_paths env);
+  reset_naming_context ();
+  try_finally f ~always:(fun () -> set_printing_env Env.empty)
+
+let wrap_printing_env ?error:_ env f =
+  Env.without_cmis (wrap_printing_env env) f
+
+type type_result = Short_paths.type_result =
+  | Nth of int
+  | Path of int list option * Path.t
+
+type type_resolution = Short_paths.type_resolution =
+  | Nth of int
+  | Subst of int list
+  | Id
+
+let apply_subst ns args =
+  List.map (List.nth args) ns
+
+let apply_subst_opt nso args =
+  match nso with
+  | None -> args
+  | Some ns -> apply_subst ns args
+
+let apply_nth n args =
+  List.nth args n
+
+let best_type_path p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then Path(None, p)
+  else Short_paths.find_type (Env.short_paths !printing_env) p
+
+let best_type_path_resolution p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then Id
+  else Short_paths.find_type_resolution (Env.short_paths !printing_env) p
+
+let best_type_path_simple p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then p
+  else Short_paths.find_type_simple (Env.short_paths !printing_env) p
+
+let best_module_type_path p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then p
+  else Short_paths.find_module_type (Env.short_paths !printing_env) p
+
+let best_module_path p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then p
+  else Short_paths.find_module (Env.short_paths !printing_env) p
+
+let best_class_type_path p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then None, p
+  else Short_paths.find_class_type (Env.short_paths !printing_env) p
+
+let best_class_type_path_simple p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then p
+  else Short_paths.find_class_type_simple (Env.short_paths !printing_env) p
+
+(* Print a type expression *)
+
+let names = ref ([] : (type_expr * string) list)
+let name_counter = ref 0
+let named_vars = ref ([] : string list)
+
+let weak_counter = ref 1
+let weak_var_map = ref TypeMap.empty
+let named_weak_vars = ref String.Set.empty
+
+let reset_names () = names := []; name_counter := 0; named_vars := []
+let add_named_var ty =
+  match ty.desc with
+    Tvar (Some name) | Tunivar (Some name) ->
+      if List.mem name !named_vars then () else
+      named_vars := name :: !named_vars
+  | _ -> ()
+
+let name_is_already_used name =
+  List.mem name !named_vars
+  || List.exists (fun (_, name') -> name = name') !names
+  || String.Set.mem name !named_weak_vars
+
+let rec new_name () =
+  let name =
+    if !name_counter < 26
+    then String.make 1 (Char.chr(97 + !name_counter))
+    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
+           Int.to_string(!name_counter / 26) in
+  incr name_counter;
+  if name_is_already_used name then new_name () else name
+
+let rec new_weak_name ty () =
+  let name = "weak" ^ Int.to_string !weak_counter in
+  incr weak_counter;
+  if name_is_already_used name then new_weak_name ty ()
+  else begin
+      named_weak_vars := String.Set.add name !named_weak_vars;
+      weak_var_map := TypeMap.add ty name !weak_var_map;
+      name
+    end
+
+let name_of_type name_generator t =
+  (* We've already been through repr at this stage, so t is our representative
+     of the union-find class. *)
+  try List.assq t !names with Not_found ->
+    try TypeMap.find t !weak_var_map with Not_found ->
+    let name =
+      match t.desc with
+        Tvar (Some name) | Tunivar (Some name) ->
+          (* Some part of the type we've already printed has assigned another
+           * unification variable to that name. We want to keep the name, so try
+           * adding a number until we find a name that's not taken. *)
+          let current_name = ref name in
+          let i = ref 0 in
+          while List.exists (fun (_, name') -> !current_name = name') !names do
+            current_name := name ^ (Int.to_string !i);
+            i := !i + 1;
+          done;
+          !current_name
+      | _ ->
+          (* No name available, create a new one *)
+          name_generator ()
+    in
+    (* Exception for type declarations *)
+    if name <> "_" then names := (t, name) :: !names;
+    name
+
+let check_name_of_type t = ignore(name_of_type new_name t)
+
+let remove_names tyl =
+  let tyl = List.map repr tyl in
+  names := List.filter (fun (ty,_) -> not (List.memq ty tyl)) !names
+
+let visited_objects = ref ([] : type_expr list)
+let aliased = ref ([] : type_expr list)
+let delayed = ref ([] : type_expr list)
+
+let add_delayed t =
+  if not (List.memq t !delayed) then delayed := t :: !delayed
+
+let is_aliased ty = List.memq (proxy ty) !aliased
+let add_alias ty =
+  let px = proxy ty in
+  if not (is_aliased px) then begin
+    aliased := px :: !aliased;
+    add_named_var px
+  end
+
+let aliasable ty =
+  match ty.desc with
+    Tvar _ | Tunivar _ | Tpoly _ -> false
+  | Tconstr (p, _, _) -> begin
+      match best_type_path_resolution p with
+      | Nth _ -> false
+      | Subst _ | Id -> true
+    end
+  | _ -> true
+
+let namable_row row =
+  row.row_name <> None &&
+  List.for_all
+    (fun (_, f) ->
+       match row_field_repr f with
+       | Reither(c, l, _, _) ->
+           row.row_closed && if c then l = [] else List.length l = 1
+       | _ -> true)
+    row.row_fields
+
+let rec mark_loops_rec visited ty =
+  let ty = repr ty in
+  let px = proxy ty in
+  if List.memq px visited && aliasable ty then add_alias px else
+    let visited = px :: visited in
+    match ty.desc with
+    | Tvar _ -> add_named_var ty
+    | Tarrow(_, ty1, ty2, _) ->
+        mark_loops_rec visited ty1; mark_loops_rec visited ty2
+    | Ttuple tyl -> List.iter (mark_loops_rec visited) tyl
+    | Tconstr(p, tyl, _) -> begin
+        match best_type_path_resolution p with
+        | Nth n ->
+            mark_loops_rec visited (apply_nth n tyl)
+        | Subst ns ->
+          List.iter (mark_loops_rec visited) (apply_subst ns tyl)
+        | Id ->
+            List.iter (mark_loops_rec visited) tyl
+      end
+    | Tpackage (_, _, tyl) ->
+        List.iter (mark_loops_rec visited) tyl
+    | Tvariant row ->
+        if List.memq px !visited_objects then add_alias px else
+         begin
+          let row = row_repr row in
+          if not (static_row row) then
+            visited_objects := px :: !visited_objects;
+          match row.row_name with
+          | Some(_p, tyl) when namable_row row ->
+              List.iter (mark_loops_rec visited) tyl
+          | _ ->
+              iter_row (mark_loops_rec visited) row
+         end
+    | Tobject (fi, nm) ->
+        if List.memq px !visited_objects then add_alias px else
+         begin
+          if opened_object ty then
+            visited_objects := px :: !visited_objects;
+          begin match !nm with
+          | None ->
+              let fields, _ = flatten_fields fi in
+              List.iter
+                (fun (_, kind, ty) ->
+                  if field_kind_repr kind = Fpresent then
+                    mark_loops_rec visited ty)
+                fields
+          | Some (_, l) ->
+              List.iter (mark_loops_rec visited) (List.tl l)
+          end
+        end
+    | Tfield(_, kind, ty1, ty2) when field_kind_repr kind = Fpresent ->
+        mark_loops_rec visited ty1; mark_loops_rec visited ty2
+    | Tfield(_, _, _, ty2) ->
+        mark_loops_rec visited ty2
+    | Tnil -> ()
+    | Tsubst ty -> mark_loops_rec visited ty
+    | Tlink _ -> fatal_error "Printtyp.mark_loops_rec (2)"
+    | Tpoly (ty, tyl) ->
+        List.iter (fun t -> add_alias t) tyl;
+        mark_loops_rec visited ty
+    | Tunivar _ -> add_named_var ty
+
+let mark_loops ty =
+  normalize_type Env.empty ty;
+  mark_loops_rec [] ty;;
+
+let reset_loop_marks () =
+  visited_objects := []; aliased := []; delayed := []
+
+let reset_except_context () =
+  reset_names (); reset_loop_marks ()
+
+let reset () =
+  reset_naming_context (); Conflicts.reset ();
+  reset_except_context ()
+
+let reset_and_mark_loops ty =
+  reset_except_context (); mark_loops ty
+
+let reset_and_mark_loops_list tyl =
+  reset_except_context (); List.iter mark_loops tyl
+
+(* Disabled in classic mode when printing an unification error *)
+let print_labels = ref true
+
+let rec tree_of_typexp sch ty =
+  let ty = repr ty in
+  let px = proxy ty in
+  if List.mem_assq px !names && not (List.memq px !delayed) then
+   let mark = is_non_gen sch ty in
+   let name = name_of_type (if mark then new_weak_name ty else new_name) px in
+   Otyp_var (mark, name) else
+
+  let pr_typ () =
+    match ty.desc with
+    | Tvar _ ->
+        (*let lev =
+          if is_non_gen sch ty then "/" ^ Int.to_string ty.level else "" in*)
+        let non_gen = is_non_gen sch ty in
+        let name_gen = if non_gen then new_weak_name ty else new_name in
+        Otyp_var (non_gen, name_of_type name_gen ty)
+    | Tarrow(l, ty1, ty2, _) ->
+        let pr_arrow l ty1 ty2 =
+          let lab =
+            if !print_labels || is_optional l then string_of_label l else ""
+          in
+          let t1 =
+            if is_optional l then
+              match (repr ty1).desc with
+              | Tconstr(path, [ty], _)
+                when Path.same path Predef.path_option ->
+                  tree_of_typexp sch ty
+              | _ -> Otyp_stuff "<hidden>"
+            else tree_of_typexp sch ty1 in
+          Otyp_arrow (lab, t1, tree_of_typexp sch ty2) in
+        pr_arrow l ty1 ty2
+    | Ttuple tyl ->
+        Otyp_tuple (tree_of_typlist sch tyl)
+    | Tconstr(p, tyl, _abbrev) -> begin
+        match best_type_path p with
+        | Nth n -> tree_of_typexp sch (apply_nth n tyl)
+        | Path(nso, p) ->
+            let tyl = apply_subst_opt nso tyl in
+            Otyp_constr (tree_of_path Type p, tree_of_typlist sch tyl)
+      end
+    | Tvariant row ->
+        let row = row_repr row in
+        let fields =
+          if row.row_closed then
+            List.filter (fun (_, f) -> row_field_repr f <> Rabsent)
+              row.row_fields
+          else row.row_fields in
+        let present =
+          List.filter
+            (fun (_, f) ->
+               match row_field_repr f with
+               | Rpresent _ -> true
+               | _ -> false)
+            fields in
+        let all_present = List.length present = List.length fields in
+        begin match row.row_name with
+        | Some(p, tyl) when namable_row row ->
+            let out_variant =
+              match best_type_path p with
+              | Nth n -> tree_of_typexp sch (apply_nth n tyl)
+              | Path(nso, p) ->
+                let id = tree_of_path Type p in
+                let args = tree_of_typlist sch (apply_subst_opt nso tyl) in
+                Otyp_constr (id, args)
+            in
+            if row.row_closed && all_present then
+              out_variant
+            else
+              let non_gen = is_non_gen sch px in
+              let tags =
+                if all_present then None else Some (List.map fst present) in
+              Otyp_variant (non_gen, Ovar_typ out_variant, row.row_closed, tags)
+        | _ ->
+            let non_gen =
+              not (row.row_closed && all_present) && is_non_gen sch px in
+            let fields = List.map (tree_of_row_field sch) fields in
+            let tags =
+              if all_present then None else Some (List.map fst present) in
+            Otyp_variant (non_gen, Ovar_fields fields, row.row_closed, tags)
+        end
+    | Tobject (fi, nm) ->
+        tree_of_typobject sch fi !nm
+    | Tnil | Tfield _ ->
+        tree_of_typobject sch ty None
+    | Tsubst ty ->
+        tree_of_typexp sch ty
+    | Tlink _ ->
+        fatal_error "Printtyp.tree_of_typexp"
+    | Tpoly (ty, []) ->
+        tree_of_typexp sch ty
+    | Tpoly (ty, tyl) ->
+        (*let print_names () =
+          List.iter (fun (_, name) -> prerr_string (name ^ " ")) !names;
+          prerr_string "; " in *)
+        let tyl = List.map repr tyl in
+        if tyl = [] then tree_of_typexp sch ty else begin
+          let old_delayed = !delayed in
+          (* Make the names delayed, so that the real type is
+             printed once when used as proxy *)
+          List.iter add_delayed tyl;
+          let tl = List.map (name_of_type new_name) tyl in
+          let tr = Otyp_poly (tl, tree_of_typexp sch ty) in
+          (* Forget names when we leave scope *)
+          remove_names tyl;
+          delayed := old_delayed; tr
+        end
+    | Tunivar _ ->
+        Otyp_var (false, name_of_type new_name ty)
+    | Tpackage (p, n, tyl) ->
+        let p = best_module_type_path p in
+        let n =
+          List.map (fun li -> String.concat "." (Longident.flatten li)) n in
+        Otyp_module (tree_of_path Module_type p, n, tree_of_typlist sch tyl)
+  in
+  if List.memq px !delayed then delayed := List.filter ((!=) px) !delayed;
+  if is_aliased px && aliasable ty then begin
+    check_name_of_type px;
+    Otyp_alias (pr_typ (), name_of_type new_name px) end
+  else pr_typ ()
+
+and tree_of_row_field sch (l, f) =
+  match row_field_repr f with
+  | Rpresent None | Reither(true, [], _, _) -> (l, false, [])
+  | Rpresent(Some ty) -> (l, false, [tree_of_typexp sch ty])
+  | Reither(c, tyl, _, _) ->
+      if c (* contradiction: constant constructor with an argument *)
+      then (l, true, tree_of_typlist sch tyl)
+      else (l, false, tree_of_typlist sch tyl)
+  | Rabsent -> (l, false, [] (* actually, an error *))
+
+and tree_of_typlist sch tyl =
+  List.map (tree_of_typexp sch) tyl
+
+and tree_of_typobject sch fi nm =
+  begin match nm with
+  | None ->
+      let pr_fields fi =
+        let (fields, rest) = flatten_fields fi in
+        let present_fields =
+          List.fold_right
+            (fun (n, k, t) l ->
+               match field_kind_repr k with
+               | Fpresent -> (n, t) :: l
+               | _ -> l)
+            fields [] in
+        let sorted_fields =
+          List.sort
+            (fun (n, _) (n', _) -> String.compare n n') present_fields in
+        tree_of_typfields sch rest sorted_fields in
+      let (fields, rest) = pr_fields fi in
+      Otyp_object (fields, rest)
+  | Some (p, ty :: tyl) -> begin
+      let non_gen = is_non_gen sch (repr ty) in
+      let args = tree_of_typlist sch tyl in
+      let p = best_type_path_simple p in
+      Otyp_class (non_gen, tree_of_path Type p, args)
+    end
+  | _ ->
+      fatal_error "Printtyp.tree_of_typobject"
+  end
+
+and is_non_gen sch ty =
+    sch && is_Tvar ty && ty.level <> generic_level
+
+and tree_of_typfields sch rest = function
+  | [] ->
+      let rest =
+        match rest.desc with
+        | Tvar _ | Tunivar _ -> Some (is_non_gen sch rest)
+        | Tconstr _ -> Some false
+        | Tnil -> None
+        | _ -> fatal_error "typfields (1)"
+      in
+      ([], rest)
+  | (s, t) :: l ->
+      let field = (s, tree_of_typexp sch t) in
+      let (fields, rest) = tree_of_typfields sch rest l in
+      (field :: fields, rest)
+
+let typexp sch ppf ty =
+  !Oprint.out_type ppf (tree_of_typexp sch ty)
+
+let marked_type_expr ppf ty = typexp false ppf ty
+
+let type_expr ppf ty =
+  (* [type_expr] is used directly by error message printers,
+     we mark eventual loops ourself to avoid any misuse and stack overflow *)
+  reset_and_mark_loops ty;
+  marked_type_expr ppf ty
+
+and type_sch ppf ty = typexp true ppf ty
+
+and type_scheme ppf ty = reset_and_mark_loops ty; typexp true ppf ty
+
+(* Maxence *)
+let type_scheme_max ?(b_reset_names=true) ppf ty =
+  if b_reset_names then reset_names () ;
+  typexp true ppf ty
+(* End Maxence *)
+
+let tree_of_type_scheme ty = reset_and_mark_loops ty; tree_of_typexp true ty
+
+(* Print one type declaration *)
+
+let tree_of_constraints params =
+  List.fold_right
+    (fun ty list ->
+       let ty' = unalias ty in
+       if proxy ty != proxy ty' then
+         let tr = tree_of_typexp true ty in
+         (tr, tree_of_typexp true ty') :: list
+       else list)
+    params []
+
+let filter_params tyl =
+  let params =
+    List.fold_left
+      (fun tyl ty ->
+        let ty = repr ty in
+        if List.memq ty tyl then Btype.newgenty (Tsubst ty) :: tyl
+        else ty :: tyl)
+      [] tyl
+  in List.rev params
+
+let mark_loops_constructor_arguments = function
+  | Cstr_tuple l -> List.iter mark_loops l
+  | Cstr_record l -> List.iter (fun l -> mark_loops l.ld_type) l
+
+let rec tree_of_type_decl id decl =
+
+  reset_except_context();
+
+  let params = filter_params decl.type_params in
+
+  begin match decl.type_manifest with
+  | Some ty ->
+      let vars = free_variables ty in
+      List.iter
+        (function {desc = Tvar (Some "_")} as ty ->
+            if List.memq ty vars then ty.desc <- Tvar None
+          | _ -> ())
+        params
+  | None -> ()
+  end;
+
+  List.iter add_alias params;
+  List.iter mark_loops params;
+  List.iter check_name_of_type (List.map proxy params);
+  let ty_manifest =
+    match decl.type_manifest with
+    | None -> None
+    | Some ty ->
+        let ty =
+          (* Special hack to hide variant name *)
+          match repr ty with {desc=Tvariant row} ->
+            let row = row_repr row in
+            begin match row.row_name with
+              Some (Pident id', _) when Ident.same id id' ->
+                newgenty (Tvariant {row with row_name = None})
+            | _ -> ty
+            end
+          | _ -> ty
+        in
+        mark_loops ty;
+        Some ty
+  in
+  begin match decl.type_kind with
+  | Type_abstract -> ()
+  | Type_variant cstrs ->
+      List.iter
+        (fun c ->
+           mark_loops_constructor_arguments c.cd_args;
+           Option.iter mark_loops c.cd_res)
+        cstrs
+  | Type_record(l, _rep) ->
+      List.iter (fun l -> mark_loops l.ld_type) l
+  | Type_open -> ()
+  end;
+
+  let type_param =
+    function
+    | Otyp_var (_, id) -> id
+    | _ -> "?"
+  in
+  let type_defined decl =
+    let abstr =
+      match decl.type_kind with
+        Type_abstract ->
+          decl.type_manifest = None || decl.type_private = Private
+      | Type_record _ ->
+          decl.type_private = Private
+      | Type_variant tll ->
+          decl.type_private = Private ||
+          List.exists (fun cd -> cd.cd_res <> None) tll
+      | Type_open ->
+          decl.type_manifest = None
+    in
+    let vari =
+      List.map2
+        (fun ty v ->
+          if abstr || not (is_Tvar (repr ty)) then Variance.get_upper v
+          else (true,true))
+        decl.type_params decl.type_variance
+    in
+    (Ident.name id,
+     List.map2 (fun ty cocn -> type_param (tree_of_typexp false ty), cocn)
+       params vari)
+  in
+  let tree_of_manifest ty1 =
+    match ty_manifest with
+    | None -> ty1
+    | Some ty -> Otyp_manifest (tree_of_typexp false ty, ty1)
+  in
+  let (name, args) = type_defined decl in
+  let constraints = tree_of_constraints params in
+  let ty, priv =
+    match decl.type_kind with
+    | Type_abstract ->
+        begin match ty_manifest with
+        | None -> (Otyp_abstract, Public)
+        | Some ty ->
+            tree_of_typexp false ty, decl.type_private
+        end
+    | Type_variant cstrs ->
+        tree_of_manifest (Otyp_sum (List.map tree_of_constructor cstrs)),
+        decl.type_private
+    | Type_record(lbls, _rep) ->
+        tree_of_manifest (Otyp_record (List.map tree_of_label lbls)),
+        decl.type_private
+    | Type_open ->
+        tree_of_manifest Otyp_open,
+        decl.type_private
+  in
+    { otype_name = name;
+      otype_params = args;
+      otype_type = ty;
+      otype_private = priv;
+      otype_immediate = Type_immediacy.of_attributes decl.type_attributes;
+      otype_unboxed = decl.type_unboxed.unboxed;
+      otype_cstrs = constraints }
+
+and tree_of_constructor_arguments = function
+  | Cstr_tuple l -> tree_of_typlist false l
+  | Cstr_record l -> [ Otyp_record (List.map tree_of_label l) ]
+
+and tree_of_constructor cd =
+  let name = Ident.name cd.cd_id in
+  let arg () = tree_of_constructor_arguments cd.cd_args in
+  match cd.cd_res with
+  | None -> (name, arg (), None)
+  | Some res ->
+      let nm = !names in
+      names := [];
+      let ret = tree_of_typexp false res in
+      let args = arg () in
+      names := nm;
+      (name, args, Some ret)
+
+and tree_of_label l =
+  (Ident.name l.ld_id, l.ld_mutable = Mutable, tree_of_typexp false l.ld_type)
+
+let constructor ppf c =
+  reset_except_context ();
+  !Oprint.out_constr ppf (tree_of_constructor c)
+
+let label ppf l =
+  reset_except_context ();
+  !Oprint.out_label ppf (tree_of_label l)
+
+let tree_of_type_declaration id decl rs =
+  Osig_type (tree_of_type_decl id decl, tree_of_rec rs)
+
+let type_declaration id ppf decl =
+  !Oprint.out_sig_item ppf (tree_of_type_declaration id decl Trec_first)
+
+let constructor_arguments ppf a =
+  let tys = tree_of_constructor_arguments a in
+  !Oprint.out_type ppf (Otyp_tuple tys)
+
+(* Print an extension declaration *)
+
+let extension_constructor_args_and_ret_type_subtree ext_args ext_ret_type =
+  match ext_ret_type with
+  | None -> (tree_of_constructor_arguments ext_args, None)
+  | Some res ->
+    let nm = !names in
+    names := [];
+    let ret = tree_of_typexp false res in
+    let args = tree_of_constructor_arguments ext_args in
+    names := nm;
+    (args, Some ret)
+
+let tree_of_extension_constructor id ext es =
+  reset_except_context ();
+  let type_path = best_type_path_simple ext.ext_type_path in
+  let ty_name = Path.name type_path in
+  let ty_params = filter_params ext.ext_type_params in
+  List.iter add_alias ty_params;
+  List.iter mark_loops ty_params;
+  List.iter check_name_of_type (List.map proxy ty_params);
+  mark_loops_constructor_arguments ext.ext_args;
+  Option.iter mark_loops ext.ext_ret_type;
+  let type_param =
+    function
+    | Otyp_var (_, id) -> id
+    | _ -> "?"
+  in
+  let ty_params =
+    List.map (fun ty -> type_param (tree_of_typexp false ty)) ty_params
+  in
+  let name = Ident.name id in
+  let args, ret =
+    extension_constructor_args_and_ret_type_subtree
+      ext.ext_args
+      ext.ext_ret_type
+  in
+  let ext =
+    { oext_name = name;
+      oext_type_name = ty_name;
+      oext_type_params = ty_params;
+      oext_args = args;
+      oext_ret_type = ret;
+      oext_private = ext.ext_private }
+  in
+  let es =
+    match es with
+        Text_first -> Oext_first
+      | Text_next -> Oext_next
+      | Text_exception -> Oext_exception
+  in
+    Osig_typext (ext, es)
+
+let extension_constructor id ppf ext =
+  !Oprint.out_sig_item ppf (tree_of_extension_constructor id ext Text_first)
+
+let extension_only_constructor id ppf ext =
+  reset_except_context ();
+  let name = Ident.name id in
+  let args, ret =
+    extension_constructor_args_and_ret_type_subtree
+      ext.ext_args
+      ext.ext_ret_type
+  in
+  Format.fprintf ppf "@[<hv>%a@]"
+    !Oprint.out_constr (name, args, ret)
+
+(* Print a value declaration *)
+
+let tree_of_value_description id decl =
+  (* Format.eprintf "@[%a@]@." raw_type_expr decl.val_type; *)
+  let id = Ident.name id in
+  let ty = tree_of_type_scheme decl.val_type in
+  let vd =
+    { oval_name = id;
+      oval_type = ty;
+      oval_prims = [];
+      oval_attributes = [] }
+  in
+  let vd =
+    match decl.val_kind with
+    | Val_prim p -> Primitive.print p vd
+    | _ -> vd
+  in
+  Osig_value vd
+
+let value_description id ppf decl =
+  !Oprint.out_sig_item ppf (tree_of_value_description id decl)
+
+(* Print a class type *)
+
+let method_type (_, kind, ty) =
+  match field_kind_repr kind, repr ty with
+    Fpresent, {desc=Tpoly(ty, tyl)} -> (ty, tyl)
+  | _       , ty                    -> (ty, [])
+
+let tree_of_metho sch concrete csil (lab, kind, ty) =
+  if lab <> dummy_method then begin
+    let kind = field_kind_repr kind in
+    let priv = kind <> Fpresent in
+    let virt = not (Concr.mem lab concrete) in
+    let (ty, tyl) = method_type (lab, kind, ty) in
+    let tty = tree_of_typexp sch ty in
+    remove_names tyl;
+    Ocsg_method (lab, priv, virt, tty) :: csil
+  end
+  else csil
+
+let rec prepare_class_type params = function
+  | Cty_constr (_p, tyl, cty) ->
+      let sty = Ctype.self_type cty in
+      if List.memq (proxy sty) !visited_objects
+      || not (List.for_all is_Tvar params)
+      || List.exists (deep_occur sty) tyl
+      then prepare_class_type params cty
+      else List.iter mark_loops tyl
+  | Cty_signature sign ->
+      let sty = repr sign.csig_self in
+      (* Self may have a name *)
+      let px = proxy sty in
+      if List.memq px !visited_objects then add_alias sty
+      else visited_objects := px :: !visited_objects;
+      let (fields, _) =
+        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
+      in
+      List.iter (fun met -> mark_loops (fst (method_type met))) fields;
+      Vars.iter (fun _ (_, _, ty) -> mark_loops ty) sign.csig_vars
+  | Cty_arrow (_, ty, cty) ->
+      mark_loops ty;
+      prepare_class_type params cty
+
+let rec tree_of_class_type sch params =
+  function
+  | Cty_constr (p, tyl, cty) ->
+      let sty = Ctype.self_type cty in
+      if List.memq (proxy sty) !visited_objects
+      || not (List.for_all is_Tvar params)
+      then
+        tree_of_class_type sch params cty
+      else begin
+        let nso, p = best_class_type_path p in
+        let tyl = apply_subst_opt nso tyl in
+        let namespace = Namespace.best_class_namespace p in
+        Octy_constr (tree_of_path namespace p, tree_of_typlist true tyl)
+      end
+  | Cty_signature sign ->
+      let sty = repr sign.csig_self in
+      let self_ty =
+        if is_aliased sty then
+          Some (Otyp_var (false, name_of_type new_name (proxy sty)))
+        else None
+      in
+      let (fields, _) =
+        Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
+      in
+      let csil = [] in
+      let csil =
+        List.fold_left
+          (fun csil (ty1, ty2) -> Ocsg_constraint (ty1, ty2) :: csil)
+          csil (tree_of_constraints params)
+      in
+      let all_vars =
+        Vars.fold (fun l (m, v, t) all -> (l, m, v, t) :: all) sign.csig_vars []
+      in
+      (* Consequence of PR#3607: order of Map.fold has changed! *)
+      let all_vars = List.rev all_vars in
+      let csil =
+        List.fold_left
+          (fun csil (l, m, v, t) ->
+            Ocsg_value (l, m = Mutable, v = Virtual, tree_of_typexp sch t)
+            :: csil)
+          csil all_vars
+      in
+      let csil =
+        List.fold_left (tree_of_metho sch sign.csig_concr) csil fields
+      in
+      Octy_signature (self_ty, List.rev csil)
+  | Cty_arrow (l, ty, cty) ->
+      let lab =
+        if !print_labels || is_optional l then string_of_label l else ""
+      in
+      let tr =
+       if is_optional l then
+         match (repr ty).desc with
+         | Tconstr(path, [ty], _) when Path.same path Predef.path_option ->
+             tree_of_typexp sch ty
+         | _ -> Otyp_stuff "<hidden>"
+       else tree_of_typexp sch ty in
+      Octy_arrow (lab, tr, tree_of_class_type sch params cty)
+
+let class_type ppf cty =
+  reset ();
+  prepare_class_type [] cty;
+  !Oprint.out_class_type ppf (tree_of_class_type false [] cty)
+
+let tree_of_class_param param variance =
+  (match tree_of_typexp true param with
+    Otyp_var (_, s) -> s
+  | _ -> "?"),
+  if is_Tvar (repr param) then (true, true) else variance
+
+let class_variance =
+  List.map Variance.(fun v -> mem May_pos v, mem May_neg v)
+
+let tree_of_class_declaration id cl rs =
+  let params = filter_params cl.cty_params in
+
+  reset_except_context ();
+  List.iter add_alias params;
+  prepare_class_type params cl.cty_type;
+  let sty = Ctype.self_type cl.cty_type in
+  List.iter mark_loops params;
+
+  List.iter check_name_of_type (List.map proxy params);
+  if is_aliased sty then check_name_of_type (proxy sty);
+
+  let vir_flag = cl.cty_new = None in
+  Osig_class
+    (vir_flag, Ident.name id,
+     List.map2 tree_of_class_param params (class_variance cl.cty_variance),
+     tree_of_class_type true params cl.cty_type,
+     tree_of_rec rs)
+
+let class_declaration id ppf cl =
+  !Oprint.out_sig_item ppf (tree_of_class_declaration id cl Trec_first)
+
+let tree_of_cltype_declaration id cl rs =
+  let params = List.map repr cl.clty_params in
+
+  reset_except_context ();
+  List.iter add_alias params;
+  prepare_class_type params cl.clty_type;
+  let sty = Ctype.self_type cl.clty_type in
+  List.iter mark_loops params;
+
+  List.iter check_name_of_type (List.map proxy params);
+  if is_aliased sty then check_name_of_type (proxy sty);
+
+  let sign = Ctype.signature_of_class_type cl.clty_type in
+
+  let virt =
+    let (fields, _) =
+      Ctype.flatten_fields (Ctype.object_fields sign.csig_self) in
+    List.exists
+      (fun (lab, _, _) ->
+         not (lab = dummy_method || Concr.mem lab sign.csig_concr))
+      fields
+    || Vars.fold (fun _ (_,vr,_) b -> vr = Virtual || b) sign.csig_vars false
+  in
+
+  Osig_class_type
+    (virt, Ident.name id,
+     List.map2 tree_of_class_param params (class_variance cl.clty_variance),
+     tree_of_class_type true params cl.clty_type,
+     tree_of_rec rs)
+
+let cltype_declaration id ppf cl =
+  !Oprint.out_sig_item ppf (tree_of_cltype_declaration id cl Trec_first)
+
+(* Print a module type *)
+
+let wrap_env fenv ftree arg =
+  let env = !printing_env in
+  let env' = Env.update_short_paths (fenv env) in
+  set_printing_env env';
+  let tree = ftree arg in
+  set_printing_env env;
+  tree
+
+let filter_rem_sig item rem =
+  match item, rem with
+  | Sig_class _, ctydecl :: tydecl1 :: tydecl2 :: rem ->
+      ([ctydecl; tydecl1; tydecl2], rem)
+  | Sig_class_type _, tydecl1 :: tydecl2 :: rem ->
+      ([tydecl1; tydecl2], rem)
+  | _ ->
+      ([], rem)
+
+let dummy =
+  { type_params = []; type_arity = 0; type_kind = Type_abstract;
+    type_private = Public; type_manifest = None; type_variance = [];
+    type_is_newtype = false; type_expansion_scope = Btype.lowest_level;
+    type_loc = Location.none;
+    type_attributes = [];
+    type_immediate = Unknown;
+    type_unboxed = unboxed_false_default_false;
+  }
+
+let hide ids env = List.fold_right
+    (fun id -> Env.add_type ~check:false (Ident.rename_no_exn id) dummy)
+    ids env
+
+let hide_rec_items = function
+  | Sig_type(id, _decl, rs, _) ::rem
+    when rs = Trec_first && not !Clflags.real_paths ->
+      let rec get_ids = function
+          Sig_type (id, _, Trec_next, _) :: rem ->
+            id :: get_ids rem
+        | _ -> []
+      in
+      let ids = id :: get_ids rem in
+      let env = hide ids !printing_env in
+      let env = Env.update_short_paths env in
+      set_printing_env env
+  | _ -> ()
+
+let recursive_sigitem = function
+  | Sig_class(id,_,rs,_) -> Some(id,rs,3)
+  | Sig_class_type (id,_,rs,_) -> Some(id,rs,2)
+  | Sig_type(id, _, rs, _)
+  | Sig_module(id, _, _, rs, _) -> Some (id,rs,0)
+  | _ -> None
+
+let skip k l = snd (Std.List.split_n k l)
+
+let protect_rec_items items =
+  let rec get_ids recs = function
+    | [] -> []
+    | item :: rem -> match recursive_sigitem item with
+      | Some (id, r, k ) when r = recs -> id :: get_ids Trec_next (skip k rem)
+      | _ -> [] in
+  List.iter Naming_context.add_protected (get_ids Trec_first items)
+
+let stop_type_group env =
+  Naming_context.reset_protected ();
+  set_printing_env env
+
+let still_in_type_group env' in_type_group item =
+  match in_type_group, recursive_sigitem item with
+  | true, Some (_,Trec_next,_) -> true
+  | _, Some (_, (Trec_not | Trec_first),_) ->
+      let env' = Env.update_short_paths env' in
+      set_printing_env env';
+      stop_type_group env';
+      true
+  | _ ->
+      let env' = Env.update_short_paths env' in
+      set_printing_env env';
+      stop_type_group env';
+      false
+
+let rec tree_of_modtype ?(ellipsis=false) = function
+  | Mty_ident p ->
+      let p = best_module_type_path p in
+      Omty_ident (tree_of_path Module_type p)
+  | Mty_signature sg ->
+      Omty_signature (if ellipsis then [Osig_ellipsis]
+                      else tree_of_signature sg)
+  | Mty_functor(param, ty_res) ->
+      let param, res =
+        match param with
+        | Unit -> None, tree_of_modtype ~ellipsis ty_res
+        | Named (param, ty_arg) ->
+          let name, env =
+            match param with
+            | None -> None, fun env -> env
+            | Some id ->
+                Some (Ident.name id),
+                Env.add_module ~arg:true id Mp_present ty_arg
+          in
+          Some (name, tree_of_modtype ~ellipsis:false ty_arg),
+          wrap_env env (tree_of_modtype ~ellipsis) ty_res
+      in
+      Omty_functor (param, res)
+  | Mty_alias p ->
+      let p = best_module_type_path p in
+      Omty_alias (tree_of_path Module p)
+
+and tree_of_signature sg =
+  wrap_env (fun env -> env) (tree_of_signature_rec !printing_env false) sg
+
+and tree_of_signature_rec env' in_type_group = function
+    [] -> stop_type_group env'; []
+  | item :: rem as items ->
+      let in_type_group = still_in_type_group env' in_type_group item in
+      let (sg, rem) = filter_rem_sig item rem in
+      hide_rec_items items;
+      protect_rec_items items;
+      reset_naming_context ();
+      let trees = trees_of_sigitem item in
+      let env' = Env.add_signature (item :: sg) env' in
+      trees @ tree_of_signature_rec env' in_type_group rem
+
+and trees_of_sigitem = function
+  | Sig_value(id, decl, _) ->
+      [tree_of_value_description id decl]
+  | Sig_type(id, _, _, _) when is_row_name (Ident.name id) ->
+      []
+  | Sig_type(id, decl, rs, _) ->
+      [tree_of_type_declaration id decl rs]
+  | Sig_typext(id, ext, es, _) ->
+      [tree_of_extension_constructor id ext es]
+  | Sig_module(id, _, md, rs, _) ->
+      let ellipsis =
+        List.exists (function
+          | Parsetree.{attr_name = {txt="..."}; attr_payload = PStr []} -> true
+          | _ -> false)
+          md.md_attributes in
+      [tree_of_module id md.md_type rs ~ellipsis]
+  | Sig_modtype(id, decl, _) ->
+      [tree_of_modtype_declaration id decl]
+  | Sig_class(id, decl, rs, _) ->
+      [tree_of_class_declaration id decl rs]
+  | Sig_class_type(id, decl, rs, _) ->
+      [tree_of_cltype_declaration id decl rs]
+
+and tree_of_modtype_declaration id decl =
+  let mty =
+    match decl.mtd_type with
+    | None -> Omty_abstract
+    | Some mty -> tree_of_modtype mty
+  in
+  Osig_modtype (Ident.name id, mty)
+
+and tree_of_module id ?ellipsis mty rs =
+  Osig_module (Ident.name id, tree_of_modtype ?ellipsis mty, tree_of_rec rs)
+
+let modtype ppf mty = !Oprint.out_module_type ppf (tree_of_modtype mty)
+let modtype_declaration id ppf decl =
+  !Oprint.out_sig_item ppf (tree_of_modtype_declaration id decl)
+
+(* For the toplevel: merge with tree_of_signature? *)
+
+(* Refresh weak variable map in the toplevel *)
+let refresh_weak () =
+  let refresh t name (m,s) =
+    if is_non_gen true (repr t) then
+      begin
+        TypeMap.add t name m,
+        String.Set.add name s
+      end
+    else m, s in
+  let m, s =
+    TypeMap.fold refresh !weak_var_map (TypeMap.empty ,String.Set.empty)  in
+  named_weak_vars := s;
+  weak_var_map := m
+
+let print_items showval env x =
+  refresh_weak();
+  reset_naming_context ();
+  Conflicts.reset ();
+  let rec print showval in_type_group env = function
+  | [] -> stop_type_group env; []
+  | item :: rem as items ->
+      let in_type_group = still_in_type_group env in_type_group item in
+      let (sg, rem) = filter_rem_sig item rem in
+      hide_rec_items items;
+      protect_rec_items items;
+      reset_naming_context ();
+      let trees = trees_of_sigitem item in
+      List.map (fun d -> (d, showval env item)) trees @
+      print showval in_type_group (Env.add_signature (item :: sg) env) rem in
+  print showval false env x
+
+(* Print a signature body (used by -i when compiling a .ml) *)
+
+let print_signature ppf tree =
+  fprintf ppf "@[<v>%a@]" !Oprint.out_signature tree
+
+let signature ppf sg =
+  fprintf ppf "%a" print_signature (tree_of_signature sg)
+
+(* Print a signature body (used by -i when compiling a .ml) *)
+let printed_signature sourcefile ppf sg =
+  (* we are tracking any collision event for warning 63 *)
+  Conflicts.reset ();
+  reset_naming_context ();
+  let t = tree_of_signature sg in
+  if Warnings.(is_active @@ Erroneous_printed_signature "")
+  && Conflicts.exists ()
+  then begin
+    let conflicts = Format.asprintf "%t" Conflicts.print_explanations in
+    Location.prerr_warning (Location.in_file sourcefile)
+      (Warnings.Erroneous_printed_signature conflicts);
+    Warnings.check_fatal ()
+  end;
+  fprintf ppf "%a" print_signature t
+
+(* Print an unification error *)
+
+let same_path t t' =
+  let t = repr t and t' = repr t' in
+  t == t' ||
+  match t.desc, t'.desc with
+  | Tconstr(p,tl,_), Tconstr(p',tl',_) -> begin
+      match best_type_path p, best_type_path p' with
+      | Nth n, Nth n' when n = n' -> true
+      | Path(nso, p), Path(nso', p') when Path.same p p' ->
+          let tl = apply_subst_opt nso tl in
+          let tl' = apply_subst_opt nso' tl' in
+          List.length tl = List.length tl' &&
+          List.for_all2 same_type tl tl'
+      | _ -> false
+      end
+  | _ ->
+      false
+
+type 'a diff = Same of 'a | Diff of 'a * 'a
+
+let trees_of_type_expansion (t,t') =
+  if same_path t t'
+  then begin add_delayed (proxy t); Same (tree_of_typexp false t) end
+  else
+    let t' = if proxy t == proxy t' then unalias t' else t' in
+    (* beware order matter due to side effect,
+       e.g. when printing object types *)
+    let first = tree_of_typexp false t in
+    let second = tree_of_typexp false t' in
+    if first = second then Same first
+    else Diff(first,second)
+
+let type_expansion ppf = function
+  | Same t -> !Oprint.out_type ppf t
+  | Diff(t,t') ->
+      fprintf ppf "@[<2>%a@ =@ %a@]"  !Oprint.out_type t  !Oprint.out_type t'
+
+module Trace = Ctype.Unification_trace
+
+let trees_of_trace = List.map (Trace.map_diff trees_of_type_expansion)
+
+let trees_of_type_path_expansion (tp,tp') =
+  if Path.same tp tp' then Same(tree_of_path Type tp) else
+    Diff(tree_of_path Type tp, tree_of_path Type tp')
+
+let type_path_expansion ppf = function
+  | Same p -> !Oprint.out_ident ppf p
+  | Diff(p,p') ->
+      fprintf ppf "@[<2>%a@ =@ %a@]"
+        !Oprint.out_ident p
+        !Oprint.out_ident p'
+
+let rec trace fst txt ppf = function
+  | {Trace.got; expected} :: rem ->
+      if not fst then fprintf ppf "@,";
+      fprintf ppf "@[Type@;<1 2>%a@ %s@;<1 2>%a@] %a"
+       type_expansion got txt type_expansion expected
+       (trace false txt) rem
+  | _ -> ()
+
+
+type printing_status =
+  | Discard
+  | Keep
+  | Optional_refinement
+  (** An [Optional_refinement] printing status is attributed to trace
+      elements that are focusing on a new subpart of a structural type.
+      Since the whole type should have been printed earlier in the trace,
+      we only print those elements if they are the last printed element
+      of a trace, and there is no explicit explanation for the
+      type error.
+  *)
+
+let printing_status  = function
+  | Trace.(Diff { got=t1, t1'; expected=t2, t2'}) ->
+      if  is_constr_row ~allow_ident:true t1'
+       || is_constr_row ~allow_ident:true t2'
+      then Discard
+      else if same_path t1 t1' && same_path t2 t2' then Optional_refinement
+      else Keep
+  | _ -> Keep
+
+(** Flatten the trace and remove elements that are always discarded
+    during printing *)
+let prepare_trace f tr =
+  let clean_trace x l = match printing_status x with
+    | Keep -> x :: l
+    | Optional_refinement when l = [] -> [x]
+    | Optional_refinement | Discard -> l
+  in
+  match Trace.flatten f tr with
+  | [] -> []
+  | elt :: rem -> (* the first element is always kept *)
+      elt :: List.fold_right clean_trace rem []
+
+(** Keep elements that are not [Diff _ ] and take the decision
+    for the last element, require a prepared trace *)
+let rec filter_trace keep_last = function
+  | [] -> []
+  | [Trace.Diff d as elt] when printing_status elt = Optional_refinement ->
+      if keep_last then [d] else []
+  | Trace.Diff d :: rem -> d :: filter_trace keep_last rem
+  | _ :: rem -> filter_trace keep_last rem
+
+let type_path_list =
+  Format.pp_print_list ~pp_sep:(fun ppf () -> Format.pp_print_break ppf 2 0)
+    type_path_expansion
+
+(* Hide variant name and var, to force printing the expanded type *)
+let hide_variant_name t =
+  match repr t with
+  | {desc = Tvariant row} as t when (row_repr row).row_name <> None ->
+      newty2 t.level
+        (Tvariant {(row_repr row) with row_name = None;
+                   row_more = newvar2 (row_more row).level})
+  | _ -> t
+
+let prepare_expansion (t, t') =
+  let t' = hide_variant_name t' in
+  mark_loops t;
+  if not (same_path t t') then mark_loops t';
+  (t, t')
+
+let may_prepare_expansion compact (t, t') =
+  match (repr t').desc with
+    Tvariant _ | Tobject _ when compact ->
+      mark_loops t; (t, t)
+  | _ -> prepare_expansion (t, t')
+
+let print_tag ppf = fprintf ppf "`%s"
+
+let print_tags =
+  let comma ppf () = Format.fprintf ppf ",@ " in
+  Format.pp_print_list ~pp_sep:comma print_tag
+
+let is_unit env ty =
+  match (Ctype.expand_head env ty).desc with
+  | Tconstr (p, _, _) -> Path.same p Predef.path_unit
+  | _ -> false
+
+let unifiable env ty1 ty2 =
+  let snap = Btype.snapshot () in
+  let res =
+    try Ctype.unify env ty1 ty2; true
+    with Unify _ -> false
+  in
+  Btype.backtrack snap;
+  res
+
+let explanation_diff env t3 t4 : (Format.formatter -> unit) option =
+  match t3.desc, t4.desc with
+  | Tarrow (_, ty1, ty2, _), _
+    when is_unit env ty1 && unifiable env ty2 t4 ->
+      Some (fun ppf ->
+        fprintf ppf
+          "@,@[Hint: Did you forget to provide `()' as argument?@]")
+  | _, Tarrow (_, ty1, ty2, _)
+    when is_unit env ty1 && unifiable env t3 ty2 ->
+      Some (fun ppf ->
+        fprintf ppf
+          "@,@[Hint: Did you forget to wrap the expression using \
+           `fun () ->'?@]")
+  | _ ->
+      None
+
+let print_pos ppf = function
+  | Trace.First -> fprintf ppf "first"
+  | Trace.Second -> fprintf ppf "second"
+
+let explain_fixed_row_case ppf = function
+  | Trace.Cannot_be_closed -> Format.fprintf ppf "it cannot be closed"
+  | Trace.Cannot_add_tags tags ->
+      Format.fprintf ppf "it may not allow the tag(s) %a"
+        print_tags tags
+
+let explain_fixed_row pos expl = match expl with
+  | Types.Fixed_private ->
+      dprintf "The %a variant type is private" print_pos pos
+  | Types.Univar x ->
+      dprintf "The %a variant type is bound to the universal type variable %a"
+        print_pos pos type_expr x
+  | Types.Reified p ->
+      let p = tree_of_path Type p in
+      dprintf "The %a variant type is bound to %a" print_pos pos
+        !Oprint.out_ident p
+  | Types.Rigid -> ignore
+
+let explain_variant = function
+  | Trace.No_intersection ->
+      Some(dprintf "@,These two variant types have no intersection")
+  | Trace.No_tags(pos,fields) -> Some(
+      dprintf
+        "@,@[The %a variant type does not allow tag(s)@ @[<hov>%a@]@]"
+        print_pos pos
+        print_tags (List.map fst fields)
+    )
+  | Trace.Incompatible_types_for s ->
+      Some(dprintf "@,Types for tag `%s are incompatible" s)
+  | Trace.Fixed_row (pos, k, (Univar _ | Reified _ | Fixed_private as e)) ->
+      Some (
+        dprintf "@,@[%t,@ %a@]" (explain_fixed_row pos e)
+          explain_fixed_row_case k
+      )
+  | Trace.Fixed_row (_,_, Rigid) ->
+      (* this case never happens *)
+      None
+
+
+let explain_escape intro prev ctx e =
+  let pre = match ctx with
+    | Some ctx ->  dprintf "@[%t@;<1 2>%a@]" intro type_expr ctx
+    | None -> match e, prev with
+      | Trace.Univ _, Some(Trace.Incompatible_fields {name; diff}) ->
+          dprintf "@,@[The method %s has type@ %a,@ \
+                   but the expected method type was@ %a@]" name
+            type_expr diff.Trace.got type_expr diff.Trace.expected
+      | _ -> ignore in
+  match e with
+  | Trace.Univ u ->  Some(
+      dprintf "%t@,The universal variable %a would escape its scope"
+        pre type_expr u)
+  | Trace.Constructor p -> Some(
+      dprintf
+        "%t@,@[The type constructor@;<1 2>%a@ would escape its scope@]"
+        pre path p
+    )
+  | Trace.Module_type p -> Some(
+      dprintf
+        "%t@,@[The module type@;<1 2>%a@ would escape its scope@]"
+        pre path p
+    )
+  | Trace.Equation (_,t) -> Some(
+      dprintf "%t @,@[<hov>This instance of %a is ambiguous:@ %s@]"
+        pre type_expr t
+        "it would escape the scope of its equation"
+    )
+  | Trace.Self ->
+      Some (dprintf "%t@,Self type cannot escape its class" pre)
+
+
+let explain_object = function
+  | Trace.Self_cannot_be_closed ->
+      Some (dprintf "@,Self type cannot be unified with a closed object type")
+  | Trace.Missing_field (pos,f) ->
+      Some(dprintf "@,@[The %a object type has no method %s@]" print_pos pos f)
+  | Trace.Abstract_row pos -> Some(
+      dprintf
+        "@,@[The %a object type has an abstract row, it cannot be closed@]"
+        print_pos pos
+    )
+
+
+let explanation intro prev env = function
+  | Trace.Diff { Trace.got = _, s; expected = _,t } -> explanation_diff env s t
+  | Trace.Escape {kind;context} -> explain_escape intro prev context kind
+  | Trace.Incompatible_fields { name; _ } ->
+        Some(dprintf "@,Types for method %s are incompatible" name)
+  | Trace.Variant v -> explain_variant v
+  | Trace.Obj o -> explain_object o
+  | Trace.Rec_occur(x,y) ->
+      reset_and_mark_loops y;
+      Some(dprintf "@,@[<hov>The type variable %a occurs inside@ %a@]"
+            marked_type_expr x marked_type_expr y)
+
+let mismatch intro env trace =
+  Trace.explain trace (fun ~prev h -> explanation intro prev env h)
+
+let explain mis ppf =
+  match mis with
+  | None -> ()
+  | Some explain -> explain ppf
+
+let warn_on_missing_def env ppf t =
+  match t.desc with
+  | Tconstr (p,_,_) ->
+    begin
+      try
+        ignore(Env.find_type p env : Types.type_declaration)
+      with Not_found ->
+        fprintf ppf
+          "@,@[%a is abstract because no corresponding cmi file was found \
+           in path.@]" path p
+    end
+  | _ -> ()
+
+
+let prepare_expansion_head empty_tr = function
+  | Trace.Diff d ->
+      Some(Trace.map_diff (may_prepare_expansion empty_tr) d)
+  | _ -> None
+
+let head_error_printer txt_got txt_but = function
+  | None -> ignore
+  | Some d ->
+      let d = Trace.map_diff trees_of_type_expansion d in
+      dprintf "%t@;<1 2>%a@ %t@;<1 2>%a"
+        txt_got type_expansion d.Trace.got
+        txt_but type_expansion d.Trace.expected
+
+let warn_on_missing_defs env ppf = function
+  | None -> ()
+  | Some {Trace.got=te1,_; expected=te2,_ } ->
+      warn_on_missing_def env ppf te1;
+      warn_on_missing_def env ppf te2
+
+let unification_error env tr txt1 ppf txt2 ty_expect_explanation =
+  reset ();
+  let tr = prepare_trace (fun t t' -> t, hide_variant_name t') tr in
+  let mis = mismatch txt1 env tr in
+  match tr with
+  | [] -> assert false
+  | elt :: tr ->
+    try
+      print_labels := not !Clflags.classic;
+      let tr = filter_trace (mis = None) tr in
+      let head = prepare_expansion_head (tr=[]) elt in
+      let tr = List.map (Trace.map_diff prepare_expansion) tr in
+      let head_error = head_error_printer txt1 txt2 head in
+      let tr = trees_of_trace tr in
+      fprintf ppf
+        "@[<v>\
+          @[%t%t@]%a%t\
+         @]"
+        head_error
+        ty_expect_explanation
+        (trace false "is not compatible with type") tr
+        (explain mis);
+      if env <> Env.empty
+      then warn_on_missing_defs env ppf head;
+      Conflicts.print_explanations ppf;
+      print_labels := true
+    with exn ->
+      print_labels := true;
+      raise exn
+
+let report_unification_error ppf env tr
+    ?(type_expected_explanation = fun _ -> ())
+    txt1 txt2 =
+  wrap_printing_env env (fun () -> unification_error env tr txt1 ppf txt2
+                            type_expected_explanation)
+    ~error:true
+;;
+
+(** [trace] requires the trace to be prepared *)
+let trace fst keep_last txt ppf tr =
+  print_labels := not !Clflags.classic;
+  try match tr with
+    | elt :: tr' ->
+        let elt = match elt with
+          | Trace.Diff diff -> [Trace.map_diff trees_of_type_expansion diff]
+          | _ -> [] in
+        let tr =
+          trees_of_trace
+          @@ List.map (Trace.map_diff prepare_expansion)
+          @@ filter_trace keep_last tr' in
+      if fst then trace fst txt ppf (elt @ tr)
+      else trace fst txt ppf tr;
+      print_labels := true
+  | _ -> ()
+  with exn ->
+    print_labels := true;
+    raise exn
+
+let report_subtyping_error ppf env tr1 txt1 tr2 =
+  wrap_printing_env ~error:true env (fun () ->
+    reset ();
+    let tr1 = prepare_trace (fun t t' -> prepare_expansion (t, t')) tr1 in
+    let tr2 = prepare_trace (fun t t' -> prepare_expansion (t, t')) tr2 in
+    let keep_first = match tr2 with
+      | Trace.[Obj _ | Variant _ | Escape _ ] | [] -> true
+      | _ -> false in
+    fprintf ppf "@[<v>%a" (trace true keep_first txt1) tr1;
+    if tr2 = [] then fprintf ppf "@]" else
+    let mis = mismatch (dprintf "Within this type") env tr2 in
+    fprintf ppf "%a%t%t@]"
+      (trace false (mis = None) "is not compatible with type") tr2
+      (explain mis)
+      Conflicts.print_explanations
+  )
+
+
+let report_ambiguous_type_error ppf env tp0 tpl txt1 txt2 txt3 =
+  wrap_printing_env ~error:true env (fun () ->
+    reset ();
+    let tp0 = trees_of_type_path_expansion tp0 in
+      match tpl with
+      [] -> assert false
+    | [tp] ->
+        fprintf ppf
+          "@[%t@;<1 2>%a@ \
+             %t@;<1 2>%a\
+           @]"
+          txt1 type_path_expansion (trees_of_type_path_expansion tp)
+          txt3 type_path_expansion tp0
+    | _ ->
+        fprintf ppf
+          "@[%t@;<1 2>@[<hv>%a@]\
+             @ %t@;<1 2>%a\
+           @]"
+          txt2 type_path_list (List.map trees_of_type_path_expansion tpl)
+          txt3 type_path_expansion tp0)
+
+(* Adapt functions to exposed interface *)
+let tree_of_path = tree_of_path Other
+let tree_of_modtype = tree_of_modtype ~ellipsis:false
+let type_expansion ty ppf ty' =
+  type_expansion ppf (trees_of_type_expansion (ty,ty'))
+let tree_of_type_declaration id td rs =
+  Naming_context.with_hidden id ( (* for disambiguation *)
+    wrap_env (hide [id]) (* for short-path *)
+      (fun () -> tree_of_type_declaration id td rs)
+  )
+
+let shorten_type_path env p =
+  wrap_printing_env env
+    (fun () -> best_type_path_simple p)
+
+let shorten_module_type_path env p =
+  wrap_printing_env env
+    (fun () -> best_module_type_path p)
+
+let shorten_module_path env p =
+  wrap_printing_env env
+    (fun () -> best_module_path p)
+
+let shorten_class_type_path env p =
+  wrap_printing_env env
+    (fun () -> best_class_type_path_simple p)
+
+let () =
+  Env.shorten_module_path := shorten_module_path
diff --git a/src/ocaml/typing/410+multicore/printtyp.mli b/src/ocaml/typing/410+multicore/printtyp.mli
new file mode 100644
index 00000000..71d9dae4
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printtyp.mli
@@ -0,0 +1,187 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Printing functions *)
+
+open Format
+open Types
+open Outcometree
+
+val longident: formatter -> Longident.t -> unit
+val ident: formatter -> Ident.t -> unit
+val tree_of_path: Path.t -> out_ident
+val path: formatter -> Path.t -> unit
+val string_of_path: Path.t -> string
+
+module Out_name: sig
+  val create: string -> out_name
+  val print: out_name -> string
+end
+
+type namespace =
+  | Type
+  | Module
+  | Module_type
+  | Class
+  | Class_type
+  | Other (** Other bypasses the unique name for identifier mechanism *)
+
+val strings_of_paths: namespace -> Path.t list -> string list
+    (** Print a list of paths, using the same naming context to
+        avoid name collisions *)
+
+val raw_type_expr: formatter -> type_expr -> unit
+val string_of_label: Asttypes.arg_label -> string
+
+val wrap_printing_env: ?error:bool -> Env.t -> (unit -> 'a) -> 'a
+    (* Call the function using the environment for type path shortening *)
+    (* This affects all the printing functions below *)
+    (* Also, if [~error:true], then disable the loading of cmis *)
+val shorten_type_path: Env.t -> Path.t -> Path.t
+val shorten_module_type_path: Env.t -> Path.t -> Path.t
+val shorten_module_path: Env.t -> Path.t -> Path.t
+val shorten_class_type_path: Env.t -> Path.t -> Path.t
+
+module Naming_context: sig
+  val enable: bool -> unit
+  (** When contextual names are enabled, the mapping between identifiers
+      and names is ensured to be one-to-one. *)
+
+  val reset: unit -> unit
+  (** Reset the naming context *)
+end
+
+(** The [Conflicts] module keeps track of conflicts arising when attributing
+    names to identifiers and provides functions that can print explanations
+    for these conflict in error messages *)
+module Conflicts: sig
+  val exists: unit -> bool
+  (** [exists()] returns true if the current naming context renamed
+        an identifier to avoid a name collision *)
+
+  type explanation =
+    { kind: namespace;
+      name:string;
+      root_name:string;
+      location:Location.t
+    }
+
+  val list_explanations: unit -> explanation list
+(** [list_explanations()] return the list of conflict explanations
+    collected up to this point, and reset the list of collected
+    explanations *)
+
+  val print_located_explanations:
+    Format.formatter -> explanation list -> unit
+
+  val print_explanations: Format.formatter -> unit
+  (** Print all conflict explanations collected up to this point *)
+
+  val reset: unit -> unit
+end
+
+
+val reset: unit -> unit
+val mark_loops: type_expr -> unit
+val reset_and_mark_loops: type_expr -> unit
+val reset_and_mark_loops_list: type_expr list -> unit
+
+val type_expr: formatter -> type_expr -> unit
+val marked_type_expr: formatter -> type_expr -> unit
+(** The function [type_expr] is the safe version of the pair
+    [(typed_expr, marked_type_expr)]:
+    it takes care of marking loops in the type expression and resetting
+    type variable names before printing.
+      Contrarily, the function [marked_type_expr] should only be called on
+    type expressions whose loops have been marked or it may stackoverflow
+    (see #8860 for examples).
+ *)
+
+val constructor_arguments: formatter -> constructor_arguments -> unit
+val tree_of_type_scheme: type_expr -> out_type
+val type_sch : formatter -> type_expr -> unit
+val type_scheme: formatter -> type_expr -> unit
+(* Maxence *)
+val reset_names: unit -> unit
+val type_scheme_max: ?b_reset_names: bool ->
+        formatter -> type_expr -> unit
+(* End Maxence *)
+val tree_of_value_description: Ident.t -> value_description -> out_sig_item
+val value_description: Ident.t -> formatter -> value_description -> unit
+val label : formatter -> label_declaration -> unit
+val constructor : formatter -> constructor_declaration -> unit
+val tree_of_type_declaration:
+    Ident.t -> type_declaration -> rec_status -> out_sig_item
+val type_declaration: Ident.t -> formatter -> type_declaration -> unit
+val tree_of_extension_constructor:
+    Ident.t -> extension_constructor -> ext_status -> out_sig_item
+val extension_constructor:
+    Ident.t -> formatter -> extension_constructor -> unit
+(* Prints extension constructor with the type signature:
+     type ('a, 'b) bar += A of float
+*)
+
+val extension_only_constructor:
+    Ident.t -> formatter -> extension_constructor -> unit
+(* Prints only extension constructor without type signature:
+     A of float
+*)
+
+val tree_of_module:
+    Ident.t -> ?ellipsis:bool -> module_type -> rec_status -> out_sig_item
+val modtype: formatter -> module_type -> unit
+val signature: formatter -> signature -> unit
+val tree_of_modtype: module_type -> out_module_type
+val tree_of_modtype_declaration:
+    Ident.t -> modtype_declaration -> out_sig_item
+val tree_of_signature: Types.signature -> out_sig_item list
+val tree_of_typexp: bool -> type_expr -> out_type
+val modtype_declaration: Ident.t -> formatter -> modtype_declaration -> unit
+val class_type: formatter -> class_type -> unit
+val tree_of_class_declaration:
+    Ident.t -> class_declaration -> rec_status -> out_sig_item
+val class_declaration: Ident.t -> formatter -> class_declaration -> unit
+val tree_of_cltype_declaration:
+    Ident.t -> class_type_declaration -> rec_status -> out_sig_item
+val cltype_declaration: Ident.t -> formatter -> class_type_declaration -> unit
+val type_expansion: type_expr -> Format.formatter -> type_expr -> unit
+val prepare_expansion: type_expr * type_expr -> type_expr * type_expr
+val trace:
+  bool -> bool-> string -> formatter
+  -> (type_expr * type_expr) Ctype.Unification_trace.elt list -> unit
+val report_unification_error:
+    formatter -> Env.t ->
+    Ctype.Unification_trace.t ->
+    ?type_expected_explanation:(formatter -> unit) ->
+    (formatter -> unit) -> (formatter -> unit) ->
+    unit
+val report_subtyping_error:
+    formatter -> Env.t -> Ctype.Unification_trace.t -> string
+    -> Ctype.Unification_trace.t -> unit
+val report_ambiguous_type_error:
+    formatter -> Env.t -> (Path.t * Path.t) -> (Path.t * Path.t) list ->
+    (formatter -> unit) -> (formatter -> unit) -> (formatter -> unit) -> unit
+
+(* for toploop *)
+val print_items: (Env.t -> signature_item -> 'a option) ->
+  Env.t -> signature_item list -> (out_sig_item * 'a option) list
+
+(* Simple heuristic to rewrite Foo__bar.* as Foo.Bar.* when Foo.Bar is an alias
+   for Foo__bar. This pattern is used by the stdlib. *)
+val rewrite_double_underscore_paths: Env.t -> Path.t -> Path.t
+
+(** [printed_signature sourcefile ppf sg] print the signature [sg] of
+    [sourcefile] with potential warnings for name collisions *)
+val printed_signature: string -> formatter -> signature -> unit
diff --git a/src/ocaml/typing/410+multicore/printtyped.ml b/src/ocaml/typing/410+multicore/printtyped.ml
new file mode 100644
index 00000000..a637eaf8
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printtyped.ml
@@ -0,0 +1,934 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Fabrice Le Fessant, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes;;
+open Format;;
+open Lexing;;
+open Location;;
+open Typedtree;;
+
+let fmt_position f l =
+  if l.pos_lnum = -1
+  then fprintf f "%s[%d]" l.pos_fname l.pos_cnum
+  else fprintf f "%s[%d,%d+%d]" l.pos_fname l.pos_lnum l.pos_bol
+               (l.pos_cnum - l.pos_bol)
+;;
+
+let fmt_location f loc =
+  fprintf f "(%a..%a)" fmt_position loc.loc_start fmt_position loc.loc_end;
+  if loc.loc_ghost then fprintf f " ghost";
+;;
+
+let rec fmt_longident_aux f x =
+  match x with
+  | Longident.Lident (s) -> fprintf f "%s" s;
+  | Longident.Ldot (y, s) -> fprintf f "%a.%s" fmt_longident_aux y s;
+  | Longident.Lapply (y, z) ->
+      fprintf f "%a(%a)" fmt_longident_aux y fmt_longident_aux z;
+;;
+
+let fmt_longident f x = fprintf f "\"%a\"" fmt_longident_aux x.txt;;
+
+let fmt_ident = Ident.print
+
+let fmt_modname f = function
+  | None -> fprintf f "_";
+  | Some id -> Ident.print f id
+
+let rec fmt_path_aux f x =
+  match x with
+  | Path.Pident (s) -> fprintf f "%a" fmt_ident s;
+  | Path.Pdot (y, s) -> fprintf f "%a.%s" fmt_path_aux y s;
+  | Path.Papply (y, z) ->
+      fprintf f "%a(%a)" fmt_path_aux y fmt_path_aux z;
+;;
+
+let fmt_path f x = fprintf f "\"%a\"" fmt_path_aux x;;
+
+let fmt_constant f x =
+  match x with
+  | Const_int (i) -> fprintf f "Const_int %d" i;
+  | Const_char (c) -> fprintf f "Const_char %02x" (Char.code c);
+  | Const_string (s, None) -> fprintf f "Const_string(%S,None)" s;
+  | Const_string (s, Some delim) ->
+      fprintf f "Const_string (%S,Some %S)" s delim;
+  | Const_float (s) -> fprintf f "Const_float %s" s;
+  | Const_int32 (i) -> fprintf f "Const_int32 %ld" i;
+  | Const_int64 (i) -> fprintf f "Const_int64 %Ld" i;
+  | Const_nativeint (i) -> fprintf f "Const_nativeint %nd" i;
+;;
+
+let fmt_mutable_flag f x =
+  match x with
+  | Immutable -> fprintf f "Immutable";
+  | Mutable -> fprintf f "Mutable";
+;;
+
+let fmt_virtual_flag f x =
+  match x with
+  | Virtual -> fprintf f "Virtual";
+  | Concrete -> fprintf f "Concrete";
+;;
+
+let fmt_override_flag f x =
+  match x with
+  | Override -> fprintf f "Override";
+  | Fresh -> fprintf f "Fresh";
+;;
+
+let fmt_closed_flag f x =
+  match x with
+  | Closed -> fprintf f "Closed"
+  | Open -> fprintf f "Open"
+
+let fmt_rec_flag f x =
+  match x with
+  | Nonrecursive -> fprintf f "Nonrec";
+  | Recursive -> fprintf f "Rec";
+;;
+
+let fmt_direction_flag f x =
+  match x with
+  | Upto -> fprintf f "Up";
+  | Downto -> fprintf f "Down";
+;;
+
+let fmt_private_flag f x =
+  match x with
+  | Public -> fprintf f "Public";
+  | Private -> fprintf f "Private";
+;;
+
+let line i f s (*...*) =
+  fprintf f "%s" (String.make (2*i) ' ');
+  fprintf f s (*...*)
+;;
+
+let list i f ppf l =
+  match l with
+  | [] -> line i ppf "[]\n";
+  | _ :: _ ->
+     line i ppf "[\n";
+     List.iter (f (i+1) ppf) l;
+     line i ppf "]\n";
+;;
+
+let array i f ppf a =
+  if Array.length a = 0 then
+    line i ppf "[]\n"
+  else begin
+    line i ppf "[\n";
+    Array.iter (f (i+1) ppf) a;
+    line i ppf "]\n"
+  end
+;;
+
+let option i f ppf x =
+  match x with
+  | None -> line i ppf "None\n";
+  | Some x ->
+      line i ppf "Some\n";
+      f (i+1) ppf x;
+;;
+
+let longident i ppf li = line i ppf "%a\n" fmt_longident li;;
+let string i ppf s = line i ppf "\"%s\"\n" s;;
+let arg_label i ppf = function
+  | Nolabel -> line i ppf "Nolabel\n"
+  | Optional s -> line i ppf "Optional \"%s\"\n" s
+  | Labelled s -> line i ppf "Labelled \"%s\"\n" s
+;;
+
+let record_representation i ppf = let open Types in function
+  | Record_regular -> line i ppf "Record_regular\n"
+  | Record_float -> line i ppf "Record_float\n"
+  | Record_unboxed b -> line i ppf "Record_unboxed %b\n" b
+  | Record_inlined i -> line i ppf "Record_inlined %d\n" i
+  | Record_extension p -> line i ppf "Record_extension %a\n" fmt_path p
+
+let attribute i ppf k a =
+  line i ppf "%s \"%s\"\n" k a.Parsetree.attr_name.txt;
+  Printast.payload i ppf a.Parsetree.attr_payload
+
+let attributes i ppf l =
+  let i = i + 1 in
+  List.iter (fun a ->
+    line i ppf "attribute \"%s\"\n" a.Parsetree.attr_name.txt;
+    Printast.payload (i + 1) ppf a.Parsetree.attr_payload
+  ) l
+
+let rec core_type i ppf x =
+  line i ppf "core_type %a\n" fmt_location x.ctyp_loc;
+  attributes i ppf x.ctyp_attributes;
+  let i = i+1 in
+  match x.ctyp_desc with
+  | Ttyp_any -> line i ppf "Ttyp_any\n";
+  | Ttyp_var (s) -> line i ppf "Ttyp_var %s\n" s;
+  | Ttyp_arrow (l, ct1, ct2) ->
+      line i ppf "Ttyp_arrow\n";
+      arg_label i ppf l;
+      core_type i ppf ct1;
+      core_type i ppf ct2;
+  | Ttyp_tuple l ->
+      line i ppf "Ttyp_tuple\n";
+      list i core_type ppf l;
+  | Ttyp_constr (li, _, l) ->
+      line i ppf "Ttyp_constr %a\n" fmt_path li;
+      list i core_type ppf l;
+  | Ttyp_variant (l, closed, low) ->
+      line i ppf "Ttyp_variant closed=%a\n" fmt_closed_flag closed;
+      list i label_x_bool_x_core_type_list ppf l;
+      option i (fun i -> list i string) ppf low
+  | Ttyp_object (l, c) ->
+      line i ppf "Ttyp_object %a\n" fmt_closed_flag c;
+      let i = i + 1 in
+      List.iter (fun {of_desc; of_attributes; _} ->
+        match of_desc with
+        | OTtag (s, t) ->
+            line i ppf "method %s\n" s.txt;
+            attributes i ppf of_attributes;
+            core_type (i + 1) ppf t
+        | OTinherit ct ->
+            line i ppf "OTinherit\n";
+            core_type (i + 1) ppf ct
+        ) l
+  | Ttyp_class (li, _, l) ->
+      line i ppf "Ttyp_class %a\n" fmt_path li;
+      list i core_type ppf l;
+  | Ttyp_alias (ct, s) ->
+      line i ppf "Ttyp_alias \"%s\"\n" s;
+      core_type i ppf ct;
+  | Ttyp_poly (sl, ct) ->
+      line i ppf "Ttyp_poly%a\n"
+        (fun ppf -> List.iter (fun x -> fprintf ppf " '%s" x)) sl;
+      core_type i ppf ct;
+  | Ttyp_package { pack_path = s; pack_fields = l } ->
+      line i ppf "Ttyp_package %a\n" fmt_path s;
+      list i package_with ppf l;
+
+and package_with i ppf (s, t) =
+  line i ppf "with type %a\n" fmt_longident s;
+  core_type i ppf t
+
+and pattern i ppf x =
+  line i ppf "pattern %a\n" fmt_location x.pat_loc;
+  attributes i ppf x.pat_attributes;
+  let i = i+1 in
+  match x.pat_extra with
+    | (Tpat_unpack, _, attrs) :: rem ->
+        line i ppf "Tpat_unpack\n";
+        attributes i ppf attrs;
+        pattern i ppf { x with pat_extra = rem }
+    | (Tpat_constraint cty, _, attrs) :: rem ->
+        line i ppf "Tpat_constraint\n";
+        attributes i ppf attrs;
+        core_type i ppf cty;
+        pattern i ppf { x with pat_extra = rem }
+    | (Tpat_type (id, _), _, attrs) :: rem ->
+        line i ppf "Tpat_type %a\n" fmt_path id;
+        attributes i ppf attrs;
+        pattern i ppf { x with pat_extra = rem }
+    | (Tpat_open (id,_,_), _, attrs)::rem ->
+        line i ppf "Tpat_open \"%a\"\n" fmt_path id;
+        attributes i ppf attrs;
+        pattern i ppf { x with pat_extra = rem }
+    | [] ->
+  match x.pat_desc with
+  | Tpat_any -> line i ppf "Tpat_any\n";
+  | Tpat_var (s,_) -> line i ppf "Tpat_var \"%a\"\n" fmt_ident s;
+  | Tpat_alias (p, s,_) ->
+      line i ppf "Tpat_alias \"%a\"\n" fmt_ident s;
+      pattern i ppf p;
+  | Tpat_constant (c) -> line i ppf "Tpat_constant %a\n" fmt_constant c;
+  | Tpat_tuple (l) ->
+      line i ppf "Tpat_tuple\n";
+      list i pattern ppf l;
+  | Tpat_construct (li, _, po) ->
+      line i ppf "Tpat_construct %a\n" fmt_longident li;
+      list i pattern ppf po;
+  | Tpat_variant (l, po, _) ->
+      line i ppf "Tpat_variant \"%s\"\n" l;
+      option i pattern ppf po;
+  | Tpat_record (l, _c) ->
+      line i ppf "Tpat_record\n";
+      list i longident_x_pattern ppf l;
+  | Tpat_array (l) ->
+      line i ppf "Tpat_array\n";
+      list i pattern ppf l;
+  | Tpat_or (p1, p2, _) ->
+      line i ppf "Tpat_or\n";
+      pattern i ppf p1;
+      pattern i ppf p2;
+  | Tpat_lazy p ->
+      line i ppf "Tpat_lazy\n";
+      pattern i ppf p;
+  | Tpat_exception p ->
+      line i ppf "Tpat_exception\n";
+      pattern i ppf p;
+
+and expression_extra i ppf x attrs =
+  match x with
+  | Texp_constraint ct ->
+      line i ppf "Texp_constraint\n";
+      attributes i ppf attrs;
+      core_type i ppf ct;
+  | Texp_coerce (cto1, cto2) ->
+      line i ppf "Texp_coerce\n";
+      attributes i ppf attrs;
+      option i core_type ppf cto1;
+      core_type i ppf cto2;
+  | Texp_poly cto ->
+      line i ppf "Texp_poly\n";
+      attributes i ppf attrs;
+      option i core_type ppf cto;
+  | Texp_newtype s ->
+      line i ppf "Texp_newtype \"%s\"\n" s;
+      attributes i ppf attrs;
+
+and expression i ppf x =
+  line i ppf "expression %a\n" fmt_location x.exp_loc;
+  attributes i ppf x.exp_attributes;
+  let i =
+    List.fold_left (fun i (extra,_,attrs) ->
+                      expression_extra i ppf extra attrs; i+1)
+      (i+1) x.exp_extra
+  in
+  match x.exp_desc with
+  | Texp_ident (li,_,_) -> line i ppf "Texp_ident %a\n" fmt_path li;
+  | Texp_instvar (_, li,_) -> line i ppf "Texp_instvar %a\n" fmt_path li;
+  | Texp_constant (c) -> line i ppf "Texp_constant %a\n" fmt_constant c;
+  | Texp_let (rf, l, e) ->
+      line i ppf "Texp_let %a\n" fmt_rec_flag rf;
+      list i value_binding ppf l;
+      expression i ppf e;
+  | Texp_function { arg_label = p; param = _; cases; partial = _; } ->
+      line i ppf "Texp_function\n";
+      arg_label i ppf p;
+      list i case ppf cases;
+  | Texp_apply (e, l) ->
+      line i ppf "Texp_apply\n";
+      expression i ppf e;
+      list i label_x_expression ppf l;
+  | Texp_match (e, l, _partial) ->
+      line i ppf "Texp_match\n";
+      expression i ppf e;
+      list i case ppf l;
+  | Texp_try (e, l) ->
+      line i ppf "Texp_try\n";
+      expression i ppf e;
+      list i case ppf l;
+  | Texp_tuple (l) ->
+      line i ppf "Texp_tuple\n";
+      list i expression ppf l;
+  | Texp_construct (li, _, eo) ->
+      line i ppf "Texp_construct %a\n" fmt_longident li;
+      list i expression ppf eo;
+  | Texp_variant (l, eo) ->
+      line i ppf "Texp_variant \"%s\"\n" l;
+      option i expression ppf eo;
+  | Texp_record { fields; representation; extended_expression } ->
+      line i ppf "Texp_record\n";
+      let i = i+1 in
+      line i ppf "fields =\n";
+      array (i+1) record_field ppf fields;
+      line i ppf "representation =\n";
+      record_representation (i+1) ppf representation;
+      line i ppf "extended_expression =\n";
+      option (i+1) expression ppf extended_expression;
+  | Texp_field (e, li, _) ->
+      line i ppf "Texp_field\n";
+      expression i ppf e;
+      longident i ppf li;
+  | Texp_setfield (e1, li, _, e2) ->
+      line i ppf "Texp_setfield\n";
+      expression i ppf e1;
+      longident i ppf li;
+      expression i ppf e2;
+  | Texp_array (l) ->
+      line i ppf "Texp_array\n";
+      list i expression ppf l;
+  | Texp_ifthenelse (e1, e2, eo) ->
+      line i ppf "Texp_ifthenelse\n";
+      expression i ppf e1;
+      expression i ppf e2;
+      option i expression ppf eo;
+  | Texp_sequence (e1, e2) ->
+      line i ppf "Texp_sequence\n";
+      expression i ppf e1;
+      expression i ppf e2;
+  | Texp_while (e1, e2) ->
+      line i ppf "Texp_while\n";
+      expression i ppf e1;
+      expression i ppf e2;
+  | Texp_for (s, _, e1, e2, df, e3) ->
+      line i ppf "Texp_for \"%a\" %a\n" fmt_ident s fmt_direction_flag df;
+      expression i ppf e1;
+      expression i ppf e2;
+      expression i ppf e3;
+  | Texp_send (e, Tmeth_name s, eo) ->
+      line i ppf "Texp_send \"%s\"\n" s;
+      expression i ppf e;
+      option i expression ppf eo
+  | Texp_send (e, Tmeth_val s, eo) ->
+      line i ppf "Texp_send \"%a\"\n" fmt_ident s;
+      expression i ppf e;
+      option i expression ppf eo
+  | Texp_new (li, _, _) -> line i ppf "Texp_new %a\n" fmt_path li;
+  | Texp_setinstvar (_, s, _, e) ->
+      line i ppf "Texp_setinstvar \"%a\"\n" fmt_path s;
+      expression i ppf e;
+  | Texp_override (_, l) ->
+      line i ppf "Texp_override\n";
+      list i string_x_expression ppf l;
+  | Texp_letmodule (s, _, _, me, e) ->
+      line i ppf "Texp_letmodule \"%a\"\n" fmt_modname s;
+      module_expr i ppf me;
+      expression i ppf e;
+  | Texp_letexception (cd, e) ->
+      line i ppf "Texp_letexception\n";
+      extension_constructor i ppf cd;
+      expression i ppf e;
+  | Texp_assert (e) ->
+      line i ppf "Texp_assert";
+      expression i ppf e;
+  | Texp_lazy (e) ->
+      line i ppf "Texp_lazy";
+      expression i ppf e;
+  | Texp_object (s, _) ->
+      line i ppf "Texp_object";
+      class_structure i ppf s
+  | Texp_pack me ->
+      line i ppf "Texp_pack";
+      module_expr i ppf me
+  | Texp_letop {let_; ands; param = _; body; partial = _} ->
+      line i ppf "Texp_letop";
+      binding_op (i+1) ppf let_;
+      list (i+1) binding_op ppf ands;
+      case i ppf body
+  | Texp_unreachable ->
+      line i ppf "Texp_unreachable"
+  | Texp_extension_constructor (li, _) ->
+      line i ppf "Texp_extension_constructor %a" fmt_longident li
+  | Texp_open (o, e) ->
+      line i ppf "Texp_open %a\n"
+        fmt_override_flag o.open_override;
+      module_expr i ppf o.open_expr;
+      attributes i ppf o.open_attributes;
+      expression i ppf e;
+
+and value_description i ppf x =
+  line i ppf "value_description %a %a\n" fmt_ident x.val_id fmt_location
+       x.val_loc;
+  attributes i ppf x.val_attributes;
+  core_type (i+1) ppf x.val_desc;
+  list (i+1) string ppf x.val_prim;
+
+and binding_op i ppf x =
+  line i ppf "binding_op %a %a\n" fmt_path x.bop_op_path
+    fmt_location x.bop_loc;
+  expression i ppf x.bop_exp
+
+and type_parameter i ppf (x, _variance) = core_type i ppf x
+
+and type_declaration i ppf x =
+  line i ppf "type_declaration %a %a\n" fmt_ident x.typ_id fmt_location
+       x.typ_loc;
+  attributes i ppf x.typ_attributes;
+  let i = i+1 in
+  line i ppf "ptype_params =\n";
+  list (i+1) type_parameter ppf x.typ_params;
+  line i ppf "ptype_cstrs =\n";
+  list (i+1) core_type_x_core_type_x_location ppf x.typ_cstrs;
+  line i ppf "ptype_kind =\n";
+  type_kind (i+1) ppf x.typ_kind;
+  line i ppf "ptype_private = %a\n" fmt_private_flag x.typ_private;
+  line i ppf "ptype_manifest =\n";
+  option (i+1) core_type ppf x.typ_manifest;
+
+and type_kind i ppf x =
+  match x with
+  | Ttype_abstract ->
+      line i ppf "Ttype_abstract\n"
+  | Ttype_variant l ->
+      line i ppf "Ttype_variant\n";
+      list (i+1) constructor_decl ppf l;
+  | Ttype_record l ->
+      line i ppf "Ttype_record\n";
+      list (i+1) label_decl ppf l;
+  | Ttype_open ->
+      line i ppf "Ttype_open\n"
+
+and type_extension i ppf x =
+  line i ppf "type_extension\n";
+  attributes i ppf x.tyext_attributes;
+  let i = i+1 in
+  line i ppf "ptyext_path = %a\n" fmt_path x.tyext_path;
+  line i ppf "ptyext_params =\n";
+  list (i+1) type_parameter ppf x.tyext_params;
+  line i ppf "ptyext_constructors =\n";
+  list (i+1) extension_constructor ppf x.tyext_constructors;
+  line i ppf "ptyext_private = %a\n" fmt_private_flag x.tyext_private;
+
+and type_exception i ppf x =
+  line i ppf "type_exception\n";
+  attributes i ppf x.tyexn_attributes;
+  let i = i+1 in
+  line i ppf "ptyext_constructor =\n";
+  let i = i+1 in
+  extension_constructor i ppf x.tyexn_constructor
+
+and extension_constructor i ppf x =
+  line i ppf "extension_constructor %a\n" fmt_location x.ext_loc;
+  attributes i ppf x.ext_attributes;
+  let i = i + 1 in
+  line i ppf "pext_name = \"%a\"\n" fmt_ident x.ext_id;
+  line i ppf "pext_kind =\n";
+  extension_constructor_kind (i + 1) ppf x.ext_kind;
+
+and extension_constructor_kind i ppf x =
+  match x with
+      Text_decl(a, r) ->
+        line i ppf "Text_decl\n";
+        constructor_arguments (i+1) ppf a;
+        option (i+1) core_type ppf r;
+    | Text_rebind(p, _) ->
+        line i ppf "Text_rebind\n";
+        line (i+1) ppf "%a\n" fmt_path p;
+
+and class_type i ppf x =
+  line i ppf "class_type %a\n" fmt_location x.cltyp_loc;
+  attributes i ppf x.cltyp_attributes;
+  let i = i+1 in
+  match x.cltyp_desc with
+  | Tcty_constr (li, _, l) ->
+      line i ppf "Tcty_constr %a\n" fmt_path li;
+      list i core_type ppf l;
+  | Tcty_signature (cs) ->
+      line i ppf "Tcty_signature\n";
+      class_signature i ppf cs;
+  | Tcty_arrow (l, co, cl) ->
+      line i ppf "Tcty_arrow\n";
+      arg_label i ppf l;
+      core_type i ppf co;
+      class_type i ppf cl;
+  | Tcty_open (o, e) ->
+      line i ppf "Tcty_open %a %a\n"
+        fmt_override_flag o.open_override
+        fmt_path (fst o.open_expr);
+      class_type i ppf e
+
+and class_signature i ppf { csig_self = ct; csig_fields = l } =
+  line i ppf "class_signature\n";
+  core_type (i+1) ppf ct;
+  list (i+1) class_type_field ppf l;
+
+and class_type_field i ppf x =
+  line i ppf "class_type_field %a\n" fmt_location x.ctf_loc;
+  let i = i+1 in
+  attributes i ppf x.ctf_attributes;
+  match x.ctf_desc with
+  | Tctf_inherit (ct) ->
+      line i ppf "Tctf_inherit\n";
+      class_type i ppf ct;
+  | Tctf_val (s, mf, vf, ct) ->
+      line i ppf "Tctf_val \"%s\" %a %a\n" s fmt_mutable_flag mf
+           fmt_virtual_flag vf;
+      core_type (i+1) ppf ct;
+  | Tctf_method (s, pf, vf, ct) ->
+      line i ppf "Tctf_method \"%s\" %a %a\n" s fmt_private_flag pf
+           fmt_virtual_flag vf;
+      core_type (i+1) ppf ct;
+  | Tctf_constraint (ct1, ct2) ->
+      line i ppf "Tctf_constraint\n";
+      core_type (i+1) ppf ct1;
+      core_type (i+1) ppf ct2;
+  | Tctf_attribute a ->
+      attribute i ppf "Tctf_attribute" a
+
+and class_description i ppf x =
+  line i ppf "class_description %a\n" fmt_location x.ci_loc;
+  attributes i ppf x.ci_attributes;
+  let i = i+1 in
+  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
+  line i ppf "pci_params =\n";
+  list (i+1) type_parameter ppf x.ci_params;
+  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
+  line i ppf "pci_expr =\n";
+  class_type (i+1) ppf x.ci_expr;
+
+and class_type_declaration i ppf x =
+  line i ppf "class_type_declaration %a\n" fmt_location x.ci_loc;
+  let i = i+1 in
+  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
+  line i ppf "pci_params =\n";
+  list (i+1) type_parameter ppf x.ci_params;
+  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
+  line i ppf "pci_expr =\n";
+  class_type (i+1) ppf x.ci_expr;
+
+and class_expr i ppf x =
+  line i ppf "class_expr %a\n" fmt_location x.cl_loc;
+  attributes i ppf x.cl_attributes;
+  let i = i+1 in
+  match x.cl_desc with
+  | Tcl_ident (li, _, l) ->
+      line i ppf "Tcl_ident %a\n" fmt_path li;
+      list i core_type ppf l;
+  | Tcl_structure (cs) ->
+      line i ppf "Tcl_structure\n";
+      class_structure i ppf cs;
+  | Tcl_fun (l, p, _, ce, _) ->
+      line i ppf "Tcl_fun\n";
+      arg_label i ppf l;
+      pattern i ppf p;
+      class_expr i ppf ce
+  | Tcl_apply (ce, l) ->
+      line i ppf "Tcl_apply\n";
+      class_expr i ppf ce;
+      list i label_x_expression ppf l;
+  | Tcl_let (rf, l1, l2, ce) ->
+      line i ppf "Tcl_let %a\n" fmt_rec_flag rf;
+      list i value_binding ppf l1;
+      list i ident_x_expression_def ppf l2;
+      class_expr i ppf ce;
+  | Tcl_constraint (ce, Some ct, _, _, _) ->
+      line i ppf "Tcl_constraint\n";
+      class_expr i ppf ce;
+      class_type i ppf ct
+  | Tcl_constraint (ce, None, _, _, _) -> class_expr i ppf ce
+  | Tcl_open (o, e) ->
+      line i ppf "Tcl_open %a %a\n"
+        fmt_override_flag o.open_override
+        fmt_path (fst o.open_expr);
+      class_expr i ppf e
+
+and class_structure i ppf { cstr_self = p; cstr_fields = l } =
+  line i ppf "class_structure\n";
+  pattern (i+1) ppf p;
+  list (i+1) class_field ppf l;
+
+and class_field i ppf x =
+  line i ppf "class_field %a\n" fmt_location x.cf_loc;
+  let i = i + 1 in
+  attributes i ppf x.cf_attributes;
+  match x.cf_desc with
+  | Tcf_inherit (ovf, ce, so, _, _) ->
+      line i ppf "Tcf_inherit %a\n" fmt_override_flag ovf;
+      class_expr (i+1) ppf ce;
+      option (i+1) string ppf so;
+  | Tcf_val (s, mf, _, k, _) ->
+      line i ppf "Tcf_val \"%s\" %a\n" s.txt fmt_mutable_flag mf;
+      class_field_kind (i+1) ppf k
+  | Tcf_method (s, pf, k) ->
+      line i ppf "Tcf_method \"%s\" %a\n" s.txt fmt_private_flag pf;
+      class_field_kind (i+1) ppf k
+  | Tcf_constraint (ct1, ct2) ->
+      line i ppf "Tcf_constraint\n";
+      core_type (i+1) ppf ct1;
+      core_type (i+1) ppf ct2;
+  | Tcf_initializer (e) ->
+      line i ppf "Tcf_initializer\n";
+      expression (i+1) ppf e;
+  | Tcf_attribute a ->
+      attribute i ppf "Tcf_attribute" a
+
+and class_field_kind i ppf = function
+  | Tcfk_concrete (o, e) ->
+      line i ppf "Concrete %a\n" fmt_override_flag o;
+      expression i ppf e
+  | Tcfk_virtual t ->
+      line i ppf "Virtual\n";
+      core_type i ppf t
+
+and class_declaration i ppf x =
+  line i ppf "class_declaration %a\n" fmt_location x.ci_loc;
+  let i = i+1 in
+  line i ppf "pci_virt = %a\n" fmt_virtual_flag x.ci_virt;
+  line i ppf "pci_params =\n";
+  list (i+1) type_parameter ppf x.ci_params;
+  line i ppf "pci_name = \"%s\"\n" x.ci_id_name.txt;
+  line i ppf "pci_expr =\n";
+  class_expr (i+1) ppf x.ci_expr;
+
+and module_type i ppf x =
+  line i ppf "module_type %a\n" fmt_location x.mty_loc;
+  attributes i ppf x.mty_attributes;
+  let i = i+1 in
+  match x.mty_desc with
+  | Tmty_ident (li,_) -> line i ppf "Tmty_ident %a\n" fmt_path li;
+  | Tmty_alias (li,_) -> line i ppf "Tmty_alias %a\n" fmt_path li;
+  | Tmty_signature (s) ->
+      line i ppf "Tmty_signature\n";
+      signature i ppf s;
+  | Tmty_functor (Unit, mt2) ->
+      line i ppf "Tmty_functor ()\n";
+      module_type i ppf mt2;
+  | Tmty_functor (Named (s, _, mt1), mt2) ->
+      line i ppf "Tmty_functor \"%a\"\n" fmt_modname s;
+      module_type i ppf mt1;
+      module_type i ppf mt2;
+  | Tmty_with (mt, l) ->
+      line i ppf "Tmty_with\n";
+      module_type i ppf mt;
+      list i longident_x_with_constraint ppf l;
+  | Tmty_typeof m ->
+      line i ppf "Tmty_typeof\n";
+      module_expr i ppf m;
+
+and signature i ppf x = list i signature_item ppf x.sig_items
+
+and signature_item i ppf x =
+  line i ppf "signature_item %a\n" fmt_location x.sig_loc;
+  let i = i+1 in
+  match x.sig_desc with
+  | Tsig_value vd ->
+      line i ppf "Tsig_value\n";
+      value_description i ppf vd;
+  | Tsig_type (rf, l) ->
+      line i ppf "Tsig_type %a\n" fmt_rec_flag rf;
+      list i type_declaration ppf l;
+  | Tsig_typesubst l ->
+      line i ppf "Tsig_typesubst\n";
+      list i type_declaration ppf l;
+  | Tsig_typext e ->
+      line i ppf "Tsig_typext\n";
+      type_extension i ppf e;
+  | Tsig_exception ext ->
+      line i ppf "Tsig_exception\n";
+      type_exception i ppf ext
+  | Tsig_module md ->
+      line i ppf "Tsig_module \"%a\"\n" fmt_modname md.md_id;
+      attributes i ppf md.md_attributes;
+      module_type i ppf md.md_type
+  | Tsig_modsubst ms ->
+      line i ppf "Tsig_modsubst \"%a\" = %a\n"
+        fmt_ident ms.ms_id fmt_path ms.ms_manifest;
+      attributes i ppf ms.ms_attributes;
+  | Tsig_recmodule decls ->
+      line i ppf "Tsig_recmodule\n";
+      list i module_declaration ppf decls;
+  | Tsig_modtype x ->
+      line i ppf "Tsig_modtype \"%a\"\n" fmt_ident x.mtd_id;
+      attributes i ppf x.mtd_attributes;
+      modtype_declaration i ppf x.mtd_type
+  | Tsig_open od ->
+      line i ppf "Tsig_open %a %a\n"
+        fmt_override_flag od.open_override
+        fmt_path (fst od.open_expr);
+      attributes i ppf od.open_attributes
+  | Tsig_include incl ->
+      line i ppf "Tsig_include\n";
+      attributes i ppf incl.incl_attributes;
+      module_type i ppf incl.incl_mod
+  | Tsig_class (l) ->
+      line i ppf "Tsig_class\n";
+      list i class_description ppf l;
+  | Tsig_class_type (l) ->
+      line i ppf "Tsig_class_type\n";
+      list i class_type_declaration ppf l;
+  | Tsig_attribute a ->
+      attribute i ppf "Tsig_attribute" a
+
+and module_declaration i ppf md =
+  line i ppf "%a" fmt_modname md.md_id;
+  attributes i ppf md.md_attributes;
+  module_type (i+1) ppf md.md_type;
+
+and module_binding i ppf x =
+  line i ppf "%a\n" fmt_modname x.mb_id;
+  attributes i ppf x.mb_attributes;
+  module_expr (i+1) ppf x.mb_expr
+
+and modtype_declaration i ppf = function
+  | None -> line i ppf "#abstract"
+  | Some mt -> module_type (i + 1) ppf mt
+
+and with_constraint i ppf x =
+  match x with
+  | Twith_type (td) ->
+      line i ppf "Twith_type\n";
+      type_declaration (i+1) ppf td;
+  | Twith_typesubst (td) ->
+      line i ppf "Twith_typesubst\n";
+      type_declaration (i+1) ppf td;
+  | Twith_module (li,_) -> line i ppf "Twith_module %a\n" fmt_path li;
+  | Twith_modsubst (li,_) -> line i ppf "Twith_modsubst %a\n" fmt_path li;
+
+and module_expr i ppf x =
+  line i ppf "module_expr %a\n" fmt_location x.mod_loc;
+  attributes i ppf x.mod_attributes;
+  let i = i+1 in
+  match x.mod_desc with
+  | Tmod_ident (li,_) -> line i ppf "Tmod_ident %a\n" fmt_path li;
+  | Tmod_structure (s) ->
+      line i ppf "Tmod_structure\n";
+      structure i ppf s;
+  | Tmod_functor (Unit, me) ->
+      line i ppf "Tmod_functor ()\n";
+      module_expr i ppf me;
+  | Tmod_functor (Named (s, _, mt), me) ->
+      line i ppf "Tmod_functor \"%a\"\n" fmt_modname s;
+      module_type i ppf mt;
+      module_expr i ppf me;
+  | Tmod_apply (me1, me2, _) ->
+      line i ppf "Tmod_apply\n";
+      module_expr i ppf me1;
+      module_expr i ppf me2;
+  | Tmod_constraint (me, _, Tmodtype_explicit mt, _) ->
+      line i ppf "Tmod_constraint\n";
+      module_expr i ppf me;
+      module_type i ppf mt;
+  | Tmod_constraint (me, _, Tmodtype_implicit, _) -> module_expr i ppf me
+  | Tmod_unpack (e, _) ->
+      line i ppf "Tmod_unpack\n";
+      expression i ppf e;
+
+and structure i ppf x = list i structure_item ppf x.str_items
+
+and structure_item i ppf x =
+  line i ppf "structure_item %a\n" fmt_location x.str_loc;
+  let i = i+1 in
+  match x.str_desc with
+  | Tstr_eval (e, attrs) ->
+      line i ppf "Tstr_eval\n";
+      attributes i ppf attrs;
+      expression i ppf e;
+  | Tstr_value (rf, l) ->
+      line i ppf "Tstr_value %a\n" fmt_rec_flag rf;
+      list i value_binding ppf l;
+  | Tstr_primitive vd ->
+      line i ppf "Tstr_primitive\n";
+      value_description i ppf vd;
+  | Tstr_type (rf, l) ->
+      line i ppf "Tstr_type %a\n" fmt_rec_flag rf;
+      list i type_declaration ppf l;
+  | Tstr_typext te ->
+      line i ppf "Tstr_typext\n";
+      type_extension i ppf te
+  | Tstr_exception ext ->
+      line i ppf "Tstr_exception\n";
+      type_exception i ppf ext;
+  | Tstr_module x ->
+      line i ppf "Tstr_module\n";
+      module_binding i ppf x
+  | Tstr_recmodule bindings ->
+      line i ppf "Tstr_recmodule\n";
+      list i module_binding ppf bindings
+  | Tstr_modtype x ->
+      line i ppf "Tstr_modtype \"%a\"\n" fmt_ident x.mtd_id;
+      attributes i ppf x.mtd_attributes;
+      modtype_declaration i ppf x.mtd_type
+  | Tstr_open od ->
+      line i ppf "Tstr_open %a\n"
+        fmt_override_flag od.open_override;
+      module_expr i ppf od.open_expr;
+      attributes i ppf od.open_attributes
+  | Tstr_class (l) ->
+      line i ppf "Tstr_class\n";
+      list i class_declaration ppf (List.map (fun (cl, _) -> cl) l);
+  | Tstr_class_type (l) ->
+      line i ppf "Tstr_class_type\n";
+      list i class_type_declaration ppf (List.map (fun (_, _, cl) -> cl) l);
+  | Tstr_include incl ->
+      line i ppf "Tstr_include";
+      attributes i ppf incl.incl_attributes;
+      module_expr i ppf incl.incl_mod;
+  | Tstr_attribute a ->
+      attribute i ppf "Tstr_attribute" a
+
+and longident_x_with_constraint i ppf (li, _, wc) =
+  line i ppf "%a\n" fmt_path li;
+  with_constraint (i+1) ppf wc;
+
+and core_type_x_core_type_x_location i ppf (ct1, ct2, l) =
+  line i ppf "<constraint> %a\n" fmt_location l;
+  core_type (i+1) ppf ct1;
+  core_type (i+1) ppf ct2;
+
+and constructor_decl i ppf {cd_id; cd_name = _; cd_args; cd_res; cd_loc;
+                            cd_attributes} =
+  line i ppf "%a\n" fmt_location cd_loc;
+  line (i+1) ppf "%a\n" fmt_ident cd_id;
+  attributes i ppf cd_attributes;
+  constructor_arguments (i+1) ppf cd_args;
+  option (i+1) core_type ppf cd_res
+
+and constructor_arguments i ppf = function
+  | Cstr_tuple l -> list i core_type ppf l
+  | Cstr_record l -> list i label_decl ppf l
+
+and label_decl i ppf {ld_id; ld_name = _; ld_mutable; ld_type; ld_loc;
+                      ld_attributes} =
+  line i ppf "%a\n" fmt_location ld_loc;
+  attributes i ppf ld_attributes;
+  line (i+1) ppf "%a\n" fmt_mutable_flag ld_mutable;
+  line (i+1) ppf "%a" fmt_ident ld_id;
+  core_type (i+1) ppf ld_type
+
+and longident_x_pattern i ppf (li, _, p) =
+  line i ppf "%a\n" fmt_longident li;
+  pattern (i+1) ppf p;
+
+and case i ppf {c_lhs; c_guard; c_rhs} =
+  line i ppf "<case>\n";
+  pattern (i+1) ppf c_lhs;
+  begin match c_guard with
+  | None -> ()
+  | Some g -> line (i+1) ppf "<when>\n"; expression (i + 2) ppf g
+  end;
+  expression (i+1) ppf c_rhs;
+
+and value_binding i ppf x =
+  line i ppf "<def>\n";
+  attributes (i+1) ppf x.vb_attributes;
+  pattern (i+1) ppf x.vb_pat;
+  expression (i+1) ppf x.vb_expr
+
+and string_x_expression i ppf (s, _, e) =
+  line i ppf "<override> \"%a\"\n" fmt_path s;
+  expression (i+1) ppf e;
+
+and record_field i ppf = function
+  | _, Overridden (li, e) ->
+      line i ppf "%a\n" fmt_longident li;
+      expression (i+1) ppf e;
+  | _, Kept _ ->
+      line i ppf "<kept>"
+
+and label_x_expression i ppf (l, e) =
+  line i ppf "<arg>\n";
+  arg_label (i+1) ppf l;
+  (match e with None -> () | Some e -> expression (i+1) ppf e)
+
+and ident_x_expression_def i ppf (l, e) =
+  line i ppf "<def> \"%a\"\n" fmt_ident l;
+  expression (i+1) ppf e;
+
+and label_x_bool_x_core_type_list i ppf x =
+  match x.rf_desc with
+  | Ttag (l, b, ctl) ->
+      line i ppf "Ttag \"%s\" %s\n" l.txt (string_of_bool b);
+      attributes (i+1) ppf x.rf_attributes;
+      list (i+1) core_type ppf ctl
+  | Tinherit (ct) ->
+      line i ppf "Tinherit\n";
+      core_type (i+1) ppf ct
+;;
+
+let interface ppf x = list 0 signature_item ppf x.sig_items;;
+
+let implementation ppf x = list 0 structure_item ppf x.str_items;;
+
+let implementation_with_coercion ppf (x, _) = implementation ppf x
diff --git a/src/ocaml/typing/410+multicore/printtyped.mli b/src/ocaml/typing/410+multicore/printtyped.mli
new file mode 100644
index 00000000..ac60af74
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/printtyped.mli
@@ -0,0 +1,26 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*              Damien Doligez, projet Para, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1999 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Typedtree;;
+open Format;;
+
+val interface : formatter -> signature -> unit;;
+val implementation : formatter -> structure -> unit;;
+
+val implementation_with_coercion :
+    formatter -> (structure * module_coercion) -> unit;;
+
+(* Added by merlin for debugging purposes *)
+val pattern : int -> formatter -> pattern -> unit
diff --git a/src/ocaml/typing/410+multicore/rec_check.ml b/src/ocaml/typing/410+multicore/rec_check.ml
new file mode 100644
index 00000000..1a9bb911
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/rec_check.ml
@@ -0,0 +1,1263 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*               Jeremy Yallop, University of Cambridge                   *)
+(*               Gabriel Scherer, Project Parsifal, INRIA Saclay          *)
+(*               Alban Reynaud, ENS Lyon                                  *)
+(*                                                                        *)
+(*   Copyright 2017 Jeremy Yallop                                         *)
+(*   Copyright 2018 Alban Reynaud                                         *)
+(*   Copyright 2018 INRIA                                                 *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Static checking of recursive declarations
+
+Some recursive definitions are meaningful
+{[
+  let rec factorial = function 0 -> 1 | n -> n * factorial (n - 1)
+  let rec infinite_list = 0 :: infinite_list
+]}
+but some other are meaningless
+{[
+  let rec x = x
+  let rec x = x+1
+|}
+
+Intuitively, a recursive definition makes sense when the body of the
+definition can be evaluated without fully knowing what the recursive
+name is yet.
+
+In the [factorial] example, the name [factorial] refers to a function,
+evaluating the function definition [function ...] can be done
+immediately and will not force a recursive call to [factorial] -- this
+will only happen later, when [factorial] is called with an argument.
+
+In the [infinite_list] example, we can evaluate [0 :: infinite_list]
+without knowing the full content of [infinite_list], but with just its
+address. This is a case of productive/guarded recursion.
+
+On the contrary, [let rec x = x] is unguarded recursion (the meaning
+is undetermined), and [let rec x = x+1] would need the value of [x]
+while evaluating its definition [x+1].
+
+This file implements a static check to decide which definitions are
+known to be meaningful, and which may be meaningless. In the general
+case, we handle a set of mutually-recursive definitions
+{[
+let rec x1 = e1
+and x2 = e2
+...
+and xn = en
+]}
+
+
+Our check (see function [is_valid_recursive_expression] is defined
+using two criteria:
+
+Usage of recursive variables: how does each of the [e1 .. en] use the
+ recursive variables [x1 .. xn]?
+
+Static or dynamic size: for which of the [ei] can we compute the
+  in-memory size of the value without evaluating [ei] (so that we can
+  pre-allocate it, and thus know its final address before evaluation).
+
+The "static or dynamic size" is decided by the classify_* functions below.
+
+The "variable usage" question is decided by a static analysis looking
+very much like a type system. The idea is to assign "access modes" to
+variables, where an "access mode" [m] is defined as either
+
+    m ::= Ignore (* the value is not used at all *)
+        | Delay (* the value is not needed at definition time *)
+        | Guard (* the value is stored under a data constructor *)
+        | Return (* the value result is directly returned *)
+        | Dereference (* full access and inspection of the value *)
+
+The access modes of an expression [e] are represented by a "context"
+[G], which is simply a mapping from variables (the variables used in
+[e]) to access modes.
+
+The core notion of the static check is a type-system-like judgment of
+the form [G |- e : m], which can be interpreted as meaning either of:
+
+- If we are allowed to use the variables of [e] at the modes in [G]
+  (but not more), then it is safe to use [e] at the mode [m].
+
+- If we want to use [e] at the mode [m], then its variables are
+  used at the modes in [G].
+
+In practice, for a given expression [e], our implementation takes the
+desired mode of use [m] as *input*, and returns a context [G] as
+*output*, which is (uniquely determined as) the most permissive choice
+of modes [G] for the variables of [e] such that [G |- e : m] holds.
+*)
+
+open Asttypes
+open Typedtree
+open Types
+
+exception Illegal_expr
+
+(** {1 Static or dynamic size} *)
+
+type sd = Static | Dynamic
+
+let is_ref : Types.value_description -> bool = function
+  | { Types.val_kind =
+        Types.Val_prim { Primitive.prim_name = "%makemutable";
+                          prim_arity = 1 } } ->
+        true
+  | _ -> false
+
+(* See the note on abstracted arguments in the documentation for
+    Typedtree.Texp_apply *)
+let is_abstracted_arg : arg_label * expression option -> bool = function
+  | (_, None) -> true
+  | (_, Some _) -> false
+
+let classify_expression : Typedtree.expression -> sd =
+  (* We need to keep track of the size of expressions
+      bound by local declarations, to be able to predict
+      the size of variables. Compare:
+
+        let rec r =
+          let y = fun () -> r ()
+          in y
+
+      and
+
+        let rec r =
+          let y = if Random.bool () then ignore else fun () -> r ()
+          in y
+
+    In both cases the final address of `r` must be known before `y` is compiled,
+    and this is only possible if `r` has a statically-known size.
+
+    The first definition can be allowed (`y` has a statically-known
+    size) but the second one is unsound (`y` has no statically-known size).
+  *)
+  let rec classify_expression env e = match e.exp_desc with
+    (* binding and variable cases *)
+    | Texp_let (rec_flag, vb, e) ->
+        let env = classify_value_bindings rec_flag env vb in
+        classify_expression env e
+    | Texp_ident (path, _, _) ->
+        classify_path env path
+
+    (* non-binding cases *)
+    | Texp_open (_, e)
+    | Texp_letmodule (_, _, _, _, e)
+    | Texp_sequence (_, e)
+    | Texp_letexception (_, e) ->
+        classify_expression env e
+
+    | Texp_construct (_, {cstr_tag = Cstr_unboxed}, [e]) ->
+        classify_expression env e
+    | Texp_construct _ ->
+        Static
+
+    | Texp_record { representation = Record_unboxed _;
+                    fields = [| _, Overridden (_,e) |] } ->
+        classify_expression env e
+    | Texp_record _ ->
+        Static
+
+    | Texp_apply ({exp_desc = Texp_ident (_, _, vd)}, _)
+      when is_ref vd ->
+        Static
+    | Texp_apply (_,args)
+      when List.exists is_abstracted_arg args ->
+        Static
+    | Texp_apply _ ->
+        Dynamic
+
+    | Texp_for _
+    | Texp_constant _
+    | Texp_new _
+    | Texp_instvar _
+    | Texp_tuple _
+    | Texp_array _
+    | Texp_variant _
+    | Texp_setfield _
+    | Texp_while _
+    | Texp_setinstvar _
+    | Texp_pack _
+    | Texp_object _
+    | Texp_function _
+    | Texp_lazy _
+    | Texp_unreachable
+    | Texp_extension_constructor _ ->
+        Static
+
+    | Texp_match _
+    | Texp_ifthenelse _
+    | Texp_send _
+    | Texp_field _
+    | Texp_assert _
+    | Texp_try _
+    | Texp_override _
+    | Texp_letop _ ->
+        Dynamic
+  and classify_value_bindings rec_flag env bindings =
+    (* We use a non-recursive classification, classifying each
+        binding with respect to the old environment
+        (before all definitions), even if the bindings are recursive.
+
+        Note: computing a fixpoint in some way would be more
+        precise, as the following could be allowed:
+
+          let rec topdef =
+            let rec x = y and y = fun () -> topdef ()
+            in x
+    *)
+    ignore rec_flag;
+    let old_env = env in
+    let add_value_binding env vb =
+      match vb.vb_pat.pat_desc with
+      | Tpat_var (id, _loc) ->
+          let size = classify_expression old_env vb.vb_expr in
+          Ident.add id size env
+      | _ ->
+          (* Note: we don't try to compute any size for complex patterns *)
+          env
+    in
+    List.fold_left add_value_binding env bindings
+  and classify_path env = function
+    | Path.Pident x ->
+        begin
+          try Ident.find_same x env
+          with Not_found ->
+            (* an identifier will be missing from the map if either:
+                - it is a non-local identifier
+                  (bound outside the letrec-binding we are analyzing)
+                - or it is bound by a complex (let p = e in ...) local binding
+                - or it is bound within a module (let module M = ... in ...)
+                  that we are not traversing for size computation
+
+                For non-local identifiers it might be reasonable (although
+                not completely clear) to consider them Static (they have
+                already been evaluated), but for the others we must
+                under-approximate with Dynamic.
+
+                This could be fixed by a more complete implementation.
+            *)
+            Dynamic
+        end
+    | Path.Pdot _ | Path.Papply _ ->
+        (* local modules could have such paths to local definitions;
+            classify_expression could be extend to compute module
+            shapes more precisely *)
+        Dynamic
+  in classify_expression Ident.empty
+
+
+(** {1 Usage of recursive variables} *)
+
+module Mode = struct
+  (** For an expression in a program, its "usage mode" represents
+      static information about how the value produced by the expression
+      will be used by the context around it. *)
+  type t =
+    | Ignore
+    (** [Ignore] is for subexpressions that are not used at all during
+       the evaluation of the whole program. This is the mode of
+       a variable in an expression in which it does not occur. *)
+
+    | Delay
+    (** A [Delay] context can be fully evaluated without evaluating its argument
+        , which will only be needed at a later point of program execution. For
+        example, [fun x -> ?] or [lazy ?] are [Delay] contexts. *)
+
+    | Guard
+    (** A [Guard] context returns the value as a member of a data structure,
+        for example a variant constructor or record. The value can safely be
+        defined mutually-recursively with their context, for example in
+        [let rec li = 1 :: li].
+        When these subexpressions participate in a cyclic definition,
+        this definition is productive/guarded.
+
+        The [Guard] mode is also used when a value is not dereferenced,
+        it is returned by a sub-expression, but the result of this
+        sub-expression is discarded instead of being returned.
+        For example, the subterm [?] is in a [Guard] context
+        in [let _ = ? in e] and in [?; e].
+        When these subexpressions participate in a cyclic definition,
+        they cannot create a self-loop.
+    *)
+
+    | Return
+    (** A [Return] context returns its value without further inspection.
+        This value cannot be defined mutually-recursively with its context,
+        as there is a risk of self-loop: in [let rec x = y and y = x], the
+        two definitions use a single variable in [Return] context. *)
+
+    | Dereference
+    (** A [Dereference] context consumes, inspects and uses the value
+        in arbitrary ways. Such a value must be fully defined at the point
+        of usage, it cannot be defined mutually-recursively with its context. *)
+
+  let equal = ((=) : t -> t -> bool)
+
+  (* Lower-ranked modes demand/use less of the variable/expression they qualify
+     -- so they allow more recursive definitions.
+
+     Ignore < Delay < Guard < Return < Dereference
+  *)
+  let rank = function
+    | Ignore -> 0
+    | Delay -> 1
+    | Guard -> 2
+    | Return -> 3
+    | Dereference -> 4
+
+  (* Returns the more conservative (highest-ranking) mode of the two
+     arguments.
+
+     In judgments we write (m + m') for (join m m').
+  *)
+  let join m m' =
+    if rank m >= rank m' then m else m'
+
+  (* If x is used with the mode m in e[x], and e[x] is used with mode
+     m' in e'[e[x]], then x is used with mode m'[m] (our notation for
+     "compose m' m") in e'[e[x]].
+
+     Return is neutral for composition: m[Return] = m = Return[m].
+
+     Composition is associative and [Ignore] is a zero/annihilator for
+     it: (compose Ignore m) and (compose m Ignore) are both Ignore. *)
+  let compose m' m = match m', m with
+    | Ignore, _ | _, Ignore -> Ignore
+    | Dereference, _ -> Dereference
+    | Delay, _ -> Delay
+    | Guard, Return -> Guard
+    | Guard, ((Dereference | Guard | Delay) as m) -> m
+    | Return, Return -> Return
+    | Return, ((Dereference | Guard | Delay) as m) -> m
+end
+
+type mode = Mode.t = Ignore | Delay | Guard | Return | Dereference
+
+module Env :
+sig
+  type t
+
+  val single : Ident.t -> Mode.t -> t
+  (** Create an environment with a single identifier used with a given mode.
+  *)
+
+  val empty : t
+  (** An environment with no used identifiers. *)
+
+  val find : Ident.t -> t -> Mode.t
+  (** Find the mode of an identifier in an environment.  The default mode is
+      Ignore. *)
+
+  val unguarded : t -> Ident.t list -> Ident.t list
+  (** unguarded e l: the list of all identifiers in l that are dereferenced or
+      returned in the environment e. *)
+
+  val dependent : t -> Ident.t list -> Ident.t list
+  (** dependent e l: the list of all identifiers in l that are used in e
+      (not ignored). *)
+
+  val join : t -> t -> t
+  val join_list : t list -> t
+  (** Environments can be joined pointwise (variable per variable) *)
+
+  val compose : Mode.t -> t -> t
+  (** Environment composition m[G] extends mode composition m1[m2]
+      by composing each mode in G pointwise *)
+
+  val remove : Ident.t -> t -> t
+  (** Remove an identifier from an environment. *)
+
+  val take: Ident.t -> t -> Mode.t * t
+  (** Remove an identifier from an environment, and return its mode *)
+
+  val remove_list : Ident.t list -> t -> t
+  (** Remove all the identifiers of a list from an environment. *)
+
+  val equal : t -> t -> bool
+end = struct
+  module M = Map.Make(Ident)
+
+  (** A "t" maps each rec-bound variable to an access status *)
+  type t = Mode.t M.t
+
+  let equal = M.equal Mode.equal
+
+  let find (id: Ident.t) (tbl: t) =
+    try M.find id tbl with Not_found -> Ignore
+
+  let empty = M.empty
+
+  let join (x: t) (y: t) =
+    M.fold
+      (fun (id: Ident.t) (v: Mode.t) (tbl: t) ->
+         let v' = find id tbl in
+         M.add id (Mode.join v v') tbl)
+      x y
+
+  let join_list li = List.fold_left join empty li
+
+  let compose m env =
+    M.map (Mode.compose m) env
+
+  let single id mode = M.add id mode empty
+
+  let unguarded env li =
+    List.filter (fun id -> Mode.rank (find id env) > Mode.rank Guard) li
+
+  let dependent env li =
+    List.filter (fun id -> Mode.rank (find id env) > Mode.rank Ignore) li
+
+  let remove = M.remove
+
+  let take id env = (find id env, remove id env)
+
+  let remove_list l env =
+    List.fold_left (fun env id -> M.remove id env) env l
+end
+
+let remove_pat pat env =
+  Env.remove_list (pat_bound_idents pat) env
+
+let remove_patlist pats env =
+  List.fold_right remove_pat pats env
+
+(* Usage mode judgments.
+
+   There are two main groups of judgment functions:
+
+   - Judgments of the form "G |- ... : m"
+     compute the environment G of a subterm ... from its mode m, so
+     the corresponding function has type [... -> Mode.t -> Env.t].
+
+     We write [... -> term_judg] in this case.
+
+   - Judgments of the form "G |- ... : m -| G'"
+
+     correspond to binding constructs (for example "let x = e" in the
+     term "let x = e in body") that have both an exterior environment
+     G (the environment of the whole term "let x = e in body") and an
+     interior environment G' (the environment at the "in", after the
+     binding construct has introduced new names in scope).
+
+     For example, let-binding could be given the following rule:
+
+       G |- e : m + m'
+       -----------------------------------
+       G+G' |- (let x = e) : m -| x:m', G'
+
+     Checking the whole term composes this judgment
+     with the "G |- e : m" form for the let body:
+
+       G  |- (let x = e) : m -| G'
+       G' |- body : m
+       -------------------------------
+       G |- let x = e in body : m
+
+     To this judgment "G |- e : m -| G'" our implementation gives the
+     type [... -> Mode.t -> Env.t -> Env.t]: it takes the mode and
+     interior environment as inputs, and returns the exterior
+     environment.
+
+     We write [... -> bind_judg] in this case.
+*)
+type term_judg = Mode.t -> Env.t
+type bind_judg = Mode.t -> Env.t -> Env.t
+
+let option : 'a. ('a -> term_judg) -> 'a option -> term_judg =
+  fun f o m -> match o with
+    | None -> Env.empty
+    | Some v -> f v m
+let list : 'a. ('a -> term_judg) -> 'a list -> term_judg =
+  fun f li m ->
+    List.fold_left (fun env item -> Env.join env (f item m)) Env.empty li
+let array : 'a. ('a -> term_judg) -> 'a array -> term_judg =
+  fun f ar m ->
+    Array.fold_left (fun env item -> Env.join env (f item m)) Env.empty ar
+
+let single : Ident.t -> term_judg = Env.single
+let remove_id : Ident.t -> term_judg -> term_judg =
+  fun id f m -> Env.remove id (f m)
+let remove_ids : Ident.t list -> term_judg -> term_judg =
+  fun ids f m -> Env.remove_list ids (f m)
+
+let join : term_judg list -> term_judg =
+  fun li m -> Env.join_list (List.map (fun f -> f m) li)
+
+let empty = fun _ -> Env.empty
+
+(* A judgment [judg] takes a mode from the context as input, and
+   returns an environment. The judgment [judg << m], given a mode [m']
+   from the context, evaluates [judg] in the composed mode [m'[m]]. *)
+let (<<) : term_judg -> Mode.t -> term_judg =
+  fun f inner_mode -> fun outer_mode -> f (Mode.compose outer_mode inner_mode)
+
+(* A binding judgment [binder] expects a mode and an inner environment,
+   and returns an outer environment. [binder >> judg] computes
+   the inner environment as the environment returned by [judg]
+   in the ambient mode. *)
+let (>>) : bind_judg -> term_judg -> term_judg =
+  fun binder term mode -> binder mode (term mode)
+
+(* Expression judgment:
+     G |- e : m
+   where (m) is an input of the code and (G) is an output;
+   in the Prolog mode notation, this is (+G |- -e : -m).
+*)
+let rec expression : Typedtree.expression -> term_judg =
+  fun exp -> match exp.exp_desc with
+    | Texp_ident (pth, _, _) ->
+      path pth
+    | Texp_let (rec_flag, bindings, body) ->
+      (*
+         G  |- <bindings> : m -| G'
+         G' |- body : m
+         -------------------------------
+         G |- let <bindings> in body : m
+      *)
+      value_bindings rec_flag bindings >> expression body
+    | Texp_letmodule (x, _, _, mexp, e) ->
+      module_binding (x, mexp) >> expression e
+    | Texp_match (e, cases, _) ->
+      (*
+         (Gi; mi |- pi -> ei : m)^i
+         G |- e : sum(mi)^i
+         ----------------------------------------------
+         G + sum(Gi)^i |- match e with (pi -> ei)^i : m
+       *)
+      (fun mode ->
+        let pat_envs, pat_modes =
+          List.split (List.map (fun c -> case c mode) cases) in
+        let env_e = expression e (List.fold_left Mode.join Ignore pat_modes) in
+        Env.join_list (env_e :: pat_envs))
+    | Texp_for (_, _, low, high, _, body) ->
+      (*
+        G1 |- low: m[Dereference]
+        G2 |- high: m[Dereference]
+        G3 |- body: m[Guard]
+        ---
+        G1 + G2 + G3 |- for _ = low to high do body done: m
+      *)
+      join [
+        expression low << Dereference;
+        expression high << Dereference;
+        expression body << Guard;
+      ]
+    | Texp_constant _ ->
+      empty
+    | Texp_new (pth, _, _) ->
+      (*
+        G |- c: m[Dereference]
+        -----------------------
+        G |- new c: m
+      *)
+      path pth << Dereference
+    | Texp_instvar (self_path, pth, _inst_var) ->
+        join [path self_path << Dereference; path pth]
+    | Texp_apply ({exp_desc = Texp_ident (_, _, vd)}, [_, Some arg])
+      when is_ref vd ->
+      (*
+        G |- e: m[Guard]
+        ------------------
+        G |- ref e: m
+      *)
+      expression arg << Guard
+    | Texp_apply (e, args)  ->
+        let arg (_, eo) = option expression eo in
+        let app_mode = if List.exists is_abstracted_arg args
+          then (* see the comment on Texp_apply in typedtree.mli;
+                  the non-abstracted arguments are bound to local
+                  variables, which corresponds to a Guard mode. *)
+            Guard
+          else Dereference
+        in
+        join [expression e; list arg args] << app_mode
+    | Texp_tuple exprs ->
+      list expression exprs << Guard
+    | Texp_array exprs ->
+      (*
+      let array_mode = match Typeopt.array_kind exp with
+        | Lambda.Pfloatarray ->
+            (* (flat) float arrays unbox their elements *)
+            Dereference
+        | Lambda.Pgenarray ->
+            (* This is counted as a use, because constructing a generic array
+               involves inspecting to decide whether to unbox (PR#6939). *)
+            Dereference
+        | Lambda.Paddrarray | Lambda.Pintarray ->
+            (* non-generic, non-float arrays act as constructors *)
+            Guard
+      in
+      *)
+      let array_mode =
+        (* FIXME MERLIN this is incorrect, but it won't report false positive, so it
+           will do for now. *)
+        Guard
+      in
+      list expression exprs << array_mode
+    | Texp_construct (_, desc, exprs) ->
+      let access_constructor =
+        match desc.cstr_tag with
+        | Cstr_extension (pth, _) ->
+          path pth << Dereference
+        | _ -> empty
+      in
+      let m' = match desc.cstr_tag with
+        | Cstr_unboxed ->
+          Return
+        | Cstr_constant _ | Cstr_block _ | Cstr_extension _ ->
+          Guard
+      in
+      join [
+        access_constructor;
+        list expression exprs << m'
+      ]
+    | Texp_variant (_, eo) ->
+      (*
+        G |- e: m[Guard]
+        ------------------   -----------
+        G |- `A e: m         [] |- `A: m
+      *)
+      option expression eo << Guard
+    | Texp_record { fields = es; extended_expression = eo;
+                    representation = rep } ->
+        let field_mode = match rep with
+          | Record_float -> Dereference
+          | Record_unboxed _ -> Return
+          | Record_regular | Record_inlined _
+          | Record_extension _ -> Guard
+        in
+        let field (_label, field_def) = match field_def with
+            Kept _ -> empty
+          | Overridden (_, e) -> expression e
+        in
+        join [
+          array field es << field_mode;
+          option expression eo << Dereference
+        ]
+    | Texp_ifthenelse (cond, ifso, ifnot) ->
+      (*
+        Gc |- c: m[Dereference]
+        G1 |- e1: m
+        G2 |- e2: m
+        ---
+        Gc + G1 + G2 |- if c then e1 else e2: m
+
+      Note: `if c then e1 else e2` is treated in the same way as
+      `match c with true -> e1 | false -> e2`
+      *)
+      join [
+        expression cond << Dereference;
+        expression ifso;
+        option expression ifnot;
+      ]
+    | Texp_setfield (e1, _, _, e2) ->
+      (*
+        G1 |- e1: m[Dereference]
+        G2 |- e2: m[Dereference]
+        ---
+        G1 + G2 |- e1.x <- e2: m
+
+        Note: e2 is dereferenced in the case of a field assignment to
+        a record of unboxed floats in that case, e2 evaluates to
+        a boxed float and it is unboxed on assignment.
+      *)
+      join [
+        expression e1 << Dereference;
+        expression e2 << Dereference;
+      ]
+    | Texp_sequence (e1, e2) ->
+      (*
+        G1 |- e1: m[Guard]
+        G2 |- e2: m
+        --------------------
+        G1 + G2 |- e1; e2: m
+
+        Note: `e1; e2` is treated in the same way as `let _ = e1 in e2`
+      *)
+      join [
+        expression e1 << Guard;
+        expression e2;
+      ]
+    | Texp_while (cond, body) ->
+      (*
+        G1 |- cond: m[Dereference]
+        G2 |- body: m[Guard]
+        ---------------------------------
+        G1 + G2 |- while cond do body done: m
+      *)
+      join [
+        expression cond << Dereference;
+        expression body << Guard;
+      ]
+    | Texp_send (e1, _, eo) ->
+      (*
+        G |- e: m[Dereference]
+        ---------------------- (plus weird 'eo' option)
+        G |- e#x: m
+      *)
+      join [
+        expression e1 << Dereference;
+        option expression eo << Dereference;
+      ]
+    | Texp_field (e, _, _) ->
+      (*
+        G |- e: m[Dereference]
+        -----------------------
+        G |- e.x: m
+      *)
+      expression e << Dereference
+    | Texp_setinstvar (pth,_,_,e) ->
+      (*
+        G |- e: m[Dereference]
+        ----------------------
+        G |- x <- e: m
+      *)
+      join [
+        path pth << Dereference;
+        expression e << Dereference;
+      ]
+    | Texp_letexception ({ext_id}, e) ->
+      (* G |- e: m
+         ----------------------------
+         G |- let exception A in e: m
+      *)
+      remove_id ext_id (expression e)
+    | Texp_assert e ->
+      (*
+        G |- e: m[Dereference]
+        -----------------------
+        G |- assert e: m
+
+        Note: `assert e` is treated just as if `assert` was a function.
+      *)
+      expression e << Dereference
+    | Texp_pack mexp ->
+      (*
+        G |- M: m
+        ----------------
+        G |- module M: m
+      *)
+      modexp mexp
+    | Texp_object (clsstrct, _) ->
+      class_structure clsstrct
+    | Texp_try (e, cases) ->
+      (*
+        G |- e: m      (Gi; _ |- pi -> ei : m)^i
+        --------------------------------------------
+        G + sum(Gi)^i |- try e with (pi -> ei)^i : m
+
+        Contrarily to match, the patterns p do not inspect
+        the value of e, so their mode does not influence the
+        mode of e.
+      *)
+      let case_env c m = fst (case c m) in
+      join [
+        expression e;
+        list case_env cases;
+      ]
+    | Texp_override (pth, fields) ->
+      (*
+         G |- pth : m   (Gi |- ei : m[Derefence])^i
+         ----------------------------------------------------
+         G + sum(Gi)^i |- {< (xi = ei)^i >} (at path pth) : m
+
+         Note: {< .. >} is desugared to a function application, but
+         the function implementation might still use its arguments in
+         a guarded way only -- intuitively it should behave as a constructor.
+         We could possibly refine the arguments' Dereference into Guard here.
+      *)
+      let field (_, _, arg) = expression arg in
+      join [
+        path pth << Dereference;
+        list field fields << Dereference;
+      ]
+    | Texp_function { cases } ->
+      (*
+         (Gi; _ |- pi -> ei : m[Delay])^i
+         --------------------------------------
+         sum(Gi)^i |- function (pi -> ei)^i : m
+
+         Contrarily to match, the value that is pattern-matched
+         is bound locally, so the pattern modes do not influence
+         the final environment.
+      *)
+      let case_env c m = fst (case c m) in
+      list case_env cases << Delay
+    | Texp_lazy e ->
+      (*
+        G |- e: m[Delay]
+        ----------------  (modulo some subtle compiler optimizations)
+        G |- lazy e: m
+      *)
+      let lazy_mode = match Typeopt.classify_lazy_argument e with
+        | `Constant_or_function
+        | `Identifier _
+        | `Float_that_cannot_be_shortcut ->
+          Return
+        | `Other ->
+          Delay
+      in
+      expression e << lazy_mode
+    | Texp_letop{let_; ands; body; _} ->
+        let case_env c m = fst (case c m) in
+        join [
+          list binding_op (let_ :: ands) << Dereference;
+          case_env body << Delay
+        ]
+    | Texp_unreachable ->
+      (*
+        ----------
+        [] |- .: m
+      *)
+      empty
+    | Texp_extension_constructor (_lid, pth) ->
+      path pth << Dereference
+    | Texp_open (od, e) ->
+      open_declaration od >> expression e
+
+and binding_op : Typedtree.binding_op -> term_judg =
+  fun bop ->
+    join [path bop.bop_op_path; expression bop.bop_exp]
+
+and class_structure : Typedtree.class_structure -> term_judg =
+  fun cs -> list class_field cs.cstr_fields
+
+and class_field : Typedtree.class_field -> term_judg =
+  fun cf -> match cf.cf_desc with
+    | Tcf_inherit (_, ce, _super, _inh_vars, _inh_meths) ->
+      class_expr ce << Dereference
+    | Tcf_val (_lab, _mut, _, cfk, _) ->
+      class_field_kind cfk
+    | Tcf_method (_, _, cfk) ->
+      class_field_kind cfk
+    | Tcf_constraint _ ->
+      empty
+    | Tcf_initializer e ->
+      expression e << Dereference
+    | Tcf_attribute _ ->
+      empty
+
+and class_field_kind : Typedtree.class_field_kind -> term_judg =
+  fun cfk -> match cfk with
+    | Tcfk_virtual _ ->
+      empty
+    | Tcfk_concrete (_, e) ->
+      expression e << Dereference
+
+and modexp : Typedtree.module_expr -> term_judg =
+  fun mexp -> match mexp.mod_desc with
+    | Tmod_ident (pth, _) ->
+      path pth
+    | Tmod_structure s ->
+      structure s
+    | Tmod_functor (_, e) ->
+      modexp e << Delay
+    | Tmod_apply (f, p, _) ->
+      join [
+        modexp f << Dereference;
+        modexp p << Dereference;
+      ]
+    | Tmod_constraint (mexp, _, _, coe) ->
+      let rec coercion coe k = match coe with
+        | Tcoerce_none ->
+          k Return
+        | Tcoerce_structure _
+        | Tcoerce_functor _ ->
+          (* These coercions perform a shallow copy of the input module,
+             by creating a new module with fields obtained by accessing
+             the same fields in the input module. *)
+           k Dereference
+        | Tcoerce_primitive _ ->
+          (* This corresponds to 'external' declarations,
+             and the coercion ignores its argument *)
+          k Ignore
+        | Tcoerce_alias (_, pth, coe) ->
+          (* Alias coercions ignore their arguments, but they evaluate
+             their alias module 'pth' under another coercion. *)
+          coercion coe (fun m -> path pth << m)
+      in
+      coercion coe (fun m -> modexp mexp << m)
+    | Tmod_unpack (e, _) ->
+      expression e
+
+
+(* G |- pth : m *)
+and path : Path.t -> term_judg =
+  (*
+    ------------
+    x: m |- x: m
+
+    G |- A: m[Dereference]
+    -----------------------
+    G |- A.x: m
+
+    G1 |- A: m[Dereference]
+    G2 |- B: m[Dereference]
+    ------------------------ (as for term application)
+    G1 + G2 |- A(B): m
+  *)
+  fun pth -> match pth with
+    | Path.Pident x ->
+        single x
+    | Path.Pdot (t, _) ->
+        path t << Dereference
+    | Path.Papply (f, p) ->
+        join [
+          path f << Dereference;
+          path p << Dereference;
+        ]
+
+(* G |- struct ... end : m *)
+and structure : Typedtree.structure -> term_judg =
+  (*
+    G1, {x: _, x in vars(G1)} |- item1: G2 + ... + Gn in m
+    G2, {x: _, x in vars(G2)} |- item2: G3 + ... + Gn in m
+    ...
+    Gn, {x: _, x in vars(Gn)} |- itemn: [] in m
+    ---
+    (G1 + ... + Gn) - V |- struct item1 ... itemn end: m
+  *)
+  fun s m ->
+    List.fold_right (fun it env -> structure_item it m env)
+      s.str_items Env.empty
+
+(* G |- <structure item> : m -| G'
+   where G is an output and m, G' are inputs *)
+and structure_item : Typedtree.structure_item -> bind_judg =
+  fun s m env -> match s.str_desc with
+    | Tstr_eval (e, _) ->
+      (*
+        Ge |- e: m[Guard]
+        G |- items: m -| G'
+        ---------------------------------
+        Ge + G |- (e;; items): m -| G'
+
+        The expression `e` is treated in the same way as let _ = e
+      *)
+      let judg_e = expression e << Guard in
+      Env.join (judg_e m) env
+    | Tstr_value (rec_flag, bindings) ->
+      value_bindings rec_flag bindings m env
+    | Tstr_module {mb_id; mb_expr} ->
+      module_binding (mb_id, mb_expr) m env
+    | Tstr_recmodule mbs ->
+      let bindings = List.map (fun {mb_id; mb_expr} -> (mb_id, mb_expr)) mbs in
+      recursive_module_bindings bindings m env
+    | Tstr_primitive _ ->
+      env
+    | Tstr_type _ ->
+      (*
+        -------------------
+        G |- type t: m -| G
+      *)
+      env
+    | Tstr_typext {tyext_constructors = exts; _} ->
+      let ext_ids = List.map (fun {ext_id = id; _} -> id) exts in
+      Env.join
+        (list extension_constructor exts m)
+        (Env.remove_list ext_ids env)
+    | Tstr_exception {tyexn_constructor = ext; _} ->
+      Env.join
+        (extension_constructor ext m)
+        (Env.remove ext.ext_id env)
+    | Tstr_modtype _
+    | Tstr_class_type _
+    | Tstr_attribute _ ->
+      env
+    | Tstr_open od ->
+      open_declaration od m env
+    | Tstr_class classes ->
+        let class_ids =
+          let class_id ({ci_id_class = id; _}, _) = id in
+          List.map class_id classes in
+        let class_declaration ({ci_expr; _}, _) m =
+          Env.remove_list class_ids (class_expr ci_expr m) in
+        Env.join
+          (list class_declaration classes m)
+          (Env.remove_list class_ids env)
+    | Tstr_include { incl_mod = mexp; incl_type = mty; _ } ->
+      let included_ids = List.map Types.signature_item_id mty in
+      Env.join (modexp mexp m) (Env.remove_list included_ids env)
+
+(* G |- module M = E : m -| G *)
+and module_binding : (Ident.t option * Typedtree.module_expr) -> bind_judg =
+  fun (id, mexp) m env ->
+      (*
+        GE |- E: m[mM + Guard]
+        -------------------------------------
+        GE + G |- module M = E : m -| M:mM, G
+      *)
+      let judg_E, env =
+        match id with
+        | None -> modexp mexp << Guard, env
+        | Some id ->
+          let mM, env = Env.take id env in
+          let judg_E = modexp mexp << (Mode.join mM Guard) in
+          judg_E, env
+      in
+      Env.join (judg_E m) env
+
+and open_declaration : Typedtree.open_declaration -> bind_judg =
+  fun { open_expr = mexp; open_bound_items = sg; _ } m env ->
+      let judg_E = modexp mexp in
+      let bound_ids = List.map Types.signature_item_id sg in
+      Env.join (judg_E m) (Env.remove_list bound_ids env)
+
+and recursive_module_bindings
+  : (Ident.t option * Typedtree.module_expr) list -> bind_judg =
+  fun m_bindings m env ->
+    let mids = List.filter_map fst m_bindings in
+    let binding (mid, mexp) m =
+      let judg_E =
+        match mid with
+        | None -> modexp mexp << Guard
+        | Some mid ->
+          let mM = Env.find mid env in
+          modexp mexp << (Mode.join mM Guard)
+      in
+      Env.remove_list mids (judg_E m)
+    in
+    Env.join (list binding m_bindings m) (Env.remove_list mids env)
+
+and class_expr : Typedtree.class_expr -> term_judg =
+  fun ce -> match ce.cl_desc with
+    | Tcl_ident (pth, _, _) ->
+        path pth << Dereference
+    | Tcl_structure cs ->
+        class_structure cs
+    | Tcl_fun (_, _, args, ce, _) ->
+        let ids = List.map fst args in
+        remove_ids ids (class_expr ce << Delay)
+    | Tcl_apply (ce, args) ->
+        let arg (_label, eo) = option expression eo in
+        join [
+          class_expr ce << Dereference;
+          list arg args << Dereference;
+        ]
+    | Tcl_let (rec_flag, bindings, _, ce) ->
+      value_bindings rec_flag bindings >> class_expr ce
+    | Tcl_constraint (ce, _, _, _, _) ->
+        class_expr ce
+    | Tcl_open (_, ce) ->
+        class_expr ce
+
+and extension_constructor : Typedtree.extension_constructor -> term_judg =
+  fun ec -> match ec.ext_kind with
+    | Text_decl _ ->
+      empty
+    | Text_rebind (pth, _lid) ->
+      path pth
+
+(* G |- let (rec?) (pi = ei)^i : m -| G' *)
+and value_bindings : rec_flag -> Typedtree.value_binding list -> bind_judg =
+  fun rec_flag bindings mode bound_env ->
+    let all_bound_pats = List.map (fun vb -> vb.vb_pat) bindings in
+    let outer_env = remove_patlist all_bound_pats bound_env in
+    let bindings_env =
+      match rec_flag with
+      | Nonrecursive ->
+        (*
+           (Gi, pi:_ |- ei : m[mbody_i])^i   (pi : mbody_i -| D)^i
+           ------------------------------------------------------------
+           Sum(Gi) + (D - (pi)^i) |- let (pi=ei)^i : m -| D
+        *)
+          let binding_env {vb_pat; vb_expr; _} m =
+            let m' = Mode.compose m (pattern vb_pat bound_env) in
+            remove_pat vb_pat (expression vb_expr m') in
+          list binding_env bindings mode
+      | Recursive ->
+        (*
+           (Gi, (xj : mdef_ij)^j |- ei : m[mbody_i])^i   (xi : mbody_i -| D)^i
+           G'i = Gi + mdef_ij[G'j]
+           -------------------------------------------------------------------
+           Sum(G'i) + (D - (pi)^i) |- let rec (xi=ei)^i : m -| D
+
+           The (mdef_ij)^i,j are a family of modes over two indices:
+           mdef_ij represents the mode of use, within e_i the definition of x_i,
+           of the mutually-recursive variable x_j.
+
+           The (G'i)^i are defined from the (Gi)^i as a family of equations,
+           whose smallest solution is computed as a least fixpoint.
+
+           The (Gi)^i are the "immediate" dependencies of each (ei)^i
+           on the outer context (excluding the mutually-defined
+           variables).
+           The (G'i)^i contain the "transitive" dependencies as well:
+           if ei depends on xj, then the dependencies of G'i of xi
+           must contain the dependencies of G'j, composed by
+           the mode mdef_ij of use of xj in ei.
+
+           For example, consider:
+
+             let rec z =
+               let rec x = ref y
+               and y = ref z
+               in f x
+
+           this definition should be rejected as the body [f x]
+           dereferences [x], which can be used to access the
+           yet-unitialized value [z]. This requires realizing that [x]
+           depends on [z] through [y], which requires the transitive
+           closure computation.
+
+           An earlier version of our check would take only the (Gi)^i
+           instead of the (G'i)^i, which is incorrect and would accept
+           the example above.
+        *)
+          (* [binding_env] takes a binding (x_i = e_i)
+             and computes (Gi, (mdef_ij)^j). *)
+          let binding_env {vb_pat = x_i; vb_expr = e_i; _} =
+            let mbody_i = pattern x_i bound_env in
+            (* Gi, (x_j:mdef_ij)^j  *)
+            let rhs_env_i = expression e_i (Mode.compose mode mbody_i) in
+            (* (mdef_ij)^j (for a fixed i) *)
+            let mutual_modes =
+              let mdef_ij {vb_pat = x_j; _} = pattern x_j rhs_env_i in
+              List.map mdef_ij bindings in
+            (* Gi *)
+            let env_i = remove_patlist all_bound_pats rhs_env_i in
+            (* (Gi, (mdef_ij)^j) *)
+            (env_i, mutual_modes) in
+          let env, mdef =
+            List.split (List.map binding_env bindings) in
+          let rec transitive_closure env =
+            let transitive_deps env_i mdef_i =
+              (* Gi, (mdef_ij)^j => Gi + Sum_j mdef_ij[Gj] *)
+              Env.join env_i
+                (Env.join_list (List.map2 Env.compose mdef_i env)) in
+            let env' = List.map2 transitive_deps env mdef in
+            if List.for_all2 Env.equal env env'
+            then env'
+            else transitive_closure env'
+          in
+          let env'_i = transitive_closure env in
+          Env.join_list env'_i
+    in Env.join bindings_env outer_env
+
+(* G; m' |- (p -> e) : m
+   with outputs G, m' and input m
+
+   m' is the mode under which the scrutinee of p
+   (the value matched against p) is placed.
+*)
+and case : Typedtree.case -> mode -> Env.t * mode =
+  fun { Typedtree.c_lhs; c_guard; c_rhs } ->
+    (*
+       Ge |- e : m    Gg |- g : m[Dereference]
+       G := Ge+Gg     p : mp -| G
+       ----------------------------------------
+       G - p; m[mp] |- (p (when g)? -> e) : m
+    *)
+    let judg = join [
+        option expression c_guard << Dereference;
+        expression c_rhs;
+      ] in
+    (fun m ->
+       let env = judg m in
+       (remove_pat c_lhs env), Mode.compose m (pattern c_lhs env))
+
+(* p : m -| G
+   with output m and input G
+
+   m is the mode under which the scrutinee of p is placed.
+*)
+and pattern : pattern -> Env.t -> mode = fun pat env ->
+  (*
+    mp := | Dereference if p is destructuring
+          | Guard       otherwise
+    me := sum{G(x), x in vars(p)}
+    --------------------------------------------
+    p : (mp + me) -| G
+  *)
+  let m_pat = if is_destructuring_pattern pat
+              then Dereference
+              else Guard
+  in
+  let m_env =
+    pat_bound_idents pat
+    |> List.map (fun id -> Env.find id env)
+    |> List.fold_left Mode.join Ignore
+  in
+  Mode.join m_pat m_env
+
+and is_destructuring_pattern : Typedtree.pattern -> bool =
+  fun pat -> match pat.pat_desc with
+    | Tpat_any -> false
+    | Tpat_var (_, _) -> false
+    | Tpat_alias (pat, _, _) -> is_destructuring_pattern pat
+    | Tpat_constant _ -> true
+    | Tpat_tuple _ -> true
+    | Tpat_construct (_, _, _) -> true
+    | Tpat_variant _ -> true
+    | Tpat_record (_, _) -> true
+    | Tpat_array _ -> true
+    | Tpat_or (l,r,_) ->
+        is_destructuring_pattern l || is_destructuring_pattern r
+    | Tpat_lazy _ -> true
+    | Tpat_exception _ -> false
+
+let is_valid_recursive_expression idlist expr =
+  let ty = expression expr Return in
+  match Env.unguarded ty idlist, Env.dependent ty idlist,
+        classify_expression expr with
+  | _ :: _, _, _ (* The expression inspects rec-bound variables *)
+  | [], _ :: _, Dynamic -> (* The expression depends on rec-bound variables
+                              and its size is unknown *)
+      false
+  | [], _, Static (* The expression has known size *)
+  | [], [], Dynamic -> (* The expression has unknown size,
+                          but does not depend on rec-bound variables *)
+      true
+
+(* A class declaration may contain let-bindings. If they are recursive,
+   their validity will already be checked by [is_valid_recursive_expression]
+   during type-checking. This function here prevents a different kind of
+   invalid recursion, which is the unsafe creations of objects of this class
+   in the let-binding. For example,
+   {|class a = let x = new a in object ... end|}
+   is forbidden, but
+   {|class a = let x () = new a in object ... end|}
+   is allowed.
+*)
+let is_valid_class_expr idlist ce =
+  let rec class_expr : mode -> Typedtree.class_expr -> Env.t =
+    fun mode ce -> match ce.cl_desc with
+      | Tcl_ident (_, _, _) ->
+        (*
+          ----------
+          [] |- a: m
+        *)
+        Env.empty
+      | Tcl_structure _ ->
+        (*
+          -----------------------
+          [] |- struct ... end: m
+        *)
+        Env.empty
+      | Tcl_fun (_, _, _, _, _) -> Env.empty
+        (*
+          ---------------------------
+          [] |- fun x1 ... xn -> C: m
+        *)
+      | Tcl_apply (_, _) -> Env.empty
+      | Tcl_let (rec_flag, bindings, _, ce) ->
+        value_bindings rec_flag bindings mode (class_expr mode ce)
+      | Tcl_constraint (ce, _, _, _, _) ->
+        class_expr mode ce
+      | Tcl_open (_, ce) ->
+        class_expr mode ce
+  in
+  match Env.unguarded (class_expr Return ce) idlist with
+  | [] -> true
+  | _ :: _ -> false
diff --git a/src/ocaml/typing/410+multicore/rec_check.mli b/src/ocaml/typing/410+multicore/rec_check.mli
new file mode 100644
index 00000000..aa5c1ca3
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/rec_check.mli
@@ -0,0 +1,19 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*               Jeremy Yallop, University of Cambridge                   *)
+(*                                                                        *)
+(*   Copyright 2017 Jeremy Yallop                                         *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+exception Illegal_expr
+
+val is_valid_recursive_expression : Ident.t list -> Typedtree.expression -> bool
+
+val is_valid_class_expr : Ident.t list -> Typedtree.class_expr -> bool
diff --git a/src/ocaml/typing/410+multicore/saved_parts.ml b/src/ocaml/typing/410+multicore/saved_parts.ml
new file mode 100644
index 00000000..47f980b6
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/saved_parts.ml
@@ -0,0 +1,27 @@
+let attribute = Location.mknoloc "merlin.saved-parts"
+
+module H = Ephemeron.K1.Make(struct
+    type t = string
+    let hash = Hashtbl.hash
+    let equal (a : t) (b : t) =  a = b
+  end)
+
+let table = H.create 7
+
+let gensym =
+  let counter = ref 0 in
+  fun () -> incr counter; !counter
+
+let store parts =
+  let id = string_of_int (gensym ()) in
+  let key = Parsetree.Pconst_integer (id, None) in
+  H.add table id parts;
+  key
+
+let find = function
+  | Parsetree.Pconst_integer (id, None) ->
+    begin
+      try H.find table id
+      with Not_found -> []
+    end
+  | _ -> assert false
diff --git a/src/ocaml/typing/410+multicore/saved_parts.mli b/src/ocaml/typing/410+multicore/saved_parts.mli
new file mode 100644
index 00000000..be1a2069
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/saved_parts.mli
@@ -0,0 +1,3 @@
+val attribute : string Location.loc
+val store : Cmt_format.binary_part list -> Parsetree.constant
+val find : Parsetree.constant -> Cmt_format.binary_part list
diff --git a/src/ocaml/typing/410+multicore/short_paths.ml b/src/ocaml/typing/410+multicore/short_paths.ml
new file mode 100644
index 00000000..efc423e3
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/short_paths.ml
@@ -0,0 +1,1932 @@
+
+open Short_paths_graph
+
+module Desc = Desc
+
+module Rev_deps : sig
+
+  type t
+
+  val create : unit -> t
+
+  val extend_up_to : t -> Dependency.t -> unit
+
+  val get : t -> Dependency.t -> Dependency.Set.t
+
+  val add : t -> source:Dependency.t -> target:Dependency.t -> unit
+
+  val add_alias : t -> source:Dependency.t -> target:Dependency.t -> unit
+
+  val before : t -> Origin.t -> Origin.t -> bool
+
+end = struct
+
+  module Stamp = Natural.Make()
+
+  type item =
+    { mutable set : Dependency.Set.t;
+      mutable edges : Dependency.t list;
+      mutable alias_edges : Dependency.t list;
+      mutable last : Stamp.t; }
+
+  type t =
+    { mutable stamp : Stamp.t;
+      mutable items : item Dependency.Array.t; }
+
+  let create () =
+    { stamp = Stamp.one;
+      items = Dependency.Array.empty; }
+
+  let extend_up_to t next =
+    match Dependency.pred next with
+    | None -> ()
+    | Some curr ->
+      if not (Dependency.Array.contains t.items curr) then begin
+        let items =
+          Dependency.Array.extend t.items curr
+            (fun _ -> { set = Dependency.Set.empty;
+                        edges = [];
+                        alias_edges = [];
+                        last = Stamp.zero; })
+        in
+        t.items <- items
+      end
+
+  let add t ~source ~target =
+    let item = Dependency.Array.get t.items source in
+    item.edges <- target :: item.edges;
+    t.stamp <- Stamp.succ t.stamp
+
+  let add_alias t ~source ~target =
+    let item = Dependency.Array.get t.items source in
+    item.alias_edges <- target :: item.alias_edges;
+    t.stamp <- Stamp.succ t.stamp
+
+  let update t dep item =
+    if Stamp.less_than item.last t.stamp then begin
+      let rec add_edges t item acc =
+        let rec loop t acc added = function
+          | [] ->
+              List.fold_left
+                (fun acc dep ->
+                   let item = Dependency.Array.get t.items dep in
+                   add_alias_edges t item acc)
+                acc added
+          | dep :: rest ->
+              if Dependency.Set.mem dep acc then loop t acc added rest
+              else begin
+                let acc = Dependency.Set.add dep acc in
+                let added = dep :: added in
+                loop t acc added rest
+              end
+        in
+        loop t acc [] item.edges
+      and add_alias_edges t item acc =
+        List.fold_left
+          (fun acc dep ->
+             if Dependency.Set.mem dep acc then acc
+             else begin
+               let acc = Dependency.Set.add dep acc in
+               let item = Dependency.Array.get t.items dep in
+               let acc = add_edges t item acc in
+               add_alias_edges t item acc
+             end)
+          acc item.alias_edges
+      in
+      let set = Dependency.Set.singleton dep in
+      let set = add_edges t item set in
+      let set = add_alias_edges t item set in
+      item.set <- set;
+      item.last <- t.stamp
+    end
+
+  let get t dep =
+    let item = Dependency.Array.get t.items dep in
+    update t dep item;
+    item.set
+
+  let before t origin1 origin2 =
+    let open Origin in
+    match origin1, origin2 with
+    | Environment age1, Environment age2 -> Age.less_than age1 age2
+    | Environment _, Dependency _ -> false
+    | Environment _, Dependencies _ -> false
+    | Dependency _, Environment _ -> true
+    | Dependency dep1, Dependency dep2 ->
+        let rev_dep = get t dep1 in
+        Dependency.Set.mem dep2 rev_dep
+    | Dependency dep1, Dependencies deps2 ->
+        let rev_dep = get t dep1 in
+        List.exists
+          (fun dep2 -> Dependency.Set.mem dep2 rev_dep)
+          deps2
+    | Dependencies _, Environment _ -> true
+    | Dependencies deps1, Dependency dep2 ->
+        List.for_all
+          (fun dep1 -> Dependency.Set.mem dep2 (get t dep1))
+          deps1
+    | Dependencies deps1, Dependencies deps2 ->
+        let rev_dep =
+          match deps1 with
+          | [] -> failwith "Rev_deps.before: invalid origin"
+          | dep1 :: deps1 ->
+              List.fold_left
+                (fun acc dep1 -> Dependency.Set.inter acc (get t dep1))
+                (get t dep1) deps1
+        in
+        List.exists
+          (fun dep2 -> Dependency.Set.mem dep2 rev_dep)
+          deps2
+
+end
+
+module Origin_range_tbl = struct
+
+  type 'a t =
+    { mutable envs : 'a list Age.Map.t;
+      mutable dep_keys : Dependency.Set.t;
+      deps : 'a list Dependency.Tbl.t; }
+
+  let create () =
+    { envs = Age.Map.empty;
+      dep_keys = Dependency.Set.empty;
+      deps = Dependency.Tbl.create 0; }
+
+  let add_dependency dep data t =
+    t.dep_keys <- Dependency.Set.add dep t.dep_keys;
+    let prev =
+      match Dependency.Tbl.find t.deps dep with
+      | exception Not_found -> []
+      | prev -> prev
+    in
+    Dependency.Tbl.replace t.deps dep (data :: prev)
+
+  let add_age age data t =
+    let prev =
+      match Age.Map.find age t.envs with
+      | exception Not_found -> []
+      | prev -> prev
+    in
+    t.envs <- Age.Map.add age (data :: prev) t.envs
+
+  let add rev_deps origin data t =
+    match origin with
+    | Origin.Dependency dep -> add_dependency dep data t
+    | Origin.Environment age -> add_age age data t
+    | Origin.Dependencies deps -> begin
+        let rev_dep_opt =
+          List.fold_left
+            (fun acc dep ->
+               let rev_dep = Rev_deps.get rev_deps dep in
+               match acc with
+               | None -> Some rev_dep
+               | Some acc -> Some (Dependency.Set.inter acc rev_dep))
+            None deps
+        in
+        let rev_dep =
+          match rev_dep_opt with
+          | None -> failwith "Origin_range_tbl.add: invalid origin"
+          | Some rev_dep -> rev_dep
+        in
+        match
+          List.find
+            (fun dep -> Dependency.Set.mem dep rev_dep)
+            deps
+        with
+        | dep -> add_dependency dep data t
+        | exception Not_found ->
+          match Dependency.Set.choose rev_dep with
+          | dep -> add_dependency dep data t
+          | exception Not_found -> add_age Age.zero data t
+      end
+
+  let pop_dependency rev_dep t =
+    let matching = Dependency.Set.inter rev_dep t.dep_keys in
+    t.dep_keys <- Dependency.Set.diff t.dep_keys matching;
+    let items =
+      Dependency.Set.fold
+        (fun dep acc ->
+           let data = Dependency.Tbl.find t.deps dep in
+           Dependency.Tbl.remove t.deps dep;
+           List.rev_append data acc)
+        matching
+        []
+    in
+    let items =
+      Age.Map.fold
+        (fun _ data acc -> List.rev_append data acc)
+        t.envs items
+    in
+    t.envs <- Age.Map.empty;
+    items
+
+  let pop_age age t =
+    let envs, first, matching = Age.Map.split age t.envs in
+    let items =
+      match first with
+      | None -> []
+      | Some first -> first
+    in
+    let items =
+      Age.Map.fold
+        (fun _ data acc -> List.rev_append data acc)
+        matching items
+    in
+    t.envs <- envs;
+    items
+
+  let pop rev_deps origin t =
+    match origin with
+    | Origin.Dependency dep ->
+        let rev_dep = Rev_deps.get rev_deps dep in
+        pop_dependency rev_dep t
+    | Origin.Dependencies deps ->
+        let rev_dep_opt =
+          List.fold_left
+            (fun acc dep ->
+               let rev_dep = Rev_deps.get rev_deps dep in
+               match acc with
+               | None -> Some rev_dep
+               | Some acc -> Some (Dependency.Set.inter acc rev_dep))
+            None deps
+        in
+        let rev_dep =
+          match rev_dep_opt with
+          | None -> failwith "Origin_range_tbl.pop: invalid origin"
+          | Some rev_dep -> rev_dep
+        in
+        pop_dependency rev_dep t
+    | Origin.Environment age ->
+        pop_age age t
+
+  let is_origin_empty rev_deps origin t =
+    match origin with
+    | Origin.Dependency dep ->
+        if not (Age.Map.is_empty t.envs) then false
+        else begin
+          let rev_dep = Rev_deps.get rev_deps dep in
+          let matching = Dependency.Set.inter rev_dep t.dep_keys in
+          Dependency.Set.is_empty matching
+        end
+    | Origin.Dependencies deps ->
+        if not (Age.Map.is_empty t.envs) then false
+        else begin
+          let rev_dep_opt =
+            List.fold_left
+              (fun acc dep ->
+                 let rev_dep = Rev_deps.get rev_deps dep in
+                 match acc with
+                 | None -> Some rev_dep
+                 | Some acc -> Some (Dependency.Set.inter acc rev_dep))
+              None deps
+          in
+          let rev_dep =
+            match rev_dep_opt with
+            | None ->
+                failwith "Origin_range_tbl.is_origin_empty: invalid origin"
+            | Some rev_dep -> rev_dep
+          in
+          let matching = Dependency.Set.inter rev_dep t.dep_keys in
+          Dependency.Set.is_empty matching
+        end
+    | Origin.Environment age ->
+        match Age.Map.max_binding t.envs with
+        | exception Not_found -> true
+        | (max, _) -> Age.less_than max age
+
+  let is_completely_empty t =
+    Age.Map.is_empty t.envs
+    && Dependency.Set.is_empty t.dep_keys
+
+end
+
+module Height = Natural.Make_no_zero()
+
+module Todo = struct
+
+  module Item = struct
+
+    type t =
+      | Base of Diff.Item.t
+      | Children of
+          { md : Module.t;
+            path : Path.t;
+            seen : Path_set.t; }
+      | Update of
+          { id : Ident.t;
+            origin : Origin.t; }
+      | Forward of
+          { id : Ident.t;
+            decl : Origin.t;
+            origin : Origin.t; }
+
+  end
+
+  type t =
+    { mutable table : Item.t Origin_range_tbl.t Height.Array.t }
+
+  let create graph rev_deps diff =
+    let tbl = Origin_range_tbl.create () in
+    List.iter
+      (fun item ->
+         let origin = Diff.Item.origin graph item in
+         match Diff.Item.previous graph item with
+         | None ->
+             Origin_range_tbl.add rev_deps origin (Item.Base item) tbl;
+         | Some decl ->
+             let id = Diff.Item.id graph item in
+             let item = Item.Forward { id; decl; origin } in
+             Origin_range_tbl.add rev_deps origin item tbl)
+      diff;
+    let table = Height.Array.singleton tbl in
+    { table }
+
+  let get_table t height =
+    if not (Height.Array.contains t.table height) then begin
+      t.table <- Height.Array.extend t.table height
+                   (fun _ -> Origin_range_tbl.create ());
+    end;
+    Height.Array.get t.table height
+
+  let get_table_opt t height =
+    if Height.Array.contains t.table height then
+      Some (Height.Array.get t.table height)
+    else None
+
+  let retract_empty t =
+    let rec loop height =
+      match Height.pred height with
+      | None ->
+          t.table <- Height.Array.empty
+      | Some prev ->
+          let tbl = Height.Array.get t.table prev in
+          if Origin_range_tbl.is_completely_empty tbl then loop prev
+          else begin
+            t.table <- Height.Array.retract t.table height
+          end
+    in
+    match Height.Array.last t.table with
+    | None -> ()
+    | Some last ->
+      let tbl = Height.Array.get t.table last in
+      if Origin_range_tbl.is_completely_empty tbl then loop last
+      else ()
+
+  let merge graph rev_deps t diff =
+    let tbl = get_table t Height.one in
+    List.iter
+      (fun item ->
+         match Diff.Item.previous graph item with
+         | None -> ()
+         | Some origin ->
+             let id = Diff.Item.id graph item in
+             let item = Item.Update { id; origin } in
+             Origin_range_tbl.add rev_deps origin item tbl)
+      diff
+
+  let mutate graph rev_deps t diff =
+    let tbl = get_table t Height.one in
+    List.iter
+      (fun item ->
+         match Diff.Item.previous graph item with
+         | None ->
+             let origin = Diff.Item.origin graph item in
+             Origin_range_tbl.add rev_deps origin (Item.Base item) tbl;
+         | Some origin ->
+             let id = Diff.Item.id graph item in
+             let item = Item.Update { id; origin } in
+             Origin_range_tbl.add rev_deps origin item tbl)
+      diff
+
+  let add_children graph rev_deps t height md path seen =
+    let height = Height.succ height in
+    let tbl = get_table t height in
+    let origin = Module.origin graph md in
+    Origin_range_tbl.add rev_deps origin (Item.Children{md; path; seen}) tbl
+
+  let add_next_update rev_deps t height origin id =
+    let height = Height.succ height in
+    let tbl = get_table t height in
+    let item = Item.Update { id; origin } in
+    Origin_range_tbl.add rev_deps origin item tbl
+
+  let add_next_forward rev_deps t height origin id decl =
+    let height = Height.succ height in
+    let tbl = get_table t height in
+    let item = Item.Forward { id; decl; origin } in
+    Origin_range_tbl.add rev_deps origin item tbl
+
+  let rec is_empty_from rev_deps t height origin =
+    match get_table_opt t height with
+    | None -> true
+    | Some tbl ->
+        Origin_range_tbl.is_origin_empty rev_deps origin tbl
+        && is_empty_from rev_deps t (Height.succ height) origin
+
+  let pop rev_deps t height origin =
+    match get_table_opt t height with
+    | None ->
+        retract_empty t;
+        None
+    | Some tbl ->
+      match Origin_range_tbl.pop rev_deps origin tbl with
+      | [] ->
+          let empty_from =
+            is_empty_from rev_deps t (Height.succ height) origin
+          in
+          if not empty_from then Some []
+          else begin
+            retract_empty t;
+            None
+          end
+      | _ :: _ as todo -> Some todo
+
+end
+
+module Forward_path_map : sig
+
+  type 'a t
+
+  val empty : 'a t
+
+  val add : 'a t -> Sort.t -> Path.t -> 'a -> 'a t
+
+  val find : 'a t -> Path.t -> 'a list
+
+  val rebase : 'a t -> 'a t -> 'a t
+
+  val iter_forwards : (Path.t -> 'a -> unit) -> 'a t -> Ident.t -> unit
+
+  val iter_updates : (Path.t -> 'a -> unit) -> 'a t -> Ident.t -> unit
+
+end = struct
+
+  type 'a t =
+    { new_paths : 'a list Path_map.t;
+      old_paths : 'a list Path_map.t;
+      updates : Path_set.t Ident_map.t;
+      forwards : Path_set.t Ident_map.t; }
+
+  let empty =
+    { new_paths = Path_map.empty;
+      old_paths = Path_map.empty;
+      forwards = Ident_map.empty;
+      updates = Ident_map.empty; }
+
+  let add t sort path data =
+    let new_paths = t.new_paths in
+    let prev =
+      match Path_map.find path new_paths with
+      | prev -> prev
+      | exception Not_found -> []
+    in
+    let new_paths = Path_map.add path (data :: prev) new_paths in
+    let updates = t.updates in
+    let updates =
+      match sort with
+      | Sort.Defined -> updates
+      | Sort.Declared ids ->
+          Ident_set.fold
+            (fun id acc ->
+               let prev =
+                 match Ident_map.find id updates with
+                 | prev -> prev
+                 | exception Not_found -> Path_set.empty
+               in
+               Ident_map.add id (Path_set.add path prev) acc)
+            ids updates
+    in
+    { t with new_paths; updates }
+
+  let find t path =
+    match Path_map.find path t.new_paths with
+    | exception Not_found -> Path_map.find path t.old_paths
+    | new_paths ->
+      match Path_map.find path t.old_paths with
+      | exception Not_found -> new_paths
+      | old_paths -> new_paths @ old_paths
+
+  let rebase t base =
+    let old_paths =
+      Path_map.union
+        (fun _ paths1 paths2 -> Some (paths1 @ paths2))
+        base.new_paths base.old_paths
+    in
+    let forwards =
+      Ident_map.union
+        (fun _ pset1 pset2 -> Some (Path_set.union pset1 pset2))
+        base.updates base.forwards
+    in
+    { t with old_paths; forwards }
+
+  let iter_updates f t id =
+    match Ident_map.find id t.updates with
+    | exception Not_found -> ()
+    | pset ->
+        Path_set.iter
+          (fun path ->
+             match Path_map.find path t.new_paths with
+             | exception Not_found -> ()
+             | paths -> List.iter (f path) paths)
+          pset
+
+  let iter_forwards f t id =
+    match Ident_map.find id t.forwards with
+    | exception Not_found -> ()
+    | pset ->
+        Path_set.iter
+          (fun path ->
+             match Path_map.find path t.old_paths with
+             | exception Not_found -> ()
+             | paths -> List.iter (f path) paths)
+          pset
+
+end
+
+module Origin_tbl = Hashtbl.Make(Origin)
+
+module History : sig
+
+  module Stamp : Natural.S
+
+  module Revision : sig
+
+    type t
+
+    val stamp : t -> Stamp.t
+
+    val diff : t -> Diff.t
+
+    val rev_deps : t -> Rev_deps.t
+
+    val next : t -> t option
+
+  end
+
+  type t
+
+  val init : Rev_deps.t ->  Diff.t -> t
+
+  val head : t -> Revision.t
+
+  val commit : t -> Rev_deps.t ->  Diff.t -> unit
+
+end = struct
+
+  module Stamp = Natural.Make()
+
+  module Revision = struct
+
+    type t =
+      { stamp : Stamp.t;
+        diff :  Diff.t;
+        rev_deps : Rev_deps.t;
+        mutable next : t option; }
+
+    let stamp t = t.stamp
+
+    let diff t = t.diff
+
+    let rev_deps t = t.rev_deps
+
+    let next t = t.next
+
+  end
+
+  type t =
+    { mutable head : Revision.t; }
+
+  let init rev_deps diff =
+    let stamp = Stamp.zero in
+    let next = None in
+    let head = { Revision.stamp; diff; rev_deps; next } in
+    { head }
+
+  let head t = t.head
+
+  let commit t rev_deps diff =
+    let head = t.head in
+    let stamp = Stamp.succ head.Revision.stamp in
+    let next = None in
+    let rev = { Revision.stamp; diff; rev_deps; next } in
+    head.Revision.next <- Some rev;
+    t.head <- rev
+
+end
+
+type type_resolution =
+  | Nth of int
+  | Subst of int list
+  | Id
+
+type type_result =
+  | Nth of int
+  | Path of int list option * Path.t
+
+type class_type_result = int list option * Path.t
+
+module Shortest = struct
+
+  module Section = struct
+
+    type t =
+      { mutable types : Path.t Forward_path_map.t;
+        mutable class_types : Path.t Forward_path_map.t;
+        mutable module_types : Path.t Forward_path_map.t;
+        mutable modules : (Path.t * Path_set.t) Forward_path_map.t; }
+
+    let create () =
+      let types = Forward_path_map.empty in
+      let class_types = Forward_path_map.empty in
+      let module_types = Forward_path_map.empty in
+      let modules = Forward_path_map.empty in
+      { types; class_types; module_types; modules }
+
+    let add_type graph t typ path =
+      let canonical = Type.path graph typ in
+      let sort = Type.sort graph typ in
+      t.types <- Forward_path_map.add t.types sort canonical path
+
+    let add_class_type graph t mty path =
+      let canonical = Class_type.path graph mty in
+      let sort = Class_type.sort graph mty in
+      t.class_types <- Forward_path_map.add t.class_types sort canonical path
+
+    let add_module_type graph t mty path =
+      let canonical = Module_type.path graph mty in
+      let sort = Module_type.sort graph mty in
+      t.module_types <- Forward_path_map.add t.module_types sort canonical path
+
+    let add_module graph t md path =
+      let canonical = Module.path graph md in
+      let sort = Module.sort graph md in
+      t.modules <- Forward_path_map.add t.modules sort canonical path
+
+    let rebase t parent =
+      t.types <- Forward_path_map.rebase t.types parent.types;
+      t.class_types <- Forward_path_map.rebase t.class_types parent.class_types;
+      t.module_types <- Forward_path_map.rebase t.module_types parent.module_types;
+      t.modules <- Forward_path_map.rebase t.modules parent.modules
+
+    let iter_updates ~type_ ~class_type ~module_type ~module_ t id =
+      Forward_path_map.iter_updates type_ t.types id;
+      Forward_path_map.iter_updates class_type t.class_types id;
+      Forward_path_map.iter_updates module_type t.module_types id;
+      Forward_path_map.iter_updates module_ t.modules id
+
+    let iter_forwards ~type_ ~class_type ~module_type ~module_ t id =
+      Forward_path_map.iter_forwards type_ t.types id;
+      Forward_path_map.iter_forwards class_type t.class_types id;
+      Forward_path_map.iter_forwards module_type t.module_types id;
+      Forward_path_map.iter_forwards module_ t.modules id
+
+    let find_type graph t typ =
+      let canonical = Type.path graph typ in
+      Forward_path_map.find t.types canonical
+
+    let find_class_type graph t mty =
+      let canonical = Class_type.path graph mty in
+      Forward_path_map.find t.class_types canonical
+
+    let find_module_type graph t mty =
+      let canonical = Module_type.path graph mty in
+      Forward_path_map.find t.module_types canonical
+
+    let find_module graph t md =
+      let canonical = Module.path graph md in
+      Forward_path_map.find t.modules canonical
+
+  end
+
+  module Sections = struct
+
+    type range =
+      | Until of Height.t
+      | All
+
+    type versioning =
+      | Unversioned
+      | Initialisation of History.Stamp.t
+      | Completion of History.Stamp.t
+
+    type t =
+      { mutable sections : Section.t Height.Array.t;
+        mutable initialised : range;
+        mutable completed : range;
+        mutable versioning : versioning; }
+
+    let create age origin =
+      let sections = Height.Array.empty in
+      let completed = Until Height.one in
+      let initialised, versioning =
+        if Age.equal age Age.zero then begin
+          All, Completion History.Stamp.zero
+        end else begin
+          match origin with
+          | Origin.Environment age' ->
+              let initialised =
+                if Age.less_than_or_equal age age' then All
+                else Until Height.one
+              in
+              initialised, Unversioned
+          | Origin.Dependency _ | Origin.Dependencies _ ->
+              Until Height.one, Initialisation History.Stamp.zero
+        end
+      in
+      { sections; initialised; completed; versioning; }
+
+    let update t stamp =
+      match t.versioning with
+      | Unversioned -> ()
+      | Initialisation initialised ->
+          if History.Stamp.less_than initialised stamp then begin
+            t.initialised <- Until Height.one;
+            t.versioning <- Initialisation stamp
+          end
+      | Completion completed ->
+          if History.Stamp.less_than completed stamp then begin
+            t.completed <- Until Height.one;
+            t.versioning <- Completion stamp
+          end
+
+    let expand t height =
+      let sections = t.sections in
+      if not (Height.Array.contains sections height) then begin
+        let sections =
+          Height.Array.extend sections height
+            (fun _ -> Section.create ())
+        in
+        t.sections <- sections;
+        sections
+      end else begin
+        sections
+      end
+
+    let is_initialised t height =
+      match t.initialised with
+      | All -> true
+      | Until until -> Height.less_than height until
+
+    let set_initialised t height =
+      match t.initialised with
+      | All ->
+          failwith "Section.set_initialised: already initialised"
+      | Until until ->
+          if not (Height.equal until height) then begin
+            if Height.less_than until height then
+              failwith "Section.set_initialised: initialised early"
+            else
+              failwith "Section.set_initialised: already initialised"
+          end;
+          t.initialised <- Until (Height.succ until)
+
+    let set_initialised_from t height =
+      match t.initialised with
+      | All ->
+          failwith "Section.set_initialised: already initialised"
+      | Until until ->
+          if not (Height.equal until height) then begin
+            if Height.less_than until height then
+              failwith "Section.set_initialised: initialised early"
+            else
+              failwith "Section.set_initialised: already initialised"
+          end;
+          t.initialised <- All
+
+    let is_completed t height =
+      match t.completed with
+      | All -> true
+      | Until until -> Height.less_than height until
+
+    let set_completed t height =
+      match t.completed with
+      | All ->
+          failwith "Section.set_completed: already completed"
+      | Until until ->
+          if not (Height.equal until height) then begin
+            if Height.less_than until height then
+              failwith "Section.set_completed: completed early"
+            else
+              failwith "Section.set_completed: already completed"
+          end;
+          t.completed <- Until (Height.succ until)
+
+    let set_completed_from t height =
+      match t.completed with
+      | All ->
+          failwith "Section.set_completed: already completed"
+      | Until until ->
+          if not (Height.equal until height) then begin
+            if Height.less_than until height then
+              failwith "Section.set_completed: completed early"
+            else
+              failwith "Section.set_completed: already completed"
+          end;
+          t.completed <- All
+
+    let is_finished t =
+      match t.initialised, t.completed with
+      | All, All -> true
+      | _, _ -> false
+
+    let get t height =
+      let sections = t.sections in
+      if Height.Array.contains sections height then
+        Some (Height.Array.get sections height)
+      else None
+
+    let check_initialised t height =
+      match t.initialised with
+      | All -> ()
+      | Until until ->
+          if not (Height.less_than height until) then
+            failwith "Sections: section not initialised"
+
+    let check_completed t height =
+      match t.completed with
+      | All -> ()
+      | Until until ->
+          if not (Height.less_than height until) then
+            failwith "Sections: section not completed"
+
+    let check_versions t parent =
+      match t.versioning, parent.versioning with
+      | Unversioned, _ | _, Unversioned -> ()
+      | (Completion stamp | Initialisation stamp),
+        (Completion parent_stamp | Initialisation parent_stamp) ->
+          if not (History.Stamp.equal stamp parent_stamp) then
+            failwith "Sections: version mismatch"
+
+    let initialise t height parent =
+      check_versions t parent;
+      check_completed parent height;
+      match get parent height with
+      | Some parent ->
+          let sections = expand t height in
+          let section = Height.Array.get sections height in
+          Section.rebase section parent;
+          set_initialised t height
+      | None ->
+          if is_finished parent then
+            set_initialised_from t height
+          else
+            set_initialised t height
+
+    let add_type graph t height typ path =
+      let sections = expand t height in
+      let section = Height.Array.get sections height in
+      Section.add_type graph section typ path
+
+    let add_class_type graph t height mty path =
+      let sections = expand t height in
+      let section = Height.Array.get sections height in
+      Section.add_class_type graph section mty path
+
+    let add_module_type graph t height mty path =
+      let sections = expand t height in
+      let section = Height.Array.get sections height in
+      Section.add_module_type graph section mty path
+
+    let add_module graph t height md path =
+      let sections = expand t height in
+      let section = Height.Array.get sections height in
+      Section.add_module graph section md path
+
+    (* returns [true] if there might be updated paths at a greater height. *)
+    let iter_updates ~type_ ~class_type ~module_type ~module_ t height id =
+      match get t height with
+      | Some section ->
+          Section.iter_updates ~type_ ~class_type
+            ~module_type ~module_ section id;
+          true
+      | None -> false
+
+    (* returns [true] if there might be forward paths at a greater height. *)
+    let iter_forwards ~type_ ~class_type ~module_type ~module_ t height id =
+      let all_initialised =
+        match t.initialised with
+        | All -> true
+        | Until until ->
+            if not (Height.less_than height until) then
+              failwith "Sections.iter_forwards: section not initialised";
+            false
+      in
+      match get t height with
+      | Some section ->
+          Section.iter_forwards ~type_ ~class_type
+            ~module_type ~module_ section id;
+          true
+      | None -> not all_initialised
+
+    type result =
+      | Not_found_here
+      | Not_found_here_or_later
+      | Found of Path.t
+
+    let rec get_visible_type graph = function
+      | [] -> None
+      | path :: rest ->
+          let visible = Graph.is_type_path_visible graph path in
+          if visible then Some path
+          else get_visible_type graph rest
+
+    let rec get_visible_class_type graph = function
+      | [] -> None
+      | path :: rest ->
+          let visible = Graph.is_class_type_path_visible graph path in
+          if visible then Some path
+          else get_visible_class_type graph rest
+
+    let rec get_visible_module_type graph = function
+      | [] -> None
+      | path :: rest ->
+          let visible = Graph.is_module_type_path_visible graph path in
+          if visible then Some path
+          else get_visible_module_type graph rest
+
+    let rec get_visible_module graph = function
+      | [] -> None
+      | (path, _) :: rest ->
+          let visible = Graph.is_module_path_visible graph path in
+          if visible then Some path
+          else get_visible_module graph rest
+
+    let find_type graph t height typ =
+      check_initialised t height;
+      check_completed t height;
+      match get t height with
+      | Some section -> begin
+          match Section.find_type graph section typ with
+          | exception Not_found -> Not_found_here
+          | paths -> begin
+              match get_visible_type graph paths with
+              | None -> Not_found_here
+              | Some path -> Found path
+            end
+        end
+      | None ->
+          if is_finished t then Not_found_here_or_later
+          else Not_found_here
+
+    let find_class_type graph t height mty =
+      check_initialised t height;
+      check_completed t height;
+      match get t height with
+      | Some section -> begin
+          match Section.find_class_type graph section mty with
+          | exception Not_found -> Not_found_here
+          | paths -> begin
+              match get_visible_class_type graph paths with
+              | None -> Not_found_here
+              | Some path -> Found path
+            end
+        end
+      | None ->
+          if is_finished t then Not_found_here_or_later
+          else Not_found_here
+
+    let find_module_type graph t height mty =
+      check_initialised t height;
+      check_completed t height;
+      match get t height with
+      | Some section -> begin
+          match Section.find_module_type graph section mty with
+          | exception Not_found -> Not_found_here
+          | paths -> begin
+              match get_visible_module_type graph paths with
+              | None -> Not_found_here
+              | Some path -> Found path
+            end
+        end
+      | None ->
+          if is_finished t then Not_found_here_or_later
+          else Not_found_here
+
+    let find_module graph t height md =
+      check_initialised t height;
+      check_completed t height;
+      match get t height with
+      | Some section -> begin
+          match Section.find_module graph section md with
+          | exception Not_found -> Not_found_here
+          | paths -> begin
+              match get_visible_module graph paths with
+              | None -> Not_found_here
+              | Some path -> Found path
+            end
+        end
+      | None ->
+          if is_finished t then Not_found_here_or_later
+          else Not_found_here
+
+  end
+
+  type basis
+
+  type env
+
+  type _ kind =
+    | Basis :
+        { history : History.t; }
+      -> basis kind
+    | Env :
+        { mutable revision : History.Revision.t;
+          parent : 'a t;
+          age : Age.t; }
+      -> env kind
+
+  and 'a t =
+    { kind : 'a kind;
+      mutable graph : Graph.t;
+      sections: Sections.t Origin_tbl.t;
+      todos: Todo.t; }
+
+  let age (type k) (t : k t) =
+    match t.kind with
+    | Basis _ -> Age.zero
+    | Env { age; _ } -> age
+
+  let revision (type k) (t : k t) =
+    match t.kind with
+    | Basis { history } -> History.head history
+    | Env { revision; _ } -> revision
+
+  let stamp t =
+    History.Revision.stamp (revision t)
+
+  let rev_deps t =
+    History.Revision.rev_deps (revision t)
+
+  let update (type kind) (t : kind t) =
+    match t.kind with
+    | Basis _ -> ()
+    | Env ({ revision } as e) ->
+        let rec loop graph revision =
+          let next = History.Revision.next revision in
+          match next with
+          | None -> revision, graph
+          | Some revision ->
+              let diff = History.Revision.diff revision in
+              let graph = Graph.merge graph diff in
+              let rev_deps = History.Revision.rev_deps revision in
+              Todo.merge graph rev_deps t.todos diff;
+              loop graph revision
+        in
+        let revision, graph = loop t.graph revision in
+        t.graph <- graph;
+        e.revision <- revision
+
+  let basis rev_deps components =
+    let graph, diff = Graph.add Graph.empty components in
+    let history = History.init rev_deps diff in
+    let kind = Basis { history } in
+    let sections = Origin_tbl.create 0 in
+    let todos = Todo.create graph rev_deps diff in
+    { kind; graph; sections; todos }
+
+  let local_or_open conc =
+    match conc with
+    | Desc.Local -> Component.Local
+    | Desc.Open -> Component.Open
+
+  let env parent desc =
+    update parent;
+    let age = Age.succ (age parent) in
+    let origin = Origin.Environment age in
+    let components =
+      List.map
+        (fun desc ->
+           match desc with
+           | Desc.Type(id, desc, conc, dpr) ->
+               Component.Type(origin, id, desc, local_or_open conc, dpr)
+           | Desc.Class_type(id, desc, conc, dpr) ->
+               Component.Class_type(origin, id, desc, local_or_open conc, dpr)
+           | Desc.Module_type(id, desc, conc, dpr) ->
+               Component.Module_type(origin, id, desc, local_or_open conc, dpr)
+           | Desc.Module(id, desc, conc, dpr) ->
+               Component.Module(origin, id, desc, local_or_open conc, dpr)
+           | Desc.Declare_type id ->
+               Component.Declare_type(origin, id)
+           | Desc.Declare_class_type id ->
+               Component.Declare_class_type(origin, id)
+           | Desc.Declare_module_type id ->
+               Component.Declare_module_type(origin, id)
+           | Desc.Declare_module id ->
+               Component.Declare_module(origin, id))
+        desc
+    in
+    let graph, diff = Graph.add parent.graph components in
+    let revision = revision parent in
+    let kind = Env { revision; parent; age } in
+    let sections = Origin_tbl.create 0 in
+    let rev_deps = History.Revision.rev_deps revision in
+    let todos = Todo.create graph rev_deps diff in
+    { kind; graph; sections; todos }
+
+  let mutate (t : basis t) rev_deps components =
+    let graph, diff = Graph.add t.graph components in
+    let Basis { history } = t.kind in
+    History.commit history rev_deps diff;
+    t.graph <- graph;
+    Todo.mutate graph rev_deps t.todos diff
+
+  let sections t origin =
+    match Origin_tbl.find t.sections origin with
+    | exception Not_found ->
+        let sections = Sections.create (age t) origin in
+        Origin_tbl.add t.sections origin sections;
+        sections
+    | sections -> sections
+
+  let update_seen t seen =
+    Path_set.fold
+      (fun path acc ->
+         match acc with
+         | None -> None
+         | Some acc ->
+             let md = Graph.find_module t.graph path in
+             let path = Module.path t.graph md in
+             if Path_set.mem path acc then None
+             else Some (Path_set.add path acc))
+      seen (Some Path_set.empty)
+
+  let process_type t height path typ =
+    let canonical_path = Type.path t.graph typ in
+    if not (Path.equal canonical_path path) then begin
+      let origin = Type.origin t.graph typ in
+      let sections = sections t origin in
+      Sections.add_type t.graph sections height typ path
+    end
+
+  let process_module_type t height path mty =
+    let canonical_path = Module_type.path t.graph mty in
+    if not (Path.equal canonical_path path) then begin
+      let origin = Module_type.origin t.graph mty in
+      let sections = sections t origin in
+      Sections.add_module_type t.graph sections height mty path
+    end
+
+  let process_class_type t height path mty =
+    let canonical_path = Class_type.path t.graph mty in
+    if not (Path.equal canonical_path path) then begin
+      let origin = Class_type.origin t.graph mty in
+      let sections = sections t origin in
+      Sections.add_class_type t.graph sections height mty path
+    end
+
+  let process_module t height path seen md =
+    let canonical_path = Module.path t.graph md in
+    if not (Path.equal canonical_path path) then begin
+      let origin = Module.origin t.graph md in
+      let sections = sections t origin in
+      Sections.add_module t.graph sections height md (path, seen);
+    end;
+    if not (Path_set.mem canonical_path seen) then begin
+      let seen = Path_set.add canonical_path seen in
+      Todo.add_children t.graph (rev_deps t) t.todos height md path seen
+    end
+
+  let process_children t height path seen md =
+    let types =
+      match Module.types t.graph md with
+      | Some types -> types
+      | None -> String_map.empty
+    in
+    let class_types =
+      match Module.class_types t.graph md with
+      | Some class_types -> class_types
+      | None -> String_map.empty
+    in
+    let module_types =
+      match Module.module_types t.graph md with
+      | Some module_types -> module_types
+      | None -> String_map.empty
+    in
+    let modules =
+      match Module.modules t.graph md with
+      | Some modules -> modules
+      | None -> String_map.empty
+    in
+    String_map.iter
+      (fun name typ ->
+         if not (Type.hidden typ) then begin
+           let path = Path.Pdot(path, name) in
+           process_type t height path typ
+         end)
+      types;
+    String_map.iter
+      (fun name clty ->
+         if not (Class_type.hidden clty) then begin
+           let path = Path.Pdot(path, name) in
+           process_class_type t height path clty
+         end)
+      class_types;
+    String_map.iter
+      (fun name mty ->
+         if not (Module_type.hidden mty) then begin
+           let path = Path.Pdot(path, name) in
+           process_module_type t height path mty
+         end)
+      module_types;
+    String_map.iter
+      (fun name md ->
+         if not (Module.hidden md) then begin
+           let path = Path.Pdot(path, name) in
+           process_module t height path seen md
+         end)
+      modules
+
+  let rec process : 'k . 'k t -> _ =
+    fun t origin height ->
+      let todo = Todo.pop (rev_deps t) t.todos height origin in
+      match todo with
+      | None -> true
+      | Some items ->
+          List.iter
+            (function
+              | Todo.Item.Base (Diff.Item.Type(id, typ, _)) ->
+                  if not (Type.hidden typ) then begin
+                    let path = Path.Pident id in
+                    process_type t height path typ
+                  end
+              | Todo.Item.Base (Diff.Item.Class_type(id, clty, _)) ->
+                  if not (Class_type.hidden clty) then begin
+                    let path = Path.Pident id in
+                    process_class_type t height path clty
+                  end
+              | Todo.Item.Base (Diff.Item.Module_type(id, mty, _)) ->
+                  if not (Module_type.hidden mty) then begin
+                    let path = Path.Pident id in
+                    process_module_type t height path mty
+                  end
+              | Todo.Item.Base (Diff.Item.Module(id, md, _)) ->
+                  if not (Module.hidden md) then begin
+                    let path = Path.Pident id in
+                    process_module t height path Path_set.empty md
+                  end
+              | Todo.Item.Children{md; path; seen} ->
+                  process_children t height path seen md
+              | Todo.Item.Update{ id; origin } ->
+                  process_update t origin height id
+              | Todo.Item.Forward{ id; decl; origin } ->
+                  process_forward t origin height id decl)
+            items;
+            false
+
+  and process_update : 'k . 'k t -> _ =
+    fun t origin height id ->
+      let sections = sections t origin in
+      let more =
+        Sections.iter_updates sections height id
+          ~type_:(fun canon path ->
+            let typ = Graph.find_type t.graph canon in
+            process_type t height path typ)
+          ~class_type:(fun canon path ->
+            let clty = Graph.find_class_type t.graph canon in
+            process_class_type t height path clty)
+          ~module_type:(fun canon path ->
+            let mty = Graph.find_module_type t.graph canon in
+            process_module_type t height path mty)
+          ~module_:(fun canon (path, seen) ->
+            let md = Graph.find_module t.graph canon in
+            match update_seen t seen with
+            | None -> ()
+            | Some seen ->
+              process_module t height path seen md);
+      in
+      if more then begin
+        Todo.add_next_update (rev_deps t) t.todos height origin id
+      end
+
+
+  and process_forward : 'k . 'k t -> _ =
+    fun t origin height id decl ->
+      let sections = init t decl height in
+      let more =
+        Sections.iter_forwards sections height id
+          ~type_:(fun canon path ->
+            let typ = Graph.find_type t.graph canon in
+            process_type t height path typ)
+          ~class_type:(fun canon path ->
+            let clty = Graph.find_class_type t.graph canon in
+            process_class_type t height path clty)
+          ~module_type:(fun canon path ->
+            let mty = Graph.find_module_type t.graph canon in
+            process_module_type t height path mty)
+          ~module_:(fun canon (path, seen) ->
+            let md = Graph.find_module t.graph canon in
+            match update_seen t seen with
+            | None -> ()
+            | Some seen ->
+              process_module t height path seen md);
+      in
+      if more then begin
+        Todo.add_next_forward (rev_deps t) t.todos height origin id decl
+      end
+
+  and initialise : type k. k t -> _ =
+    fun t sections origin height ->
+      if not (Sections.is_initialised sections height) then begin
+        begin match Height.pred height with
+        | None -> ()
+        | Some pred -> initialise t sections origin pred
+        end;
+        let parent =
+          match t.kind with
+          | Basis _ -> assert false
+          | Env { parent; _ } ->
+              update parent;
+              force parent origin height
+        in
+        Sections.initialise sections height parent
+      end
+
+  and init : 'k . 'k t -> _ =
+    fun t origin height ->
+      let sections = sections t origin in
+      Sections.update sections (stamp t);
+      initialise t sections origin height;
+      sections
+
+  and complete : 'k. 'k t -> _ =
+    fun t sections origin height ->
+      if not (Sections.is_completed sections height) then begin
+        begin match Height.pred height with
+        | None -> ()
+        | Some pred -> ignore (complete t sections origin pred)
+        end;
+        let finished = process t origin height in
+        if finished then Sections.set_completed_from sections height
+        else Sections.set_completed sections height
+      end
+
+  and force : 'k. 'k t -> _ =
+    fun t origin height ->
+      let sections = sections t origin in
+      Sections.update sections (stamp t);
+      initialise t sections origin height;
+      complete t sections origin height;
+      sections
+
+  module Search = struct
+
+    type 'a shortest = 'a t
+
+    type _ kind =
+      | Type : Type.t kind
+      | Class_type : Class_type.t kind
+      | Module_type : Module_type.t kind
+      | Module : Module.t kind
+
+    type name =
+      { name : string;
+        height : Height.t; }
+
+    type 'a t =
+      | Ident of
+          { kind : 'a kind;
+            node : 'a;
+            origin : Origin.t;
+            best : Path.t;
+            min: Height.t;
+            max: Height.t;
+            finished : bool; }
+      | Dot of
+          { kind : 'a kind;
+            node : 'a;
+            origin : Origin.t;
+            best : Path.t;
+            min: Height.t;
+            max: Height.t;
+            parent : Module.t t;
+            name : name;
+            searched : bool;
+            finished : bool; }
+      | Application of
+          { kind : 'a kind;
+            node : 'a;
+            origin : Origin.t;
+            best : Path.t;
+            min: Height.t;
+            max: Height.t;
+            func : Module.t t;
+            arg : Module.t t;
+            func_first : bool;
+            searched : bool;
+            finished : bool; }
+
+    let min_height = function
+      | Ident { min; _ } -> min
+      | Dot { min; _ } -> min
+      | Application { min; _ } -> min
+
+    let max_height = function
+      | Ident { max; _ } -> max
+      | Dot { max; _ } -> max
+      | Application { max; _ } -> max
+
+    let search_origin = function
+      | Ident { origin; _ } -> origin
+      | Dot { origin; _ } -> origin
+      | Application { origin; _ } -> origin
+
+    let finished = function
+      | Ident { finished; _ } -> finished
+      | Dot { finished; _ } -> finished
+      | Application { finished; _ } -> finished
+
+    let best = function
+      | Ident { best; _ } -> best
+      | Dot { best; _ } -> best
+      | Application { best; _ } -> best
+
+    let min_application fst snd =
+      Height.plus (min_height fst) (min_height snd)
+
+    let max_application fst snd =
+      Height.plus (max_height fst) (max_height snd)
+
+    let min_dot parent name =
+      let base = min_height parent in
+      Height.plus base name.height
+
+    let path_application fst snd =
+      Path.Papply(best fst, best snd)
+
+    let path_dot parent name =
+      Path.Pdot(best parent, name.name)
+
+    let is_visible_ident (type k) graph (kind : k kind) id =
+      match kind with
+      | Type -> Graph.is_type_ident_visible graph id
+      | Class_type -> Graph.is_class_type_ident_visible graph id
+      | Module_type -> Graph.is_module_type_ident_visible graph id
+      | Module -> Graph.is_module_ident_visible graph id
+
+    let create (type k) shortest (kind : k kind) canonical_path =
+      let rec loop : type k. k kind -> Path.t -> k t =
+        fun kind path ->
+          let graph = shortest.graph in
+          let (node : k), origin, hidden =
+            match kind with
+            | Type ->
+                let node = Graph.find_type graph path in
+                let origin = Type.origin graph node in
+                let hidden = Type.hidden node in
+                node, origin, hidden
+            | Class_type ->
+                let node = Graph.find_class_type graph path in
+                let origin = Class_type.origin graph node in
+                let hidden = Class_type.hidden node in
+                node, origin, hidden
+            | Module_type ->
+                let node = Graph.find_module_type graph path in
+                let origin = Module_type.origin graph node in
+                let hidden = Module_type.hidden node in
+                node, origin, hidden
+            | Module ->
+                let node = Graph.find_module graph path in
+                let origin = Module.origin graph node in
+                let hidden = Module.hidden node in
+                node, origin, hidden
+          in
+          let best = path in
+          match path with
+          | Path.Pident id ->
+              let max =
+                if is_visible_ident graph kind id && not hidden then
+                  Height.one
+                else
+                  Height.maximum
+              in
+              let min = Height.one in
+              let finished = false in
+              Ident { kind; node; origin; best; min; max; finished }
+          | Path.Pdot(parent, name) ->
+              let parent = loop Module parent in
+              let finished = false in
+              let name_height =
+                if not hidden then Height.one
+                else Height.maximum
+              in
+              let name = { name; height = name_height } in
+              let searched = false in
+              let max = Height.plus (max_height parent) name_height in
+              let min = Height.one in
+              Dot
+                { kind; node; origin; best; min; max;
+                  parent; name; searched; finished }
+          | Path.Papply(func, arg) ->
+              let func = loop Module func in
+              let arg = loop Module arg in
+              let func_first =
+                Rev_deps.before (rev_deps shortest)
+                  (search_origin arg) (search_origin func)
+              in
+              let finished = false in
+              (* There are no module aliases containing extended paths *)
+              let searched = true in
+              let max = max_application func arg in
+              let min = min_application func arg in
+              Application
+                { kind; node; origin; best; min; max;
+                  func; arg; func_first; searched; finished }
+      in
+      loop kind canonical_path
+
+    let find (type k) shortest origin height (kind : k kind) (node : k) =
+      let sections = force shortest origin height in
+      match kind with
+      | Type ->
+          Sections.find_type shortest.graph sections height node
+      | Class_type ->
+          Sections.find_class_type shortest.graph sections height node
+      | Module_type ->
+          Sections.find_module_type shortest.graph sections height node
+      | Module ->
+          Sections.find_module shortest.graph sections height node
+
+    let rec step : type k . _ shortest -> k t -> k t =
+      fun shortest search ->
+        if finished search then search
+        else begin
+          match search with
+          | Ident r -> begin
+              match find shortest r.origin r.min r.kind r.node with
+              | Sections.Not_found_here ->
+                  if Height.equal r.min r.max then
+                    Ident { r with finished = true }
+                  else
+                    Ident { r with min = Height.succ r.min }
+              | Sections.Not_found_here_or_later ->
+                  Ident { r with finished = true; min = r.max }
+              | Sections.Found path ->
+                  let best = path in
+                  let max = r.min in
+                  let finished = true in
+                  Ident { r with best; max; finished }
+            end
+          | Dot r ->
+              let parent = r.parent in
+              let parent =
+                let should_try_dot =
+                  Height.equal
+                    (min_dot parent r.name) r.min
+                in
+                if not should_try_dot then parent
+                else step shortest parent
+              in
+              let found =
+                finished parent
+                && Height.equal (min_dot parent r.name) r.min
+              in
+              if found then begin
+                let best = path_dot parent r.name in
+                let max = r.min in
+                let finished = true in
+                Dot
+                  { r with best; parent; max; finished }
+              end else begin
+                let best, max, searched, finished =
+                  if r.searched then r.best, r.max, r.searched, r.finished
+                  else begin
+                    match find shortest r.origin r.min r.kind r.node with
+                    | Sections.Not_found_here ->
+                        r.best, r.max, (Height.equal r.min r.max), r.finished
+                    | Sections.Not_found_here_or_later ->
+                        r.best, r.max, true, r.finished
+                    | Sections.Found path ->
+                        path, r.min, true, true
+                  end
+                in
+                let finished =
+                  finished ||
+                  (searched
+                   && Height.less_than_or_equal
+                        r.max (min_dot parent r.name))
+                in
+                let min = if finished then max else Height.succ r.min in
+                Dot { r with best; parent; min; max; searched; finished }
+              end
+         | Application r ->
+              let try_app searched =
+                let fst, snd =
+                  if r.func_first then r.func, r.arg
+                  else r.arg, r.func
+                in
+                let fst, snd =
+                  let should_try_app =
+                    Height.equal (min_application fst snd) r.min
+                  in
+                  if not should_try_app then fst, snd
+                  else begin
+                    let fst = step shortest fst in
+                    let should_try_app =
+                      Height.equal (min_application fst snd) r.min
+                    in
+                    if not should_try_app then fst, snd
+                    else fst, step shortest snd
+                  end
+                in
+                let func, arg =
+                  if r.func_first then fst, snd
+                  else snd, fst
+                in
+                let found =
+                  finished func && finished arg
+                  && Height.equal (min_application fst snd) r.min
+                in
+                if found then begin
+                  let best = path_application func arg in
+                  let max = r.min in
+                  let finished = true in
+                  Application
+                    { r with best; func; arg; max; searched; finished }
+                end else begin
+                  let finished =
+                    searched
+                    && Height.less_than_or_equal
+                         r.max (min_application fst snd)
+                  in
+                  let min = if finished then r.max else Height.succ r.min in
+                  Application
+                    { r with func; arg; min; searched; finished }
+                end
+              in
+              if r.searched then try_app true
+              else begin
+                match find shortest r.origin r.min r.kind r.node with
+                | Sections.Not_found_here ->
+                    try_app (Height.equal r.min r.max)
+                | Sections.Not_found_here_or_later ->
+                    try_app true
+                | Sections.Found path ->
+                    let best = path in
+                    let max = r.min in
+                    let searched = true in
+                    let finished = true in
+                    Application { r with best; max; searched; finished }
+              end
+        end
+
+    let rec perform shortest search =
+      if finished search then best search
+      else perform shortest (step shortest search)
+
+  end
+
+  let find_type t path =
+    update t;
+    let typ = Graph.find_type t.graph path in
+    match Type.resolve t.graph typ with
+    | Type.Nth n -> Nth n
+    | Type.Path(subst, typ) ->
+      let canonical_path = Type.path t.graph typ in
+      let search = Search.create t Search.Type canonical_path in
+      let path = Search.perform t search in
+      Path(subst, path)
+
+  let find_type_resolution t path : type_resolution =
+    update t;
+    let typ = Graph.find_type t.graph path in
+    match Type.resolve t.graph typ with
+    | Type.Nth n -> Nth n
+    | Type.Path(Some ns, _) -> Subst ns
+    | Type.Path(None, _) -> Id
+
+  let find_type_simple t path =
+    update t;
+    let typ = Graph.find_type t.graph path in
+    let canonical_path = Type.path t.graph typ in
+    let search = Search.create t Search.Type canonical_path in
+    Search.perform t search
+
+  let find_class_type t path =
+    update t;
+    let clty = Graph.find_class_type t.graph path in
+    let subst, clty = Class_type.resolve t.graph clty in
+    let canonical_path = Class_type.path t.graph clty in
+    let search = Search.create t Search.Class_type canonical_path in
+    let path = Search.perform t search in
+    (subst, path)
+
+  let find_class_type_simple t path =
+    update t;
+    let clty = Graph.find_class_type t.graph path in
+    let canonical_path = Class_type.path t.graph clty in
+    let search = Search.create t Search.Class_type canonical_path in
+    Search.perform t search
+
+  let find_module_type t path =
+    update t;
+    let mty = Graph.find_module_type t.graph path in
+    let canonical_path = Module_type.path t.graph mty in
+    let search = Search.create t Search.Module_type canonical_path in
+    Search.perform t search
+
+  let find_module t path =
+    update t;
+    let md = Graph.find_module t.graph path in
+    let canonical_path = Module.path t.graph md in
+    let search = Search.create t Search.Module canonical_path in
+    Search.perform t search
+
+end
+
+module String_set = Set.Make(String)
+
+module Basis = struct
+
+  type load =
+    { name : string;
+      depends : string list;
+      alias_depends : string list;
+      desc : Desc.Module.t;
+      deprecated : Desc.deprecated; }
+
+  type t =
+    { mutable next_dep : Dependency.t;
+      mutable pending_additions : String_set.t;
+      mutable pending_loads : load list;
+      mutable assignment : Dependency.t String_map.t;
+      rev_deps : Rev_deps.t;
+      mutable shortest : Shortest.basis Shortest.t option; }
+
+  let create () =
+    { next_dep = Dependency.zero;
+      pending_additions = String_set.empty;
+      pending_loads = [];
+      assignment = String_map.empty;
+      rev_deps = Rev_deps.create ();
+      shortest = None; }
+
+  let update_assignments t additions =
+    String_set.iter
+      (fun name ->
+         if not (String_map.mem name t.assignment) then begin
+           t.assignment <- String_map.add name t.next_dep t.assignment;
+           t.next_dep <- Dependency.succ t.next_dep
+         end)
+      additions
+
+  let update_rev_deps t loads =
+    Rev_deps.extend_up_to t.rev_deps t.next_dep;
+    List.iter
+      (fun { name; depends; alias_depends; _ } ->
+         let index = String_map.find name t.assignment in
+         List.iter
+           (fun dep_name ->
+              let dep_index = String_map.find dep_name t.assignment in
+              Rev_deps.add t.rev_deps ~source:dep_index ~target:index)
+           depends;
+         List.iter
+           (fun dep_name ->
+              let dep_index = String_map.find dep_name t.assignment in
+              Rev_deps.add_alias t.rev_deps ~source:dep_index ~target:index)
+           alias_depends)
+      loads
+
+  let update_shortest t additions loads =
+    let components =
+      List.map
+        (fun { name; desc; deprecated; _ } ->
+           let index = String_map.find name t.assignment in
+           let origin = Origin.Dependency index in
+           let id = Ident.global name in
+           Component.Module(origin, id, desc, Component.Global, deprecated))
+        loads
+    in
+    let components =
+      String_set.fold
+        (fun name acc ->
+           let index = String_map.find name t.assignment in
+           let origin = Origin.Dependency index in
+           let id = Ident.global name in
+           Component.Declare_module(origin, id) :: acc)
+        additions
+        components
+    in
+    match t.shortest with
+    | None ->
+        t.shortest <- Some (Shortest.basis t.rev_deps components)
+    | Some shortest ->
+        Shortest.mutate shortest t.rev_deps components
+
+  let update t =
+    let loads = t.pending_loads in
+    let additions = t.pending_additions in
+    match loads, String_set.is_empty additions with
+    | [], true -> ()
+    | _, _ ->
+      t.pending_loads <- [];
+      t.pending_additions <- String_set.empty;
+      let loads = List.rev loads in
+      update_assignments t additions;
+      update_rev_deps t loads;
+      update_shortest t additions loads
+
+  let shortest t =
+    update t;
+    match t.shortest with
+    | None ->
+        let shortest = Shortest.basis t.rev_deps [] in
+        t.shortest <- Some shortest;
+        shortest
+    | Some shortest -> shortest
+
+  let add t name =
+    t.pending_additions <- String_set.add name t.pending_additions
+
+  let load t name depends alias_depends desc deprecated =
+    let load = { name; depends; alias_depends; desc; deprecated } in
+    t.pending_loads <- load :: t.pending_loads
+
+end
+
+type state =
+  | Initial of Basis.t
+  | Unforced of
+      { parent : t;
+        desc : Desc.t list Lazy.t; }
+  | Forced of
+      { basis : Basis.t;
+        shortest : Shortest.env Shortest.t; }
+
+and t = state ref
+
+let rec force t =
+  match !t with
+  | Initial _ | Forced _ as state -> state
+  | Unforced { parent; desc } ->
+    let desc = Lazy.force desc in
+    let state =
+      match force parent with
+      | Unforced _ -> assert false
+      | Initial basis ->
+        let shortest = Shortest.env (Basis.shortest basis) desc in
+        Forced { basis; shortest }
+      | Forced { basis; shortest } ->
+        let shortest = Shortest.env shortest desc in
+        Forced { basis; shortest }
+    in
+    t := state;
+    state
+
+let initial basis = ref (Initial basis)
+
+let add parent desc =
+  ref (Unforced { parent; desc })
+
+type ext_shortest = Shortest : 'k Shortest.t -> ext_shortest
+
+let shortest t =
+  match force t with
+  | Unforced _ -> assert false
+  | Initial basis ->
+      Basis.update basis;
+      Shortest (Basis.shortest basis)
+  | Forced { basis; shortest } ->
+      Basis.update basis;
+      Shortest shortest
+
+let find_type t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_type shortest path with
+  | exception Not_found -> Path(None, path)
+  | result -> result
+
+let find_type_resolution t path : type_resolution =
+  let Shortest shortest = shortest t in
+  match Shortest.find_type_resolution shortest path with
+  | exception Not_found -> Id
+  | subst -> subst
+
+let find_type_simple t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_type_simple shortest path with
+  | exception Not_found -> path
+  | path -> path
+
+let find_class_type t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_class_type shortest path with
+  | exception Not_found -> (None, path)
+  | result -> result
+
+let find_class_type_simple t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_class_type_simple shortest path with
+  | exception Not_found -> path
+  | path -> path
+
+let find_module_type t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_module_type shortest path with
+  | exception Not_found -> path
+  | path -> path
+
+let find_module t path =
+  let Shortest shortest = shortest t in
+  match Shortest.find_module shortest path with
+  | exception Not_found -> path
+  | path -> path
diff --git a/src/ocaml/typing/410+multicore/short_paths.mli b/src/ocaml/typing/410+multicore/short_paths.mli
new file mode 100644
index 00000000..1cc7608f
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/short_paths.mli
@@ -0,0 +1,46 @@
+
+module Desc = Short_paths_graph.Desc
+
+module Basis : sig
+
+  type t
+
+  val create : unit -> t
+
+  val add : t -> string -> unit
+
+  val load : t -> string -> string list -> string list ->
+    Desc.Module.t -> Desc.deprecated -> unit
+
+end
+
+type t
+
+val initial : Basis.t -> t
+
+val add : t -> Desc.t list Lazy.t -> t
+
+type type_result =
+  | Nth of int
+  | Path of int list option * Path.t
+
+val find_type : t -> Path.t -> type_result
+
+type type_resolution =
+  | Nth of int
+  | Subst of int list
+  | Id
+
+val find_type_resolution : t -> Path.t -> type_resolution
+
+val find_type_simple : t -> Path.t -> Path.t
+
+type class_type_result = int list option * Path.t
+
+val find_class_type : t -> Path.t -> class_type_result
+
+val find_class_type_simple : t -> Path.t -> Path.t
+
+val find_module_type : t -> Path.t -> Path.t
+
+val find_module : t -> Path.t -> Path.t
diff --git a/src/ocaml/typing/410+multicore/short_paths_graph.ml b/src/ocaml/typing/410+multicore/short_paths_graph.ml
new file mode 100644
index 00000000..1b2fbde6
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/short_paths_graph.ml
@@ -0,0 +1,1535 @@
+
+module String_map = Misc.String.Map
+
+module Ident = struct
+
+  type t = Ident.t
+
+  let equal t1 t2 = Ident.equal t1 t2
+
+  let compare t1 t2 = Ident.compare t1 t2
+
+  let name = Ident.name
+
+  let global name =
+    Ident.create_persistent name
+
+end
+
+module Ident_map = Map.Make(Ident)
+module Ident_set = Set.Make(Ident)
+
+module Path = struct
+
+  type t = Path.t =
+    | Pident of Ident.t
+    | Pdot of t * string
+    | Papply of t * t
+
+  open Path
+
+  let rec equal t1 t2 =
+    match t1, t2 with
+    | Pident id1, Pident id2 -> Ident.equal id1 id2
+    | Pident _, Pdot _ -> false
+    | Pident _, Papply _ -> false
+    | Pdot _, Pident _ -> false
+    | Pdot(parent1, name1), Pdot(parent2, name2) ->
+        equal parent1 parent2
+        && String.equal name1 name2
+    | Pdot _, Papply _ -> false
+    | Papply _, Pident _ -> false
+    | Papply _, Pdot _ -> false
+    | Papply(func1, arg1), Papply(func2, arg2) ->
+        equal func1 func2
+        && equal arg1 arg2
+
+  let rec compare t1 t2 =
+    match t1, t2 with
+    | Pident id1, Pident id2 -> Ident.compare id1 id2
+    | Pident _, Pdot _ -> -1
+    | Pident _, Papply _ -> -1
+    | Pdot _, Pident _ -> 1
+    | Pdot(parent1, name1), Pdot(parent2, name2) ->
+        let c = compare parent1 parent2 in
+        if c <> 0 then c
+        else String.compare name1 name2
+    | Pdot _, Papply _ -> -1
+    | Papply _, Pident _ -> 1
+    | Papply _, Pdot _ -> 1
+    | Papply(func1, arg1), Papply(func2, arg2) ->
+        let c = compare func1 func2 in
+        if c <> 0 then c
+        else compare arg1 arg2
+
+end
+
+module Path_map = Map.Make(Path)
+module Path_set = Set.Make(Path)
+
+module Desc = struct
+
+  type deprecated =
+    | Deprecated
+    | Not_deprecated
+
+  module Type = struct
+
+    type t =
+      | Fresh
+      | Nth of int
+      | Subst of Path.t * int list
+      | Alias of Path.t
+
+  end
+
+  module Module_type = struct
+
+    type t =
+      | Fresh
+      | Alias of Path.t
+
+  end
+
+  module Class_type = struct
+
+    type t =
+      | Fresh
+      | Subst of Path.t * int list
+      | Alias of Path.t
+
+  end
+
+  module Module = struct
+
+    type component =
+      | Type of string * Type.t * deprecated
+      | Class_type of string * Class_type.t * deprecated
+      | Module_type of string * Module_type.t * deprecated
+      | Module of string * t * deprecated
+
+    and components = component list
+
+    and kind =
+      | Signature of components Lazy.t
+      | Functor of (Path.t -> t)
+
+    and t =
+      | Fresh of kind
+      | Alias of Path.t
+
+  end
+
+  type source =
+    | Local
+    | Open
+
+  type t =
+    | Type of Ident.t * Type.t * source * deprecated
+    | Class_type of Ident.t * Class_type.t * source * deprecated
+    | Module_type of Ident.t * Module_type.t * source * deprecated
+    | Module of Ident.t * Module.t * source * deprecated
+    | Declare_type of Ident.t
+    | Declare_class_type of Ident.t
+    | Declare_module_type of Ident.t
+    | Declare_module of Ident.t
+
+end
+
+module Sort = struct
+
+  type t =
+    | Defined
+    | Declared of Ident_set.t
+
+  let application t1 t2 =
+    match t1, t2 with
+    | Defined, Defined -> Defined
+    | Defined, Declared _ -> t2
+    | Declared _, Defined -> t1
+    | Declared ids1, Declared ids2 -> Declared (Ident_set.union ids1 ids2)
+
+end
+
+module Age = Natural.Make()
+
+module Dependency = Natural.Make()
+
+module Origin = struct
+
+  type t =
+    | Dependency of Dependency.t
+    | Dependencies of Dependency.t list
+    | Environment of Age.t
+
+  let rec deps_add dep deps =
+    match deps with
+    | [] -> [dep]
+    | dep' :: rest ->
+      if Dependency.equal dep dep' then
+        deps
+      else if Dependency.less_than dep dep' then
+        dep :: deps
+      else
+        dep' :: deps_add dep rest
+
+  let rec deps_union deps1 deps2 =
+    match deps1, deps2 with
+    | [], _ -> deps2
+    | _, [] -> deps1
+    | dep1 :: rest1, dep2 :: rest2 ->
+        if Dependency.equal dep1 dep2 then
+          dep1 :: deps_union rest1 rest2
+        else if Dependency.less_than dep1 dep2 then
+          dep1 :: deps_union rest1 deps2
+        else
+          dep2 :: deps_union deps1 rest2
+
+  let rec deps_equal deps1 deps2 =
+    match deps1, deps2 with
+    | [], [] -> true
+    | [], _ :: _ -> false
+    | _ :: _, [] -> false
+    | dep1 :: rest1, dep2 :: rest2 ->
+        Dependency.equal dep1 dep2
+        && deps_equal rest1 rest2
+
+  let application t1 t2 =
+    match t1, t2 with
+    | Dependency dep1, Dependency dep2 ->
+        if Dependency.equal dep1 dep2 then t1
+        else if Dependency.less_than dep1 dep2 then
+          Dependencies [dep1; dep2]
+        else
+          Dependencies [dep2; dep1]
+    | Dependency dep1, Dependencies deps2 ->
+        Dependencies (deps_add dep1 deps2)
+    | Dependency _, Environment _ -> t2
+    | Dependencies deps1, Dependency dep2 ->
+        Dependencies (deps_add dep2 deps1)
+    | Dependencies deps1, Dependencies deps2 ->
+        Dependencies (deps_union deps1 deps2)
+    | Dependencies _, Environment _ -> t2
+    | Environment _, Dependency _ -> t1
+    | Environment _, Dependencies _ -> t1
+    | Environment age1, Environment age2 ->
+        Environment (Age.max age1 age2)
+
+  let equal t1 t2 =
+    match t1, t2 with
+    | Dependency dep1, Dependency dep2 -> Dependency.equal dep1 dep2
+    | Dependency _, Dependencies _ -> false
+    | Dependency _, Environment _ -> false
+    | Dependencies _, Dependency _ -> false
+    | Dependencies deps1, Dependencies deps2 -> deps_equal deps1 deps2
+    | Dependencies _, Environment _ -> false
+    | Environment _, Dependency _ -> false
+    | Environment _, Dependencies _ -> false
+    | Environment env1, Environment env2 -> Age.equal env1 env2
+
+  let hash = Hashtbl.hash
+
+end
+
+let hidden_name name =
+  if name <> "" && name.[0] = '_' then true
+  else
+    try
+      for i = 1 to String.length name - 2 do
+        if name.[i] = '_' && name.[i + 1] = '_' then
+          raise Exit
+      done;
+      false
+    with Exit -> true
+
+let hidden_ident id =
+  if !Clflags.unsafe_string && Ident.equal id Predef.ident_bytes then true
+  else hidden_name (Ident.name id)
+
+let hidden_definition deprecated name =
+  match deprecated with
+  | Desc.Deprecated -> true
+  | Desc.Not_deprecated -> hidden_name name
+
+let hidden_base_definition deprecated id =
+  match deprecated with
+  | Desc.Deprecated -> true
+  | Desc.Not_deprecated -> hidden_ident id
+
+module rec Type : sig
+
+  type t
+
+  val base : Origin.t -> Ident.t -> Desc.Type.t option -> Desc.deprecated -> t
+
+  val child :
+    Module.normalized -> string -> Desc.Type.t option -> Desc.deprecated -> t
+
+  val declare : Origin.t -> Ident.t -> t
+
+  val declaration : t -> Origin.t option
+
+  val origin : Graph.t -> t -> Origin.t
+
+  val path : Graph.t -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : Graph.t -> t -> Sort.t
+
+  type resolved =
+    | Nth of int
+    | Path of int list option * t
+
+  val resolve : Graph.t -> t -> resolved
+
+end = struct
+
+  open Desc.Type
+
+  type definition =
+    | Alias of Path.t
+    | Defined
+    | Nth of int
+    | Subst of Path.t * int list
+    | Unknown
+
+  type t =
+    | Declaration of
+        { origin : Origin.t;
+          id : Ident.t;
+          hidden : bool; }
+    | Definition of
+        { origin : Origin.t;
+          path : Path.t;
+          hidden : bool;
+          sort : Sort.t;
+          definition : definition; }
+
+  let definition_of_desc (desc : Desc.Type.t option) =
+    match desc with
+    | None -> Unknown
+    | Some Fresh -> Defined
+    | Some (Nth n) -> Nth n
+    | Some (Subst(p, ns)) -> Subst(p, ns)
+    | Some (Alias alias) -> Alias alias
+
+  let base origin id desc deprecated =
+    let path = Path.Pident id in
+    let hidden = hidden_base_definition deprecated id in
+    let sort = Sort.Defined in
+    let definition = definition_of_desc desc in
+    Definition { origin; path; hidden; sort; definition }
+
+  let child md name desc deprecated =
+    let origin = Module.raw_origin md in
+    let sort = Module.raw_sort md in
+    let path = Path.Pdot(Module.raw_path md, name) in
+    let hidden = hidden_definition deprecated name in
+    let definition = definition_of_desc desc in
+    Definition { origin; path; hidden; sort; definition }
+
+  let declare origin id =
+    let hidden = hidden_ident id in
+    Declaration { origin; id; hidden }
+
+  let declaration t =
+    match t with
+    | Definition _ -> None
+    | Declaration { origin; _} -> Some origin
+
+  let hidden t =
+    match t with
+    | Definition { hidden; _ } -> hidden
+    | Declaration { hidden; _ } -> hidden
+
+  let raw_origin t =
+    match t with
+    | Declaration { origin; _ }
+    | Definition { origin; _ } -> origin
+
+  let raw_path t =
+    match t with
+    | Declaration { id; _ } -> Path.Pident id
+    | Definition { path; _ } -> path
+
+  let raw_sort t =
+    match t with
+    | Declaration { id; _ } -> Sort.Declared (Ident_set.singleton id)
+    | Definition { sort; _ } -> sort
+
+  let rec normalize_loop root t =
+    match t with
+    | Declaration _ -> t
+    | Definition { definition = Defined | Unknown | Nth _ | Subst _ } -> t
+    | Definition ({ definition = Alias alias } as r) -> begin
+        match Graph.find_type root alias with
+        | exception Not_found -> Definition { r with definition = Unknown }
+        | aliased -> normalize_loop root aliased
+      end
+
+  let normalize root t =
+    match t with
+    | Definition { sort = Sort.Defined } -> normalize_loop root t
+    | Definition { sort = Sort.Declared _ } | Declaration _ ->
+        match Graph.find_type root (raw_path t) with
+        | exception Not_found -> normalize_loop root t
+        | t -> normalize_loop root t
+
+  let origin root t =
+    raw_origin (normalize root t)
+
+  let path root t =
+    raw_path (normalize root t)
+
+  let sort root t =
+    raw_sort (normalize root t)
+
+  type resolved =
+    | Nth of int
+    | Path of int list option * t
+
+  let subst ns = function
+    | Nth n -> Nth (List.nth ns n)
+    | Path(None, p) -> Path(Some ns, p)
+    | Path(Some ms, p) -> Path(Some (List.map (List.nth ns) ms), p)
+
+  let rec resolve root t =
+    match normalize root t with
+    | Declaration _ -> Path(None, t)
+    | Definition { definition = Defined | Unknown } -> Path(None, t)
+    | Definition { definition = Nth n } -> Nth n
+    | Definition { definition = Subst(p, ns) } -> begin
+        match Graph.find_type root p with
+        | exception Not_found -> Path(None, t)
+        | aliased -> subst ns (resolve root aliased)
+      end
+    | Definition { definition = Alias _ } -> assert false
+
+end
+
+and Class_type : sig
+
+  type t
+
+  val base :
+    Origin.t -> Ident.t -> Desc.Class_type.t option -> Desc.deprecated -> t
+
+  val child :
+    Module.normalized -> string ->
+    Desc.Class_type.t option -> Desc.deprecated -> t
+
+  val declare : Origin.t -> Ident.t -> t
+
+  val declaration : t -> Origin.t option
+
+  val origin : Graph.t -> t -> Origin.t
+
+  val path : Graph.t -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : Graph.t -> t -> Sort.t
+
+  type resolved = int list option * t
+
+  val resolve : Graph.t -> t -> resolved
+
+end = struct
+
+  open Desc.Class_type
+
+  type definition =
+    | Alias of Path.t
+    | Defined
+    | Subst of Path.t * int list
+    | Unknown
+
+  type t =
+    | Declaration of
+        { origin : Origin.t;
+          id : Ident.t;
+          hidden : bool; }
+    | Definition of
+        { origin : Origin.t;
+          path : Path.t;
+          hidden : bool;
+          sort : Sort.t;
+          definition : definition; }
+
+  let definition_of_desc (desc : Desc.Class_type.t option) =
+    match desc with
+    | None -> Unknown
+    | Some Fresh -> Defined
+    | Some (Subst(p, ns)) -> Subst(p, ns)
+    | Some (Alias alias) -> Alias alias
+
+  let base origin id desc deprecated =
+    let path = Path.Pident id in
+    let hidden = hidden_base_definition deprecated id in
+    let sort = Sort.Defined in
+    let definition = definition_of_desc desc in
+    Definition { origin; path; hidden; sort; definition }
+
+  let child md name desc deprecated =
+    let origin = Module.raw_origin md in
+    let sort = Module.raw_sort md in
+    let path = Path.Pdot(Module.raw_path md, name) in
+    let hidden = hidden_definition deprecated name in
+    let definition = definition_of_desc desc in
+    Definition { origin; path; hidden; sort; definition }
+
+  let declare origin id =
+    let hidden = hidden_ident id in
+    Declaration { origin; id; hidden }
+
+  let declaration t =
+    match t with
+    | Definition _ -> None
+    | Declaration { origin; _} -> Some origin
+
+  let hidden t =
+    match t with
+    | Definition { hidden; _ } -> hidden
+    | Declaration { hidden; _ } -> hidden
+
+  let raw_origin t =
+    match t with
+    | Declaration { origin; _ }
+    | Definition { origin; _ } -> origin
+
+  let raw_path t =
+    match t with
+    | Declaration { id; _ } -> Path.Pident id
+    | Definition { path; _ } -> path
+
+  let raw_sort t =
+    match t with
+    | Declaration { id; _ } -> Sort.Declared (Ident_set.singleton id)
+    | Definition { sort; _ } -> sort
+
+  let rec normalize_loop root t =
+    match t with
+    | Declaration _ -> t
+    | Definition { definition = Defined | Unknown | Subst _ } -> t
+    | Definition ({ definition = Alias alias } as r) -> begin
+        match Graph.find_class_type root alias with
+        | exception Not_found -> Definition { r with definition = Unknown }
+        | aliased -> normalize_loop root aliased
+      end
+
+  let normalize root t =
+    match t with
+    | Definition { sort = Sort.Defined } -> normalize_loop root t
+    | Definition { sort = Sort.Declared _ } | Declaration _ ->
+        match Graph.find_class_type root (raw_path t) with
+        | exception Not_found -> normalize_loop root t
+        | t -> normalize_loop root t
+
+  let origin root t =
+    raw_origin (normalize root t)
+
+  let path root t =
+    raw_path (normalize root t)
+
+  let sort root t =
+    raw_sort (normalize root t)
+
+  type resolved = int list option * t
+
+  let subst ns = function
+    | (None, p) -> (Some ns, p)
+    | (Some ms, p) -> (Some (List.map (List.nth ns) ms), p)
+
+  let rec resolve root t =
+    match normalize root t with
+    | Declaration _ -> (None, t)
+    | Definition { definition = Defined | Unknown } -> (None, t)
+    | Definition { definition = Subst(p, ns) } -> begin
+        match Graph.find_class_type root p with
+        | exception Not_found -> (None, t)
+        | aliased -> subst ns (resolve root aliased)
+      end
+    | Definition { definition = Alias _ } -> assert false
+
+end
+
+and Module_type : sig
+
+  type t
+
+  val base :
+    Origin.t -> Ident.t -> Desc.Module_type.t option -> Desc.deprecated -> t
+
+  val child :
+    Module.normalized -> string ->
+    Desc.Module_type.t option -> Desc.deprecated -> t
+
+  val declare : Origin.t -> Ident.t -> t
+
+  val declaration : t -> Origin.t option
+
+  val origin : Graph.t -> t -> Origin.t
+
+  val path : Graph.t -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : Graph.t -> t -> Sort.t
+
+end = struct
+
+  open Desc.Module_type
+
+  type definition =
+    | Alias of Path.t
+    | Defined
+    | Unknown
+
+  type t =
+    | Declaration of
+        { origin : Origin.t;
+          id : Ident.t;
+          hidden : bool; }
+    | Definition of
+        { origin : Origin.t;
+          path : Path.t;
+          hidden : bool;
+          sort : Sort.t;
+          definition : definition; }
+
+  let base origin id desc deprecated =
+    let path = Path.Pident id in
+    let hidden = hidden_base_definition deprecated id in
+    let sort = Sort.Defined in
+    let definition =
+      match desc with
+      | None -> Unknown
+      | Some Fresh -> Defined
+      | Some (Alias alias) -> Alias alias
+    in
+    Definition { origin; path; hidden; sort; definition }
+
+  let child md name desc deprecated =
+    let origin = Module.raw_origin md in
+    let sort = Module.raw_sort md in
+    let path = Path.Pdot (Module.raw_path md, name) in
+    let hidden = hidden_definition deprecated name in
+    let definition =
+      match desc with
+      | None -> Unknown
+      | Some Fresh -> Defined
+      | Some (Alias alias) -> Alias alias
+    in
+    Definition { origin; path; hidden; sort; definition }
+
+  let declare origin id =
+    let hidden = hidden_ident id in
+    Declaration { origin; id; hidden }
+
+  let declaration t =
+    match t with
+    | Definition _ -> None
+    | Declaration { origin; _} -> Some origin
+
+  let hidden t =
+    match t with
+    | Definition { hidden; _ } -> hidden
+    | Declaration { hidden; _ } -> hidden
+
+  let raw_origin t =
+    match t with
+    | Declaration { origin; _ } | Definition { origin; _ } ->
+        origin
+
+  let raw_path t =
+    match t with
+    | Declaration { id; _ } -> Path.Pident id
+    | Definition { path; _ } -> path
+
+  let raw_sort t =
+    match t with
+    | Declaration { id; _ } -> Sort.Declared (Ident_set.singleton id)
+    | Definition { sort; _ } -> sort
+
+  let rec normalize_loop root t =
+    match t with
+    | Declaration _ -> t
+    | Definition { definition = Defined | Unknown } -> t
+    | Definition ({ definition = Alias alias } as r) -> begin
+        match Graph.find_module_type root alias with
+        | exception Not_found -> Definition { r with definition = Unknown }
+        | aliased -> normalize_loop root aliased
+      end
+
+  let normalize root t =
+    match t with
+    | Definition { sort = Sort.Defined } -> normalize_loop root t
+    | Definition { sort = Sort.Declared _ } | Declaration _ ->
+        match Graph.find_module_type root (raw_path t) with
+        | exception Not_found -> normalize_loop root t
+        | t -> normalize_loop root t
+
+  let origin root t =
+    raw_origin (normalize root t)
+
+  let path root t =
+    raw_path (normalize root t)
+
+  let sort root t =
+    raw_sort (normalize root t)
+
+end
+
+and Module : sig
+
+  type t
+
+  type normalized
+
+  val base :
+    Origin.t -> Ident.t -> Desc.Module.t option -> Desc.deprecated -> t
+
+  val child :
+    normalized -> string -> Desc.Module.t option -> Desc.deprecated -> t
+
+  val application : normalized -> t -> Desc.Module.t option -> t
+
+  val declare : Origin.t -> Ident.t -> t
+
+  val declaration : t -> Origin.t option
+
+  val origin : Graph.t -> t -> Origin.t
+
+  val path : Graph.t -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : Graph.t -> t -> Sort.t
+
+  val types : Graph.t -> t -> Type.t String_map.t option
+
+  val class_types : Graph.t -> t -> Class_type.t String_map.t option
+
+  val module_types : Graph.t -> t -> Module_type.t String_map.t option
+
+  val modules : Graph.t -> t -> Module.t String_map.t option
+
+  val find_type : Graph.t -> t -> string -> Type.t
+
+  val find_class_type : Graph.t -> t -> string -> Class_type.t
+
+  val find_module_type : Graph.t -> t -> string -> Module_type.t
+
+  val find_module : Graph.t -> t -> string -> Module.t
+
+  val find_application : Graph.t -> t -> Path.t -> Module.t
+
+  val normalize : Graph.t -> t -> normalized
+
+  val unnormalize : normalized -> t
+
+  val raw_origin : normalized -> Origin.t
+
+  val raw_path : normalized -> Path.t
+
+  val raw_sort : normalized -> Sort.t
+
+end = struct
+
+  open Desc.Module
+
+  type components =
+    | Unforced of Desc.Module.components Lazy.t
+    | Forced of
+        { types : Type.t String_map.t;
+          class_types : Class_type.t String_map.t;
+          module_types : Module_type.t String_map.t;
+          modules : t String_map.t; }
+
+  and definition =
+    | Alias of Path.t
+    | Signature of
+        { mutable components : components }
+    | Functor of
+        { apply : Path.t -> Desc.Module.t;
+          mutable applications : t Path_map.t; }
+    | Unknown
+
+  and t =
+    | Declaration of
+        { origin : Origin.t;
+          id : Ident.t;
+          hidden : bool; }
+    | Definition of
+        { origin : Origin.t;
+          path : Path.t;
+          hidden : bool;
+          sort : Sort.t;
+          definition : definition; }
+
+  let base origin id desc deprecated =
+    let path = Path.Pident id in
+    let hidden = hidden_base_definition deprecated id in
+    let sort = Sort.Defined in
+    let definition =
+      match desc with
+      | None -> Unknown
+      | Some (Fresh (Signature components)) ->
+          let components = Unforced components in
+          Signature { components }
+      | Some (Fresh (Functor apply)) ->
+          let applications = Path_map.empty in
+          Functor { apply; applications }
+      | Some (Alias alias) ->
+          Alias alias
+    in
+    Definition { origin; path; hidden; sort; definition }
+
+  let child md name desc deprecated =
+    let origin = Module.raw_origin md in
+    let sort = Module.raw_sort md in
+    let path = Path.Pdot(Module.raw_path md, name) in
+    let hidden = hidden_definition deprecated name in
+    let definition =
+      match desc with
+      | None -> Unknown
+      | Some (Fresh (Signature components)) ->
+          let components = Unforced components in
+          Signature { components }
+      | Some (Fresh (Functor apply)) ->
+          let applications = Path_map.empty in
+          Functor { apply; applications }
+      | Some (Alias alias) ->
+          Alias alias
+    in
+    Definition { origin; path; hidden; sort; definition }
+
+  let application func arg desc =
+    let func_origin = Module.raw_origin func in
+    let arg_origin = Module.raw_origin arg in
+    let origin = Origin.application func_origin arg_origin in
+    let func_sort = Module.raw_sort func in
+    let arg_sort = Module.raw_sort arg in
+    let sort = Sort.application func_sort arg_sort in
+    let func_path = Module.raw_path func in
+    let arg_path = Module.raw_path arg in
+    let path = Path.Papply(func_path, arg_path) in
+    let hidden = false in
+    let definition =
+      match desc with
+      | None -> Unknown
+      | Some (Fresh (Signature components)) ->
+          let components = Unforced components in
+          Signature { components }
+      | Some (Fresh (Functor apply)) ->
+          let applications = Path_map.empty in
+          Functor { apply; applications }
+      | Some (Alias alias) ->
+          Alias alias
+    in
+    Definition { origin; path; hidden; sort; definition }
+
+  let declare origin id =
+    let hidden = hidden_ident id in
+    Declaration { origin; id; hidden }
+
+  let declaration t =
+    match t with
+    | Definition _ -> None
+    | Declaration { origin; _} -> Some origin
+
+  let hidden t =
+    match t with
+    | Definition { hidden; _ } -> hidden
+    | Declaration { hidden; _ } -> hidden
+
+  let raw_origin t =
+    match t with
+    | Declaration { origin; _ } | Definition { origin; _ } ->
+        origin
+
+  let raw_path t =
+    match t with
+    | Declaration { id; _ } -> Path.Pident id
+    | Definition { path; _ } -> path
+
+  let raw_sort t =
+    match t with
+    | Declaration { id; _ } -> Sort.Declared (Ident_set.singleton id)
+    | Definition { sort; _ } -> sort
+
+  type normalized = t
+
+  let rec normalize_loop root t =
+    match t with
+    | Declaration _ -> t
+    | Definition { definition = Signature _ | Functor _ | Unknown } -> t
+    | Definition ({ definition = Alias alias } as r) -> begin
+        match Graph.find_module root alias with
+        | exception Not_found -> Definition { r with definition = Unknown }
+        | aliased -> normalize_loop root aliased
+      end
+
+  let normalize root t =
+    match t with
+    | Definition { sort = Sort.Defined } -> normalize_loop root t
+    | Definition { sort = Sort.Declared _ } | Declaration _ ->
+        match Graph.find_module root (raw_path t) with
+        | exception Not_found -> normalize_loop root t
+        | t -> normalize_loop root t
+
+  let unnormalize t = t
+
+  let origin root t =
+    raw_origin (normalize root t)
+
+  let path root t =
+    raw_path (normalize root t)
+
+  let sort root t =
+    raw_sort (normalize root t)
+
+  let definition t =
+    match Module.unnormalize t with
+    | Declaration _ -> Unknown
+    | Definition { definition; _ } -> definition
+
+  let force root t =
+    let t = Module.normalize root t in
+    match definition t with
+    | Alias _ -> assert false
+    | Unknown
+    | Functor _
+    | Signature { components = Forced _ } -> t
+    | Signature ({ components = Unforced components; _} as r) -> begin
+        let rec loop types class_types module_types modules = function
+          | [] -> Forced { types; class_types; module_types; modules }
+          | Type(name, desc, dpr) :: rest ->
+              let typ = Type.child t name (Some desc) dpr in
+              let types = String_map.add name typ types in
+              loop types class_types module_types modules rest
+          | Class_type(name, desc, dpr) :: rest ->
+              let clty = Class_type.child t name (Some desc) dpr in
+              let class_types = String_map.add name clty class_types in
+              loop types class_types module_types modules rest
+          | Module_type(name, desc, dpr) :: rest ->
+              let mty = Module_type.child t name (Some desc) dpr in
+              let module_types = String_map.add name mty module_types in
+              loop types class_types module_types modules rest
+          | Module(name, desc, dpr) :: rest ->
+              let md = Module.child t name (Some desc) dpr in
+              let modules = String_map.add name md modules in
+              loop types class_types module_types modules rest
+        in
+        let empty = String_map.empty in
+        let components = loop empty empty empty empty (Lazy.force components) in
+        r.components <- components;
+        t
+      end
+
+  let types root t =
+    let t = force root t in
+    match definition t with
+    | Alias _ | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown | Functor _ ->
+        None
+    | Signature { components = Forced { types; _ }; _ } ->
+        Some types
+
+  let class_types root t =
+    let t = force root t in
+    match definition t with
+    | Alias _ | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown | Functor _ ->
+        None
+    | Signature { components = Forced { class_types; _ } } ->
+        Some class_types
+
+  let module_types root t =
+    let t = force root t in
+    match definition t with
+    | Alias _ | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown | Functor _ ->
+        None
+    | Signature { components = Forced { module_types; _ } } ->
+        Some module_types
+
+  let modules root t =
+    let t = force root t in
+    match definition t with
+    | Alias _ | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown | Functor _ ->
+        None
+    | Signature { components = Forced { modules; _ } } ->
+        Some modules
+
+  let find_type root t name =
+    let t = force root t in
+    match definition t with
+    | Alias _
+    | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown ->
+        Type.child t name None Not_deprecated
+    | Functor _ ->
+        raise Not_found
+    | Signature { components = Forced { types; _ }; _ } ->
+        String_map.find name types
+
+  let find_class_type root t name =
+    let t = force root t in
+    match definition t with
+    | Alias _
+    | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown ->
+        Class_type.child t name None Not_deprecated
+    | Functor _ ->
+        raise Not_found
+    | Signature { components = Forced { class_types; _ }; _ } ->
+        String_map.find name class_types
+
+  let find_module_type root t name =
+    let t = force root t in
+    match definition t with
+    | Alias _
+    | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown ->
+        Module_type.child t name None Not_deprecated
+    | Functor _ ->
+        raise Not_found
+    | Signature { components = Forced { module_types; _ }; _ } ->
+        String_map.find name module_types
+
+  let find_module root t name =
+    let t = force root t in
+    match definition t with
+    | Alias _
+    | Signature { components = Unforced _ } ->
+        assert false
+    | Unknown ->
+        Module.child t name None Not_deprecated
+    | Functor _ ->
+        raise Not_found
+    | Signature { components = Forced { modules; _ }; _ } ->
+        String_map.find name modules
+
+  let find_application root t path =
+    let t = Module.normalize root t in
+    match definition t with
+    | Alias _ -> assert false
+    | Signature _ -> raise Not_found
+    | Unknown ->
+        let arg = Graph.find_module root path in
+        Module.application t arg None
+    | Functor ({ apply; applications } as r)->
+        let arg = Graph.find_module root path in
+        let arg_path = Module.path root arg in
+        match Path_map.find arg_path applications with
+        | md -> md
+        | exception Not_found ->
+            let md = Module.application t arg (Some (apply arg_path)) in
+            r.applications <- Path_map.add arg_path md applications;
+            md
+
+end
+
+and Diff : sig
+
+  module Item : sig
+
+    type t =
+      | Type of Ident.t * Type.t * Origin.t option
+      | Class_type of Ident.t * Class_type.t * Origin.t option
+      | Module_type of Ident.t * Module_type.t * Origin.t option
+      | Module of Ident.t * Module.t * Origin.t option
+
+    val origin : Graph.t -> t -> Origin.t
+
+    val id : Graph.t -> t -> Ident.t
+
+    val previous : Graph.t -> t -> Origin.t option
+
+  end
+
+  type t = Item.t list
+
+end = struct
+
+  module Item = struct
+
+    type t =
+      | Type of Ident.t * Type.t * Origin.t option
+      | Class_type of Ident.t * Class_type.t * Origin.t option
+      | Module_type of Ident.t * Module_type.t * Origin.t option
+      | Module of Ident.t * Module.t * Origin.t option
+
+    let origin root = function
+      | Type(_, typ, _) -> Type.origin root typ
+      | Class_type(_, clty, _) -> Class_type.origin root clty
+      | Module_type(_, mty, _) -> Module_type.origin root mty
+      | Module(_, md, _) -> Module.origin root md
+
+    let id _root = function
+      | Type(id, _, _) -> id
+      | Class_type(id, _, _) -> id
+      | Module_type(id, _, _) -> id
+      | Module(id, _, _) -> id
+
+    let previous _root = function
+      | Type(_, _, prev) -> prev
+      | Class_type(_, _, prev) -> prev
+      | Module_type(_, _, prev) -> prev
+      | Module(_, _, prev) -> prev
+
+  end
+
+  type t = Item.t list
+
+end
+
+and Component : sig
+
+  type source =
+    | Global
+    | Local
+    | Open
+
+  type t =
+    | Type of
+        Origin.t * Ident.t * Desc.Type.t * source * Desc.deprecated
+    | Class_type of
+        Origin.t * Ident.t * Desc.Class_type.t * source * Desc.deprecated
+    | Module_type of
+        Origin.t * Ident.t * Desc.Module_type.t * source * Desc.deprecated
+    | Module of
+        Origin.t * Ident.t * Desc.Module.t * source * Desc.deprecated
+    | Declare_type of Origin.t * Ident.t
+    | Declare_class_type of Origin.t * Ident.t
+    | Declare_module_type of Origin.t * Ident.t
+    | Declare_module of Origin.t * Ident.t
+
+end = Component
+
+and Graph : sig
+
+  type t
+
+  val empty : t
+
+  val add : t -> Component.t list -> t * Diff.t
+
+  val merge : t -> Diff.t -> t
+
+  val find_type : t -> Path.t -> Type.t
+
+  val find_class_type : t -> Path.t -> Class_type.t
+
+  val find_module_type : t -> Path.t -> Module_type.t
+
+  val find_module : t -> Path.t -> Module.t
+
+  val is_type_path_visible : t -> Path.t -> bool
+
+  val is_class_type_path_visible : t -> Path.t -> bool
+
+  val is_module_type_path_visible : t -> Path.t -> bool
+
+  val is_module_path_visible : t -> Path.t -> bool
+
+  val is_type_ident_visible : t -> Ident.t -> bool
+
+  val is_class_type_ident_visible : t -> Ident.t -> bool
+
+  val is_module_type_ident_visible : t -> Ident.t -> bool
+
+  val is_module_ident_visible : t -> Ident.t -> bool
+
+end = struct
+
+  type defs =
+    | Global of Ident.t
+    | Local of Ident.t
+    | Unambiguous of Ident.t
+    | Ambiguous of Ident.t * Ident.t list
+
+  type t =
+    { types : Type.t Ident_map.t;
+      class_types : Class_type.t Ident_map.t;
+      module_types : Module_type.t Ident_map.t;
+      modules : Module.t Ident_map.t;
+      type_names : defs String_map.t;
+      class_type_names : defs String_map.t;
+      module_type_names : defs String_map.t;
+      module_names : defs String_map.t; }
+
+  let empty =
+    { types = Ident_map.empty;
+      class_types = Ident_map.empty;
+      module_types = Ident_map.empty;
+      modules = Ident_map.empty;
+      type_names = String_map.empty;
+      class_type_names = String_map.empty;
+      module_type_names = String_map.empty;
+      module_names = String_map.empty; }
+
+  let previous_type t id =
+    match Ident_map.find id t.types with
+    | exception Not_found -> None
+    | prev ->
+      match Type.declaration prev with
+      | None -> failwith "Graph.add: type already defined"
+      | Some _ as o -> o
+
+  let previous_class_type t id =
+    match Ident_map.find id t.class_types with
+    | exception Not_found -> None
+    | prev ->
+      match Class_type.declaration prev with
+      | None -> failwith "Graph.add: class type already defined"
+      | Some _ as o -> o
+
+  let previous_module_type t id =
+    match Ident_map.find id t.module_types with
+    | exception Not_found -> None
+    | prev ->
+      match Module_type.declaration prev with
+      | None -> failwith "Graph.add: module type already defined"
+      | Some _ as o -> o
+
+  let previous_module t id =
+    match Ident_map.find id t.modules with
+    | exception Not_found -> None
+    | prev ->
+      match Module.declaration prev with
+      | None -> failwith "Graph.add: module already defined"
+      | Some _ as o -> o
+
+  let add_name source id names =
+    let name = Ident.name id in
+    let defs =
+      match source with
+      | Component.Global -> Global id
+      | Component.Local -> Local id
+      | Component.Open -> begin
+        match String_map.find name names with
+        | exception Not_found -> Unambiguous id
+        | Global id' -> Unambiguous id'
+        | Local id' -> Ambiguous(id, [id'])
+        | Unambiguous id' -> Ambiguous(id, [id'])
+        | Ambiguous(id', ids) -> Ambiguous(id, id' :: ids)
+      end
+    in
+    String_map.add name defs names
+
+  let merge_name id names =
+    let name = Ident.name id in
+    match String_map.find name names with
+    | exception Not_found ->
+        String_map.add name (Global id) names
+    | _ -> names
+
+  let add t descs =
+    let rec loop acc diff declarations = function
+      | [] -> loop_declarations acc diff declarations
+      | Component.Type(origin, id, desc, source, dpr) :: rest ->
+          let prev = previous_type acc id in
+          let typ = Type.base origin id (Some desc) dpr in
+          let types = Ident_map.add id typ acc.types in
+          let type_names = add_name source id acc.type_names in
+          let item = Diff.Item.Type(id, typ, prev) in
+          let diff = item :: diff in
+          let acc = { acc with types; type_names } in
+          loop acc diff declarations rest
+      | Component.Class_type(origin,id, desc, source, dpr) :: rest ->
+          let prev = previous_class_type acc id in
+          let clty = Class_type.base origin id (Some desc) dpr in
+          let class_types = Ident_map.add id clty acc.class_types in
+          let class_type_names = add_name source id acc.class_type_names in
+          let item = Diff.Item.Class_type(id, clty, prev) in
+          let diff = item :: diff in
+          let acc = { acc with class_types; class_type_names } in
+          loop acc diff declarations rest
+      | Component.Module_type(origin,id, desc, source, dpr) :: rest ->
+          let prev = previous_module_type acc id in
+          let mty = Module_type.base origin id (Some desc) dpr in
+          let module_types = Ident_map.add id mty acc.module_types in
+          let module_type_names = add_name source id acc.module_type_names in
+          let item = Diff.Item.Module_type(id, mty, prev) in
+          let diff = item :: diff in
+          let acc = { acc with module_types; module_type_names } in
+          loop acc diff declarations rest
+      | Component.Module(origin,id, desc, source, dpr) :: rest ->
+          let prev = previous_module acc id in
+          let md = Module.base origin id (Some desc) dpr in
+          let modules = Ident_map.add id md acc.modules in
+          let module_names = add_name source id acc.module_names in
+          let item = Diff.Item.Module(id, md, prev) in
+          let diff = item :: diff in
+          let acc = { acc with modules; module_names } in
+          loop acc diff declarations rest
+      | Component.Declare_type(_, id) as decl :: rest ->
+          let declarations = decl :: declarations in
+          let type_names =
+            (* CR lwhite: This should probably not always be [Global] *)
+            add_name Component.Global id acc.type_names
+          in
+          let acc = { acc with type_names } in
+          loop acc diff declarations rest
+      | Component.Declare_class_type(_, id) as decl :: rest ->
+          let declarations = decl :: declarations in
+          let class_type_names =
+            (* CR lwhite: This should probably not always be [Global] *)
+            add_name Component.Global id acc.class_type_names
+          in
+          let acc = { acc with class_type_names } in
+          loop acc diff declarations rest
+      | Component.Declare_module_type(_, id) as decl :: rest ->
+          let declarations = decl :: declarations in
+          let module_type_names =
+            (* CR lwhite: This should probably not always be [Global] *)
+            add_name Component.Global id acc.module_type_names
+          in
+          let acc = { acc with module_type_names } in
+          loop acc diff declarations rest
+      | Component.Declare_module(_, id) as decl :: rest ->
+          let declarations = decl :: declarations in
+          let module_names =
+            (* CR lwhite: This should probably not always be [Global] *)
+            add_name Component.Global id acc.module_names
+          in
+          let acc = { acc with module_names } in
+          loop acc diff declarations rest
+    and loop_declarations acc diff = function
+      | [] -> acc, diff
+      | Component.Declare_type(origin, id) :: rest ->
+          if Ident_map.mem id acc.types then begin
+            loop_declarations acc diff rest
+          end else begin
+            let typ = Type.declare origin id in
+            let types = Ident_map.add id typ acc.types in
+            let acc = { acc with types } in
+            loop_declarations acc diff rest
+          end
+      | Component.Declare_class_type(origin, id) :: rest ->
+          if Ident_map.mem id acc.class_types then begin
+            loop_declarations acc diff rest
+          end else begin
+            let clty = Class_type.declare origin id in
+            let class_types = Ident_map.add id clty acc.class_types in
+            let acc = { acc with class_types } in
+            loop_declarations acc diff rest
+          end
+      | Component.Declare_module_type(origin, id) :: rest ->
+          if Ident_map.mem id acc.module_types then begin
+            loop_declarations acc diff rest
+          end else begin
+            let mty = Module_type.declare origin id in
+            let module_types = Ident_map.add id mty acc.module_types in
+            let acc = { acc with module_types } in
+            loop_declarations acc diff rest
+          end
+      | Component.Declare_module(origin, id) :: rest ->
+          if Ident_map.mem id acc.modules then begin
+            loop_declarations acc diff rest
+          end else begin
+            let md = Module.declare origin id in
+            let modules = Ident_map.add id md acc.modules in
+            let acc = { acc with modules } in
+            loop_declarations acc diff rest
+          end
+      | ( Component.Type _
+        | Component.Class_type _
+        | Component.Module_type _
+        | Component.Module _) :: _ -> assert false
+    in
+    loop t [] [] descs
+
+  let merge t diff =
+    let rec loop acc = function
+      | [] -> acc
+      | Diff.Item.Type(id, typ, _) :: rest ->
+          let types = Ident_map.add id typ acc.types in
+          let type_names = merge_name id acc.type_names in
+          let acc = { acc with types; type_names } in
+          loop acc rest
+      | Diff.Item.Class_type(id, clty, _) :: rest ->
+          let class_types = Ident_map.add id clty acc.class_types in
+          let class_type_names = merge_name id acc.class_type_names in
+          let acc = { acc with class_types; class_type_names } in
+          loop acc rest
+      | Diff.Item.Module_type(id, mty, _) :: rest ->
+          let module_types = Ident_map.add id mty acc.module_types in
+          let module_type_names = merge_name id acc.module_type_names in
+          let acc = { acc with module_types; module_type_names } in
+          loop acc rest
+      | Diff.Item.Module(id, md, _) :: rest ->
+          let modules = Ident_map.add id md acc.modules in
+          let module_names = merge_name id acc.module_names in
+          let acc = { acc with modules; module_names } in
+          loop acc rest
+    in
+    loop t diff
+
+  let rec find_module t path =
+    match path with
+    | Path.Pident id ->
+        Ident_map.find id t.modules
+    | Path.Pdot(p, name) ->
+        let md = find_module t p in
+        Module.find_module t md name
+    | Path.Papply(p, arg) ->
+        let md = find_module t p in
+        Module.find_application t md arg
+
+  let find_type t path =
+    match path with
+    | Path.Pident id ->
+        Ident_map.find id t.types
+    | Path.Pdot(p, name) ->
+        let md = find_module t p in
+        Module.find_type t md name
+    | Path.Papply _ ->
+        raise Not_found
+
+  let find_class_type t path =
+    match path with
+    | Path.Pident id ->
+        Ident_map.find id t.class_types
+    | Path.Pdot(p, name) ->
+        let md = find_module t p in
+        Module.find_class_type t md name
+    | Path.Papply _ ->
+        raise Not_found
+
+  let find_module_type t path =
+    match path with
+    | Path.Pident id ->
+        Ident_map.find id t.module_types
+    | Path.Pdot(p, name) ->
+        let md = find_module t p in
+        Module.find_module_type t md name
+    | Path.Papply _ ->
+        raise Not_found
+
+  let canonical_type_path t id =
+    match Ident_map.find id t.types with
+    | exception Not_found -> Path.Pident id
+    | md -> Type.path t md
+
+  let canonical_class_type_path t id =
+    match Ident_map.find id t.class_types with
+    | exception Not_found -> Path.Pident id
+    | md -> Class_type.path t md
+
+  let canonical_module_type_path t id =
+    match Ident_map.find id t.module_types with
+    | exception Not_found -> Path.Pident id
+    | md -> Module_type.path t md
+
+  let canonical_module_path t id =
+    match Ident_map.find id t.modules with
+    | exception Not_found -> Path.Pident id
+    | md -> Module.path t md
+
+  let is_module_ident_visible t id =
+    let name = Ident.name id in
+    match String_map.find name t.module_names with
+    | exception Not_found -> false
+    | Local id' -> Ident.equal id id'
+    | Global id' -> Ident.equal id id'
+    | Unambiguous id' -> Ident.equal id id'
+    | Ambiguous(id', ids) ->
+      if not (Ident.equal id id') then false
+      else begin
+        let paths = List.map (canonical_module_path t) ids in
+        let path = canonical_module_path t id in
+        List.for_all (Path.equal path) paths
+      end
+
+  let rec is_module_path_visible t = function
+    | Path.Pident id -> is_module_ident_visible t id
+    | Path.Pdot(path, _) ->
+        is_module_path_visible t path
+    | Path.Papply(path1, path2) ->
+        is_module_path_visible t path1
+        && is_module_path_visible t path2
+
+  let is_type_ident_visible t id =
+    let name = Ident.name id in
+    match String_map.find name t.type_names with
+    | exception Not_found -> false
+    | Local id' -> Ident.equal id id'
+    | Global id' -> Ident.equal id id'
+    | Unambiguous id' -> Ident.equal id id'
+    | Ambiguous(id', ids) ->
+      if not (Ident.equal id id') then false
+      else begin
+        let paths = List.map (canonical_type_path t) ids in
+        let path = canonical_type_path t id in
+        List.for_all (Path.equal path) paths
+      end
+
+  let is_type_path_visible t = function
+    | Path.Pident id -> is_type_ident_visible t id
+    | Path.Pdot(path, _) -> is_module_path_visible t path
+    | Path.Papply _ ->
+        failwith
+          "Short_paths_graph.Graph.is_type_path_visible: \
+           invalid type path"
+
+  let is_class_type_ident_visible t id =
+    let name = Ident.name id in
+    match String_map.find name t.class_type_names with
+    | exception Not_found -> false
+    | Local id' -> Ident.equal id id'
+    | Global id' -> Ident.equal id id'
+    | Unambiguous id' -> Ident.equal id id'
+    | Ambiguous(id', ids) ->
+      if not (Ident.equal id id') then false
+      else begin
+        let paths = List.map (canonical_class_type_path t) ids in
+        let path = canonical_class_type_path t id in
+        List.for_all (Path.equal path) paths
+      end
+
+  let is_class_type_path_visible t = function
+    | Path.Pident id -> is_class_type_ident_visible t id
+    | Path.Pdot(path, _) -> is_module_path_visible t path
+    | Path.Papply _ ->
+        failwith
+          "Short_paths_graph.Graph.is_class_type_path_visible: \
+           invalid class type path"
+
+  let is_module_type_ident_visible t id =
+    let name = Ident.name id in
+    match String_map.find name t.module_type_names with
+    | exception Not_found -> false
+    | Local id' -> Ident.equal id id'
+    | Global id' -> Ident.equal id id'
+    | Unambiguous id' -> Ident.equal id id'
+    | Ambiguous(id', ids) ->
+      if not (Ident.equal id id') then false
+      else begin
+        let paths = List.map (canonical_module_type_path t) ids in
+        let path = canonical_module_type_path t id in
+        List.for_all (Path.equal path) paths
+      end
+
+  let is_module_type_path_visible t = function
+    | Path.Pident id -> is_module_type_ident_visible t id
+    | Path.Pdot(path, _) -> is_module_path_visible t path
+    | Path.Papply _ ->
+        failwith
+          "Short_paths_graph.Graph.is_module_type_path_visible: \
+           invalid module type path"
+
+end
+
+type graph = Graph.t
diff --git a/src/ocaml/typing/410+multicore/short_paths_graph.mli b/src/ocaml/typing/410+multicore/short_paths_graph.mli
new file mode 100644
index 00000000..5f021764
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/short_paths_graph.mli
@@ -0,0 +1,308 @@
+(** [Short_path_graph] is a representation of the environment (as a graph,
+    using [Graph.t]) that is more suitable to answer short path queries.
+
+    The only structures shared with the typechecker are [Ident.t] and [Path.t].
+    [Graph.t] is pure and doesn't hook into the [Env.t].
+    Context has to be rebuilt by outside code using [Graph.add].
+*)
+
+(* Generic definitions *)
+
+module String_map : Map.S with type key = string
+
+module Ident : sig
+
+  type t = Ident.t
+
+  val equal : t -> t -> bool
+
+  val compare : t -> t -> int
+
+  val name : t -> string
+
+  val global : string -> t
+
+end
+
+module Ident_map : Map.S with type key = Ident.t
+
+module Ident_set : Set.S with type elt = Ident.t
+
+module Path : sig
+
+  type t = Path.t =
+    | Pident of Ident.t
+    | Pdot of t * string
+    | Papply of t * t
+
+  val equal : t -> t -> bool
+
+  val compare : t -> t -> int
+
+end
+
+module Path_map : Map.S with type key = Path.t
+
+module Path_set : Set.S with type elt = Path.t
+
+(* Subset of the type algebra that is relevant to short path *)
+
+module Desc : sig
+
+  type deprecated =
+    | Deprecated
+    | Not_deprecated
+
+  module Type : sig
+
+    type t =
+      | Fresh
+      (** type t *)
+      | Nth of int
+      (** The n'th projection of type parameters.
+          E.g. for n < m, [type ('x_0,'x_1,...,'x_m-1) t = 'x_n]
+          is represented as [Nth n]. *)
+      | Subst of Path.t * int list
+      (** An alias to some other type after substitution of type parameters.
+          E.g. [type ('x_0, 'x_1', 'x_2, 'x_3) t = ('x_3, 'x_2) p]
+          is represented as [Subst (p, [3,2])]. *)
+      | Alias of Path.t
+      (** A direct alias to another type, preserving parameters.
+          E.g [type t = p], [type 'a t = 'a p], ...
+          are represented as [Alias p]. *)
+  end
+
+  module Class_type : sig
+
+    type t =
+      | Fresh
+      | Subst of Path.t * int list
+      | Alias of Path.t
+
+  end
+
+  module Module_type : sig
+
+    type t =
+      | Fresh
+      | Alias of Path.t
+
+  end
+
+  module Module : sig
+
+    type component =
+      | Type of string * Type.t * deprecated
+      | Class_type of string * Class_type.t * deprecated
+      | Module_type of string * Module_type.t * deprecated
+      | Module of string * t * deprecated
+
+    and components = component list
+
+    and kind =
+      | Signature of components Lazy.t
+      | Functor of (Path.t -> t)
+
+    and t =
+      | Fresh of kind
+      | Alias of Path.t
+
+  end
+
+  type source =
+    | Local
+    | Open
+
+  type t =
+    | Type of Ident.t * Type.t * source * deprecated
+    | Class_type of Ident.t * Class_type.t * source * deprecated
+    | Module_type of Ident.t * Module_type.t * source * deprecated
+    | Module of Ident.t * Module.t * source * deprecated
+    | Declare_type of Ident.t
+    | Declare_class_type of Ident.t
+    | Declare_module_type of Ident.t
+    | Declare_module of Ident.t
+
+end
+
+module Sort : sig
+
+  type t =
+    | Defined
+    | Declared of Ident_set.t
+
+end
+
+module Age : Natural.S
+
+module Dependency : Natural.S
+
+module Origin : sig
+
+  type t =
+    | Dependency of Dependency.t
+    | Dependencies of Dependency.t list
+    | Environment of Age.t
+
+  val equal : t -> t -> bool
+
+  val hash : t -> int
+
+end
+
+type graph
+
+module Type : sig
+
+  type t
+
+  val origin : graph -> t -> Origin.t
+
+  val path : graph -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : graph -> t -> Sort.t
+
+  type resolved =
+    | Nth of int
+    | Path of int list option * t
+
+  val resolve : graph -> t -> resolved
+
+end
+
+module Class_type : sig
+
+  type t
+
+  val origin : graph -> t -> Origin.t
+
+  val path : graph -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : graph -> t -> Sort.t
+
+  type resolved = int list option * t
+
+  val resolve : graph -> t -> resolved
+
+end
+
+module Module_type : sig
+
+  type t
+
+  val origin : graph -> t -> Origin.t
+
+  val path : graph -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : graph -> t -> Sort.t
+
+end
+
+module Module : sig
+
+  type t
+
+  val origin : graph -> t -> Origin.t
+
+  val path : graph -> t -> Path.t
+
+  val hidden : t -> bool
+
+  val sort : graph -> t -> Sort.t
+
+  val types : graph -> t -> Type.t String_map.t option
+
+  val class_types : graph -> t -> Class_type.t String_map.t option
+
+  val module_types : graph -> t -> Module_type.t String_map.t option
+
+  val modules : graph -> t -> t String_map.t option
+
+end
+
+module Diff : sig
+
+  module Item : sig
+
+    type t =
+      | Type of Ident.t * Type.t * Origin.t option
+      | Class_type of Ident.t * Class_type.t * Origin.t option
+      | Module_type of Ident.t * Module_type.t * Origin.t option
+      | Module of Ident.t * Module.t * Origin.t option
+
+    val origin : graph -> t -> Origin.t
+
+    val id : graph -> t -> Ident.t
+
+    val previous : graph -> t -> Origin.t option
+
+  end
+
+  type t = Item.t list
+
+end
+
+module Component : sig
+
+  type source =
+    | Global
+    | Local
+    | Open
+
+  type t =
+    | Type of
+        Origin.t * Ident.t * Desc.Type.t * source * Desc.deprecated
+    | Class_type of
+        Origin.t * Ident.t * Desc.Class_type.t * source * Desc.deprecated
+    | Module_type of
+        Origin.t * Ident.t * Desc.Module_type.t * source * Desc.deprecated
+    | Module of
+        Origin.t * Ident.t * Desc.Module.t * source * Desc.deprecated
+    | Declare_type of Origin.t * Ident.t
+    | Declare_class_type of Origin.t * Ident.t
+    | Declare_module_type of Origin.t * Ident.t
+    | Declare_module of Origin.t * Ident.t
+
+end
+
+module Graph : sig
+
+  type t = graph
+
+  val empty : t
+
+  val add : t -> Component.t list -> t * Diff.t
+
+  val merge : t -> Diff.t -> t
+
+  val find_type : t -> Path.t -> Type.t
+
+  val find_class_type : t -> Path.t -> Class_type.t
+
+  val find_module_type : t -> Path.t -> Module_type.t
+
+  val find_module : t -> Path.t -> Module.t
+
+  val is_type_path_visible : t -> Path.t -> bool
+
+  val is_class_type_path_visible : t -> Path.t -> bool
+
+  val is_module_type_path_visible : t -> Path.t -> bool
+
+  val is_module_path_visible : t -> Path.t -> bool
+
+  val is_type_ident_visible : t -> Ident.t -> bool
+
+  val is_class_type_ident_visible : t -> Ident.t -> bool
+
+  val is_module_type_ident_visible : t -> Ident.t -> bool
+
+  val is_module_ident_visible : t -> Ident.t -> bool
+
+end
diff --git a/src/ocaml/typing/410+multicore/stypes.ml b/src/ocaml/typing/410+multicore/stypes.ml
new file mode 100644
index 00000000..5e6ef97d
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/stypes.ml
@@ -0,0 +1,210 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Damien Doligez, projet Moscova, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 2003 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Recording and dumping (partial) type information *)
+
+(*
+  We record all types in a list as they are created.
+  This means we can dump type information even if type inference fails,
+  which is extremely important, since type information is most
+  interesting in case of errors.
+*)
+
+open Annot;;
+open Lexing;;
+open Location;;
+open Typedtree;;
+
+let output_int oc i = output_string oc (Int.to_string i)
+
+type annotation =
+  | Ti_pat   of pattern
+  | Ti_expr  of expression
+  | Ti_class of class_expr
+  | Ti_mod   of module_expr
+  | An_call of Location.t * Annot.call
+  | An_ident of Location.t * string * Annot.ident
+;;
+
+let get_location ti =
+  match ti with
+    Ti_pat p   -> p.pat_loc
+  | Ti_expr e  -> e.exp_loc
+  | Ti_class c -> c.cl_loc
+  | Ti_mod m   -> m.mod_loc
+  | An_call (l, _k) -> l
+  | An_ident (l, _s, _k) -> l
+;;
+
+let annotations = ref ([] : annotation list);;
+let phrases = ref ([] : Location.t list);;
+
+let record ti =
+  if !Clflags.annotations && not (get_location ti).Location.loc_ghost then
+    annotations := ti :: !annotations
+;;
+
+let record_phrase loc =
+  if !Clflags.annotations then phrases := loc :: !phrases;
+;;
+
+(* comparison order:
+   the intervals are sorted by order of increasing upper bound
+   same upper bound -> sorted by decreasing lower bound
+*)
+let cmp_loc_inner_first loc1 loc2 =
+  match compare loc1.loc_end.pos_cnum loc2.loc_end.pos_cnum with
+  | 0 -> compare loc2.loc_start.pos_cnum loc1.loc_start.pos_cnum
+  | x -> x
+;;
+let cmp_ti_inner_first ti1 ti2 =
+  cmp_loc_inner_first (get_location ti1) (get_location ti2)
+;;
+
+let print_position pp pos =
+  if pos = dummy_pos then
+    output_string pp "--"
+  else begin
+    output_char pp '\"';
+    output_string pp (String.escaped pos.pos_fname);
+    output_string pp "\" ";
+    output_int pp pos.pos_lnum;
+    output_char pp ' ';
+    output_int pp pos.pos_bol;
+    output_char pp ' ';
+    output_int pp pos.pos_cnum;
+  end
+;;
+
+let print_location pp loc =
+  print_position pp loc.loc_start;
+  output_char pp ' ';
+  print_position pp loc.loc_end;
+;;
+
+let sort_filter_phrases () =
+  let ph = List.sort (fun x y -> cmp_loc_inner_first y x) !phrases in
+  let rec loop accu cur l =
+    match l with
+    | [] -> accu
+    | loc :: t ->
+       if cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum
+          && cur.loc_end.pos_cnum >= loc.loc_end.pos_cnum
+       then loop accu cur t
+       else loop (loc :: accu) loc t
+  in
+  phrases := loop [] Location.none ph;
+;;
+
+let rec printtyp_reset_maybe loc =
+  match !phrases with
+  | cur :: t when cur.loc_start.pos_cnum <= loc.loc_start.pos_cnum ->
+     Printtyp.reset ();
+     phrases := t;
+     printtyp_reset_maybe loc;
+  | _ -> ()
+;;
+
+let call_kind_string k =
+  match k with
+  | Tail -> "tail"
+  | Stack -> "stack"
+  | Inline -> "inline"
+;;
+
+let print_ident_annot pp str k =
+  match k with
+  | Idef l ->
+      output_string pp "def ";
+      output_string pp str;
+      output_char pp ' ';
+      print_location pp l;
+      output_char pp '\n'
+  | Iref_internal l ->
+      output_string pp "int_ref ";
+      output_string pp str;
+      output_char pp ' ';
+      print_location pp l;
+      output_char pp '\n'
+  | Iref_external ->
+      output_string pp "ext_ref ";
+      output_string pp str;
+      output_char pp '\n'
+;;
+
+(* The format of the annotation file is documented in emacs/caml-types.el. *)
+
+let print_info pp prev_loc ti =
+  match ti with
+  | Ti_class _ | Ti_mod _ -> prev_loc
+  | Ti_pat  {pat_loc = loc; pat_type = typ; pat_env = env}
+  | Ti_expr {exp_loc = loc; exp_type = typ; exp_env = env} ->
+      if loc <> prev_loc then begin
+        print_location pp loc;
+        output_char pp '\n'
+      end;
+      output_string pp "type(\n";
+      printtyp_reset_maybe loc;
+      Printtyp.mark_loops typ;
+      Format.pp_print_string Format.str_formatter "  ";
+      Printtyp.wrap_printing_env ~error:false env
+                       (fun () -> Printtyp.type_sch Format.str_formatter typ);
+      Format.pp_print_newline Format.str_formatter ();
+      let s = Format.flush_str_formatter () in
+      output_string pp s;
+      output_string pp ")\n";
+      loc
+  | An_call (loc, k) ->
+      if loc <> prev_loc then begin
+        print_location pp loc;
+        output_char pp '\n'
+      end;
+      output_string pp "call(\n  ";
+      output_string pp (call_kind_string k);
+      output_string pp "\n)\n";
+      loc
+  | An_ident (loc, str, k) ->
+      if loc <> prev_loc then begin
+        print_location pp loc;
+        output_char pp '\n'
+      end;
+      output_string pp "ident(\n  ";
+      print_ident_annot pp str k;
+      output_string pp ")\n";
+      loc
+;;
+
+let get_info () =
+  let info = List.fast_sort cmp_ti_inner_first !annotations in
+  annotations := [];
+  info
+;;
+
+let dump filename =
+  if !Clflags.annotations then begin
+    let do_dump _temp_filename pp =
+      let info = get_info () in
+      sort_filter_phrases ();
+      ignore (List.fold_left (print_info pp) Location.none info) in
+    begin match filename with
+    | None -> do_dump "" stdout
+    | Some filename ->
+        Misc.output_to_file_via_temporary ~mode:[Open_text] filename do_dump
+    end;
+    phrases := [];
+  end else begin
+    annotations := [];
+  end;
+;;
diff --git a/src/ocaml/typing/410+multicore/stypes.mli b/src/ocaml/typing/410+multicore/stypes.mli
new file mode 100644
index 00000000..46df1ce6
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/stypes.mli
@@ -0,0 +1,36 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*           Damien Doligez, projet Moscova, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 2003 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Recording and dumping (partial) type information *)
+
+(* Clflags.save_types must be true *)
+
+open Typedtree;;
+
+type annotation =
+  | Ti_pat   of pattern
+  | Ti_expr  of expression
+  | Ti_class of class_expr
+  | Ti_mod   of module_expr
+  | An_call of Location.t * Annot.call
+  | An_ident of Location.t * string * Annot.ident
+;;
+
+val record : annotation -> unit;;
+val record_phrase : Location.t -> unit;;
+val dump : string option -> unit;;
+
+val get_location : annotation -> Location.t;;
+val get_info : unit -> annotation list;;
diff --git a/src/ocaml/typing/410+multicore/subst.ml b/src/ocaml/typing/410+multicore/subst.ml
new file mode 100644
index 00000000..d1bd98ad
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/subst.ml
@@ -0,0 +1,550 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Substitutions *)
+
+open Misc
+open Path
+open Types
+open Btype
+
+type type_replacement =
+  | Path of Path.t
+  | Type_function of { params : type_expr list; body : type_expr }
+
+open Local_store.Compiler
+
+type t =
+  { types: type_replacement Path.Map.t;
+    modules: Path.t Path.Map.t;
+    modtypes: module_type Ident.Map.t;
+    for_saving: bool;
+    make_loc_ghost: bool;
+  }
+
+let identity =
+  { types = Path.Map.empty;
+    modules = Path.Map.empty;
+    modtypes = Ident.Map.empty;
+    for_saving = false;
+    make_loc_ghost = false;
+  }
+
+let add_type_path id p s = { s with types = Path.Map.add id (Path p) s.types }
+let add_type id p s = add_type_path (Pident id) p s
+
+let add_type_function id ~params ~body s =
+  { s with types = Path.Map.add id (Type_function { params; body }) s.types }
+
+let add_module_path id p s = { s with modules = Path.Map.add id p s.modules }
+let add_module id p s = add_module_path (Pident id) p s
+
+let add_modtype id ty s = { s with modtypes = Ident.Map.add id ty s.modtypes }
+
+let for_saving s = { s with for_saving = true }
+let make_loc_ghost s = { s with make_loc_ghost = true }
+
+let loc s x =
+  if s.for_saving && not !Clflags.keep_locs then Location.none
+  else if s.make_loc_ghost then { x with loc_ghost = true }
+  else x
+
+let remove_loc =
+  let open Ast_mapper in
+  {default_mapper with location = (fun _this _loc -> Location.none)}
+
+let is_not_doc = function
+  | {Parsetree.attr_name = {Location.txt = "ocaml.doc"}; _} -> false
+  | {Parsetree.attr_name = {Location.txt = "ocaml.text"}; _} -> false
+  | {Parsetree.attr_name = {Location.txt = "doc"}; _} -> false
+  | {Parsetree.attr_name = {Location.txt = "text"}; _} -> false
+  | _ -> true
+
+let attrs s x =
+  let x =
+    if s.for_saving && not !Clflags.keep_docs then
+      List.filter is_not_doc x
+    else x
+  in
+    if s.for_saving && not !Clflags.keep_locs
+    then remove_loc.Ast_mapper.attributes remove_loc x
+    else x
+
+let rec module_path s path =
+  try Path.Map.find path s.modules
+  with Not_found ->
+    match path with
+    | Pident _ -> path
+    | Pdot(p, n) ->
+       Pdot(module_path s p, n)
+    | Papply(p1, p2) ->
+       Papply(module_path s p1, module_path s p2)
+
+let modtype_path s = function
+    Pident id as p ->
+      begin try
+        match Ident.Map.find id s.modtypes with
+          | Mty_ident p -> p
+          | _ -> fatal_error "Subst.modtype_path"
+      with Not_found -> p end
+  | Pdot(p, n) ->
+      Pdot(module_path s p, n)
+  | Papply _ ->
+      fatal_error "Subst.modtype_path"
+
+let type_path s path =
+  match Path.Map.find path s.types with
+  | Path p -> p
+  | Type_function _ -> assert false
+  | exception Not_found ->
+     match path with
+     | Pident _ -> path
+     | Pdot(p, n) ->
+        Pdot(module_path s p, n)
+     | Papply _ ->
+        fatal_error "Subst.type_path"
+
+let type_path s p =
+  match Path.constructor_typath p with
+  | Regular p -> type_path s p
+  | Cstr (ty_path, cstr) -> Pdot(type_path s ty_path, cstr)
+  | LocalExt _ -> type_path s p
+  | Ext (p, cstr) -> Pdot(module_path s p, cstr)
+
+let to_subst_by_type_function s p =
+  match Path.Map.find p s.types with
+  | Path _ -> false
+  | Type_function _ -> true
+  | exception Not_found -> false
+
+(* Special type ids for saved signatures *)
+
+let new_id = s_ref (-1)
+let reset_for_saving () = new_id := -1
+
+let newpersty desc =
+  decr new_id;
+  { desc; level = generic_level; scope = Btype.lowest_level; id = !new_id }
+
+(* ensure that all occurrences of 'Tvar None' are physically shared *)
+let tvar_none = Tvar None
+let tunivar_none = Tunivar None
+let norm = function
+  | Tvar None -> tvar_none
+  | Tunivar None -> tunivar_none
+  | d -> d
+
+let ctype_apply_env_empty = ref (fun _ -> assert false)
+
+(* Similar to [Ctype.nondep_type_rec]. *)
+let rec typexp copy_scope s ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar _ | Tunivar _ as desc ->
+      if s.for_saving || ty.id < 0 then
+        let ty' =
+          if s.for_saving then newpersty (norm desc)
+          else newty2 ty.level desc
+        in
+        For_copy.save_desc copy_scope ty desc;
+        ty.desc <- Tsubst ty';
+        ty'
+      else ty
+  | Tsubst ty ->
+      ty
+  | Tfield (m, k, _t1, _t2) when not s.for_saving && m = dummy_method
+      && field_kind_repr k <> Fabsent && (repr ty).level < generic_level ->
+      (* do not copy the type of self when it is not generalized *)
+      ty
+(* cannot do it, since it would omit substitution
+  | Tvariant row when not (static_row row) ->
+      ty
+*)
+  | _ ->
+    let desc = ty.desc in
+    For_copy.save_desc copy_scope ty desc;
+    let tm = row_of_type ty in
+    let has_fixed_row =
+      not (is_Tconstr ty) && is_constr_row ~allow_ident:false tm in
+    (* Make a stub *)
+    let ty' = if s.for_saving then newpersty (Tvar None) else newgenvar () in
+    ty'.scope <- ty.scope;
+    ty.desc <- Tsubst ty';
+    ty'.desc <-
+      begin if has_fixed_row then
+        match tm.desc with (* PR#7348 *)
+          Tconstr (Pdot(m,i), tl, _abbrev) ->
+            let i' = String.sub i 0 (String.length i - 4) in
+            Tconstr(type_path s (Pdot(m,i')), tl, ref Mnil)
+        | _ -> assert false
+      else match desc with
+      | Tconstr (p, args, _abbrev) ->
+         let args = List.map (typexp copy_scope s) args in
+         begin match Path.Map.find p s.types with
+         | exception Not_found -> Tconstr(type_path s p, args, ref Mnil)
+         | Path _ -> Tconstr(type_path s p, args, ref Mnil)
+         | Type_function { params; body } ->
+            (!ctype_apply_env_empty params body args).desc
+         end
+      | Tpackage(p, n, tl) ->
+          Tpackage(modtype_path s p, n, List.map (typexp copy_scope s) tl)
+      | Tobject (t1, name) ->
+          let t1' = typexp copy_scope s t1 in
+          let name' =
+            match !name with
+            | None -> None
+            | Some (p, tl) ->
+                if to_subst_by_type_function s p
+                then None
+                else Some (type_path s p, List.map (typexp copy_scope s) tl)
+          in
+          Tobject (t1', ref name')
+      | Tvariant row ->
+          let row = row_repr row in
+          let more = repr row.row_more in
+          (* We must substitute in a subtle way *)
+          (* Tsubst takes a tuple containing the row var and the variant *)
+          begin match more.desc with
+            Tsubst {desc = Ttuple [_;ty2]} ->
+              (* This variant type has been already copied *)
+              ty.desc <- Tsubst ty2; (* avoid Tlink in the new type *)
+              Tlink ty2
+          | _ ->
+              let dup =
+                s.for_saving || more.level = generic_level || static_row row ||
+                match more.desc with Tconstr _ -> true | _ -> false in
+              (* Various cases for the row variable *)
+              let more' =
+                match more.desc with
+                  Tsubst ty -> ty
+                | Tconstr _ | Tnil -> typexp copy_scope s more
+                | Tunivar _ | Tvar _ ->
+                    For_copy.save_desc copy_scope more more.desc;
+                    if s.for_saving then newpersty (norm more.desc) else
+                    if dup && is_Tvar more then newgenty more.desc else more
+                | _ -> assert false
+              in
+              (* Register new type first for recursion *)
+              more.desc <- Tsubst(newgenty(Ttuple[more';ty']));
+              (* Return a new copy *)
+              let row =
+                copy_row (typexp copy_scope s) true row (not dup) more' in
+              match row.row_name with
+              | Some (p, tl) ->
+                 Tvariant {row with row_name =
+                                      if to_subst_by_type_function s p
+                                      then None
+                                      else Some (type_path s p, tl)}
+              | None ->
+                  Tvariant row
+          end
+      | Tfield(_label, kind, _t1, t2) when field_kind_repr kind = Fabsent ->
+          Tlink (typexp copy_scope s t2)
+      | _ -> copy_type_desc (typexp copy_scope s) desc
+      end;
+    ty'
+
+(*
+   Always make a copy of the type. If this is not done, type levels
+   might not be correct.
+*)
+let type_expr s ty =
+  For_copy.with_scope (fun copy_scope -> typexp copy_scope s ty)
+
+let label_declaration copy_scope s l =
+  {
+    ld_id = l.ld_id;
+    ld_mutable = l.ld_mutable;
+    ld_type = typexp copy_scope s l.ld_type;
+    ld_loc = loc s l.ld_loc;
+    ld_attributes = attrs s l.ld_attributes;
+  }
+
+let constructor_arguments copy_scope s = function
+  | Cstr_tuple l ->
+      Cstr_tuple (List.map (typexp copy_scope s) l)
+  | Cstr_record l ->
+      Cstr_record (List.map (label_declaration copy_scope s) l)
+
+let constructor_declaration copy_scope s c =
+  {
+    cd_id = c.cd_id;
+    cd_args = constructor_arguments copy_scope s c.cd_args;
+    cd_res = Option.map (typexp copy_scope s) c.cd_res;
+    cd_loc = loc s c.cd_loc;
+    cd_attributes = attrs s c.cd_attributes;
+  }
+
+let type_declaration' copy_scope s decl =
+  { type_params = List.map (typexp copy_scope s) decl.type_params;
+    type_arity = decl.type_arity;
+    type_kind =
+      begin match decl.type_kind with
+        Type_abstract -> Type_abstract
+      | Type_variant cstrs ->
+          Type_variant (List.map (constructor_declaration copy_scope s) cstrs)
+      | Type_record(lbls, rep) ->
+          Type_record (List.map (label_declaration copy_scope s) lbls, rep)
+      | Type_open -> Type_open
+      end;
+    type_manifest =
+      begin
+        match decl.type_manifest with
+          None -> None
+        | Some ty -> Some(typexp copy_scope s ty)
+      end;
+    type_private = decl.type_private;
+    type_variance = decl.type_variance;
+    type_is_newtype = false;
+    type_expansion_scope = Btype.lowest_level;
+    type_loc = loc s decl.type_loc;
+    type_attributes = attrs s decl.type_attributes;
+    type_immediate = decl.type_immediate;
+    type_unboxed = decl.type_unboxed;
+  }
+
+let type_declaration s decl =
+  For_copy.with_scope (fun copy_scope -> type_declaration' copy_scope s decl)
+
+let class_signature copy_scope s sign =
+  { csig_self = typexp copy_scope s sign.csig_self;
+    csig_vars =
+      Vars.map
+        (function (m, v, t) -> (m, v, typexp copy_scope s t)) sign.csig_vars;
+    csig_concr = sign.csig_concr;
+    csig_inher =
+      List.map
+        (fun (p, tl) -> (type_path s p, List.map (typexp copy_scope s) tl))
+        sign.csig_inher;
+  }
+
+let rec class_type copy_scope s = function
+  | Cty_constr (p, tyl, cty) ->
+      let p' = type_path s p in
+      let tyl' = List.map (typexp copy_scope s) tyl in
+      let cty' = class_type copy_scope s cty in
+      Cty_constr (p', tyl', cty')
+  | Cty_signature sign ->
+      Cty_signature (class_signature copy_scope s sign)
+  | Cty_arrow (l, ty, cty) ->
+      Cty_arrow (l, typexp copy_scope s ty, class_type copy_scope s cty)
+
+let class_declaration' copy_scope s decl =
+  { cty_params = List.map (typexp copy_scope s) decl.cty_params;
+    cty_variance = decl.cty_variance;
+    cty_type = class_type copy_scope s decl.cty_type;
+    cty_path = type_path s decl.cty_path;
+    cty_new =
+      begin match decl.cty_new with
+      | None    -> None
+      | Some ty -> Some (typexp copy_scope s ty)
+      end;
+    cty_loc = loc s decl.cty_loc;
+    cty_attributes = attrs s decl.cty_attributes;
+  }
+
+let class_declaration s decl =
+  For_copy.with_scope (fun copy_scope -> class_declaration' copy_scope s decl)
+
+let cltype_declaration' copy_scope s decl =
+  { clty_params = List.map (typexp copy_scope s) decl.clty_params;
+    clty_variance = decl.clty_variance;
+    clty_type = class_type copy_scope s decl.clty_type;
+    clty_path = type_path s decl.clty_path;
+    clty_loc = loc s decl.clty_loc;
+    clty_attributes = attrs s decl.clty_attributes;
+  }
+
+let cltype_declaration s decl =
+  For_copy.with_scope (fun copy_scope -> cltype_declaration' copy_scope s decl)
+
+let class_type s cty =
+  For_copy.with_scope (fun copy_scope -> class_type copy_scope s cty)
+
+let value_description' copy_scope s descr =
+  { val_type = typexp copy_scope s descr.val_type;
+    val_kind = descr.val_kind;
+    val_loc = loc s descr.val_loc;
+    val_attributes = attrs s descr.val_attributes;
+   }
+
+let value_description s descr =
+  For_copy.with_scope (fun copy_scope -> value_description' copy_scope s descr)
+
+let extension_constructor' copy_scope s ext =
+  { ext_type_path = type_path s ext.ext_type_path;
+    ext_type_params = List.map (typexp copy_scope s) ext.ext_type_params;
+    ext_args = constructor_arguments copy_scope s ext.ext_args;
+    ext_ret_type = Option.map (typexp copy_scope s) ext.ext_ret_type;
+    ext_private = ext.ext_private;
+    ext_attributes = attrs s ext.ext_attributes;
+    ext_loc = if s.for_saving then Location.none else ext.ext_loc; }
+
+let extension_constructor s ext =
+  For_copy.with_scope
+    (fun copy_scope -> extension_constructor' copy_scope s ext)
+
+type scoping =
+  | Keep
+  | Make_local
+  | Rescope of int
+
+let rename_bound_idents scoping s sg =
+  let rename =
+    let open Ident in
+    match scoping with
+    | Keep -> (fun id -> create_scoped ~scope:(scope id) (name id))
+    | Make_local -> Ident.rename
+    | Rescope scope -> (fun id -> create_scoped ~scope (name id))
+  in
+  let rec rename_bound_idents s sg = function
+    | [] -> sg, s
+    | Sig_type(id, td, rs, vis) :: rest ->
+        let id' = rename id in
+        rename_bound_idents
+          (add_type id (Pident id') s)
+          (Sig_type(id', td, rs, vis) :: sg)
+          rest
+    | Sig_module(id, pres, md, rs, vis) :: rest ->
+        let id' = rename id in
+        rename_bound_idents
+          (add_module id (Pident id') s)
+          (Sig_module (id', pres, md, rs, vis) :: sg)
+          rest
+    | Sig_modtype(id, mtd, vis) :: rest ->
+        let id' = rename id in
+        rename_bound_idents
+          (add_modtype id (Mty_ident(Pident id')) s)
+          (Sig_modtype(id', mtd, vis) :: sg)
+          rest
+    | Sig_class(id, cd, rs, vis) :: rest ->
+        (* cheat and pretend they are types cf. PR#6650 *)
+        let id' = rename id in
+        rename_bound_idents
+          (add_type id (Pident id') s)
+          (Sig_class(id', cd, rs, vis) :: sg)
+          rest
+    | Sig_class_type(id, ctd, rs, vis) :: rest ->
+        (* cheat and pretend they are types cf. PR#6650 *)
+        let id' = rename id in
+        rename_bound_idents
+          (add_type id (Pident id') s)
+          (Sig_class_type(id', ctd, rs, vis) :: sg)
+          rest
+    | Sig_value(id, vd, vis) :: rest ->
+        (* scope doesn't matter for value identifiers. *)
+        let id' = Ident.rename id in
+        rename_bound_idents s (Sig_value(id', vd, vis) :: sg) rest
+    | Sig_typext(id, ec, es, vis) :: rest ->
+        let id' = rename id in
+        rename_bound_idents s (Sig_typext(id',ec,es,vis) :: sg) rest
+  in
+  rename_bound_idents s [] sg
+
+let rec modtype scoping s = function
+    Mty_ident p as mty ->
+      begin match p with
+        Pident id ->
+          begin try Ident.Map.find id s.modtypes with Not_found -> mty end
+      | Pdot(p, n) ->
+          Mty_ident(Pdot(module_path s p, n))
+      | Papply _ ->
+          fatal_error "Subst.modtype"
+      end
+  | Mty_signature sg ->
+      Mty_signature(signature scoping s sg)
+  | Mty_functor(Unit, res) ->
+      Mty_functor(Unit, modtype scoping s res)
+  | Mty_functor(Named (None, arg), res) ->
+      Mty_functor(Named (None, (modtype scoping s) arg), modtype scoping s res)
+  | Mty_functor(Named (Some id, arg), res) ->
+      let id' = Ident.rename id in
+      Mty_functor(Named (Some id', (modtype scoping s) arg),
+                  modtype scoping (add_module id (Pident id') s) res)
+  | Mty_alias p ->
+      Mty_alias (module_path s p)
+
+and signature scoping s sg =
+  (* Components of signature may be mutually recursive (e.g. type declarations
+     or class and type declarations), so first build global renaming
+     substitution... *)
+  let (sg', s') = rename_bound_idents scoping s sg in
+  (* ... then apply it to each signature component in turn *)
+  For_copy.with_scope (fun copy_scope ->
+    List.rev_map (signature_item' copy_scope scoping s') sg'
+  )
+
+
+and signature_item' copy_scope scoping s comp =
+  match comp with
+    Sig_value(id, d, vis) ->
+      Sig_value(id, value_description' copy_scope s d, vis)
+  | Sig_type(id, d, rs, vis) ->
+      Sig_type(id, type_declaration' copy_scope s d, rs, vis)
+  | Sig_typext(id, ext, es, vis) ->
+      Sig_typext(id, extension_constructor' copy_scope s ext, es, vis)
+  | Sig_module(id, pres, d, rs, vis) ->
+      Sig_module(id, pres, module_declaration scoping s d, rs, vis)
+  | Sig_modtype(id, d, vis) ->
+      Sig_modtype(id, modtype_declaration scoping s d, vis)
+  | Sig_class(id, d, rs, vis) ->
+      Sig_class(id, class_declaration' copy_scope s d, rs, vis)
+  | Sig_class_type(id, d, rs, vis) ->
+      Sig_class_type(id, cltype_declaration' copy_scope s d, rs, vis)
+
+and signature_item s comp =
+  For_copy.with_scope (fun copy_scope -> signature_item' copy_scope s comp)
+
+and module_declaration scoping s decl =
+  {
+    md_type = modtype scoping s decl.md_type;
+    md_attributes = attrs s decl.md_attributes;
+    md_loc = loc s decl.md_loc;
+  }
+
+and modtype_declaration scoping s decl  =
+  {
+    mtd_type = Option.map (modtype scoping s) decl.mtd_type;
+    mtd_attributes = attrs s decl.mtd_attributes;
+    mtd_loc = loc s decl.mtd_loc;
+  }
+
+
+(* For every binding k |-> d of m1, add k |-> f d to m2
+   and return resulting merged map. *)
+
+let merge_tbls f m1 m2 =
+  Ident.Map.fold (fun k d accu -> Ident.Map.add k (f d) accu) m1 m2
+
+let merge_path_maps f m1 m2 =
+  Path.Map.fold (fun k d accu -> Path.Map.add k (f d) accu) m1 m2
+
+let type_replacement s = function
+  | Path p -> Path (type_path s p)
+  | Type_function { params; body } ->
+     let params = List.map (type_expr s) params in
+     let body = type_expr s body in
+     Type_function { params; body }
+
+(* Composition of substitutions:
+     apply (compose s1 s2) x = apply s2 (apply s1 x) *)
+
+let compose s1 s2 =
+  { types = merge_path_maps (type_replacement s2) s1.types s2.types;
+    modules = merge_path_maps (module_path s2) s1.modules s2.modules;
+    modtypes = merge_tbls (modtype Keep s2) s1.modtypes s2.modtypes;
+    for_saving = s1.for_saving || s2.for_saving;
+    make_loc_ghost = s1.make_loc_ghost || s2.make_loc_ghost;
+  }
diff --git a/src/ocaml/typing/410+multicore/subst.mli b/src/ocaml/typing/410+multicore/subst.mli
new file mode 100644
index 00000000..eb079b19
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/subst.mli
@@ -0,0 +1,86 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Substitutions *)
+
+open Types
+
+type t
+
+(*
+   Substitutions are used to translate a type from one context to
+   another.  This requires substituting paths for identifiers, and
+   possibly also lowering the level of non-generic variables so that
+   they are inferior to the maximum level of the new context.
+
+   Substitutions can also be used to create a "clean" copy of a type.
+   Indeed, non-variable node of a type are duplicated, with their
+   levels set to generic level.  That way, the resulting type is
+   well-formed (decreasing levels), even if the original one was not.
+*)
+
+val identity: t
+
+val add_type: Ident.t -> Path.t -> t -> t
+val add_type_path: Path.t -> Path.t -> t -> t
+val add_type_function:
+  Path.t -> params:type_expr list -> body:type_expr -> t -> t
+val add_module: Ident.t -> Path.t -> t -> t
+val add_module_path: Path.t -> Path.t -> t -> t
+val add_modtype: Ident.t -> module_type -> t -> t
+val for_saving: t -> t
+val make_loc_ghost: t -> t
+val reset_for_saving: unit -> unit
+
+val module_path: t -> Path.t -> Path.t
+val type_path: t -> Path.t -> Path.t
+
+val type_expr: t -> type_expr -> type_expr
+val class_type: t -> class_type -> class_type
+val value_description: t -> value_description -> value_description
+val type_declaration: t -> type_declaration -> type_declaration
+val extension_constructor:
+        t -> extension_constructor -> extension_constructor
+val class_declaration: t -> class_declaration -> class_declaration
+val cltype_declaration: t -> class_type_declaration -> class_type_declaration
+
+(*
+   When applied to a signature item, a substitution not only modifies the types
+   present in its declaration, but also refreshes the identifier of the item.
+   Effectively this creates new declarations, and so one should decide what the
+   scope of this new declaration should be.
+
+   This is decided by the [scoping] argument passed to the following functions.
+*)
+
+type scoping =
+  | Keep
+  | Make_local
+  | Rescope of int
+
+val modtype: scoping -> t -> module_type -> module_type
+val signature: scoping -> t -> signature -> signature
+val signature_item: scoping -> t -> signature_item -> signature_item
+val modtype_declaration:
+  scoping -> t -> modtype_declaration -> modtype_declaration
+val module_declaration: scoping -> t -> module_declaration -> module_declaration
+
+(* Composition of substitutions:
+     apply (compose s1 s2) x = apply s2 (apply s1 x) *)
+val compose: t -> t -> t
+
+(* A forward reference to be filled in ctype.ml. *)
+val ctype_apply_env_empty:
+  (type_expr list -> type_expr -> type_expr list -> type_expr) ref
diff --git a/src/ocaml/typing/410+multicore/tast_iterator.ml b/src/ocaml/typing/410+multicore/tast_iterator.ml
new file mode 100644
index 00000000..a6a2e440
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/tast_iterator.ml
@@ -0,0 +1,510 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                          Isaac "Izzy" Avram                            *)
+(*                                                                        *)
+(*   Copyright 2019 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Typedtree
+
+type iterator =
+  {
+    binding_op: iterator -> binding_op -> unit;
+    case: iterator -> case -> unit;
+    cases: iterator -> case list -> unit;
+    class_declaration: iterator -> class_declaration -> unit;
+    class_description: iterator -> class_description -> unit;
+    class_expr: iterator -> class_expr -> unit;
+    class_field: iterator -> class_field -> unit;
+    class_signature: iterator -> class_signature -> unit;
+    class_structure: iterator -> class_structure -> unit;
+    class_type: iterator -> class_type -> unit;
+    class_type_declaration: iterator -> class_type_declaration -> unit;
+    class_type_field: iterator -> class_type_field -> unit;
+    env: iterator -> Env.t -> unit;
+    expr: iterator -> expression -> unit;
+    extension_constructor: iterator -> extension_constructor -> unit;
+    module_binding: iterator -> module_binding -> unit;
+    module_coercion: iterator -> module_coercion -> unit;
+    module_declaration: iterator -> module_declaration -> unit;
+    module_substitution: iterator -> module_substitution -> unit;
+    module_expr: iterator -> module_expr -> unit;
+    module_type: iterator -> module_type -> unit;
+    module_type_declaration: iterator -> module_type_declaration -> unit;
+    package_type: iterator -> package_type -> unit;
+    pat: iterator -> pattern -> unit;
+    row_field: iterator -> row_field -> unit;
+    object_field: iterator -> object_field -> unit;
+    open_declaration: iterator -> open_declaration -> unit;
+    open_description: iterator -> open_description -> unit;
+    signature: iterator -> signature -> unit;
+    signature_item: iterator -> signature_item -> unit;
+    structure: iterator -> structure -> unit;
+    structure_item: iterator -> structure_item -> unit;
+    typ: iterator -> core_type -> unit;
+    type_declaration: iterator -> type_declaration -> unit;
+    type_declarations: iterator -> (rec_flag * type_declaration list) -> unit;
+    type_extension: iterator -> type_extension -> unit;
+    type_exception: iterator -> type_exception -> unit;
+    type_kind: iterator -> type_kind -> unit;
+    value_binding: iterator -> value_binding -> unit;
+    value_bindings: iterator -> (rec_flag * value_binding list) -> unit;
+    value_description: iterator -> value_description -> unit;
+    with_constraint: iterator -> with_constraint -> unit;
+  }
+
+let structure sub {str_items; str_final_env; _} =
+  List.iter (sub.structure_item sub) str_items;
+  sub.env sub str_final_env
+
+let class_infos sub f x =
+  List.iter (fun (ct, _) -> sub.typ sub ct) x.ci_params;
+  f x.ci_expr
+
+let module_type_declaration sub {mtd_type; _} =
+  Option.iter (sub.module_type sub) mtd_type
+
+let module_declaration sub {md_type; _} =
+  sub.module_type sub md_type
+let module_substitution _ _ = ()
+
+let include_infos f {incl_mod; _} = f incl_mod
+
+let class_type_declaration sub x =
+  class_infos sub (sub.class_type sub) x
+
+let class_declaration sub x =
+  class_infos sub (sub.class_expr sub) x
+
+let structure_item sub {str_desc; str_env; _} =
+  sub.env sub str_env;
+  match str_desc with
+  | Tstr_eval   (exp, _) -> sub.expr sub exp
+  | Tstr_value  (rec_flag, list) -> sub.value_bindings sub (rec_flag, list)
+  | Tstr_primitive v -> sub.value_description sub v
+  | Tstr_type (rec_flag, list) -> sub.type_declarations sub (rec_flag, list)
+  | Tstr_typext te -> sub.type_extension sub te
+  | Tstr_exception ext -> sub.type_exception sub ext
+  | Tstr_module mb -> sub.module_binding sub mb
+  | Tstr_recmodule list -> List.iter (sub.module_binding sub) list
+  | Tstr_modtype x -> sub.module_type_declaration sub x
+  | Tstr_class list ->
+      List.iter (fun (cls,_) -> sub.class_declaration sub cls) list
+  | Tstr_class_type list ->
+      List.iter (fun (_, _, cltd) -> sub.class_type_declaration sub cltd) list
+  | Tstr_include incl -> include_infos (sub.module_expr sub) incl
+  | Tstr_open od -> sub.open_declaration sub od
+  | Tstr_attribute _ -> ()
+
+let value_description sub x = sub.typ sub x.val_desc
+
+let label_decl sub {ld_type; _} = sub.typ sub ld_type
+
+let constructor_args sub = function
+  | Cstr_tuple l -> List.iter (sub.typ sub) l
+  | Cstr_record l -> List.iter (label_decl sub) l
+
+let constructor_decl sub {cd_args; cd_res; _} =
+  constructor_args sub cd_args;
+  Option.iter (sub.typ sub) cd_res
+
+let type_kind sub = function
+  | Ttype_abstract -> ()
+  | Ttype_variant list -> List.iter (constructor_decl sub) list
+  | Ttype_record list -> List.iter (label_decl sub) list
+  | Ttype_open -> ()
+
+let type_declaration sub {typ_cstrs; typ_kind; typ_manifest; typ_params; _} =
+  List.iter
+    (fun (c1, c2, _) ->
+      sub.typ sub c1;
+      sub.typ sub c2)
+    typ_cstrs;
+  sub.type_kind sub typ_kind;
+  Option.iter (sub.typ sub) typ_manifest;
+  List.iter (fun (c, _) -> sub.typ sub c) typ_params
+
+let type_declarations sub (_, list) = List.iter (sub.type_declaration sub) list
+
+let type_extension sub {tyext_constructors; tyext_params; _} =
+  List.iter (fun (c, _) -> sub.typ sub c) tyext_params;
+  List.iter (sub.extension_constructor sub) tyext_constructors
+
+let type_exception sub {tyexn_constructor; _} =
+  sub.extension_constructor sub tyexn_constructor
+
+let extension_constructor sub {ext_kind; _} =
+  match ext_kind with
+  | Text_decl (ctl, cto) ->
+      constructor_args sub ctl;
+      Option.iter (sub.typ sub) cto
+  | Text_rebind _ -> ()
+
+let pat sub {pat_extra; pat_desc; pat_env; _} =
+  let extra = function
+    | Tpat_type _ -> ()
+    | Tpat_unpack -> ()
+    | Tpat_open (_, _, env) -> sub.env sub env
+    | Tpat_constraint ct -> sub.typ sub ct
+  in
+  sub.env sub pat_env;
+  List.iter (fun (e, _, _) -> extra e) pat_extra;
+  match pat_desc with
+  | Tpat_any  -> ()
+  | Tpat_var _ -> ()
+  | Tpat_constant _ -> ()
+  | Tpat_tuple l -> List.iter (sub.pat sub) l
+  | Tpat_construct (_, _, l) -> List.iter (sub.pat sub) l
+  | Tpat_variant (_, po, _) -> Option.iter (sub.pat sub) po
+  | Tpat_record (l, _) -> List.iter (fun (_, _, i) -> sub.pat sub i) l
+  | Tpat_array l -> List.iter (sub.pat sub) l
+  | Tpat_or (p1, p2, _) ->
+      sub.pat sub p1;
+      sub.pat sub p2
+  | Tpat_alias (p, _, _) -> sub.pat sub p
+  | Tpat_lazy p -> sub.pat sub p
+  | Tpat_exception p -> sub.pat sub p
+
+let expr sub {exp_extra; exp_desc; exp_env; _} =
+  let extra = function
+    | Texp_constraint cty -> sub.typ sub cty
+    | Texp_coerce (cty1, cty2) ->
+        Option.iter (sub.typ sub) cty1;
+        sub.typ sub cty2
+    | Texp_newtype _ -> ()
+    | Texp_poly cto -> Option.iter (sub.typ sub) cto
+  in
+  List.iter (fun (e, _, _) -> extra e) exp_extra;
+  sub.env sub exp_env;
+  match exp_desc with
+  | Texp_ident _  -> ()
+  | Texp_constant _ -> ()
+  | Texp_let (rec_flag, list, exp) ->
+      sub.value_bindings sub (rec_flag, list);
+      sub.expr sub exp
+  | Texp_function {cases; _} -> sub.cases sub cases
+  | Texp_apply (exp, list) ->
+      sub.expr sub exp;
+      List.iter (fun (_, o) -> Option.iter (sub.expr sub) o) list
+  | Texp_match (exp, cases, _) ->
+      sub.expr sub exp;
+      sub.cases sub cases
+  | Texp_try (exp, cases) ->
+      sub.expr sub exp;
+      sub.cases sub cases
+  | Texp_tuple list -> List.iter (sub.expr sub) list
+  | Texp_construct (_, _, args) -> List.iter (sub.expr sub) args
+  | Texp_variant (_, expo) -> Option.iter (sub.expr sub) expo
+  | Texp_record { fields; extended_expression; _} ->
+      Array.iter (function
+        | _, Kept _ -> ()
+        | _, Overridden (_, exp) -> sub.expr sub exp)
+        fields;
+      Option.iter (sub.expr sub) extended_expression;
+  | Texp_field (exp, _, _) -> sub.expr sub exp
+  | Texp_setfield (exp1, _, _, exp2) ->
+      sub.expr sub exp1;
+      sub.expr sub exp2
+  | Texp_array list -> List.iter (sub.expr sub) list
+  | Texp_ifthenelse (exp1, exp2, expo) ->
+      sub.expr sub exp1;
+      sub.expr sub exp2;
+      Option.iter (sub.expr sub) expo
+  | Texp_sequence (exp1, exp2) ->
+      sub.expr sub exp1;
+      sub.expr sub exp2
+  | Texp_while (exp1, exp2) ->
+      sub.expr sub exp1;
+      sub.expr sub exp2
+  | Texp_for (_, _, exp1, exp2, _, exp3) ->
+      sub.expr sub exp1;
+      sub.expr sub exp2;
+      sub.expr sub exp3
+  | Texp_send (exp, _, expo) ->
+      sub.expr sub exp;
+      Option.iter (sub.expr sub) expo
+  | Texp_new _ -> ()
+  | Texp_instvar _ -> ()
+  | Texp_setinstvar (_, _, _, exp) ->sub.expr sub exp
+  | Texp_override (_, list) ->
+      List.iter (fun (_, _, e) -> sub.expr sub e) list
+  | Texp_letmodule (_, _, _, mexpr, exp) ->
+      sub.module_expr sub mexpr;
+      sub.expr sub exp
+  | Texp_letexception (cd, exp) ->
+      sub.extension_constructor sub cd;
+      sub.expr sub exp
+  | Texp_assert exp -> sub.expr sub exp
+  | Texp_lazy exp -> sub.expr sub exp
+  | Texp_object (cl, _) -> sub.class_structure sub cl
+  | Texp_pack mexpr -> sub.module_expr sub mexpr
+  | Texp_letop {let_ = l; ands; body; _} ->
+      sub.binding_op sub l;
+      List.iter (sub.binding_op sub) ands;
+      sub.case sub body
+  | Texp_unreachable -> ()
+  | Texp_extension_constructor _ -> ()
+  | Texp_open (od, e) ->
+      sub.open_declaration sub od;
+      sub.expr sub e
+
+
+let package_type sub {pack_fields; _} =
+  List.iter (fun (_, p) -> sub.typ sub p) pack_fields
+
+let binding_op sub {bop_exp; _} = sub.expr sub bop_exp
+
+let signature sub {sig_items; sig_final_env; _} =
+  sub.env sub sig_final_env;
+  List.iter (sub.signature_item sub) sig_items
+
+let signature_item sub {sig_desc; sig_env; _} =
+  sub.env sub sig_env;
+  match sig_desc with
+  | Tsig_value v -> sub.value_description sub v
+  | Tsig_type (rf, tdl)  -> sub.type_declarations sub (rf, tdl)
+  | Tsig_typesubst list -> sub.type_declarations sub (Nonrecursive, list)
+  | Tsig_typext te -> sub.type_extension sub te
+  | Tsig_exception ext -> sub.type_exception sub ext
+  | Tsig_module x -> sub.module_declaration sub x
+  | Tsig_modsubst x -> sub.module_substitution sub x
+  | Tsig_recmodule list -> List.iter (sub.module_declaration sub) list
+  | Tsig_modtype x -> sub.module_type_declaration sub x
+  | Tsig_include incl -> include_infos (sub.module_type sub) incl
+  | Tsig_class list -> List.iter (sub.class_description sub) list
+  | Tsig_class_type list -> List.iter (sub.class_type_declaration sub) list
+  | Tsig_open od -> sub.open_description sub od
+  | Tsig_attribute _ -> ()
+
+let class_description sub x =
+  class_infos sub (sub.class_type sub) x
+
+let functor_parameter sub = function
+  | Unit -> ()
+  | Named (_, _, mtype) -> sub.module_type sub mtype
+
+let module_type sub {mty_desc; mty_env; _} =
+  sub.env sub mty_env;
+  match mty_desc with
+  | Tmty_ident _      -> ()
+  | Tmty_alias _      -> ()
+  | Tmty_signature sg -> sub.signature sub sg
+  | Tmty_functor (arg, mtype2) ->
+      functor_parameter sub arg;
+      sub.module_type sub mtype2
+  | Tmty_with (mtype, list) ->
+      sub.module_type sub mtype;
+      List.iter (fun (_, _, e) -> sub.with_constraint sub e) list
+  | Tmty_typeof mexpr -> sub.module_expr sub mexpr
+
+let with_constraint sub = function
+  | Twith_type      decl -> sub.type_declaration sub decl
+  | Twith_typesubst decl -> sub.type_declaration sub decl
+  | Twith_module    _    -> ()
+  | Twith_modsubst  _    -> ()
+
+let open_description sub {open_env; _} = sub.env sub open_env
+
+let open_declaration sub {open_expr; open_env; _} =
+  sub.module_expr sub open_expr;
+  sub.env sub open_env
+
+let module_coercion sub = function
+  | Tcoerce_none -> ()
+  | Tcoerce_functor (c1,c2) ->
+      sub.module_coercion sub c1;
+      sub.module_coercion sub c2
+  | Tcoerce_alias (env, _, c1) ->
+      sub.env sub env;
+      sub.module_coercion sub c1
+  | Tcoerce_structure (l1, l2) ->
+      List.iter (fun (_, c) -> sub.module_coercion sub c) l1;
+      List.iter (fun (_, _ ,c) -> sub.module_coercion sub c) l2
+  | Tcoerce_primitive {pc_env; _} -> sub.env sub pc_env
+
+let module_expr sub {mod_desc; mod_env; _} =
+  sub.env sub mod_env;
+  match mod_desc with
+  | Tmod_ident _      -> ()
+  | Tmod_structure st -> sub.structure sub st
+  | Tmod_functor (arg, mexpr) ->
+      functor_parameter sub arg;
+      sub.module_expr sub mexpr
+  | Tmod_apply (mexp1, mexp2, c) ->
+      sub.module_expr sub mexp1;
+      sub.module_expr sub mexp2;
+      sub.module_coercion sub c
+  | Tmod_constraint (mexpr, _, Tmodtype_implicit, c) ->
+      sub.module_expr sub mexpr;
+      sub.module_coercion sub c
+  | Tmod_constraint (mexpr, _, Tmodtype_explicit mtype, c) ->
+      sub.module_expr sub mexpr;
+      sub.module_type sub mtype;
+      sub.module_coercion sub c
+  | Tmod_unpack (exp, _) -> sub.expr sub exp
+
+let module_binding sub {mb_expr; _} = sub.module_expr sub mb_expr
+
+let class_expr sub {cl_desc; cl_env; _} =
+  sub.env sub cl_env;
+  match cl_desc with
+  | Tcl_constraint (cl, clty, _, _, _) ->
+      sub.class_expr sub cl;
+      Option.iter (sub.class_type sub) clty
+  | Tcl_structure clstr -> sub.class_structure sub clstr
+  | Tcl_fun (_, pat, priv, cl, _) ->
+      sub.pat sub pat;
+      List.iter (fun (_, e) -> sub.expr sub e) priv;
+      sub.class_expr sub cl
+  | Tcl_apply (cl, args) ->
+      sub.class_expr sub cl;
+      List.iter (fun (_, e) -> Option.iter (sub.expr sub) e) args
+  | Tcl_let (rec_flag, value_bindings, ivars, cl) ->
+      sub.value_bindings sub (rec_flag, value_bindings);
+      List.iter (fun (_, e) -> sub.expr sub e) ivars;
+      sub.class_expr sub cl
+  | Tcl_ident (_, _, tyl) -> List.iter (sub.typ sub) tyl
+  | Tcl_open (od, e) ->
+      sub.open_description sub od;
+      sub.class_expr sub e
+
+let class_type sub {cltyp_desc; cltyp_env; _} =
+  sub.env sub cltyp_env;
+  match cltyp_desc with
+  | Tcty_signature csg -> sub.class_signature sub csg
+  | Tcty_constr (_, _, list) -> List.iter (sub.typ sub) list
+  | Tcty_arrow (_, ct, cl) ->
+      sub.typ sub ct;
+      sub.class_type sub cl
+  | Tcty_open (od, e) ->
+      sub.open_description sub od;
+      sub.class_type sub e
+
+let class_signature sub {csig_self; csig_fields; _} =
+  sub.typ sub csig_self;
+  List.iter (sub.class_type_field sub) csig_fields
+
+let class_type_field sub {ctf_desc; _} =
+  match ctf_desc with
+  | Tctf_inherit ct -> sub.class_type sub ct
+  | Tctf_val (_, _, _, ct) ->  sub.typ sub ct
+  | Tctf_method (_, _, _, ct) -> sub.typ sub ct
+  | Tctf_constraint  (ct1, ct2) ->
+      sub.typ sub ct1;
+      sub.typ sub ct2
+  | Tctf_attribute _ -> ()
+
+let typ sub {ctyp_desc; ctyp_env; _} =
+  sub.env sub ctyp_env;
+  match ctyp_desc with
+  | Ttyp_any   -> ()
+  | Ttyp_var _ -> ()
+  | Ttyp_arrow (_, ct1, ct2) ->
+      sub.typ sub ct1;
+      sub.typ sub ct2
+  | Ttyp_tuple list -> List.iter (sub.typ sub) list
+  | Ttyp_constr (_, _, list) ->  List.iter (sub.typ sub) list
+  | Ttyp_object (list, _) -> List.iter (sub.object_field sub) list
+  | Ttyp_class (_, _, list) -> List.iter (sub.typ sub) list
+  | Ttyp_alias (ct, _) -> sub.typ sub ct
+  | Ttyp_variant (list, _, _) -> List.iter (sub.row_field sub) list
+  | Ttyp_poly (_, ct) -> sub.typ sub ct
+  | Ttyp_package pack -> sub.package_type sub pack
+
+let class_structure sub {cstr_self; cstr_fields; _} =
+  sub.pat sub cstr_self;
+  List.iter (sub.class_field sub) cstr_fields
+
+let row_field sub {rf_desc; _} =
+  match rf_desc with
+  | Ttag (_, _, list) -> List.iter (sub.typ sub) list
+  | Tinherit ct -> sub.typ sub ct
+
+let object_field sub {of_desc; _} =
+  match of_desc with
+  | OTtag (_, ct) -> sub.typ sub ct
+  | OTinherit ct -> sub.typ sub ct
+
+let class_field_kind sub = function
+  | Tcfk_virtual ct -> sub.typ sub ct
+  | Tcfk_concrete (_, e) -> sub.expr sub e
+
+let class_field sub {cf_desc; _} = match cf_desc with
+  | Tcf_inherit (_, cl, _, _, _) -> sub.class_expr sub cl
+  | Tcf_constraint (cty1, cty2) ->
+      sub.typ sub cty1;
+      sub.typ sub cty2
+  | Tcf_val (_, _, _, k, _) -> class_field_kind sub k
+  | Tcf_method (_, _, k) -> class_field_kind sub k
+  | Tcf_initializer exp -> sub.expr sub exp
+  | Tcf_attribute _ -> ()
+
+let value_bindings sub (_, list) = List.iter (sub.value_binding sub) list
+
+let cases sub l = List.iter (sub.case sub) l
+
+let case sub {c_lhs; c_guard; c_rhs} =
+  sub.pat sub c_lhs;
+  Option.iter (sub.expr sub) c_guard;
+  sub.expr sub c_rhs
+
+let value_binding sub {vb_pat; vb_expr; _} =
+  sub.pat sub vb_pat;
+  sub.expr sub vb_expr
+
+let env _sub _ = ()
+
+let default_iterator =
+  {
+    binding_op;
+    case;
+    cases;
+    class_declaration;
+    class_description;
+    class_expr;
+    class_field;
+    class_signature;
+    class_structure;
+    class_type;
+    class_type_declaration;
+    class_type_field;
+    env;
+    expr;
+    extension_constructor;
+    module_binding;
+    module_coercion;
+    module_declaration;
+    module_substitution;
+    module_expr;
+    module_type;
+    module_type_declaration;
+    package_type;
+    pat;
+    row_field;
+    object_field;
+    open_declaration;
+    open_description;
+    signature;
+    signature_item;
+    structure;
+    structure_item;
+    typ;
+    type_declaration;
+    type_declarations;
+    type_extension;
+    type_exception;
+    type_kind;
+    value_binding;
+    value_bindings;
+    value_description;
+    with_constraint;
+  }
diff --git a/src/ocaml/typing/410+multicore/tast_iterator.mli b/src/ocaml/typing/410+multicore/tast_iterator.mli
new file mode 100644
index 00000000..dc6f56f4
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/tast_iterator.mli
@@ -0,0 +1,69 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                           Isaac "Izzy" Avram                           *)
+(*                                                                        *)
+(*   Copyright 2019 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(**
+Allows the implementation of typed tree inspection using open recursion
+*)
+
+open Asttypes
+open Typedtree
+
+type iterator =
+  {
+    binding_op: iterator -> binding_op -> unit;
+    case: iterator -> case -> unit;
+    cases: iterator -> case list -> unit;
+    class_declaration: iterator -> class_declaration -> unit;
+    class_description: iterator -> class_description -> unit;
+    class_expr: iterator -> class_expr -> unit;
+    class_field: iterator -> class_field -> unit;
+    class_signature: iterator -> class_signature -> unit;
+    class_structure: iterator -> class_structure -> unit;
+    class_type: iterator -> class_type -> unit;
+    class_type_declaration: iterator -> class_type_declaration -> unit;
+    class_type_field: iterator -> class_type_field -> unit;
+    env: iterator -> Env.t -> unit;
+    expr: iterator -> expression -> unit;
+    extension_constructor: iterator -> extension_constructor -> unit;
+    module_binding: iterator -> module_binding -> unit;
+    module_coercion: iterator -> module_coercion -> unit;
+    module_declaration: iterator -> module_declaration -> unit;
+    module_substitution: iterator -> module_substitution -> unit;
+    module_expr: iterator -> module_expr -> unit;
+    module_type: iterator -> module_type -> unit;
+    module_type_declaration: iterator -> module_type_declaration -> unit;
+    package_type: iterator -> package_type -> unit;
+    pat: iterator -> pattern -> unit;
+    row_field: iterator -> row_field -> unit;
+    object_field: iterator -> object_field -> unit;
+    open_declaration: iterator -> open_declaration -> unit;
+    open_description: iterator -> open_description -> unit;
+    signature: iterator -> signature -> unit;
+    signature_item: iterator -> signature_item -> unit;
+    structure: iterator -> structure -> unit;
+    structure_item: iterator -> structure_item -> unit;
+    typ: iterator -> core_type -> unit;
+    type_declaration: iterator -> type_declaration -> unit;
+    type_declarations: iterator -> (rec_flag * type_declaration list) -> unit;
+    type_extension: iterator -> type_extension -> unit;
+    type_exception: iterator -> type_exception -> unit;
+    type_kind: iterator -> type_kind -> unit;
+    value_binding: iterator -> value_binding -> unit;
+    value_bindings: iterator -> (rec_flag * value_binding list) -> unit;
+    value_description: iterator -> value_description -> unit;
+    with_constraint: iterator -> with_constraint -> unit;
+  }
+
+val default_iterator: iterator
diff --git a/src/ocaml/typing/410+multicore/tast_mapper.ml b/src/ocaml/typing/410+multicore/tast_mapper.ml
new file mode 100644
index 00000000..c288345e
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/tast_mapper.ml
@@ -0,0 +1,742 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                        Alain Frisch, LexiFi                            *)
+(*                                                                        *)
+(*   Copyright 2015 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Typedtree
+
+(* TODO: add 'methods' for location, attribute, extension,
+   include_declaration, include_description *)
+
+type mapper =
+  {
+    binding_op: mapper -> binding_op -> binding_op;
+    case: mapper -> case -> case;
+    cases: mapper -> case list -> case list;
+    class_declaration: mapper -> class_declaration -> class_declaration;
+    class_description: mapper -> class_description -> class_description;
+    class_expr: mapper -> class_expr -> class_expr;
+    class_field: mapper -> class_field -> class_field;
+    class_signature: mapper -> class_signature -> class_signature;
+    class_structure: mapper -> class_structure -> class_structure;
+    class_type: mapper -> class_type -> class_type;
+    class_type_declaration: mapper -> class_type_declaration ->
+      class_type_declaration;
+    class_type_field: mapper -> class_type_field -> class_type_field;
+    env: mapper -> Env.t -> Env.t;
+    expr: mapper -> expression -> expression;
+    extension_constructor: mapper -> extension_constructor ->
+      extension_constructor;
+    module_binding: mapper -> module_binding -> module_binding;
+    module_coercion: mapper -> module_coercion -> module_coercion;
+    module_declaration: mapper -> module_declaration -> module_declaration;
+    module_substitution: mapper -> module_substitution -> module_substitution;
+    module_expr: mapper -> module_expr -> module_expr;
+    module_type: mapper -> module_type -> module_type;
+    module_type_declaration:
+      mapper -> module_type_declaration -> module_type_declaration;
+    package_type: mapper -> package_type -> package_type;
+    pat: mapper -> pattern -> pattern;
+    row_field: mapper -> row_field -> row_field;
+    object_field: mapper -> object_field -> object_field;
+    open_declaration: mapper -> open_declaration -> open_declaration;
+    open_description: mapper -> open_description -> open_description;
+    signature: mapper -> signature -> signature;
+    signature_item: mapper -> signature_item -> signature_item;
+    structure: mapper -> structure -> structure;
+    structure_item: mapper -> structure_item -> structure_item;
+    typ: mapper -> core_type -> core_type;
+    type_declaration: mapper -> type_declaration -> type_declaration;
+    type_declarations: mapper -> (rec_flag * type_declaration list)
+      -> (rec_flag * type_declaration list);
+    type_extension: mapper -> type_extension -> type_extension;
+    type_exception: mapper -> type_exception -> type_exception;
+    type_kind: mapper -> type_kind -> type_kind;
+    value_binding: mapper -> value_binding -> value_binding;
+    value_bindings: mapper -> (rec_flag * value_binding list) ->
+      (rec_flag * value_binding list);
+    value_description: mapper -> value_description -> value_description;
+    with_constraint: mapper -> with_constraint -> with_constraint;
+  }
+
+let id x = x
+let tuple2 f1 f2 (x, y) = (f1 x, f2 y)
+let tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
+
+let structure sub {str_items; str_type; str_final_env} =
+  {
+    str_items = List.map (sub.structure_item sub) str_items;
+    str_final_env = sub.env sub str_final_env;
+    str_type;
+  }
+
+let class_infos sub f x =
+  {x with
+   ci_params = List.map (tuple2 (sub.typ sub) id) x.ci_params;
+   ci_expr = f x.ci_expr;
+  }
+
+let module_type_declaration sub x =
+  let mtd_type = Option.map (sub.module_type sub) x.mtd_type in
+  {x with mtd_type}
+
+let module_declaration sub x =
+  let md_type = sub.module_type sub x.md_type in
+  {x with md_type}
+
+let module_substitution _ x = x
+
+let include_infos f x = {x with incl_mod = f x.incl_mod}
+
+let class_type_declaration sub x =
+  class_infos sub (sub.class_type sub) x
+
+let class_declaration sub x =
+  class_infos sub (sub.class_expr sub) x
+
+let structure_item sub {str_desc; str_loc; str_env} =
+  let str_env = sub.env sub str_env in
+  let str_desc =
+    match str_desc with
+    | Tstr_eval (exp, attrs) -> Tstr_eval (sub.expr sub exp, attrs)
+    | Tstr_value (rec_flag, list) ->
+        let (rec_flag, list) = sub.value_bindings sub (rec_flag, list) in
+        Tstr_value (rec_flag, list)
+    | Tstr_primitive v -> Tstr_primitive (sub.value_description sub v)
+    | Tstr_type (rec_flag, list) ->
+        let (rec_flag, list) = sub.type_declarations sub (rec_flag, list) in
+        Tstr_type (rec_flag, list)
+    | Tstr_typext te -> Tstr_typext (sub.type_extension sub te)
+    | Tstr_exception ext -> Tstr_exception (sub.type_exception sub ext)
+    | Tstr_module mb -> Tstr_module (sub.module_binding sub mb)
+    | Tstr_recmodule list ->
+        Tstr_recmodule (List.map (sub.module_binding sub) list)
+    | Tstr_modtype x -> Tstr_modtype (sub.module_type_declaration sub x)
+    | Tstr_class list ->
+        Tstr_class
+          (List.map (tuple2 (sub.class_declaration sub) id) list)
+    | Tstr_class_type list ->
+        Tstr_class_type
+          (List.map (tuple3 id id (sub.class_type_declaration sub)) list)
+    | Tstr_include incl ->
+        Tstr_include (include_infos (sub.module_expr sub) incl)
+    | Tstr_open od -> Tstr_open (sub.open_declaration sub od)
+    | Tstr_attribute _ as d -> d
+  in
+  {str_desc; str_env; str_loc}
+
+let value_description sub x =
+  let val_desc = sub.typ sub x.val_desc in
+  {x with val_desc}
+
+let label_decl sub x =
+  let ld_type = sub.typ sub x.ld_type in
+  {x with ld_type}
+
+let constructor_args sub = function
+  | Cstr_tuple l -> Cstr_tuple (List.map (sub.typ sub) l)
+  | Cstr_record l -> Cstr_record (List.map (label_decl sub) l)
+
+let constructor_decl sub cd =
+  let cd_args = constructor_args sub cd.cd_args in
+  let cd_res = Option.map (sub.typ sub) cd.cd_res in
+  {cd with cd_args; cd_res}
+
+let type_kind sub = function
+  | Ttype_abstract -> Ttype_abstract
+  | Ttype_variant list -> Ttype_variant (List.map (constructor_decl sub) list)
+  | Ttype_record list -> Ttype_record (List.map (label_decl sub) list)
+  | Ttype_open -> Ttype_open
+
+let type_declaration sub x =
+  let typ_cstrs =
+    List.map
+      (tuple3 (sub.typ sub) (sub.typ sub) id)
+      x.typ_cstrs
+  in
+  let typ_kind = sub.type_kind sub x.typ_kind in
+  let typ_manifest = Option.map (sub.typ sub) x.typ_manifest in
+  let typ_params = List.map (tuple2 (sub.typ sub) id) x.typ_params in
+  {x with typ_cstrs; typ_kind; typ_manifest; typ_params}
+
+let type_declarations sub (rec_flag, list) =
+  (rec_flag, List.map (sub.type_declaration sub) list)
+
+let type_extension sub x =
+  let tyext_params = List.map (tuple2 (sub.typ sub) id) x.tyext_params in
+  let tyext_constructors =
+    List.map (sub.extension_constructor sub) x.tyext_constructors
+  in
+  {x with tyext_constructors; tyext_params}
+
+let type_exception sub x =
+  let tyexn_constructor =
+    sub.extension_constructor sub x.tyexn_constructor
+  in
+  {x with tyexn_constructor}
+
+let extension_constructor sub x =
+  let ext_kind =
+    match x.ext_kind with
+      Text_decl(ctl, cto) ->
+        Text_decl(constructor_args sub ctl, Option.map (sub.typ sub) cto)
+    | Text_rebind _ as d -> d
+  in
+  {x with ext_kind}
+
+let pat sub x =
+  let extra = function
+    | Tpat_type _
+    | Tpat_unpack as d -> d
+    | Tpat_open (path,loc,env) ->  Tpat_open (path, loc, sub.env sub env)
+    | Tpat_constraint ct -> Tpat_constraint (sub.typ sub ct)
+  in
+  let pat_env = sub.env sub x.pat_env in
+  let pat_extra = List.map (tuple3 extra id id) x.pat_extra in
+  let pat_desc =
+    match x.pat_desc with
+    | Tpat_any
+    | Tpat_var _
+    | Tpat_constant _ as d -> d
+    | Tpat_tuple l -> Tpat_tuple (List.map (sub.pat sub) l)
+    | Tpat_construct (loc, cd, l) ->
+        Tpat_construct (loc, cd, List.map (sub.pat sub) l)
+    | Tpat_variant (l, po, rd) ->
+        Tpat_variant (l, Option.map (sub.pat sub) po, rd)
+    | Tpat_record (l, closed) ->
+        Tpat_record (List.map (tuple3 id id (sub.pat sub)) l, closed)
+    | Tpat_array l -> Tpat_array (List.map (sub.pat sub) l)
+    | Tpat_or (p1, p2, rd) ->
+        Tpat_or (sub.pat sub p1, sub.pat sub p2, rd)
+    | Tpat_alias (p, id, s) -> Tpat_alias (sub.pat sub p, id, s)
+    | Tpat_lazy p -> Tpat_lazy (sub.pat sub p)
+    | Tpat_exception p -> Tpat_exception (sub.pat sub p)
+  in
+  {x with pat_extra; pat_desc; pat_env}
+
+let expr sub x =
+  let extra = function
+    | Texp_constraint cty ->
+        Texp_constraint (sub.typ sub cty)
+    | Texp_coerce (cty1, cty2) ->
+        Texp_coerce (Option.map (sub.typ sub) cty1, sub.typ sub cty2)
+    | Texp_newtype _ as d -> d
+    | Texp_poly cto -> Texp_poly (Option.map (sub.typ sub) cto)
+  in
+  let exp_extra = List.map (tuple3 extra id id) x.exp_extra in
+  let exp_env = sub.env sub x.exp_env in
+  let exp_desc =
+    match x.exp_desc with
+    | Texp_ident _
+    | Texp_constant _ as d -> d
+    | Texp_let (rec_flag, list, exp) ->
+        let (rec_flag, list) = sub.value_bindings sub (rec_flag, list) in
+        Texp_let (rec_flag, list, sub.expr sub exp)
+    | Texp_function { arg_label; param; cases; partial; } ->
+        Texp_function { arg_label; param; cases = sub.cases sub cases;
+          partial; }
+    | Texp_apply (exp, list) ->
+        Texp_apply (
+          sub.expr sub exp,
+          List.map (tuple2 id (Option.map (sub.expr sub))) list
+        )
+    | Texp_match (exp, cases, p) ->
+        Texp_match (
+          sub.expr sub exp,
+          sub.cases sub cases,
+          p
+        )
+    | Texp_try (exp, cases) ->
+        Texp_try (
+          sub.expr sub exp,
+          sub.cases sub cases
+        )
+    | Texp_tuple list ->
+        Texp_tuple (List.map (sub.expr sub) list)
+    | Texp_construct (lid, cd, args) ->
+        Texp_construct (lid, cd, List.map (sub.expr sub) args)
+    | Texp_variant (l, expo) ->
+        Texp_variant (l, Option.map (sub.expr sub) expo)
+    | Texp_record { fields; representation; extended_expression } ->
+        let fields = Array.map (function
+            | label, Kept t -> label, Kept t
+            | label, Overridden (lid, exp) ->
+                label, Overridden (lid, sub.expr sub exp))
+            fields
+        in
+        Texp_record {
+          fields; representation;
+          extended_expression = Option.map (sub.expr sub) extended_expression;
+        }
+    | Texp_field (exp, lid, ld) ->
+        Texp_field (sub.expr sub exp, lid, ld)
+    | Texp_setfield (exp1, lid, ld, exp2) ->
+        Texp_setfield (
+          sub.expr sub exp1,
+          lid,
+          ld,
+          sub.expr sub exp2
+        )
+    | Texp_array list ->
+        Texp_array (List.map (sub.expr sub) list)
+    | Texp_ifthenelse (exp1, exp2, expo) ->
+        Texp_ifthenelse (
+          sub.expr sub exp1,
+          sub.expr sub exp2,
+          Option.map (sub.expr sub) expo
+        )
+    | Texp_sequence (exp1, exp2) ->
+        Texp_sequence (
+          sub.expr sub exp1,
+          sub.expr sub exp2
+        )
+    | Texp_while (exp1, exp2) ->
+        Texp_while (
+          sub.expr sub exp1,
+          sub.expr sub exp2
+        )
+    | Texp_for (id, p, exp1, exp2, dir, exp3) ->
+        Texp_for (
+          id,
+          p,
+          sub.expr sub exp1,
+          sub.expr sub exp2,
+          dir,
+          sub.expr sub exp3
+        )
+    | Texp_send (exp, meth, expo) ->
+        Texp_send
+          (
+            sub.expr sub exp,
+            meth,
+            Option.map (sub.expr sub) expo
+          )
+    | Texp_new _
+    | Texp_instvar _ as d -> d
+    | Texp_setinstvar (path1, path2, id, exp) ->
+        Texp_setinstvar (
+          path1,
+          path2,
+          id,
+          sub.expr sub exp
+        )
+    | Texp_override (path, list) ->
+        Texp_override (
+          path,
+          List.map (tuple3 id id (sub.expr sub)) list
+        )
+    | Texp_letmodule (id, s, pres, mexpr, exp) ->
+        Texp_letmodule (
+          id,
+          s,
+          pres,
+          sub.module_expr sub mexpr,
+          sub.expr sub exp
+        )
+    | Texp_letexception (cd, exp) ->
+        Texp_letexception (
+          sub.extension_constructor sub cd,
+          sub.expr sub exp
+        )
+    | Texp_assert exp ->
+        Texp_assert (sub.expr sub exp)
+    | Texp_lazy exp ->
+        Texp_lazy (sub.expr sub exp)
+    | Texp_object (cl, sl) ->
+        Texp_object (sub.class_structure sub cl, sl)
+    | Texp_pack mexpr ->
+        Texp_pack (sub.module_expr sub mexpr)
+    | Texp_letop {let_; ands; param; body; partial} ->
+        Texp_letop{
+          let_ = sub.binding_op sub let_;
+          ands = List.map (sub.binding_op sub) ands;
+          param;
+          body = sub.case sub body;
+          partial;
+        }
+    | Texp_unreachable ->
+        Texp_unreachable
+    | Texp_extension_constructor _ as e ->
+        e
+    | Texp_open (od, e) ->
+        Texp_open (sub.open_declaration sub od, sub.expr sub e)
+  in
+  {x with exp_extra; exp_desc; exp_env}
+
+
+let package_type sub x =
+  let pack_fields = List.map (tuple2 id (sub.typ sub)) x.pack_fields in
+  {x with pack_fields}
+
+let binding_op sub x =
+  { x with bop_exp = sub.expr sub x.bop_exp }
+
+let signature sub x =
+  let sig_final_env = sub.env sub x.sig_final_env in
+  let sig_items = List.map (sub.signature_item sub) x.sig_items in
+  {x with sig_items; sig_final_env}
+
+let signature_item sub x =
+  let sig_env = sub.env sub x.sig_env in
+  let sig_desc =
+    match x.sig_desc with
+    | Tsig_value v ->
+        Tsig_value (sub.value_description sub v)
+    | Tsig_type (rec_flag, list) ->
+        let (rec_flag, list) = sub.type_declarations sub (rec_flag, list) in
+        Tsig_type (rec_flag, list)
+    | Tsig_typesubst list ->
+        let (_, list) = sub.type_declarations sub (Nonrecursive, list) in
+        Tsig_typesubst list
+    | Tsig_typext te ->
+        Tsig_typext (sub.type_extension sub te)
+    | Tsig_exception ext ->
+        Tsig_exception (sub.type_exception sub ext)
+    | Tsig_module x ->
+        Tsig_module (sub.module_declaration sub x)
+    | Tsig_modsubst x ->
+        Tsig_modsubst (sub.module_substitution sub x)
+    | Tsig_recmodule list ->
+        Tsig_recmodule (List.map (sub.module_declaration sub) list)
+    | Tsig_modtype x ->
+        Tsig_modtype (sub.module_type_declaration sub x)
+    | Tsig_include incl ->
+        Tsig_include (include_infos (sub.module_type sub) incl)
+    | Tsig_class list ->
+        Tsig_class (List.map (sub.class_description sub) list)
+    | Tsig_class_type list ->
+        Tsig_class_type
+          (List.map (sub.class_type_declaration sub) list)
+    | Tsig_open od -> Tsig_open (sub.open_description sub od)
+    | Tsig_attribute _ as d -> d
+  in
+  {x with sig_desc; sig_env}
+
+let class_description sub x =
+  class_infos sub (sub.class_type sub) x
+
+let functor_parameter sub = function
+  | Unit -> Unit
+  | Named (id, s, mtype) -> Named (id, s, sub.module_type sub mtype)
+
+let module_type sub x =
+  let mty_env = sub.env sub x.mty_env in
+  let mty_desc =
+    match x.mty_desc with
+    | Tmty_ident _
+    | Tmty_alias _ as d -> d
+    | Tmty_signature sg -> Tmty_signature (sub.signature sub sg)
+    | Tmty_functor (arg, mtype2) ->
+        Tmty_functor (functor_parameter sub arg, sub.module_type sub mtype2)
+    | Tmty_with (mtype, list) ->
+        Tmty_with (
+          sub.module_type sub mtype,
+          List.map (tuple3 id id (sub.with_constraint sub)) list
+        )
+    | Tmty_typeof mexpr ->
+        Tmty_typeof (sub.module_expr sub mexpr)
+  in
+  {x with mty_desc; mty_env}
+
+let with_constraint sub = function
+  | Twith_type decl -> Twith_type (sub.type_declaration sub decl)
+  | Twith_typesubst decl -> Twith_typesubst (sub.type_declaration sub decl)
+  | Twith_module _
+  | Twith_modsubst _ as d -> d
+
+let open_description sub od =
+  {od with open_env = sub.env sub od.open_env}
+
+let open_declaration sub od =
+  {od with open_expr = sub.module_expr sub od.open_expr;
+           open_env = sub.env sub od.open_env}
+
+let module_coercion sub = function
+  | Tcoerce_none -> Tcoerce_none
+  | Tcoerce_functor (c1,c2) ->
+      Tcoerce_functor (sub.module_coercion sub c1, sub.module_coercion sub c2)
+  | Tcoerce_alias (env, p, c1) ->
+      Tcoerce_alias (sub.env sub env, p, sub.module_coercion sub c1)
+  | Tcoerce_structure (l1, l2) ->
+      let l1' = List.map (fun (i,c) -> i, sub.module_coercion sub c) l1 in
+      let l2' =
+        List.map (fun (id,i,c) -> id, i, sub.module_coercion sub c) l2
+      in
+      Tcoerce_structure (l1', l2')
+  | Tcoerce_primitive pc ->
+      Tcoerce_primitive {pc with pc_env = sub.env sub pc.pc_env}
+
+let module_expr sub x =
+  let mod_env = sub.env sub x.mod_env in
+  let mod_desc =
+    match x.mod_desc with
+    | Tmod_ident _ as d -> d
+    | Tmod_structure st -> Tmod_structure (sub.structure sub st)
+    | Tmod_functor (arg, mexpr) ->
+        Tmod_functor (functor_parameter sub arg, sub.module_expr sub mexpr)
+    | Tmod_apply (mexp1, mexp2, c) ->
+        Tmod_apply (
+          sub.module_expr sub mexp1,
+          sub.module_expr sub mexp2,
+          sub.module_coercion sub c
+        )
+    | Tmod_constraint (mexpr, mt, Tmodtype_implicit, c) ->
+        Tmod_constraint (sub.module_expr sub mexpr, mt, Tmodtype_implicit,
+                         sub.module_coercion sub c)
+    | Tmod_constraint (mexpr, mt, Tmodtype_explicit mtype, c) ->
+        Tmod_constraint (
+          sub.module_expr sub mexpr,
+          mt,
+          Tmodtype_explicit (sub.module_type sub mtype),
+          sub.module_coercion sub c
+        )
+    | Tmod_unpack (exp, mty) ->
+        Tmod_unpack
+          (
+            sub.expr sub exp,
+            mty
+          )
+  in
+  {x with mod_desc; mod_env}
+
+let module_binding sub x =
+  let mb_expr = sub.module_expr sub x.mb_expr in
+  {x with mb_expr}
+
+let class_expr sub x =
+  let cl_env = sub.env sub x.cl_env in
+  let cl_desc =
+    match x.cl_desc with
+    | Tcl_constraint (cl, clty, vals, meths, concrs) ->
+        Tcl_constraint (
+          sub.class_expr sub cl,
+          Option.map (sub.class_type sub) clty,
+          vals,
+          meths,
+          concrs
+        )
+    | Tcl_structure clstr ->
+        Tcl_structure (sub.class_structure sub clstr)
+    | Tcl_fun (label, pat, priv, cl, partial) ->
+        Tcl_fun (
+          label,
+          sub.pat sub pat,
+          List.map (tuple2 id (sub.expr sub)) priv,
+          sub.class_expr sub cl,
+          partial
+        )
+    | Tcl_apply (cl, args) ->
+        Tcl_apply (
+          sub.class_expr sub cl,
+          List.map (tuple2 id (Option.map (sub.expr sub))) args
+        )
+    | Tcl_let (rec_flag, value_bindings, ivars, cl) ->
+        let (rec_flag, value_bindings) =
+          sub.value_bindings sub (rec_flag, value_bindings)
+        in
+        Tcl_let (
+          rec_flag,
+          value_bindings,
+          List.map (tuple2 id (sub.expr sub)) ivars,
+          sub.class_expr sub cl
+        )
+    | Tcl_ident (path, lid, tyl) ->
+        Tcl_ident (path, lid, List.map (sub.typ sub) tyl)
+    | Tcl_open (od, e) ->
+        Tcl_open (sub.open_description sub od, sub.class_expr sub e)
+  in
+  {x with cl_desc; cl_env}
+
+let class_type sub x =
+  let cltyp_env = sub.env sub x.cltyp_env in
+  let cltyp_desc =
+    match x.cltyp_desc with
+    | Tcty_signature csg -> Tcty_signature (sub.class_signature sub csg)
+    | Tcty_constr (path, lid, list) ->
+        Tcty_constr (
+          path,
+          lid,
+          List.map (sub.typ sub) list
+        )
+    | Tcty_arrow (label, ct, cl) ->
+        Tcty_arrow
+          (label,
+           sub.typ sub ct,
+           sub.class_type sub cl
+          )
+    | Tcty_open (od, e) ->
+        Tcty_open (sub.open_description sub od, sub.class_type sub e)
+  in
+  {x with cltyp_desc; cltyp_env}
+
+let class_signature sub x =
+  let csig_self = sub.typ sub x.csig_self in
+  let csig_fields = List.map (sub.class_type_field sub) x.csig_fields in
+  {x with csig_self; csig_fields}
+
+let class_type_field sub x =
+  let ctf_desc =
+    match x.ctf_desc with
+    | Tctf_inherit ct ->
+        Tctf_inherit (sub.class_type sub ct)
+    | Tctf_val (s, mut, virt, ct) ->
+        Tctf_val (s, mut, virt, sub.typ sub ct)
+    | Tctf_method (s, priv, virt, ct) ->
+        Tctf_method (s, priv, virt, sub.typ sub ct)
+    | Tctf_constraint  (ct1, ct2) ->
+        Tctf_constraint (sub.typ sub ct1, sub.typ sub ct2)
+    | Tctf_attribute _ as d -> d
+  in
+  {x with ctf_desc}
+
+let typ sub x =
+  let ctyp_env = sub.env sub x.ctyp_env in
+  let ctyp_desc =
+    match x.ctyp_desc with
+    | Ttyp_any
+    | Ttyp_var _ as d -> d
+    | Ttyp_arrow (label, ct1, ct2) ->
+        Ttyp_arrow (label, sub.typ sub ct1, sub.typ sub ct2)
+    | Ttyp_tuple list -> Ttyp_tuple (List.map (sub.typ sub) list)
+    | Ttyp_constr (path, lid, list) ->
+        Ttyp_constr (path, lid, List.map (sub.typ sub) list)
+    | Ttyp_object (list, closed) ->
+        Ttyp_object ((List.map (sub.object_field sub) list), closed)
+    | Ttyp_class (path, lid, list) ->
+        Ttyp_class
+          (path,
+           lid,
+           List.map (sub.typ sub) list
+          )
+    | Ttyp_alias (ct, s) ->
+        Ttyp_alias (sub.typ sub ct, s)
+    | Ttyp_variant (list, closed, labels) ->
+        Ttyp_variant (List.map (sub.row_field sub) list, closed, labels)
+    | Ttyp_poly (sl, ct) ->
+        Ttyp_poly (sl, sub.typ sub ct)
+    | Ttyp_package pack ->
+        Ttyp_package (sub.package_type sub pack)
+  in
+  {x with ctyp_desc; ctyp_env}
+
+let class_structure sub x =
+  let cstr_self = sub.pat sub x.cstr_self in
+  let cstr_fields = List.map (sub.class_field sub) x.cstr_fields in
+  {x with cstr_self; cstr_fields}
+
+let row_field sub x =
+  let rf_desc = match x.rf_desc with
+    | Ttag (label, b, list) ->
+        Ttag (label, b, List.map (sub.typ sub) list)
+    | Tinherit ct -> Tinherit (sub.typ sub ct)
+  in
+  { x with rf_desc; }
+
+let object_field sub x =
+  let of_desc = match x.of_desc with
+    | OTtag (label, ct) ->
+        OTtag (label, (sub.typ sub ct))
+    | OTinherit ct -> OTinherit (sub.typ sub ct)
+  in
+  { x with of_desc; }
+
+let class_field_kind sub = function
+  | Tcfk_virtual ct -> Tcfk_virtual (sub.typ sub ct)
+  | Tcfk_concrete (ovf, e) -> Tcfk_concrete (ovf, sub.expr sub e)
+
+let class_field sub x =
+  let cf_desc =
+    match x.cf_desc with
+    | Tcf_inherit (ovf, cl, super, vals, meths) ->
+        Tcf_inherit (ovf, sub.class_expr sub cl, super, vals, meths)
+    | Tcf_constraint (cty, cty') ->
+        Tcf_constraint (
+          sub.typ sub cty,
+          sub.typ sub cty'
+        )
+    | Tcf_val (s, mf, id, k, b) ->
+        Tcf_val (s, mf, id, class_field_kind sub k, b)
+    | Tcf_method (s, priv, k) ->
+        Tcf_method (s, priv, class_field_kind sub k)
+    | Tcf_initializer exp ->
+        Tcf_initializer (sub.expr sub exp)
+    | Tcf_attribute _ as d -> d
+  in
+  {x with cf_desc}
+
+let value_bindings sub (rec_flag, list) =
+  (rec_flag, List.map (sub.value_binding sub) list)
+
+let cases sub l =
+  List.map (sub.case sub) l
+
+let case sub {c_lhs; c_guard; c_rhs} =
+  {
+    c_lhs = sub.pat sub c_lhs;
+    c_guard = Option.map (sub.expr sub) c_guard;
+    c_rhs = sub.expr sub c_rhs;
+  }
+
+let value_binding sub x =
+  let vb_pat = sub.pat sub x.vb_pat in
+  let vb_expr = sub.expr sub x.vb_expr in
+  {x with vb_pat; vb_expr}
+
+let env _sub x = x
+
+let default =
+  {
+    binding_op;
+    case;
+    cases;
+    class_declaration;
+    class_description;
+    class_expr;
+    class_field;
+    class_signature;
+    class_structure;
+    class_type;
+    class_type_declaration;
+    class_type_field;
+    env;
+    expr;
+    extension_constructor;
+    module_binding;
+    module_coercion;
+    module_declaration;
+    module_substitution;
+    module_expr;
+    module_type;
+    module_type_declaration;
+    package_type;
+    pat;
+    row_field;
+    object_field;
+    open_declaration;
+    open_description;
+    signature;
+    signature_item;
+    structure;
+    structure_item;
+    typ;
+    type_declaration;
+    type_declarations;
+    type_extension;
+    type_exception;
+    type_kind;
+    value_binding;
+    value_bindings;
+    value_description;
+    with_constraint;
+  }
diff --git a/src/ocaml/typing/410+multicore/tast_mapper.mli b/src/ocaml/typing/410+multicore/tast_mapper.mli
new file mode 100644
index 00000000..467f203e
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/tast_mapper.mli
@@ -0,0 +1,73 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                        Alain Frisch, LexiFi                            *)
+(*                                                                        *)
+(*   Copyright 2015 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Typedtree
+
+(** {1 A generic Typedtree mapper} *)
+
+type mapper =
+  {
+    binding_op: mapper -> binding_op -> binding_op;
+    case: mapper -> case -> case;
+    cases: mapper -> case list -> case list;
+    class_declaration: mapper -> class_declaration -> class_declaration;
+    class_description: mapper -> class_description -> class_description;
+    class_expr: mapper -> class_expr -> class_expr;
+    class_field: mapper -> class_field -> class_field;
+    class_signature: mapper -> class_signature -> class_signature;
+    class_structure: mapper -> class_structure -> class_structure;
+    class_type: mapper -> class_type -> class_type;
+    class_type_declaration: mapper -> class_type_declaration ->
+      class_type_declaration;
+    class_type_field: mapper -> class_type_field -> class_type_field;
+    env: mapper -> Env.t -> Env.t;
+    expr: mapper -> expression -> expression;
+    extension_constructor: mapper -> extension_constructor ->
+      extension_constructor;
+    module_binding: mapper -> module_binding -> module_binding;
+    module_coercion: mapper -> module_coercion -> module_coercion;
+    module_declaration: mapper -> module_declaration -> module_declaration;
+    module_substitution: mapper -> module_substitution -> module_substitution;
+    module_expr: mapper -> module_expr -> module_expr;
+    module_type: mapper -> module_type -> module_type;
+    module_type_declaration:
+      mapper -> module_type_declaration -> module_type_declaration;
+    package_type: mapper -> package_type -> package_type;
+    pat: mapper -> pattern -> pattern;
+    row_field: mapper -> row_field -> row_field;
+    object_field: mapper -> object_field -> object_field;
+    open_declaration: mapper -> open_declaration -> open_declaration;
+    open_description: mapper -> open_description -> open_description;
+    signature: mapper -> signature -> signature;
+    signature_item: mapper -> signature_item -> signature_item;
+    structure: mapper -> structure -> structure;
+    structure_item: mapper -> structure_item -> structure_item;
+    typ: mapper -> core_type -> core_type;
+    type_declaration: mapper -> type_declaration -> type_declaration;
+    type_declarations: mapper -> (rec_flag * type_declaration list)
+      -> (rec_flag * type_declaration list);
+    type_extension: mapper -> type_extension -> type_extension;
+    type_exception: mapper -> type_exception -> type_exception;
+    type_kind: mapper -> type_kind -> type_kind;
+    value_binding: mapper -> value_binding -> value_binding;
+    value_bindings: mapper -> (rec_flag * value_binding list) ->
+      (rec_flag * value_binding list);
+    value_description: mapper -> value_description -> value_description;
+    with_constraint: mapper -> with_constraint -> with_constraint;
+  }
+
+
+val default: mapper
diff --git a/src/ocaml/typing/410+multicore/type_immediacy.ml b/src/ocaml/typing/410+multicore/type_immediacy.ml
new file mode 100644
index 00000000..557ed427
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/type_immediacy.ml
@@ -0,0 +1,43 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Jeremie Dimino, Jane Street Europe                   *)
+(*                                                                        *)
+(*   Copyright 2019 Jane Street Group LLC                                 *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type t =
+  | Unknown
+  | Always
+  | Always_on_64bits
+
+module Violation = struct
+  type t =
+    | Not_always_immediate
+    | Not_always_immediate_on_64bits
+end
+
+let coerce t ~as_ =
+  match t, as_ with
+  | _, Unknown
+  | Always, Always
+  | (Always | Always_on_64bits), Always_on_64bits -> Ok ()
+  | (Unknown | Always_on_64bits), Always ->
+      Error Violation.Not_always_immediate
+  | Unknown, Always_on_64bits ->
+      Error Violation.Not_always_immediate_on_64bits
+
+let of_attributes attrs =
+  match
+    Builtin_attributes.immediate attrs,
+    Builtin_attributes.immediate64 attrs
+  with
+  | true, _ -> Always
+  | false, true -> Always_on_64bits
+  | false, false -> Unknown
diff --git a/src/ocaml/typing/410+multicore/type_immediacy.mli b/src/ocaml/typing/410+multicore/type_immediacy.mli
new file mode 100644
index 00000000..3fc2e3b4
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/type_immediacy.mli
@@ -0,0 +1,40 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*                   Jeremie Dimino, Jane Street Europe                   *)
+(*                                                                        *)
+(*   Copyright 2019 Jane Street Group LLC                                 *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Immediacy status of a type *)
+
+type t =
+  | Unknown
+  (** We don't know anything *)
+  | Always
+  (** We know for sure that values of this type are always immediate *)
+  | Always_on_64bits
+  (** We know for sure that values of this type are always immediate
+      on 64 bit platforms. For other platforms, we know nothing. *)
+
+module Violation : sig
+  type t =
+    | Not_always_immediate
+    | Not_always_immediate_on_64bits
+end
+
+(** [coerce t ~as_] returns [Ok ()] iff [t] can be seen as type
+    immediacy [as_]. For instance, [Always] can be seen as
+    [Always_on_64bits] but the opposite is not true. Return [Error _]
+    if the coercion is not possible. *)
+val coerce : t -> as_:t -> (unit, Violation.t) result
+
+(** Return the immediateness of a type as indicated by the user via
+    attributes *)
+val of_attributes : Parsetree.attributes -> t
diff --git a/src/ocaml/typing/410+multicore/typeclass.ml b/src/ocaml/typing/410+multicore/typeclass.ml
new file mode 100644
index 00000000..5b7ee769
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typeclass.ml
@@ -0,0 +1,2036 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Parsetree
+open Asttypes
+open Path
+open Types
+open Typecore
+open Typetexp
+open Format
+
+type 'a class_info = {
+  cls_id : Ident.t;
+  cls_id_loc : string loc;
+  cls_decl : class_declaration;
+  cls_ty_id : Ident.t;
+  cls_ty_decl : class_type_declaration;
+  cls_obj_id : Ident.t;
+  cls_obj_abbr : type_declaration;
+  cls_typesharp_id : Ident.t;
+  cls_abbr : type_declaration;
+  cls_arity : int;
+  cls_pub_methods : string list;
+  cls_info : 'a;
+}
+
+type class_type_info = {
+  clsty_ty_id : Ident.t;
+  clsty_id_loc : string loc;
+  clsty_ty_decl : class_type_declaration;
+  clsty_obj_id : Ident.t;
+  clsty_obj_abbr : type_declaration;
+  clsty_typesharp_id : Ident.t;
+  clsty_abbr : type_declaration;
+  clsty_info : Typedtree.class_type_declaration;
+}
+
+type 'a full_class = {
+  id : Ident.t;
+  id_loc : tag loc;
+  clty: class_declaration;
+  ty_id: Ident.t;
+  cltydef: class_type_declaration;
+  obj_id: Ident.t;
+  obj_abbr: type_declaration;
+  cl_id: Ident.t;
+  cl_abbr: type_declaration;
+  arity: int;
+  pub_meths: string list;
+  coe: Warnings.loc list;
+  expr: 'a;
+  req: 'a Typedtree.class_infos;
+}
+
+type error =
+    Unconsistent_constraint of Ctype.Unification_trace.t
+  | Field_type_mismatch of string * string * Ctype.Unification_trace.t
+  | Structure_expected of class_type
+  | Cannot_apply of class_type
+  | Apply_wrong_label of arg_label
+  | Pattern_type_clash of type_expr
+  | Repeated_parameter
+  | Unbound_class_2 of Longident.t
+  | Unbound_class_type_2 of Longident.t
+  | Abbrev_type_clash of type_expr * type_expr * type_expr
+  | Constructor_type_mismatch of string * Ctype.Unification_trace.t
+  | Virtual_class of bool * bool * string list * string list
+  | Parameter_arity_mismatch of Longident.t * int * int
+  | Parameter_mismatch of Ctype.Unification_trace.t
+  | Bad_parameters of Ident.t * type_expr * type_expr
+  | Class_match_failure of Ctype.class_match_failure list
+  | Unbound_val of string
+  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
+  | Non_generalizable_class of Ident.t * Types.class_declaration
+  | Cannot_coerce_self of type_expr
+  | Non_collapsable_conjunction of
+      Ident.t * Types.class_declaration * Ctype.Unification_trace.t
+  | Final_self_clash of Ctype.Unification_trace.t
+  | Mutability_mismatch of string * mutable_flag
+  | No_overriding of string * string
+  | Duplicate of string * string
+  | Closing_self_type of type_expr
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+open Typedtree
+
+let type_open_descr :
+  (?used_slot:bool ref -> Env.t -> Parsetree.open_description
+   -> open_description * Env.t) ref =
+  ref (fun ?used_slot:_ _ -> assert false)
+
+let ctyp desc typ env loc =
+  { ctyp_desc = desc; ctyp_type = typ; ctyp_loc = loc; ctyp_env = env;
+    ctyp_attributes = [] }
+
+                       (**********************)
+                       (*  Useful constants  *)
+                       (**********************)
+
+
+(*
+   Self type have a dummy private method, thus preventing it to become
+   closed.
+*)
+let dummy_method = Btype.dummy_method
+
+(*
+   Path associated to the temporary class type of a class being typed
+   (its constructor is not available).
+*)
+let unbound_class = Env.unbound_class
+
+
+                (************************************)
+                (*  Some operations on class types  *)
+                (************************************)
+
+
+(* Fully expand the head of a class type *)
+let rec scrape_class_type =
+  function
+    Cty_constr (_, _, cty) -> scrape_class_type cty
+  | cty                     -> cty
+
+(* Generalize a class type *)
+let rec generalize_class_type gen =
+  function
+    Cty_constr (_, params, cty) ->
+      List.iter gen params;
+      generalize_class_type gen cty
+  | Cty_signature {csig_self = sty; csig_vars = vars; csig_inher = inher} ->
+      gen sty;
+      Vars.iter (fun _ (_, _, ty) -> gen ty) vars;
+      List.iter (fun (_,tl) -> List.iter gen tl) inher
+  | Cty_arrow (_, ty, cty) ->
+      gen ty;
+      generalize_class_type gen cty
+
+let generalize_class_type vars =
+  let gen = if vars then Ctype.generalize else Ctype.generalize_structure in
+  generalize_class_type gen
+
+(* Return the virtual methods of a class type *)
+let virtual_methods sign =
+  let (fields, _) =
+    Ctype.flatten_fields (Ctype.object_fields sign.Types.csig_self)
+  in
+  List.fold_left
+    (fun virt (lab, _, _) ->
+       if lab = dummy_method then virt else
+       if Concr.mem lab sign.csig_concr then virt else
+       lab::virt)
+    [] fields
+
+(* Return the constructor type associated to a class type *)
+let rec constructor_type constr cty =
+  match cty with
+    Cty_constr (_, _, cty) ->
+      constructor_type constr cty
+  | Cty_signature _ ->
+      constr
+  | Cty_arrow (l, ty, cty) ->
+      Ctype.newty (Tarrow (l, ty, constructor_type constr cty, Cok))
+
+let rec class_body cty =
+  match cty with
+    Cty_constr _ ->
+      cty (* Only class bodies can be abbreviated *)
+  | Cty_signature _ ->
+      cty
+  | Cty_arrow (_, _, cty) ->
+      class_body cty
+
+let extract_constraints cty =
+  let sign = Ctype.signature_of_class_type cty in
+  (Vars.fold (fun lab _ vars -> lab :: vars) sign.csig_vars [],
+   begin let (fields, _) =
+     Ctype.flatten_fields (Ctype.object_fields sign.csig_self)
+   in
+   List.fold_left
+     (fun meths (lab, _, _) ->
+        if lab = dummy_method then meths else lab::meths)
+     [] fields
+   end,
+   sign.csig_concr)
+
+let rec abbreviate_class_type path params cty =
+  match cty with
+    Cty_constr (_, _, _) | Cty_signature _ ->
+      Cty_constr (path, params, cty)
+  | Cty_arrow (l, ty, cty) ->
+      Cty_arrow (l, ty, abbreviate_class_type path params cty)
+
+(* Check that all type variables are generalizable *)
+(* Use Env.empty to prevent expansion of recursively defined object types;
+   cf. typing-poly/poly.ml *)
+let rec closed_class_type =
+  function
+    Cty_constr (_, params, _) ->
+      List.for_all (Ctype.closed_schema Env.empty) params
+  | Cty_signature sign ->
+      Ctype.closed_schema Env.empty sign.csig_self
+        &&
+      Vars.fold (fun _ (_, _, ty) cc -> Ctype.closed_schema Env.empty ty && cc)
+        sign.csig_vars
+        true
+  | Cty_arrow (_, ty, cty) ->
+      Ctype.closed_schema Env.empty ty
+        &&
+      closed_class_type cty
+
+let closed_class cty =
+  List.for_all (Ctype.closed_schema Env.empty) cty.cty_params
+    &&
+  closed_class_type cty.cty_type
+
+let rec limited_generalize rv =
+  function
+    Cty_constr (_path, params, cty) ->
+      List.iter (Ctype.limited_generalize rv) params;
+      limited_generalize rv cty
+  | Cty_signature sign ->
+      Ctype.limited_generalize rv sign.csig_self;
+      Vars.iter (fun _ (_, _, ty) -> Ctype.limited_generalize rv ty)
+        sign.csig_vars;
+      List.iter (fun (_, tl) -> List.iter (Ctype.limited_generalize rv) tl)
+        sign.csig_inher
+  | Cty_arrow (_, ty, cty) ->
+      Ctype.limited_generalize rv ty;
+      limited_generalize rv cty
+
+(* Record a class type *)
+let rc node =
+  Cmt_format.add_saved_type (Cmt_format.Partial_class_expr node);
+  Stypes.record (Stypes.Ti_class node); (* moved to genannot *)
+  node
+
+
+                (***********************************)
+                (*  Primitives for typing classes  *)
+                (***********************************)
+
+
+(* Enter a value in the method environment only *)
+let enter_met_env ?check loc lab kind unbound_kind ty val_env met_env par_env =
+  let val_env = Env.enter_unbound_value lab unbound_kind val_env in
+  let par_env = Env.enter_unbound_value lab unbound_kind par_env in
+  let (id, met_env) =
+    Env.enter_value ?check lab
+      {val_type = ty; val_kind = kind;
+       val_attributes = []; Types.val_loc = loc} met_env
+  in
+  (id, val_env, met_env, par_env)
+
+(* Enter an instance variable in the environment *)
+let enter_val cl_num vars inh lab mut virt ty val_env met_env par_env loc =
+  let (id, virt) =
+    try
+      let (id, mut', virt', ty') = Vars.find lab !vars in
+      if mut' <> mut then
+        raise (Error(loc, val_env, Mutability_mismatch(lab, mut)));
+      Ctype.unify val_env (Ctype.instance ty) (Ctype.instance ty');
+      (if not inh then Some id else None),
+      (if virt' = Concrete then virt' else virt)
+    with
+      Ctype.Unify tr ->
+        raise (Error(loc, val_env,
+                     Field_type_mismatch("instance variable", lab, tr)))
+    | Not_found -> None, virt
+  in
+  let (id, _, _, _) as result =
+    match id with Some id -> (id, val_env, met_env, par_env)
+    | None ->
+        enter_met_env Location.none lab (Val_ivar (mut, cl_num))
+          Val_unbound_instance_variable ty val_env met_env par_env
+  in
+  vars := Vars.add lab (id, mut, virt, ty) !vars;
+  result
+
+let concr_vals vars =
+  Vars.fold
+    (fun id (_, vf, _) s -> if vf = Virtual then s else Concr.add id s)
+    vars Concr.empty
+
+let inheritance self_type env ovf concr_meths warn_vals loc parent =
+  match scrape_class_type parent with
+    Cty_signature cl_sig ->
+
+      (* Methods *)
+      begin try
+        Ctype.unify env self_type cl_sig.csig_self
+      with Ctype.Unify trace ->
+        let open Ctype.Unification_trace in
+        match trace with
+        | Diff _ :: Incompatible_fields {name = n; _ } :: rem ->
+            raise(Error(loc, env, Field_type_mismatch ("method", n, rem)))
+        | _ -> assert false
+      end;
+
+      (* Overriding *)
+      let over_meths = Concr.inter cl_sig.csig_concr concr_meths in
+      let concr_vals = concr_vals cl_sig.csig_vars in
+      let over_vals = Concr.inter concr_vals warn_vals in
+      begin match ovf with
+        Some Fresh ->
+          let cname =
+            match parent with
+              Cty_constr (p, _, _) -> Path.name p
+            | _ -> "inherited"
+          in
+          if not (Concr.is_empty over_meths) then
+            Location.prerr_warning loc
+              (Warnings.Method_override (cname :: Concr.elements over_meths));
+          if not (Concr.is_empty over_vals) then
+            Location.prerr_warning loc
+              (Warnings.Instance_variable_override
+                 (cname :: Concr.elements over_vals));
+      | Some Override
+        when Concr.is_empty over_meths && Concr.is_empty over_vals ->
+        raise (Error(loc, env, No_overriding ("","")))
+      | _ -> ()
+      end;
+
+      let concr_meths = Concr.union cl_sig.csig_concr concr_meths
+      and warn_vals = Concr.union concr_vals warn_vals in
+
+      (cl_sig, concr_meths, warn_vals)
+
+  | _ ->
+      raise(Error(loc, env, Structure_expected parent))
+
+let virtual_method val_env meths self_type lab priv sty loc =
+  let (_, ty') =
+     Ctype.filter_self_method val_env lab priv meths self_type
+  in
+  let sty = Ast_helper.Typ.force_poly sty in
+  let cty = transl_simple_type val_env false sty in
+  let ty = cty.ctyp_type in
+  begin
+    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
+        raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)));
+  end;
+  cty
+
+let delayed_meth_specs = ref []
+
+let declare_method val_env meths self_type lab priv sty loc =
+  let (_, ty') =
+     Ctype.filter_self_method val_env lab priv meths self_type
+  in
+  let unif ty =
+    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
+      raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)))
+  in
+  let sty = Ast_helper.Typ.force_poly sty in
+  match sty.ptyp_desc, priv with
+    Ptyp_poly ([],sty'), Public ->
+(* TODO: we moved the [transl_simple_type_univars] outside of the lazy,
+so that we can get an immediate value. Is that correct ? Ask Jacques. *)
+      let returned_cty = ctyp Ttyp_any (Ctype.newty Tnil) val_env loc in
+      delayed_meth_specs :=
+      Warnings.mk_lazy (fun () ->
+            let cty = transl_simple_type_univars val_env sty' in
+            let ty = cty.ctyp_type in
+            unif ty;
+            returned_cty.ctyp_desc <- Ttyp_poly ([], cty);
+            returned_cty.ctyp_type <- ty;
+          ) ::
+      !delayed_meth_specs;
+      returned_cty
+  | _ ->
+      let cty = transl_simple_type val_env false sty in
+      let ty = cty.ctyp_type in
+      unif ty;
+      cty
+
+let type_constraint val_env sty sty' loc =
+  let cty  = transl_simple_type val_env false sty in
+  let ty = cty.ctyp_type in
+  let cty' = transl_simple_type val_env false sty' in
+  let ty' = cty'.ctyp_type in
+  begin
+    try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
+        raise(Error(loc, val_env, Unconsistent_constraint trace));
+  end;
+  (cty, cty')
+
+let make_method loc cl_num expr =
+  let open Ast_helper in
+  let mkid s = mkloc s loc in
+  Exp.fun_ ~loc:expr.pexp_loc Nolabel None
+    (Pat.alias ~loc (Pat.var ~loc (mkid "self-*")) (mkid ("self-" ^ cl_num)))
+    expr
+
+(*******************************)
+
+let add_val lab (mut, virt, ty) val_sig =
+  let virt =
+    try
+      let (_mut', virt', _ty') = Vars.find lab val_sig in
+      if virt' = Concrete then virt' else virt
+    with Not_found -> virt
+  in
+  Vars.add lab (mut, virt, ty) val_sig
+
+let rec class_type_field env self_type meths arg ctf =
+  Builtin_attributes.warning_scope ctf.pctf_attributes
+    (fun () -> class_type_field_aux env self_type meths arg ctf)
+
+and class_type_field_aux env self_type meths
+    (fields, val_sig, concr_meths, inher) ctf =
+
+  let loc = ctf.pctf_loc in
+  let mkctf desc =
+    { ctf_desc = desc; ctf_loc = loc; ctf_attributes = ctf.pctf_attributes }
+  in
+  match ctf.pctf_desc with
+    Pctf_inherit sparent ->
+      let parent = class_type env sparent in
+      let inher =
+        match parent.cltyp_type with
+          Cty_constr (p, tl, _) -> (p, tl) :: inher
+        | _ -> inher
+      in
+      let (cl_sig, concr_meths, _) =
+        inheritance self_type env None concr_meths Concr.empty sparent.pcty_loc
+          parent.cltyp_type
+      in
+      let val_sig =
+        Vars.fold add_val cl_sig.csig_vars val_sig in
+      (mkctf (Tctf_inherit parent) :: fields,
+       val_sig, concr_meths, inher)
+
+  | Pctf_val ({txt=lab}, mut, virt, sty) ->
+      let cty = transl_simple_type env false sty in
+      let ty = cty.ctyp_type in
+      (mkctf (Tctf_val (lab, mut, virt, cty)) :: fields,
+      add_val lab (mut, virt, ty) val_sig, concr_meths, inher)
+
+  | Pctf_method ({txt=lab}, priv, virt, sty)  ->
+      let cty =
+        declare_method env meths self_type lab priv sty  ctf.pctf_loc in
+      let concr_meths =
+        match virt with
+        | Concrete -> Concr.add lab concr_meths
+        | Virtual -> concr_meths
+      in
+      (mkctf (Tctf_method (lab, priv, virt, cty)) :: fields,
+        val_sig, concr_meths, inher)
+
+  | Pctf_constraint (sty, sty') ->
+      let (cty, cty') = type_constraint env sty sty'  ctf.pctf_loc in
+      (mkctf (Tctf_constraint (cty, cty')) :: fields,
+        val_sig, concr_meths, inher)
+
+  | Pctf_attribute x ->
+      Builtin_attributes.warning_attribute x;
+      (mkctf (Tctf_attribute x) :: fields,
+        val_sig, concr_meths, inher)
+
+  | Pctf_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+and class_signature env {pcsig_self=sty; pcsig_fields=sign} =
+  let meths = ref Meths.empty in
+  let self_cty = transl_simple_type env false sty in
+  let self_cty = { self_cty with
+    ctyp_type = Ctype.expand_head env self_cty.ctyp_type } in
+  let self_type =  self_cty.ctyp_type in
+
+  (* Check that the binder is a correct type, and introduce a dummy
+     method preventing self type from being closed. *)
+  let dummy_obj = Ctype.newvar () in
+  Ctype.unify env (Ctype.filter_method env dummy_method Private dummy_obj)
+    (Ctype.newty (Ttuple []));
+  begin try
+    Ctype.unify env self_type dummy_obj
+  with Ctype.Unify _ ->
+    raise(Error(sty.ptyp_loc, env, Pattern_type_clash self_type))
+  end;
+
+  (* Class type fields *)
+  let (rev_fields, val_sig, concr_meths, inher) =
+    Builtin_attributes.warning_scope []
+      (fun () ->
+         List.fold_left (class_type_field env self_type meths)
+           ([], Vars.empty, Concr.empty, [])
+           sign
+      )
+  in
+  let cty =   {csig_self = self_type;
+   csig_vars = val_sig;
+   csig_concr = concr_meths;
+   csig_inher = inher}
+  in
+  { csig_self = self_cty;
+    csig_fields = List.rev rev_fields;
+    csig_type = cty;
+  }
+
+and class_type env scty =
+  Builtin_attributes.warning_scope scty.pcty_attributes
+    (fun () -> class_type_aux env scty)
+
+and class_type_aux env scty =
+  let cltyp desc typ =
+    {
+     cltyp_desc = desc;
+     cltyp_type = typ;
+     cltyp_loc = scty.pcty_loc;
+     cltyp_env = env;
+     cltyp_attributes = scty.pcty_attributes;
+    }
+  in
+  match scty.pcty_desc with
+    Pcty_constr (lid, styl) ->
+      let (path, decl) = Env.lookup_cltype ~loc:scty.pcty_loc lid.txt env in
+      if Path.same decl.clty_path unbound_class then
+        raise(Error(scty.pcty_loc, env, Unbound_class_type_2 lid.txt));
+      let (params, clty) =
+        Ctype.instance_class decl.clty_params decl.clty_type
+      in
+      if List.length params <> List.length styl then
+        raise(Error(scty.pcty_loc, env,
+                    Parameter_arity_mismatch (lid.txt, List.length params,
+                                                   List.length styl)));
+      let ctys = List.map2
+        (fun sty ty ->
+          let cty' = transl_simple_type env false sty in
+          let ty' = cty'.ctyp_type in
+          begin
+           try Ctype.unify env ty' ty with Ctype.Unify trace ->
+                  raise(Error(sty.ptyp_loc, env, Parameter_mismatch trace))
+            end;
+            cty'
+        )       styl params
+      in
+      let typ = Cty_constr (path, params, clty) in
+      cltyp (Tcty_constr ( path, lid , ctys)) typ
+
+  | Pcty_signature pcsig ->
+      let clsig = class_signature env pcsig in
+      let typ = Cty_signature clsig.csig_type in
+      cltyp (Tcty_signature clsig) typ
+
+  | Pcty_arrow (l, sty, scty) ->
+      let cty = transl_simple_type env false sty in
+      let ty = cty.ctyp_type in
+      let ty =
+        if Btype.is_optional l
+        then Ctype.newty (Tconstr(Predef.path_option,[ty], ref Mnil))
+        else ty in
+      let clty = class_type env scty in
+      let typ = Cty_arrow (l, ty, clty.cltyp_type) in
+      cltyp (Tcty_arrow (l, cty, clty)) typ
+
+  | Pcty_open (od, e) ->
+      let (od, newenv) = !type_open_descr env od in
+      let clty = class_type newenv e in
+      cltyp (Tcty_open (od, clty)) clty.cltyp_type
+
+  | Pcty_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+let class_type env scty =
+  delayed_meth_specs := [];
+  let cty = class_type env scty in
+  List.iter Lazy.force (List.rev !delayed_meth_specs);
+  delayed_meth_specs := [];
+  cty
+
+(*******************************)
+
+let rec class_field self_loc cl_num self_type meths vars arg cf =
+  Builtin_attributes.warning_scope cf.pcf_attributes
+    (fun () -> class_field_aux self_loc cl_num self_type meths vars arg cf)
+
+and class_field_aux self_loc cl_num self_type meths vars
+    (val_env, met_env, par_env, fields, concr_meths, warn_vals, inher,
+     local_meths, local_vals) cf =
+  let loc = cf.pcf_loc in
+  let mkcf desc =
+    { cf_desc = desc; cf_loc = loc; cf_attributes = cf.pcf_attributes }
+  in
+  match cf.pcf_desc with
+    Pcf_inherit (ovf, sparent, super) ->
+      let parent = class_expr cl_num val_env par_env sparent in
+      let inher =
+        match parent.cl_type with
+          Cty_constr (p, tl, _) -> (p, tl) :: inher
+        | _ -> inher
+      in
+      let (cl_sig, concr_meths, warn_vals) =
+        inheritance self_type val_env (Some ovf) concr_meths warn_vals
+          sparent.pcl_loc parent.cl_type
+      in
+      (* Variables *)
+      let (val_env, met_env, par_env, inh_vars) =
+        Vars.fold
+          (fun lab info (val_env, met_env, par_env, inh_vars) ->
+             let mut, vr, ty = info in
+             let (id, val_env, met_env, par_env) =
+               enter_val cl_num vars true lab mut vr ty val_env met_env par_env
+                 sparent.pcl_loc
+             in
+             (val_env, met_env, par_env, (lab, id) :: inh_vars))
+          cl_sig.csig_vars (val_env, met_env, par_env, [])
+      in
+      (* Inherited concrete methods *)
+      let inh_meths =
+        Concr.fold (fun lab rem -> (lab, Ident.create_local lab)::rem)
+          cl_sig.csig_concr []
+      in
+      (* Super *)
+      let (val_env, met_env, par_env,super) =
+        match super with
+          None ->
+            (val_env, met_env, par_env,None)
+        | Some {txt=name} ->
+            let (_id, val_env, met_env, par_env) =
+              enter_met_env ~check:(fun s -> Warnings.Unused_ancestor s)
+                sparent.pcl_loc name (Val_anc (inh_meths, cl_num))
+                Val_unbound_ancestor self_type val_env met_env par_env
+            in
+            (val_env, met_env, par_env,Some name)
+      in
+      (val_env, met_env, par_env,
+       lazy (mkcf (Tcf_inherit (ovf, parent, super, inh_vars, inh_meths)))
+       :: fields,
+       concr_meths, warn_vals, inher, local_meths, local_vals)
+
+  | Pcf_val (lab, mut, Cfk_virtual styp) ->
+      if !Clflags.principal then Ctype.begin_def ();
+      let cty = Typetexp.transl_simple_type val_env false styp in
+      let ty = cty.ctyp_type in
+      if !Clflags.principal then begin
+        Ctype.end_def ();
+        Ctype.generalize_structure ty
+      end;
+      let (id, val_env, met_env', par_env) =
+        enter_val cl_num vars false lab.txt mut Virtual ty
+          val_env met_env par_env loc
+      in
+      (val_env, met_env', par_env,
+       lazy (mkcf (Tcf_val (lab, mut, id, Tcfk_virtual cty,
+                            met_env == met_env')))
+             :: fields,
+             concr_meths, warn_vals, inher, local_meths, local_vals)
+
+  | Pcf_val (lab, mut, Cfk_concrete (ovf, sexp)) ->
+      if Concr.mem lab.txt local_vals then
+        raise(Error(loc, val_env, Duplicate ("instance variable", lab.txt)));
+      if Concr.mem lab.txt warn_vals then begin
+        if ovf = Fresh then
+          Location.prerr_warning lab.loc
+            (Warnings.Instance_variable_override[lab.txt])
+      end else begin
+        if ovf = Override then
+          raise(Error(loc, val_env,
+                      No_overriding ("instance variable", lab.txt)))
+      end;
+      if !Clflags.principal then Ctype.begin_def ();
+      let exp = type_exp val_env sexp in
+      if !Clflags.principal then begin
+        Ctype.end_def ();
+        Ctype.generalize_structure exp.exp_type
+       end;
+      let (id, val_env, met_env', par_env) =
+        enter_val cl_num vars false lab.txt mut Concrete exp.exp_type
+          val_env met_env par_env loc
+      in
+      (val_env, met_env', par_env,
+       lazy (mkcf (Tcf_val (lab, mut, id,
+                            Tcfk_concrete (ovf, exp), met_env == met_env')))
+       :: fields,
+       concr_meths, Concr.add lab.txt warn_vals, inher, local_meths,
+       Concr.add lab.txt local_vals)
+
+  | Pcf_method (lab, priv, Cfk_virtual sty) ->
+      let cty = virtual_method val_env meths self_type lab.txt priv sty loc in
+      (val_env, met_env, par_env,
+        lazy (mkcf(Tcf_method (lab, priv, Tcfk_virtual cty)))
+       ::fields,
+        concr_meths, warn_vals, inher, local_meths, local_vals)
+
+  | Pcf_method (lab, priv, Cfk_concrete (ovf, expr))  ->
+      let expr =
+        match expr.pexp_desc with
+        | Pexp_poly _ -> expr
+        | _ -> Ast_helper.Exp.poly ~loc:expr.pexp_loc expr None
+      in
+      if Concr.mem lab.txt local_meths then
+        raise(Error(loc, val_env, Duplicate ("method", lab.txt)));
+      if Concr.mem lab.txt concr_meths then begin
+        if ovf = Fresh then
+          Location.prerr_warning loc (Warnings.Method_override [lab.txt])
+      end else begin
+        if ovf = Override then
+          raise(Error(loc, val_env, No_overriding("method", lab.txt)))
+      end;
+      let (_, ty) =
+        Ctype.filter_self_method val_env lab.txt priv meths self_type
+      in
+      begin try match expr.pexp_desc with
+        Pexp_poly (sbody, sty) ->
+          begin match sty with None -> ()
+                | Some sty ->
+                    let sty = Ast_helper.Typ.force_poly sty in
+                    let cty' = Typetexp.transl_simple_type val_env false sty in
+                    let ty' = cty'.ctyp_type in
+              Ctype.unify val_env ty' ty
+          end;
+          begin match (Ctype.repr ty).desc with
+            Tvar _ ->
+              let ty' = Ctype.newvar () in
+              Ctype.unify val_env (Ctype.newty (Tpoly (ty', []))) ty;
+              Ctype.unify val_env (type_approx val_env sbody) ty'
+          | Tpoly (ty1, tl) ->
+              let _, ty1' = Ctype.instance_poly false tl ty1 in
+              let ty2 = type_approx val_env sbody in
+              Ctype.unify val_env ty2 ty1'
+          | _ -> assert false
+          end
+      | _ -> assert false
+      with Ctype.Unify trace ->
+        raise(Error(loc, val_env,
+                    Field_type_mismatch ("method", lab.txt, trace)))
+      end;
+      let meth_expr = make_method self_loc cl_num expr in
+      (* backup variables for Pexp_override *)
+      let vars_local = !vars in
+
+      let field =
+        Warnings.mk_lazy
+          (fun () ->
+             (* Read the generalized type *)
+             let (_, ty) = Meths.find lab.txt !meths in
+             let meth_type = mk_expected (
+               Btype.newgenty (Tarrow(Nolabel, self_type, ty, Cok))
+             ) in
+             Ctype.raise_nongen_level ();
+             vars := vars_local;
+             let texp = type_expect met_env meth_expr meth_type in
+             Ctype.end_def ();
+             mkcf (Tcf_method (lab, priv, Tcfk_concrete (ovf, texp)))
+          )
+      in
+      (val_env, met_env, par_env, field::fields,
+       Concr.add lab.txt concr_meths, warn_vals, inher,
+       Concr.add lab.txt local_meths, local_vals)
+
+  | Pcf_constraint (sty, sty') ->
+      let (cty, cty') = type_constraint val_env sty sty' loc in
+      (val_env, met_env, par_env,
+        lazy (mkcf (Tcf_constraint (cty, cty'))) :: fields,
+        concr_meths, warn_vals, inher, local_meths, local_vals)
+
+  | Pcf_initializer expr ->
+      let expr = make_method self_loc cl_num expr in
+      let vars_local = !vars in
+      let field =
+        lazy begin
+          Ctype.raise_nongen_level ();
+          let meth_type = mk_expected (
+            Ctype.newty
+              (Tarrow (Nolabel, self_type,
+                       Ctype.instance Predef.type_unit, Cok))
+          ) in
+          vars := vars_local;
+          let texp = type_expect met_env expr meth_type in
+          Ctype.end_def ();
+          mkcf (Tcf_initializer texp)
+        end in
+      (val_env, met_env, par_env, field::fields, concr_meths, warn_vals,
+       inher, local_meths, local_vals)
+  | Pcf_attribute x ->
+      Builtin_attributes.warning_attribute x;
+      (val_env, met_env, par_env,
+        lazy (mkcf (Tcf_attribute x)) :: fields,
+        concr_meths, warn_vals, inher, local_meths, local_vals)
+  | Pcf_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+(* N.B. the self type of a final object type doesn't contain a dummy method in
+   the beginning.
+   We only explicitly add a dummy method to class definitions (and class (type)
+   declarations)), which are later removed (made absent) by [final_decl].
+
+   If we ever find a dummy method in a final object self type, it means that
+   somehow we've unified the self type of the object with the self type of a not
+   yet finished class.
+   When this happens, we cannot close the object type and must error. *)
+and class_structure cl_num final val_env met_env loc
+  { pcstr_self = spat; pcstr_fields = str } =
+  (* Environment for substructures *)
+  let par_env = met_env in
+
+  (* Location of self. Used for locations of self arguments *)
+  let self_loc = {spat.ppat_loc with Location.loc_ghost = true} in
+
+  let self_type = Ctype.newobj (Ctype.newvar ()) in
+
+  (* Adding a dummy method to the self type prevents it from being closed /
+     escaping.
+     That isn't needed for objects though. *)
+  if not final then
+    Ctype.unify val_env
+      (Ctype.filter_method val_env dummy_method Private self_type)
+      (Ctype.newty (Ttuple []));
+
+  (* Private self is used for private method calls *)
+  let private_self = if final then Ctype.newvar () else self_type in
+
+  (* Self binder *)
+  let (pat, meths, vars, val_env, meth_env, par_env) =
+    type_self_pattern cl_num private_self val_env met_env par_env spat
+  in
+  let public_self = pat.pat_type in
+
+  (* Check that the binder has a correct type *)
+  let ty =
+    if final then Ctype.newobj (Ctype.newvar()) else self_type in
+  begin try Ctype.unify val_env public_self ty with
+    Ctype.Unify _ ->
+      raise(Error(spat.ppat_loc, val_env, Pattern_type_clash public_self))
+  end;
+  let get_methods ty =
+    (fst (Ctype.flatten_fields
+            (Ctype.object_fields (Ctype.expand_head val_env ty)))) in
+  if final then begin
+    (* Copy known information to still empty self_type *)
+    List.iter
+      (fun (lab,kind,ty) ->
+        let k =
+          if Btype.field_kind_repr kind = Fpresent then Public else Private in
+        try Ctype.unify val_env ty
+            (Ctype.filter_method val_env lab k self_type)
+        with _ -> assert false)
+      (get_methods public_self)
+  end;
+
+  (* Typing of class fields *)
+  let (_, _, _, fields, concr_meths, _, inher, _local_meths, _local_vals) =
+    Builtin_attributes.warning_scope []
+      (fun () ->
+         List.fold_left (class_field self_loc cl_num self_type meths vars)
+           (val_env, meth_env, par_env, [], Concr.empty, Concr.empty, [],
+            Concr.empty, Concr.empty)
+           str
+      )
+  in
+  Ctype.unify val_env self_type (Ctype.newvar ()); (* useless ? *)
+  let sign =
+    {csig_self = public_self;
+     csig_vars = Vars.map (fun (_id, mut, vr, ty) -> (mut, vr, ty)) !vars;
+     csig_concr = concr_meths;
+      csig_inher = inher} in
+  let methods = get_methods self_type in
+  let priv_meths =
+    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind <> Fpresent)
+      methods in
+  (* ensure that inherited methods are listed too *)
+  List.iter (fun (met, _kind, _ty) ->
+      if Meths.mem met !meths then () else
+      ignore (Ctype.filter_self_method val_env met Private meths self_type))
+    methods;
+  if final then begin
+    (* Unify private_self and a copy of self_type. self_type will not
+       be modified after this point *)
+    if not (Ctype.close_object self_type) then
+      raise(Error(loc, val_env, Closing_self_type self_type));
+    let mets = virtual_methods {sign with csig_self = self_type} in
+    let vals =
+      Vars.fold
+        (fun name (_mut, vr, _ty) l -> if vr = Virtual then name :: l else l)
+        sign.csig_vars [] in
+    if mets <> [] || vals <> [] then
+      raise(Error(loc, val_env, Virtual_class(true, final, mets, vals)));
+    let self_methods =
+      List.fold_right
+        (fun (lab,kind,ty) rem ->
+           Ctype.newty(Tfield(lab, Btype.copy_kind kind, ty, rem)))
+        methods (Ctype.newty Tnil) in
+    begin try
+      Ctype.unify val_env private_self
+        (Ctype.newty (Tobject(self_methods, ref None)));
+      Ctype.unify val_env public_self self_type
+    with Ctype.Unify trace -> raise(Error(loc, val_env, Final_self_clash trace))
+    end;
+  end;
+
+  (* Typing of method bodies *)
+  (* if !Clflags.principal then *) begin
+    let ms = !meths in
+    (* Generalize the spine of methods accessed through self *)
+    Meths.iter (fun _ (_,ty) -> Ctype.generalize_spine ty) ms;
+    meths :=
+      Meths.map (fun (id,ty) -> (id, Ctype.generic_instance ty)) ms;
+    (* But keep levels correct on the type of self *)
+    Meths.iter (fun _ (_,ty) -> Ctype.unify val_env ty (Ctype.newvar ())) ms
+  end;
+  let fields = List.map Lazy.force (List.rev fields) in
+  let meths = Meths.map (function (id, _ty) -> id) !meths in
+
+  (* Check for private methods made public *)
+  let pub_meths' =
+    List.filter (fun (_,kind,_) -> Btype.field_kind_repr kind = Fpresent)
+      (get_methods public_self) in
+  let names = List.map (fun (x,_,_) -> x) in
+  let l1 = names priv_meths and l2 = names pub_meths' in
+  let added = List.filter (fun x -> List.mem x l1) l2 in
+  if added <> [] then
+    Location.prerr_warning loc (Warnings.Implicit_public_methods added);
+  let sign = if final then sign else
+      {sign with Types.csig_self = Ctype.expand_head val_env public_self} in
+  {
+    cstr_self = pat;
+    cstr_fields = fields;
+    cstr_type = sign;
+    cstr_meths = meths}, sign (* redondant, since already in cstr_type *)
+
+and class_expr cl_num val_env met_env scl =
+  Builtin_attributes.warning_scope scl.pcl_attributes
+    (fun () -> class_expr_aux cl_num val_env met_env scl)
+
+and class_expr_aux cl_num val_env met_env scl =
+  match scl.pcl_desc with
+    Pcl_constr (lid, styl) ->
+      let (path, decl) = Env.lookup_class ~loc:scl.pcl_loc lid.txt val_env in
+      if Path.same decl.cty_path unbound_class then
+        raise(Error(scl.pcl_loc, val_env, Unbound_class_2 lid.txt));
+      let tyl = List.map
+          (fun sty -> transl_simple_type val_env false sty)
+          styl
+      in
+      let (params, clty) =
+        Ctype.instance_class decl.cty_params decl.cty_type
+      in
+      let clty' = abbreviate_class_type path params clty in
+      if List.length params <> List.length tyl then
+        raise(Error(scl.pcl_loc, val_env,
+                    Parameter_arity_mismatch (lid.txt, List.length params,
+                                                   List.length tyl)));
+      List.iter2
+        (fun cty' ty ->
+          let ty' = cty'.ctyp_type in
+           try Ctype.unify val_env ty' ty with Ctype.Unify trace ->
+             raise(Error(cty'.ctyp_loc, val_env, Parameter_mismatch trace)))
+        tyl params;
+      let cl =
+        rc {cl_desc = Tcl_ident (path, lid, tyl);
+            cl_loc = scl.pcl_loc;
+            cl_type = clty';
+            cl_env = val_env;
+            cl_attributes = scl.pcl_attributes;
+           }
+      in
+      let (vals, meths, concrs) = extract_constraints clty in
+      rc {cl_desc = Tcl_constraint (cl, None, vals, meths, concrs);
+          cl_loc = scl.pcl_loc;
+          cl_type = clty';
+          cl_env = val_env;
+          cl_attributes = []; (* attributes are kept on the inner cl node *)
+         }
+  | Pcl_structure cl_str ->
+      let (desc, ty) =
+        class_structure cl_num false val_env met_env scl.pcl_loc cl_str in
+      rc {cl_desc = Tcl_structure desc;
+          cl_loc = scl.pcl_loc;
+          cl_type = Cty_signature ty;
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_fun (l, Some default, spat, sbody) ->
+      let loc = default.pexp_loc in
+      let open Ast_helper in
+      let scases = [
+        Exp.case
+          (Pat.construct ~loc
+             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
+             (Some (Pat.var ~loc (mknoloc "*sth*"))))
+          (Exp.ident ~loc (mknoloc (Longident.Lident "*sth*")));
+
+        Exp.case
+          (Pat.construct ~loc
+             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
+             None)
+          default;
+       ]
+      in
+      let smatch =
+        Exp.match_ ~loc (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
+          scases
+      in
+      let sfun =
+        Cl.fun_ ~loc:scl.pcl_loc
+          l None
+          (Pat.var ~loc (mknoloc "*opt*"))
+          (Cl.let_ ~loc:scl.pcl_loc Nonrecursive [Vb.mk spat smatch] sbody)
+          (* Note: we don't put the '#default' attribute, as it
+             is not detected for class-level let bindings.  See #5975.*)
+      in
+      class_expr cl_num val_env met_env sfun
+  | Pcl_fun (l, None, spat, scl') ->
+      if !Clflags.principal then Ctype.begin_def ();
+      let (pat, pv, val_env', met_env) =
+        Typecore.type_class_arg_pattern cl_num val_env met_env l spat
+      in
+      if !Clflags.principal then begin
+        Ctype.end_def ();
+        iter_pattern (fun {pat_type=ty} -> Ctype.generalize_structure ty) pat
+      end;
+      let pv =
+        List.map
+          begin fun (id, id', _ty) ->
+            let path = Pident id' in
+            (* do not mark the value as being used *)
+            let vd = Env.find_value path val_env' in
+            (id,
+             {exp_desc =
+              Texp_ident(path, mknoloc (Longident.Lident (Ident.name id)), vd);
+              exp_loc = Location.none; exp_extra = [];
+              exp_type = Ctype.instance vd.val_type;
+              exp_attributes = []; (* check *)
+              exp_env = val_env'})
+          end
+          pv
+      in
+      let not_function = function
+          Cty_arrow _ -> false
+        | _ -> true
+      in
+      let partial =
+        let dummy = type_exp val_env (Ast_helper.Exp.unreachable ()) in
+        Typecore.check_partial val_env pat.pat_type pat.pat_loc
+          [{c_lhs = pat; c_guard = None; c_rhs = dummy}]
+      in
+      Ctype.raise_nongen_level ();
+      let cl = class_expr cl_num val_env' met_env scl' in
+      Ctype.end_def ();
+      if Btype.is_optional l && not_function cl.cl_type then
+        Location.prerr_warning pat.pat_loc
+          Warnings.Unerasable_optional_argument;
+      rc {cl_desc = Tcl_fun (l, pat, pv, cl, partial);
+          cl_loc = scl.pcl_loc;
+          cl_type = Cty_arrow
+            (l, Ctype.instance pat.pat_type, cl.cl_type);
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_apply (scl', sargs) ->
+      assert (sargs <> []);
+      if !Clflags.principal then Ctype.begin_def ();
+      let cl = class_expr cl_num val_env met_env scl' in
+      if !Clflags.principal then begin
+        Ctype.end_def ();
+        generalize_class_type false cl.cl_type;
+      end;
+      let rec nonopt_labels ls ty_fun =
+        match ty_fun with
+        | Cty_arrow (l, _, ty_res) ->
+            if Btype.is_optional l then nonopt_labels ls ty_res
+            else nonopt_labels (l::ls) ty_res
+        | _    -> ls
+      in
+      let ignore_labels =
+        !Clflags.classic ||
+        let labels = nonopt_labels [] cl.cl_type in
+        List.length labels = List.length sargs &&
+        List.for_all (fun (l,_) -> l = Nolabel) sargs &&
+        List.exists (fun l -> l <> Nolabel) labels &&
+        begin
+          Location.prerr_warning
+            cl.cl_loc
+            (Warnings.Labels_omitted
+               (List.map Printtyp.string_of_label
+                         (List.filter ((<>) Nolabel) labels)));
+          true
+        end
+      in
+      let rec type_args args omitted ty_fun ty_fun0 sargs more_sargs =
+        match ty_fun, ty_fun0 with
+        | Cty_arrow (l, ty, ty_fun), Cty_arrow (_, ty0, ty_fun0)
+          when sargs <> [] || more_sargs <> [] ->
+            let name = Btype.label_name l
+            and optional = Btype.is_optional l in
+            let sargs, more_sargs, arg =
+              if ignore_labels && not (Btype.is_optional l) then begin
+                match sargs, more_sargs with
+                  (l', sarg0)::_, _ ->
+                    raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l'))
+                | _, (l', sarg0)::more_sargs ->
+                    if l <> l' && l' <> Nolabel then
+                      raise(Error(sarg0.pexp_loc, val_env,
+                                  Apply_wrong_label l'))
+                    else ([], more_sargs,
+                          Some (type_argument val_env sarg0 ty ty0))
+                | _ ->
+                    assert false
+              end else try
+                let (l', sarg0, sargs, more_sargs) =
+                  try
+                    let (l', sarg0, sargs1, sargs2) =
+                      Btype.extract_label name sargs
+                    in (l', sarg0, sargs1 @ sargs2, more_sargs)
+                  with Not_found ->
+                    let (l', sarg0, sargs1, sargs2) =
+                      Btype.extract_label name more_sargs
+                    in (l', sarg0, sargs @ sargs1, sargs2)
+                in
+                if not optional && Btype.is_optional l' then
+                  Location.prerr_warning sarg0.pexp_loc
+                    (Warnings.Nonoptional_label (Printtyp.string_of_label l));
+                sargs, more_sargs,
+                if not optional || Btype.is_optional l' then
+                  Some (type_argument val_env sarg0 ty ty0)
+                else
+                  let ty' = extract_option_type val_env ty
+                  and ty0' = extract_option_type val_env ty0 in
+                  let arg = type_argument val_env sarg0 ty' ty0' in
+                  Some (option_some val_env arg)
+              with Not_found ->
+                sargs, more_sargs,
+                if Btype.is_optional l
+                   && (List.mem_assoc Nolabel sargs
+                       || List.mem_assoc Nolabel more_sargs)
+                then
+                  Some (option_none val_env ty0 Location.none)
+                else None
+            in
+            let omitted = if arg = None then (l,ty0) :: omitted else omitted in
+            type_args ((l,arg)::args) omitted ty_fun ty_fun0
+              sargs more_sargs
+        | _ ->
+            match sargs @ more_sargs with
+              (l, sarg0)::_ ->
+                if omitted <> [] then
+                  raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l))
+                else
+                  raise(Error(cl.cl_loc, val_env, Cannot_apply cl.cl_type))
+            | [] ->
+                (List.rev args,
+                 List.fold_left
+                   (fun ty_fun (l,ty) -> Cty_arrow(l,ty,ty_fun))
+                   ty_fun0 omitted)
+      in
+      let (args, cty) =
+        let (_, ty_fun0) = Ctype.instance_class [] cl.cl_type in
+        if ignore_labels then
+          type_args [] [] cl.cl_type ty_fun0 [] sargs
+        else
+          type_args [] [] cl.cl_type ty_fun0 sargs []
+      in
+      rc {cl_desc = Tcl_apply (cl, args);
+          cl_loc = scl.pcl_loc;
+          cl_type = cty;
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_let (rec_flag, sdefs, scl') ->
+      let (defs, val_env) =
+        Typecore.type_let In_class_def val_env rec_flag sdefs None in
+      let (vals, met_env) =
+        List.fold_right
+          (fun (id, _id_loc, _typ) (vals, met_env) ->
+             let path = Pident id in
+             (* do not mark the value as used *)
+             let vd = Env.find_value path val_env in
+             Ctype.begin_def ();
+             let expr =
+               {exp_desc =
+                Texp_ident(path, mknoloc(Longident.Lident (Ident.name id)),vd);
+                exp_loc = Location.none; exp_extra = [];
+                exp_type = Ctype.instance vd.val_type;
+                exp_attributes = [];
+                exp_env = val_env;
+               }
+             in
+             Ctype.end_def ();
+             Ctype.generalize expr.exp_type;
+             let desc =
+               {val_type = expr.exp_type; val_kind = Val_ivar (Immutable,
+                                                               cl_num);
+                val_attributes = [];
+                Types.val_loc = vd.Types.val_loc;
+               }
+             in
+             let id' = Ident.create_local (Ident.name id) in
+             ((id', expr)
+              :: vals,
+              Env.add_value id' desc met_env))
+          (let_bound_idents_full defs)
+          ([], met_env)
+      in
+      let cl = class_expr cl_num val_env met_env scl' in
+      let () = if rec_flag = Recursive then
+        check_recursive_bindings val_env defs
+      in
+      rc {cl_desc = Tcl_let (rec_flag, defs, vals, cl);
+          cl_loc = scl.pcl_loc;
+          cl_type = cl.cl_type;
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_constraint (scl', scty) ->
+      Ctype.begin_class_def ();
+      let context = Typetexp.narrow () in
+      let cl = class_expr cl_num val_env met_env scl' in
+      Typetexp.widen context;
+      let context = Typetexp.narrow () in
+      let clty = class_type val_env scty in
+      Typetexp.widen context;
+      Ctype.end_def ();
+
+      limited_generalize (Ctype.row_variable (Ctype.self_type cl.cl_type))
+          cl.cl_type;
+      limited_generalize (Ctype.row_variable (Ctype.self_type clty.cltyp_type))
+        clty.cltyp_type;
+
+      begin match
+        Includeclass.class_types val_env cl.cl_type clty.cltyp_type
+      with
+        []    -> ()
+      | error -> raise(Error(cl.cl_loc, val_env, Class_match_failure error))
+      end;
+      let (vals, meths, concrs) = extract_constraints clty.cltyp_type in
+      rc {cl_desc = Tcl_constraint (cl, Some clty, vals, meths, concrs);
+          cl_loc = scl.pcl_loc;
+          cl_type = snd (Ctype.instance_class [] clty.cltyp_type);
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_open (pod, e) ->
+      let used_slot = ref false in
+      let (od, new_val_env) = !type_open_descr ~used_slot val_env pod in
+      let ( _, new_met_env) = !type_open_descr ~used_slot met_env pod in
+      let cl = class_expr cl_num new_val_env new_met_env e in
+      rc {cl_desc = Tcl_open (od, cl);
+          cl_loc = scl.pcl_loc;
+          cl_type = cl.cl_type;
+          cl_env = val_env;
+          cl_attributes = scl.pcl_attributes;
+         }
+  | Pcl_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+(*******************************)
+
+(* Approximate the type of the constructor to allow recursive use *)
+(* of optional parameters                                         *)
+
+let var_option = Predef.type_option (Btype.newgenvar ())
+
+let rec approx_declaration cl =
+  match cl.pcl_desc with
+    Pcl_fun (l, _, _, cl) ->
+      let arg =
+        if Btype.is_optional l then Ctype.instance var_option
+        else Ctype.newvar () in
+      Ctype.newty (Tarrow (l, arg, approx_declaration cl, Cok))
+  | Pcl_let (_, _, cl) ->
+      approx_declaration cl
+  | Pcl_constraint (cl, _) ->
+      approx_declaration cl
+  | _ -> Ctype.newvar ()
+
+let rec approx_description ct =
+  match ct.pcty_desc with
+    Pcty_arrow (l, _, ct) ->
+      let arg =
+        if Btype.is_optional l then Ctype.instance var_option
+        else Ctype.newvar () in
+      Ctype.newty (Tarrow (l, arg, approx_description ct, Cok))
+  | _ -> Ctype.newvar ()
+
+(*******************************)
+
+let temp_abbrev loc env id arity =
+  let params = ref [] in
+  for _i = 1 to arity do
+    params := Ctype.newvar () :: !params
+  done;
+  let ty = Ctype.newobj (Ctype.newvar ()) in
+  let env =
+    Env.add_type ~check:true id
+      {type_params = !params;
+       type_arity = arity;
+       type_kind = Type_abstract;
+       type_private = Public;
+       type_manifest = Some ty;
+       type_variance = Misc.replicate_list Variance.full arity;
+       type_is_newtype = false;
+       type_expansion_scope = Btype.lowest_level;
+       type_loc = loc;
+       type_attributes = []; (* or keep attrs from the class decl? *)
+       type_immediate = Unknown;
+       type_unboxed = unboxed_false_default_false;
+      }
+      env
+  in
+  (!params, ty, env)
+
+let initial_env define_class approx
+    (res, env) (cl, id, ty_id, obj_id, cl_id) =
+  (* Temporary abbreviations *)
+  let arity = List.length cl.pci_params in
+  let (obj_params, obj_ty, env) = temp_abbrev cl.pci_loc env obj_id arity in
+  let (cl_params, cl_ty, env) = temp_abbrev cl.pci_loc env cl_id arity in
+
+  (* Temporary type for the class constructor *)
+  let constr_type = approx cl.pci_expr in
+  if !Clflags.principal then Ctype.generalize_spine constr_type;
+  let dummy_cty =
+    Cty_signature
+      { csig_self = Ctype.newvar ();
+        csig_vars = Vars.empty;
+        csig_concr = Concr.empty;
+        csig_inher = [] }
+  in
+  let dummy_class =
+    {Types.cty_params = [];             (* Dummy value *)
+     cty_variance = [];
+     cty_type = dummy_cty;        (* Dummy value *)
+     cty_path = unbound_class;
+     cty_new =
+       begin match cl.pci_virt with
+       | Virtual  -> None
+       | Concrete -> Some constr_type
+       end;
+     cty_loc = Location.none;
+     cty_attributes = [];
+    }
+  in
+  let env =
+    Env.add_cltype ty_id
+      {clty_params = [];            (* Dummy value *)
+       clty_variance = [];
+       clty_type = dummy_cty;       (* Dummy value *)
+       clty_path = unbound_class;
+       clty_loc = Location.none;
+       clty_attributes = [];
+      }
+      (
+        if define_class then
+          Env.add_class id dummy_class env
+        else
+          env
+      )
+  in
+  ((cl, id, ty_id,
+    obj_id, obj_params, obj_ty,
+    cl_id, cl_params, cl_ty,
+    constr_type, dummy_class)::res,
+   env)
+
+let class_infos define_class kind
+    (cl, id, ty_id,
+     obj_id, obj_params, obj_ty,
+     cl_id, cl_params, cl_ty,
+     constr_type, dummy_class)
+    (res, env) =
+
+  reset_type_variables ();
+  Ctype.begin_class_def ();
+
+  (* Introduce class parameters *)
+  let ci_params =
+    let make_param (sty, v) =
+      try
+          (transl_type_param env sty, v)
+      with Already_bound ->
+        raise(Error(sty.ptyp_loc, env, Repeated_parameter))
+    in
+      List.map make_param cl.pci_params
+  in
+  let params = List.map (fun (cty, _) -> cty.ctyp_type) ci_params in
+
+  (* Allow self coercions (only for class declarations) *)
+  let coercion_locs = ref [] in
+
+  (* Type the class expression *)
+  let (expr, typ) =
+    try
+      Typecore.self_coercion :=
+        (Path.Pident obj_id, coercion_locs) :: !Typecore.self_coercion;
+      let res = kind env cl.pci_expr in
+      Typecore.self_coercion := List.tl !Typecore.self_coercion;
+      res
+    with exn ->
+      Typecore.self_coercion := []; raise exn
+  in
+
+  Ctype.end_def ();
+
+  let sty = Ctype.self_type typ in
+
+  (* First generalize the type of the dummy method (cf PR#6123) *)
+  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
+  List.iter (fun (met, _, ty) -> if met = dummy_method then Ctype.generalize ty)
+    fields;
+  (* Generalize the row variable *)
+  let rv = Ctype.row_variable sty in
+  List.iter (Ctype.limited_generalize rv) params;
+  limited_generalize rv typ;
+
+  (* Check the abbreviation for the object type *)
+  let (obj_params', obj_type) = Ctype.instance_class params typ in
+  let constr = Ctype.newconstr (Path.Pident obj_id) obj_params in
+  begin
+    let ty = Ctype.self_type obj_type in
+    Ctype.hide_private_methods ty;
+    if not (Ctype.close_object ty) then
+      raise(Error(cl.pci_loc, env, Closing_self_type ty));
+    begin try
+      List.iter2 (Ctype.unify env) obj_params obj_params'
+    with Ctype.Unify _ ->
+      raise(Error(cl.pci_loc, env,
+            Bad_parameters (obj_id, constr,
+                            Ctype.newconstr (Path.Pident obj_id)
+                                            obj_params')))
+    end;
+    begin try
+      Ctype.unify env ty constr
+    with Ctype.Unify _ ->
+      raise(Error(cl.pci_loc, env,
+        Abbrev_type_clash (constr, ty, Ctype.expand_head env constr)))
+    end
+  end;
+
+  (* Check the other temporary abbreviation (#-type) *)
+  begin
+    let (cl_params', cl_type) = Ctype.instance_class params typ in
+    let ty = Ctype.self_type cl_type in
+    Ctype.hide_private_methods ty;
+    Ctype.set_object_name obj_id (Ctype.row_variable ty) cl_params ty;
+    begin try
+      List.iter2 (Ctype.unify env) cl_params cl_params'
+    with Ctype.Unify _ ->
+      raise(Error(cl.pci_loc, env,
+            Bad_parameters (cl_id,
+                            Ctype.newconstr (Path.Pident cl_id)
+                                            cl_params,
+                            Ctype.newconstr (Path.Pident cl_id)
+                                            cl_params')))
+    end;
+    begin try
+      Ctype.unify env ty cl_ty
+    with Ctype.Unify _ ->
+      let constr = Ctype.newconstr (Path.Pident cl_id) params in
+      raise(Error(cl.pci_loc, env, Abbrev_type_clash (constr, ty, cl_ty)))
+    end
+  end;
+
+  (* Type of the class constructor *)
+  begin try
+    Ctype.unify env
+      (constructor_type constr obj_type)
+      (Ctype.instance constr_type)
+  with Ctype.Unify trace ->
+    raise(Error(cl.pci_loc, env,
+                Constructor_type_mismatch (cl.pci_name.txt, trace)))
+  end;
+
+  (* Class and class type temporary definitions *)
+  let cty_variance = List.map (fun _ -> Variance.full) params in
+  let cltydef =
+    {clty_params = params; clty_type = class_body typ;
+     clty_variance = cty_variance;
+     clty_path = Path.Pident obj_id;
+     clty_loc = cl.pci_loc;
+     clty_attributes = cl.pci_attributes;
+    }
+  and clty =
+    {cty_params = params; cty_type = typ;
+     cty_variance = cty_variance;
+     cty_path = Path.Pident obj_id;
+     cty_new =
+       begin match cl.pci_virt with
+       | Virtual  -> None
+       | Concrete -> Some constr_type
+       end;
+     cty_loc = cl.pci_loc;
+     cty_attributes = cl.pci_attributes;
+    }
+  in
+  dummy_class.cty_type <- typ;
+  let env =
+    Env.add_cltype ty_id cltydef (
+    if define_class then Env.add_class id clty env else env)
+  in
+
+  if cl.pci_virt = Concrete then begin
+    let sign = Ctype.signature_of_class_type typ in
+    let mets = virtual_methods sign in
+    let vals =
+      Vars.fold
+        (fun name (_mut, vr, _ty) l -> if vr = Virtual then name :: l else l)
+        sign.csig_vars [] in
+    if mets <> []  || vals <> [] then
+      raise(Error(cl.pci_loc, env, Virtual_class(define_class, false, mets,
+                                                 vals)));
+  end;
+
+  (* Misc. *)
+  let arity = Ctype.class_type_arity typ in
+  let pub_meths =
+    let (fields, _) =
+      Ctype.flatten_fields (Ctype.object_fields (Ctype.expand_head env obj_ty))
+    in
+    List.map (function (lab, _, _) -> lab) fields
+  in
+
+  (* Final definitions *)
+  let (params', typ') = Ctype.instance_class params typ in
+  let cltydef =
+    {clty_params = params'; clty_type = class_body typ';
+     clty_variance = cty_variance;
+     clty_path = Path.Pident obj_id;
+     clty_loc = cl.pci_loc;
+     clty_attributes = cl.pci_attributes;
+    }
+  and clty =
+    {cty_params = params'; cty_type = typ';
+     cty_variance = cty_variance;
+     cty_path = Path.Pident obj_id;
+     cty_new =
+       begin match cl.pci_virt with
+       | Virtual  -> None
+       | Concrete -> Some (Ctype.instance constr_type)
+       end;
+     cty_loc = cl.pci_loc;
+     cty_attributes = cl.pci_attributes;
+    }
+  in
+  let obj_abbr =
+    {type_params = obj_params;
+     type_arity = List.length obj_params;
+     type_kind = Type_abstract;
+     type_private = Public;
+     type_manifest = Some obj_ty;
+     type_variance = List.map (fun _ -> Variance.full) obj_params;
+     type_is_newtype = false;
+     type_expansion_scope = Btype.lowest_level;
+     type_loc = cl.pci_loc;
+     type_attributes = []; (* or keep attrs from cl? *)
+     type_immediate = Unknown;
+     type_unboxed = unboxed_false_default_false;
+    }
+  in
+  let (cl_params, cl_ty) =
+    Ctype.instance_parameterized_type params (Ctype.self_type typ)
+  in
+  Ctype.hide_private_methods cl_ty;
+  Ctype.set_object_name obj_id (Ctype.row_variable cl_ty) cl_params cl_ty;
+  let cl_abbr =
+    {type_params = cl_params;
+     type_arity = List.length cl_params;
+     type_kind = Type_abstract;
+     type_private = Public;
+     type_manifest = Some cl_ty;
+     type_variance = List.map (fun _ -> Variance.full) cl_params;
+     type_is_newtype = false;
+     type_expansion_scope = Btype.lowest_level;
+     type_loc = cl.pci_loc;
+     type_attributes = []; (* or keep attrs from cl? *)
+     type_immediate = Unknown;
+     type_unboxed = unboxed_false_default_false;
+    }
+  in
+  ((cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
+    arity, pub_meths, List.rev !coercion_locs, expr) :: res,
+   env)
+
+let final_decl env define_class
+    (cl, id, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr, ci_params,
+     arity, pub_meths, coe, expr) =
+
+  begin try Ctype.collapse_conj_params env clty.cty_params
+  with Ctype.Unify trace ->
+    raise(Error(cl.pci_loc, env, Non_collapsable_conjunction (id, clty, trace)))
+  end;
+
+  (* make the dummy method disappear *)
+  begin
+    let self_type = Ctype.self_type clty.cty_type in
+    let methods, _ =
+      Ctype.flatten_fields
+        (Ctype.object_fields (Ctype.expand_head env self_type))
+    in
+    List.iter (fun (lab,kind,_) ->
+      if lab = dummy_method then
+        match Btype.field_kind_repr kind with
+          Fvar r -> Btype.set_kind r Fabsent
+        | _ -> ()
+    ) methods
+  end;
+
+  List.iter Ctype.generalize clty.cty_params;
+  generalize_class_type true clty.cty_type;
+  Option.iter  Ctype.generalize clty.cty_new;
+  List.iter Ctype.generalize obj_abbr.type_params;
+  Option.iter  Ctype.generalize obj_abbr.type_manifest;
+  List.iter Ctype.generalize cl_abbr.type_params;
+  Option.iter  Ctype.generalize cl_abbr.type_manifest;
+
+  if not (closed_class clty) then
+    raise(Error(cl.pci_loc, env, Non_generalizable_class (id, clty)));
+
+  begin match
+    Ctype.closed_class clty.cty_params
+      (Ctype.signature_of_class_type clty.cty_type)
+  with
+    None        -> ()
+  | Some reason ->
+      let printer =
+        if define_class
+        then function ppf -> Printtyp.class_declaration id ppf clty
+        else function ppf -> Printtyp.cltype_declaration id ppf cltydef
+      in
+      raise(Error(cl.pci_loc, env, Unbound_type_var(printer, reason)))
+  end;
+  { id; clty; ty_id; cltydef; obj_id; obj_abbr; cl_id; cl_abbr; arity;
+    pub_meths; coe; expr;
+    id_loc = cl.pci_name;
+    req = { ci_loc = cl.pci_loc;
+            ci_virt = cl.pci_virt;
+            ci_params = ci_params;
+        (* TODO : check that we have the correct use of identifiers *)
+            ci_id_name = cl.pci_name;
+            ci_id_class = id;
+            ci_id_class_type = ty_id;
+            ci_id_object = obj_id;
+            ci_id_typehash = cl_id;
+            ci_expr = expr;
+            ci_decl = clty;
+            ci_type_decl = cltydef;
+            ci_attributes = cl.pci_attributes;
+        }
+  }
+(*   (cl.pci_variance, cl.pci_loc)) *)
+
+let class_infos define_class kind
+    (cl, id, ty_id,
+     obj_id, obj_params, obj_ty,
+     cl_id, cl_params, cl_ty,
+     constr_type, dummy_class)
+    (res, env) =
+  Builtin_attributes.warning_scope cl.pci_attributes
+    (fun () ->
+       class_infos define_class kind
+         (cl, id, ty_id,
+          obj_id, obj_params, obj_ty,
+          cl_id, cl_params, cl_ty,
+          constr_type, dummy_class)
+         (res, env)
+    )
+
+let extract_type_decls { clty; cltydef; obj_id; obj_abbr; cl_abbr; req} decls =
+  (obj_id, obj_abbr, cl_abbr, clty, cltydef, req) :: decls
+
+let merge_type_decls decl (obj_abbr, cl_abbr, clty, cltydef) =
+  {decl with obj_abbr; cl_abbr; clty; cltydef}
+
+let final_env define_class env { id; clty; ty_id; cltydef; obj_id; obj_abbr;
+    cl_id; cl_abbr } =
+  (* Add definitions after cleaning them *)
+  Env.add_type ~check:true obj_id
+    (Subst.type_declaration Subst.identity obj_abbr) (
+  Env.add_type ~check:true cl_id
+    (Subst.type_declaration Subst.identity cl_abbr) (
+  Env.add_cltype ty_id (Subst.cltype_declaration Subst.identity cltydef) (
+  if define_class then
+    Env.add_class id (Subst.class_declaration Subst.identity clty) env
+  else env)))
+
+(* Check that #c is coercible to c if there is a self-coercion *)
+let check_coercions env { id; id_loc; clty; ty_id; cltydef; obj_id; obj_abbr;
+    cl_id; cl_abbr; arity; pub_meths; coe; req } =
+  begin match coe with [] -> ()
+  | loc :: _ ->
+      let cl_ty, obj_ty =
+        match cl_abbr.type_manifest, obj_abbr.type_manifest with
+          Some cl_ab, Some obj_ab ->
+            let cl_params, cl_ty =
+              Ctype.instance_parameterized_type cl_abbr.type_params cl_ab
+            and obj_params, obj_ty =
+              Ctype.instance_parameterized_type obj_abbr.type_params obj_ab
+            in
+            List.iter2 (Ctype.unify env) cl_params obj_params;
+            cl_ty, obj_ty
+        | _ -> assert false
+      in
+      begin try Ctype.subtype env cl_ty obj_ty ()
+      with Ctype.Subtype (tr1, tr2) ->
+        raise(Typecore.Error(loc, env, Typecore.Not_subtype(tr1, tr2)))
+      end;
+      if not (Ctype.opened_object cl_ty) then
+        raise(Error(loc, env, Cannot_coerce_self obj_ty))
+  end;
+  {cls_id = id;
+   cls_id_loc = id_loc;
+   cls_decl = clty;
+   cls_ty_id = ty_id;
+   cls_ty_decl = cltydef;
+   cls_obj_id = obj_id;
+   cls_obj_abbr = obj_abbr;
+   cls_typesharp_id = cl_id;
+   cls_abbr = cl_abbr;
+   cls_arity = arity;
+   cls_pub_methods = pub_meths;
+   cls_info=req}
+
+(*******************************)
+
+let type_classes define_class approx kind env cls =
+  let scope = Ctype.create_scope () in
+  let cls =
+    List.map
+      (function cl ->
+         (cl,
+          Ident.create_scoped ~scope cl.pci_name.txt,
+          Ident.create_scoped ~scope cl.pci_name.txt,
+          Ident.create_scoped ~scope cl.pci_name.txt,
+          Ident.create_scoped ~scope ("#" ^ cl.pci_name.txt)))
+      cls
+  in
+  Ctype.begin_class_def ();
+  let (res, newenv) =
+    List.fold_left (initial_env define_class approx) ([], env) cls
+  in
+  let (res, newenv) =
+    List.fold_right (class_infos define_class kind) res ([], newenv)
+  in
+  Ctype.end_def ();
+  let res = List.rev_map (final_decl newenv define_class) res in
+  let decls = List.fold_right extract_type_decls res [] in
+  let decls =
+    try Typedecl_variance.update_class_decls newenv decls
+    with Typedecl_variance.Error(loc, err) ->
+      raise (Typedecl.Error(loc, Typedecl.Variance err))
+  in
+  let res = List.map2 merge_type_decls res decls in
+  let env = List.fold_left (final_env define_class) env res in
+  let res = List.map (check_coercions env) res in
+  (res, env)
+
+let class_num = ref 0
+let class_declaration env sexpr =
+  incr class_num;
+  let expr = class_expr (Int.to_string !class_num) env env sexpr in
+  (expr, expr.cl_type)
+
+let class_description env sexpr =
+  let expr = class_type env sexpr in
+  (expr, expr.cltyp_type)
+
+let class_declarations env cls =
+  let info, env =
+    type_classes true approx_declaration class_declaration env cls
+  in
+  let ids, exprs =
+    List.split
+      (List.map
+         (fun ci -> ci.cls_id, ci.cls_info.ci_expr)
+         info)
+  in
+  check_recursive_class_bindings env ids exprs;
+  info, env
+
+let class_descriptions env cls =
+  type_classes true approx_description class_description env cls
+
+let class_type_declarations env cls =
+  let (decls, env) =
+    type_classes false approx_description class_description env cls
+  in
+  (List.map
+     (fun decl ->
+        {clsty_ty_id = decl.cls_ty_id;
+         clsty_id_loc = decl.cls_id_loc;
+         clsty_ty_decl = decl.cls_ty_decl;
+         clsty_obj_id = decl.cls_obj_id;
+         clsty_obj_abbr = decl.cls_obj_abbr;
+         clsty_typesharp_id = decl.cls_typesharp_id;
+         clsty_abbr = decl.cls_abbr;
+         clsty_info = decl.cls_info})
+     decls,
+   env)
+
+let rec unify_parents env ty cl =
+  match cl.cl_desc with
+    Tcl_ident (p, _, _) ->
+      begin try
+        let decl = Env.find_class p env in
+        let _, body = Ctype.find_cltype_for_path env decl.cty_path in
+        Ctype.unify env ty (Ctype.instance body)
+      with
+        Not_found -> ()
+      | _exn -> assert false
+      end
+  | Tcl_structure st -> unify_parents_struct env ty st
+  | Tcl_open (_, cl)
+  | Tcl_fun (_, _, _, cl, _)
+  | Tcl_apply (cl, _)
+  | Tcl_let (_, _, _, cl)
+  | Tcl_constraint (cl, _, _, _, _) -> unify_parents env ty cl
+and unify_parents_struct env ty st =
+  List.iter
+    (function
+      | {cf_desc = Tcf_inherit (_, cl, _, _, _)} ->
+          unify_parents env ty cl
+      | _ -> ())
+    st.cstr_fields
+
+let type_object env loc s =
+  incr class_num;
+  let (desc, sign) =
+    class_structure (Int.to_string !class_num) true env env loc s in
+  let sty = Ctype.expand_head env sign.csig_self in
+  Ctype.hide_private_methods sty;
+  let (fields, _) = Ctype.flatten_fields (Ctype.object_fields sty) in
+  let meths = List.map (fun (s,_,_) -> s) fields in
+  unify_parents_struct env sign.csig_self desc;
+  (desc, sign, meths)
+
+let () =
+  Typecore.type_object := type_object
+
+(*******************************)
+
+(* Approximate the class declaration as class ['params] id = object end *)
+let approx_class sdecl =
+  let open Ast_helper in
+  let self' = Typ.any () in
+  let clty' = Cty.signature ~loc:sdecl.pci_expr.pcty_loc (Csig.mk self' []) in
+  { sdecl with pci_expr = clty' }
+
+let approx_class_declarations env sdecls =
+  fst (class_type_declarations env (List.map approx_class sdecls))
+
+(*******************************)
+
+(* Error report *)
+
+open Format
+
+let report_error env ppf = function
+  | Repeated_parameter ->
+      fprintf ppf "A type parameter occurs several times"
+  | Unconsistent_constraint trace ->
+      fprintf ppf "The class constraints are not consistent.@.";
+      Printtyp.report_unification_error ppf env trace
+        (fun ppf -> fprintf ppf "Type")
+        (fun ppf -> fprintf ppf "is not compatible with type")
+  | Field_type_mismatch (k, m, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "The %s %s@ has type" k m)
+        (function ppf ->
+           fprintf ppf "but is expected to have type")
+  | Structure_expected clty ->
+      fprintf ppf
+        "@[This class expression is not a class structure; it has type@ %a@]"
+        Printtyp.class_type clty
+  | Cannot_apply _ ->
+      fprintf ppf
+        "This class expression is not a class function, it cannot be applied"
+  | Apply_wrong_label l ->
+      let mark_label = function
+        | Nolabel -> "out label"
+        |  l -> sprintf " label %s" (Btype.prefixed_label_name l) in
+      fprintf ppf "This argument cannot be applied with%s" (mark_label l)
+  | Pattern_type_clash ty ->
+      (* XXX Trace *)
+      (* XXX Revoir message d'erreur | Improve error message *)
+      fprintf ppf "@[%s@ %a@]"
+        "This pattern cannot match self: it only matches values of type"
+        Printtyp.type_expr ty
+  | Unbound_class_2 cl ->
+      fprintf ppf "@[The class@ %a@ is not yet completely defined@]"
+      Printtyp.longident cl
+  | Unbound_class_type_2 cl ->
+      fprintf ppf "@[The class type@ %a@ is not yet completely defined@]"
+      Printtyp.longident cl
+  | Abbrev_type_clash (abbrev, actual, expected) ->
+      (* XXX Afficher une trace ? | Print a trace? *)
+      Printtyp.reset_and_mark_loops_list [abbrev; actual; expected];
+      fprintf ppf "@[The abbreviation@ %a@ expands to type@ %a@ \
+       but is used with type@ %a@]"
+        !Oprint.out_type (Printtyp.tree_of_typexp false abbrev)
+        !Oprint.out_type (Printtyp.tree_of_typexp false actual)
+        !Oprint.out_type (Printtyp.tree_of_typexp false expected)
+  | Constructor_type_mismatch (c, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "The expression \"new %s\" has type" c)
+        (function ppf ->
+           fprintf ppf "but is used with type")
+  | Virtual_class (cl, imm, mets, vals) ->
+      let print_mets ppf mets =
+        List.iter (function met -> fprintf ppf "@ %s" met) mets in
+      let missings =
+        match mets, vals with
+          [], _ -> "variables"
+        | _, [] -> "methods"
+        | _ -> "methods and variables"
+      in
+      let print_msg ppf =
+        if imm then fprintf ppf "This object has virtual %s" missings
+        else if cl then fprintf ppf "This class should be virtual"
+        else fprintf ppf "This class type should be virtual"
+      in
+      fprintf ppf
+        "@[%t.@ @[<2>The following %s are undefined :%a@]@]"
+        print_msg missings print_mets (mets @ vals)
+  | Parameter_arity_mismatch(lid, expected, provided) ->
+      fprintf ppf
+        "@[The class constructor %a@ expects %i type argument(s),@ \
+           but is here applied to %i type argument(s)@]"
+        Printtyp.longident lid expected provided
+  | Parameter_mismatch trace ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "The type parameter")
+        (function ppf ->
+           fprintf ppf "does not meet its constraint: it should be")
+  | Bad_parameters (id, params, cstrs) ->
+      Printtyp.reset_and_mark_loops_list [params; cstrs];
+      fprintf ppf
+        "@[The abbreviation %a@ is used with parameters@ %a@ \
+           which are incompatible with constraints@ %a@]"
+        Printtyp.ident id
+        !Oprint.out_type (Printtyp.tree_of_typexp false params)
+        !Oprint.out_type (Printtyp.tree_of_typexp false cstrs)
+  | Class_match_failure error ->
+      Includeclass.report_error ppf error
+  | Unbound_val lab ->
+      fprintf ppf "Unbound instance variable %s" lab
+  | Unbound_type_var (printer, reason) ->
+      let print_common ppf kind ty0 real lab ty =
+        let ty1 =
+          if real then ty0 else Btype.newgenty(Tobject(ty0, ref None)) in
+        List.iter Printtyp.mark_loops [ty; ty1];
+        fprintf ppf
+          "The %s %s@ has type@;<1 2>%a@ where@ %a@ is unbound"
+          kind lab
+          !Oprint.out_type (Printtyp.tree_of_typexp false ty)
+          !Oprint.out_type (Printtyp.tree_of_typexp false ty0)
+      in
+      let print_reason ppf = function
+      | Ctype.CC_Method (ty0, real, lab, ty) ->
+          print_common ppf "method" ty0 real lab ty
+      | Ctype.CC_Value (ty0, real, lab, ty) ->
+          print_common ppf "instance variable" ty0 real lab ty
+      in
+      Printtyp.reset ();
+      fprintf ppf
+        "@[<v>@[Some type variables are unbound in this type:@;<1 2>%t@]@ \
+              @[%a@]@]"
+       printer print_reason reason
+  | Non_generalizable_class (id, clty) ->
+      fprintf ppf
+        "@[The type of this class,@ %a,@ \
+           contains type variables that cannot be generalized@]"
+        (Printtyp.class_declaration id) clty
+  | Cannot_coerce_self ty ->
+      fprintf ppf
+        "@[The type of self cannot be coerced to@ \
+           the type of the current class:@ %a.@.\
+           Some occurrences are contravariant@]"
+        Printtyp.type_scheme ty
+  | Non_collapsable_conjunction (id, clty, trace) ->
+      fprintf ppf
+        "@[The type of this class,@ %a,@ \
+           contains non-collapsible conjunctive types in constraints.@ %t@]"
+        (Printtyp.class_declaration id) clty
+        (fun ppf -> Printtyp.report_unification_error ppf env trace
+            (fun ppf -> fprintf ppf "Type")
+            (fun ppf -> fprintf ppf "is not compatible with type")
+        )
+  | Final_self_clash trace ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "This object is expected to have type")
+        (function ppf ->
+           fprintf ppf "but actually has type")
+  | Mutability_mismatch (_lab, mut) ->
+      let mut1, mut2 =
+        if mut = Immutable then "mutable", "immutable"
+        else "immutable", "mutable" in
+      fprintf ppf
+        "@[The instance variable is %s;@ it cannot be redefined as %s@]"
+        mut1 mut2
+  | No_overriding (_, "") ->
+      fprintf ppf "@[This inheritance does not override any method@ %s@]"
+        "instance variable"
+  | No_overriding (kind, name) ->
+      fprintf ppf "@[The %s `%s'@ has no previous definition@]" kind name
+  | Duplicate (kind, name) ->
+      fprintf ppf "@[The %s `%s'@ has multiple definitions in this object@]"
+                    kind name
+  | Closing_self_type self ->
+    fprintf ppf
+      "@[Cannot close type of object literal:@ %a@,\
+       it has been unified with the self type of a class that is not yet@ \
+       completely defined.@]"
+      Printtyp.type_scheme self
+
+let report_error env ppf err =
+  Printtyp.wrap_printing_env ~error:true
+    env (fun () -> report_error env ppf err)
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, env, err) ->
+        Some (Location.error_of_printer ~loc (report_error env) err)
+      | Error_forward err ->
+        Some err
+      | _ ->
+        None
+    )
diff --git a/src/ocaml/typing/410+multicore/typeclass.mli b/src/ocaml/typing/410+multicore/typeclass.mli
new file mode 100644
index 00000000..c3503526
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typeclass.mli
@@ -0,0 +1,130 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Types
+open Format
+
+type 'a class_info = {
+  cls_id : Ident.t;
+  cls_id_loc : string loc;
+  cls_decl : class_declaration;
+  cls_ty_id : Ident.t;
+  cls_ty_decl : class_type_declaration;
+  cls_obj_id : Ident.t;
+  cls_obj_abbr : type_declaration;
+  cls_typesharp_id : Ident.t;
+  cls_abbr : type_declaration;
+  cls_arity : int;
+  cls_pub_methods : string list;
+  cls_info : 'a;
+}
+
+type class_type_info = {
+  clsty_ty_id : Ident.t;
+  clsty_id_loc : string loc;
+  clsty_ty_decl : class_type_declaration;
+  clsty_obj_id : Ident.t;
+  clsty_obj_abbr : type_declaration;
+  clsty_typesharp_id : Ident.t;
+  clsty_abbr : type_declaration;
+  clsty_info : Typedtree.class_type_declaration;
+}
+
+val class_declarations:
+  Env.t -> Parsetree.class_declaration list ->
+  Typedtree.class_declaration class_info list * Env.t
+
+(*
+and class_declaration =
+  (class_expr, Types.class_declaration) class_infos
+*)
+
+val class_descriptions:
+  Env.t -> Parsetree.class_description list ->
+  Typedtree.class_description class_info list * Env.t
+
+(*
+and class_description =
+  (class_type, unit) class_infos
+*)
+
+val class_type_declarations:
+  Env.t -> Parsetree.class_description list -> class_type_info list * Env.t
+
+(*
+and class_type_declaration =
+  (class_type, Types.class_type_declaration) class_infos
+*)
+
+val approx_class_declarations:
+  Env.t -> Parsetree.class_description list -> class_type_info list
+
+val virtual_methods: Types.class_signature -> label list
+
+(*
+val type_classes :
+           bool ->
+           ('a -> Types.type_expr) ->
+           (Env.t -> 'a -> 'b * Types.class_type) ->
+           Env.t ->
+           'a Parsetree.class_infos list ->
+  (  Ident.t * Types.class_declaration *
+     Ident.t * Types.class_type_declaration *
+     Ident.t * Types.type_declaration *
+     Ident.t * Types.type_declaration *
+     int * string list * 'b * 'b Typedtree.class_infos)
+           list * Env.t
+*)
+
+type error =
+    Unconsistent_constraint of Ctype.Unification_trace.t
+  | Field_type_mismatch of string * string * Ctype.Unification_trace.t
+  | Structure_expected of class_type
+  | Cannot_apply of class_type
+  | Apply_wrong_label of arg_label
+  | Pattern_type_clash of type_expr
+  | Repeated_parameter
+  | Unbound_class_2 of Longident.t
+  | Unbound_class_type_2 of Longident.t
+  | Abbrev_type_clash of type_expr * type_expr * type_expr
+  | Constructor_type_mismatch of string * Ctype.Unification_trace.t
+  | Virtual_class of bool * bool * string list * string list
+  | Parameter_arity_mismatch of Longident.t * int * int
+  | Parameter_mismatch of Ctype.Unification_trace.t
+  | Bad_parameters of Ident.t * type_expr * type_expr
+  | Class_match_failure of Ctype.class_match_failure list
+  | Unbound_val of string
+  | Unbound_type_var of (formatter -> unit) * Ctype.closed_class_failure
+  | Non_generalizable_class of Ident.t * Types.class_declaration
+  | Cannot_coerce_self of type_expr
+  | Non_collapsable_conjunction of
+      Ident.t * Types.class_declaration * Ctype.Unification_trace.t
+  | Final_self_clash of Ctype.Unification_trace.t
+  | Mutability_mismatch of string * mutable_flag
+  | No_overriding of string * string
+  | Duplicate of string * string
+  | Closing_self_type of type_expr
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+val report_error : Env.t -> formatter -> error -> unit
+
+(* Forward decl filled in by Typemod.type_open_descr *)
+val type_open_descr :
+  (?used_slot:bool ref ->
+   Env.t -> Parsetree.open_description -> Typedtree.open_description * Env.t)
+    ref
diff --git a/src/ocaml/typing/410+multicore/typecore.ml b/src/ocaml/typing/410+multicore/typecore.ml
new file mode 100644
index 00000000..1fd5297a
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typecore.ml
@@ -0,0 +1,5428 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Typechecking for the core language *)
+
+open Misc
+open Asttypes
+open Parsetree
+open Types
+open Typedtree
+open Btype
+open Ctype
+
+let merlin_incorrect_attribute =
+  Ast_helper.Attr.mk (Location.mknoloc "merlin.incorrect") (Parsetree.PStr [])
+
+let merlin_recovery_attributes attrs =
+  let attrs' = merlin_incorrect_attribute :: Msupport.flush_saved_types () in
+  match attrs with
+  | [] -> attrs'
+  | attrs -> attrs' @ attrs
+
+let raise_error = Msupport.raise_error
+
+type type_forcing_context =
+  | If_conditional
+  | If_no_else_branch
+  | While_loop_conditional
+  | While_loop_body
+  | For_loop_start_index
+  | For_loop_stop_index
+  | For_loop_body
+  | Assert_condition
+  | Sequence_left_hand_side
+  | When_guard
+
+type type_expected = {
+  ty: type_expr;
+  explanation: type_forcing_context option;
+}
+
+type existential_restriction =
+  | At_toplevel (** no existential types at the toplevel *)
+  | In_group (** nor with let ... and ... *)
+  | In_rec (** or recursive definition *)
+  | With_attributes (** or let[@any_attribute] = ... *)
+  | In_class_args (** or in class arguments *)
+  | In_class_def  (** or in [class c = let ... in ...] *)
+  | In_self_pattern (** or in self pattern *)
+
+type error =
+  | Constructor_arity_mismatch of Longident.t * int * int
+  | Label_mismatch of Longident.t * Ctype.Unification_trace.t
+  | Pattern_type_clash of Ctype.Unification_trace.t * pattern_desc option
+  | Or_pattern_type_clash of Ident.t * Ctype.Unification_trace.t
+  | Multiply_bound_variable of string
+  | Orpat_vars of Ident.t * Ident.t list
+  | Expr_type_clash of
+      Ctype.Unification_trace.t * type_forcing_context option
+      * expression_desc option
+  | Apply_non_function of type_expr
+  | Apply_wrong_label of arg_label * type_expr
+  | Label_multiply_defined of string
+  | Label_missing of Ident.t list
+  | Label_not_mutable of Longident.t
+  | Wrong_name of
+      string * type_expected * string * Path.t * string * string list
+  | Name_type_mismatch of
+      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
+  | Invalid_format of string
+  | Undefined_method of type_expr * string * string list option
+  | Undefined_inherited_method of string * string list
+  | Virtual_class of Longident.t
+  | Private_type of type_expr
+  | Private_label of Longident.t * type_expr
+  | Private_constructor of constructor_description * type_expr
+  | Unbound_instance_variable of string * string list
+  | Instance_variable_not_mutable of string
+  | Not_subtype of Ctype.Unification_trace.t * Ctype.Unification_trace.t
+  | Outside_class
+  | Value_multiply_overridden of string
+  | Coercion_failure of
+      type_expr * type_expr * Ctype.Unification_trace.t * bool
+  | Too_many_arguments of bool * type_expr * type_forcing_context option
+  | Abstract_wrong_label of arg_label * type_expr * type_forcing_context option
+  | Scoping_let_module of string * type_expr
+  | Not_a_variant_type of Longident.t
+  | Incoherent_label_order
+  | Less_general of string * Ctype.Unification_trace.t
+  | Modules_not_allowed
+  | Cannot_infer_signature
+  | Not_a_packed_module of type_expr
+  | Unexpected_existential of existential_restriction * string * string list
+  | Invalid_interval
+  | Invalid_for_loop_index
+  | No_value_clauses
+  | Exception_pattern_disallowed
+  | Mixed_value_and_exception_patterns_under_guard
+  | Inlined_record_escape
+  | Inlined_record_expected
+  | Unrefuted_pattern of pattern
+  | Invalid_extension_constructor_payload
+  | Not_an_extension_constructor
+  | Literal_overflow of string
+  | Unknown_literal of string * char
+  | Illegal_letrec_pat
+  | Illegal_letrec_expr
+  | Illegal_class_expr
+  | Empty_pattern
+  | Letop_type_clash of string * Ctype.Unification_trace.t
+  | Andop_type_clash of string * Ctype.Unification_trace.t
+  | Bindings_type_clash of Ctype.Unification_trace.t
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+(* merlin: deep copy types in errors, to keep them meaningful after
+   backtracking *)
+let deep_copy () =
+  let table = TypeHash.create 7 in
+  let rec copy ty =
+    let ty = repr ty in
+    try TypeHash.find table ty
+    with Not_found ->
+      let ty' = {ty with desc = ty.desc} in
+      TypeHash.add table ty ty';
+      let desc =
+        match ty.desc with
+        | Tvar _ | Tnil | Tunivar _ as desc -> desc
+        | Tvariant _ as desc -> (* fixme *) desc
+        | Tarrow (l,t1,t2,c) -> Tarrow (l, copy t1, copy t2, c)
+        | Ttuple tl -> Ttuple (List.map copy tl)
+        | Tconstr (p, tl, _) -> Tconstr (p, List.map copy tl, ref Mnil)
+        | Tobject (t1, r) ->
+          let r = match !r with
+            | None -> None
+            | Some (p,tl) -> Some (p, List.map copy tl)
+          in
+          Tobject (copy t1, ref r)
+        | Tfield (s,fk,t1,t2) -> Tfield (s, fk, copy t1, copy t2)
+        | Tpoly (t,tl) -> Tpoly (copy t, List.map copy tl)
+        | Tpackage (p,l,tl) -> Tpackage (p,l,List.map copy tl)
+        | Tlink _ | Tsubst _ -> assert false
+      in
+      ty'.desc <- desc;
+      ty'
+  in
+  copy
+
+let trace_copy ?(copy=deep_copy ()) tr =
+  Unification_trace.map_types copy tr
+
+let error (loc, env, err) =
+  let err = match err with
+    | Label_mismatch (li, trace) ->
+      Label_mismatch (li, trace_copy trace)
+    | Pattern_type_clash (trace, popt) ->
+      Pattern_type_clash (trace_copy trace, popt)
+    | Or_pattern_type_clash (i, trace) ->
+      Or_pattern_type_clash (i, trace_copy trace)
+    | Expr_type_clash (trace, ctx_opt, eopt) ->
+      Expr_type_clash (trace_copy trace, ctx_opt, eopt)
+    | Apply_non_function t ->
+      Apply_non_function (deep_copy () t)
+    | Apply_wrong_label (l, t) ->
+      Apply_wrong_label (l, deep_copy () t)
+    | Wrong_name (s1, t, s2, p, n, l) ->
+      Wrong_name (s1, { t with ty = deep_copy () t.ty }, s2, p, n, l)
+    | Undefined_method (t, s, l) ->
+      Undefined_method (deep_copy () t, s, l)
+    | Private_type t ->
+      Private_type (deep_copy () t)
+    | Private_label (li, t) ->
+      Private_label (li, deep_copy () t)
+    | Not_subtype (t1, t2) ->
+      let copy = deep_copy () in
+      Not_subtype (trace_copy ~copy t1, trace_copy ~copy t2)
+    | Coercion_failure (t1, t2, ts, b) ->
+      let copy = deep_copy () in
+      Coercion_failure (copy t1, copy t2, trace_copy ~copy ts, b)
+    | Too_many_arguments (b, t, ctx_opt) ->
+      Too_many_arguments (b, deep_copy () t, ctx_opt)
+    | Abstract_wrong_label (l, t, ctx_opt) ->
+      Abstract_wrong_label (l, deep_copy () t, ctx_opt)
+    | Scoping_let_module (s, t) ->
+      Scoping_let_module (s, deep_copy () t)
+    | Less_general (s, tr) ->
+      Less_general (s, trace_copy tr)
+    | Not_a_packed_module t ->
+      Not_a_packed_module (deep_copy () t)
+    | err -> err
+  in
+  Error (loc, env, err)
+
+(* Forward declaration, to be filled in by Typemod.type_module *)
+
+let type_module =
+  ref ((fun _env _md -> assert false) :
+       Env.t -> Parsetree.module_expr -> Typedtree.module_expr)
+
+(* Forward declaration, to be filled in by Typemod.type_open *)
+
+let type_open :
+  (?used_slot:bool ref -> override_flag -> Env.t -> Location.t ->
+   Longident.t loc -> Path.t * Env.t)
+    ref =
+  ref (fun ?used_slot:_ _ -> assert false)
+
+let type_open_decl :
+  (?used_slot:bool ref -> Env.t -> Parsetree.open_declaration
+   -> open_declaration * Types.signature * Env.t)
+    ref =
+  ref (fun ?used_slot:_ _ -> assert false)
+
+(* Forward declaration, to be filled in by Typemod.type_package *)
+
+let type_package =
+  ref (fun _ -> assert false)
+
+(* Forward declaration, to be filled in by Typeclass.class_structure *)
+let type_object =
+  ref (fun _env _s -> assert false :
+       Env.t -> Location.t -> Parsetree.class_structure ->
+         Typedtree.class_structure * Types.class_signature * string list)
+
+(*
+  Saving and outputting type information.
+  We keep these function names short, because they have to be
+  called each time we create a record of type [Typedtree.expression]
+  or [Typedtree.pattern] that will end up in the typed AST.
+*)
+let re node =
+  Cmt_format.add_saved_type (Cmt_format.Partial_expression node);
+  Stypes.record (Stypes.Ti_expr node);
+  node
+;;
+let rp node =
+  Cmt_format.add_saved_type (Cmt_format.Partial_pattern node);
+  Stypes.record (Stypes.Ti_pat node);
+  node
+;;
+
+
+type recarg =
+  | Allowed
+  | Required
+  | Rejected
+
+
+let mk_expected ?explanation ty = { ty; explanation; }
+
+let case lhs rhs =
+  {c_lhs = lhs; c_guard = None; c_rhs = rhs}
+
+(* Typing of constants *)
+
+let type_constant = function
+    Const_int _ -> instance Predef.type_int
+  | Const_char _ -> instance Predef.type_char
+  | Const_string _ -> instance Predef.type_string
+  | Const_float _ -> instance Predef.type_float
+  | Const_int32 _ -> instance Predef.type_int32
+  | Const_int64 _ -> instance Predef.type_int64
+  | Const_nativeint _ -> instance Predef.type_nativeint
+
+let constant : Parsetree.constant -> (Asttypes.constant, error) result =
+  function
+  | Pconst_integer (i,None) ->
+     begin
+       try Ok (Const_int (Misc.Int_literal_converter.int i))
+       with Failure _ -> Error (Literal_overflow "int")
+     end
+  | Pconst_integer (i,Some 'l') ->
+     begin
+       try Ok (Const_int32 (Misc.Int_literal_converter.int32 i))
+       with Failure _ -> Error (Literal_overflow "int32")
+     end
+  | Pconst_integer (i,Some 'L') ->
+     begin
+       try Ok (Const_int64 (Misc.Int_literal_converter.int64 i))
+       with Failure _ -> Error (Literal_overflow "int64")
+     end
+  | Pconst_integer (i,Some 'n') ->
+     begin
+       try Ok (Const_nativeint (Misc.Int_literal_converter.nativeint i))
+       with Failure _ -> Error (Literal_overflow "nativeint")
+     end
+  | Pconst_integer (i,Some c) -> Error (Unknown_literal (i, c))
+  | Pconst_char c -> Ok (Const_char c)
+  | Pconst_string (s,d) -> Ok (Const_string (s,d))
+  | Pconst_float (f,None)-> Ok (Const_float f)
+  | Pconst_float (f,Some c) -> Error (Unknown_literal (f, c))
+
+let constant_or_raise env loc cst =
+  match constant cst with
+  | Ok c -> c
+  | Error err -> raise (error (loc, env, err))
+
+(* Specific version of type_option, using newty rather than newgenty *)
+
+let type_option ty =
+  newty (Tconstr(Predef.path_option,[ty], ref Mnil))
+
+let mkexp exp_desc exp_type exp_loc exp_env =
+  { exp_desc; exp_type; exp_loc; exp_env; exp_extra = []; exp_attributes = [] }
+
+let option_none env ty loc =
+  let lid = Longident.Lident "None" in
+  let cnone = Env.find_ident_constructor Predef.ident_none env in
+  mkexp (Texp_construct(mknoloc lid, cnone, [])) ty loc env
+
+let option_some env texp =
+  let lid = Longident.Lident "Some" in
+  let csome = Env.find_ident_constructor Predef.ident_some env in
+  mkexp ( Texp_construct(mknoloc lid , csome, [texp]) )
+    (type_option texp.exp_type) texp.exp_loc texp.exp_env
+
+let extract_option_type env ty =
+  match expand_head env ty with {desc = Tconstr(path, [ty], _)}
+    when Path.same path Predef.path_option -> ty
+  | _ -> assert false
+
+let extract_concrete_record env ty =
+  match extract_concrete_typedecl env ty with
+    (p0, p, {type_kind=Type_record (fields, _)}) -> (p0, p, fields)
+  | _ -> raise Not_found
+
+let extract_concrete_variant env ty =
+  match extract_concrete_typedecl env ty with
+    (p0, p, {type_kind=Type_variant cstrs}) -> (p0, p, cstrs)
+  | (p0, p, {type_kind=Type_open}) -> (p0, p, [])
+  | _ -> raise Not_found
+
+let extract_label_names env ty =
+  try
+    let (_, _,fields) = extract_concrete_record env ty in
+    List.map (fun l -> l.Types.ld_id) fields
+  with Not_found ->
+    assert false
+
+(* Typing of patterns *)
+
+(* unification inside type_exp and type_expect *)
+let unify_exp_types loc env ty expected_ty =
+  (* Format.eprintf "@[%a@ %a@]@." Printtyp.raw_type_expr exp.exp_type
+    Printtyp.raw_type_expr expected_ty; *)
+  try
+    unify env ty expected_ty
+  with
+    Unify trace ->
+      raise(error(loc, env, Expr_type_clash(trace, None, None)))
+  | Tags(l1,l2) ->
+      raise(Typetexp.Error(loc, env, Typetexp.Variant_tags (l1, l2)))
+
+(* level at which to create the local type declarations *)
+let gadt_equations_level = ref None
+let get_gadt_equations_level () =
+  match !gadt_equations_level with
+    Some y -> y
+  | None -> assert false
+
+(* unification inside type_pat*)
+let unify_pat_types ?(refine=false) loc env ty ty' =
+  try
+    if refine then
+      unify_gadt ~equations_level:(get_gadt_equations_level ()) env ty ty'
+    else
+      unify !env ty ty'
+  with
+  | Unify trace ->
+      raise(error(loc, !env, Pattern_type_clash(trace, None)))
+  | Tags(l1,l2) ->
+      raise(Typetexp.Error(loc, !env, Typetexp.Variant_tags (l1, l2)))
+
+let unify_pat ?refine env pat expected_ty =
+  try unify_pat_types ?refine pat.pat_loc env pat.pat_type expected_ty
+  with Error (loc, env, Pattern_type_clash(trace, None)) ->
+    raise(Error(loc, env, Pattern_type_clash(trace, Some pat.pat_desc)))
+
+(* Creating new conjunctive types is not allowed when typing patterns *)
+(* make all Reither present in open variants *)
+let finalize_variant pat =
+  match pat.pat_desc with
+    Tpat_variant(tag, opat, r) ->
+      let row =
+        match expand_head pat.pat_env pat.pat_type with
+          {desc = Tvariant row} -> r := row; row_repr row
+        | _ -> assert false
+      in
+      begin match row_field tag row with
+      | Rabsent -> () (* assert false *)
+      | Reither (true, [], _, e) when not row.row_closed ->
+          set_row_field e (Rpresent None)
+      | Reither (false, ty::tl, _, e) when not row.row_closed ->
+          set_row_field e (Rpresent (Some ty));
+          begin match opat with None -> assert false
+          | Some pat ->
+              let env = ref pat.pat_env in
+              List.iter (unify_pat env pat) (ty::tl)
+          end
+      | Reither (c, _l, true, e) when not (row_fixed row) ->
+          set_row_field e (Reither (c, [], false, ref None))
+      | _ -> ()
+      end;
+      (* Force check of well-formedness   WHY? *)
+      (* unify_pat pat.pat_env pat
+        (newty(Tvariant{row_fields=[]; row_more=newvar(); row_closed=false;
+                        row_bound=(); row_fixed=false; row_name=None})); *)
+  | _ -> ()
+
+let has_variants p =
+  exists_pattern
+    (function {pat_desc=Tpat_variant _} -> true | _ -> false)
+    p
+
+(* pattern environment *)
+type pattern_variable =
+  {
+    pv_id: Ident.t;
+    pv_type: type_expr;
+    pv_loc: Location.t;
+    pv_as_var: bool;
+    pv_attributes: attributes;
+  }
+
+type module_variable =
+  string loc * Location.t
+
+let pattern_variables = ref ([] : pattern_variable list)
+let pattern_force = ref ([] : (unit -> unit) list)
+let pattern_scope = ref (None : Annot.ident option);;
+let allow_modules = ref false
+let module_variables = ref ([] : module_variable list)
+let reset_pattern scope allow =
+  pattern_variables := [];
+  pattern_force := [];
+  pattern_scope := scope;
+  allow_modules := allow;
+  module_variables := [];
+;;
+
+let maybe_add_pattern_variables_ghost loc_let env pv =
+  List.fold_right
+    (fun {pv_id; _} env ->
+       let name = Ident.name pv_id in
+       if Env.bound_value name env then env
+       else begin
+         Env.enter_unbound_value name
+           (Val_unbound_ghost_recursive loc_let) env
+       end
+    ) pv env
+
+let enter_variable ?(is_module=false) ?(is_as_variable=false) loc name ty
+    attrs =
+  if List.exists (fun {pv_id; _} -> Ident.name pv_id = name.txt)
+      !pattern_variables
+  then raise(error(loc, Env.empty, Multiply_bound_variable name.txt));
+  let id = Ident.create_local name.txt in
+  pattern_variables :=
+    {pv_id = id;
+     pv_type = ty;
+     pv_loc = loc;
+     pv_as_var = is_as_variable;
+     pv_attributes = attrs} :: !pattern_variables;
+  if is_module then begin
+    (* Note: unpack patterns enter a variable of the same name *)
+    if not !allow_modules then
+      raise (error (loc, Env.empty, Modules_not_allowed));
+    module_variables := (name, loc) :: !module_variables
+  end else begin
+    (* moved to genannot *)
+    Option.iter
+      (fun s -> Stypes.record (Stypes.An_ident (name.loc, name.txt, s)))
+      !pattern_scope
+  end;
+  id
+
+let sort_pattern_variables vs =
+  List.sort
+    (fun {pv_id = x; _} {pv_id = y; _} ->
+      Stdlib.compare (Ident.name x) (Ident.name y))
+    vs
+
+let enter_orpat_variables loc env  p1_vs p2_vs =
+  (* unify_vars operate on sorted lists *)
+
+  let p1_vs = sort_pattern_variables p1_vs
+  and p2_vs = sort_pattern_variables p2_vs in
+
+  let rec unify_vars p1_vs p2_vs =
+    let vars vs = List.map (fun {pv_id; _} -> pv_id) vs in
+    match p1_vs, p2_vs with
+      | {pv_id = x1; pv_type = t1; _}::rem1, {pv_id = x2; pv_type = t2; _}::rem2
+        when Ident.equal x1 x2 ->
+          if x1==x2 then
+            unify_vars rem1 rem2
+          else begin
+            begin try
+              unify_var env (newvar ()) t1;
+              unify env t1 t2
+            with
+            | Unify trace ->
+                raise(error(loc, env, Or_pattern_type_clash(x1, trace)))
+            end;
+          (x2,x1)::unify_vars rem1 rem2
+          end
+      | [],[] -> []
+      | {pv_id; _}::_, [] | [],{pv_id; _}::_ ->
+          raise (error (loc, env, Orpat_vars (pv_id, [])))
+      | {pv_id = x; _}::_, {pv_id = y; _}::_ ->
+          let err =
+            if Ident.name x < Ident.name y
+            then Orpat_vars (x, vars p2_vs)
+            else Orpat_vars (y, vars p1_vs) in
+          raise (error (loc, env, err)) in
+  unify_vars p1_vs p2_vs
+
+let rec build_as_type env p =
+  match p.pat_desc with
+    Tpat_alias(p1,_, _) -> build_as_type env p1
+  | Tpat_tuple pl ->
+      let tyl = List.map (build_as_type env) pl in
+      newty (Ttuple tyl)
+  | Tpat_construct(_, cstr, pl) ->
+      let keep = cstr.cstr_private = Private || cstr.cstr_existentials <> [] in
+      if keep then p.pat_type else
+      let tyl = List.map (build_as_type env) pl in
+      let ty_args, ty_res = instance_constructor cstr in
+      List.iter2 (fun (p,ty) -> unify_pat env {p with pat_type = ty})
+        (List.combine pl tyl) ty_args;
+      ty_res
+  | Tpat_variant(l, p', _) ->
+      let ty = Option.map (build_as_type env) p' in
+      newty (Tvariant{row_fields=[l, Rpresent ty]; row_more=newvar();
+                      row_bound=(); row_name=None;
+                      row_fixed=None; row_closed=false})
+  | Tpat_record (lpl,_) ->
+      let lbl = snd3 (List.hd lpl) in
+      if lbl.lbl_private = Private then p.pat_type else
+      let ty = newvar () in
+      let ppl = List.map (fun (_, l, p) -> l.lbl_pos, p) lpl in
+      let do_label lbl =
+        let _, ty_arg, ty_res = instance_label false lbl in
+        unify_pat env {p with pat_type = ty} ty_res;
+        let refinable =
+          lbl.lbl_mut = Immutable && List.mem_assoc lbl.lbl_pos ppl &&
+          match (repr lbl.lbl_arg).desc with Tpoly _ -> false | _ -> true in
+        if refinable then begin
+          let arg = List.assoc lbl.lbl_pos ppl in
+          unify_pat env {arg with pat_type = build_as_type env arg} ty_arg
+        end else begin
+          let _, ty_arg', ty_res' = instance_label false lbl in
+          unify !env ty_arg ty_arg';
+          unify_pat env p ty_res'
+        end in
+      Array.iter do_label lbl.lbl_all;
+      ty
+  | Tpat_or(p1, p2, row) ->
+      begin match row with
+        None ->
+          let ty1 = build_as_type env p1 and ty2 = build_as_type env p2 in
+          unify_pat env {p2 with pat_type = ty2} ty1;
+          ty1
+      | Some row ->
+          let row = row_repr row in
+          newty (Tvariant{row with row_closed=false; row_more=newvar()})
+      end
+  | Tpat_any | Tpat_var _ | Tpat_constant _
+  | Tpat_array _ | Tpat_lazy _ | Tpat_exception _ -> p.pat_type
+
+let build_or_pat env loc lid =
+  let path, decl = Env.lookup_type ~loc:lid.loc lid.txt env in
+  let tyl = List.map (fun _ -> newvar()) decl.type_params in
+  let row0 =
+    let ty = expand_head env (newty(Tconstr(path, tyl, ref Mnil))) in
+    match ty.desc with
+      Tvariant row when static_row row -> row
+    | _ -> raise(error(lid.loc, env, Not_a_variant_type lid.txt))
+  in
+  let pats, fields =
+    List.fold_left
+      (fun (pats,fields) (l,f) ->
+        match row_field_repr f with
+          Rpresent None ->
+            (l,None) :: pats,
+            (l, Reither(true,[], true, ref None)) :: fields
+        | Rpresent (Some ty) ->
+            (l, Some {pat_desc=Tpat_any; pat_loc=Location.none; pat_env=env;
+                      pat_type=ty; pat_extra=[]; pat_attributes=[]})
+            :: pats,
+            (l, Reither(false, [ty], true, ref None)) :: fields
+        | _ -> pats, fields)
+      ([],[]) (row_repr row0).row_fields in
+  let row =
+    { row_fields = List.rev fields; row_more = newvar(); row_bound = ();
+      row_closed = false; row_fixed = None; row_name = Some (path, tyl) }
+  in
+  let ty = newty (Tvariant row) in
+  let gloc = {loc with Location.loc_ghost=true} in
+  let row' = ref {row with row_more=newvar()} in
+  let pats =
+    List.map
+      (fun (l,p) ->
+        {pat_desc=Tpat_variant(l,p,row'); pat_loc=gloc;
+         pat_env=env; pat_type=ty; pat_extra=[]; pat_attributes=[]})
+      pats
+  in
+  match pats with
+    [] ->
+      (* empty polymorphic variants: not possible with the concrete language
+         but valid at the ast level *)
+      raise(error(lid.loc, env, Not_a_variant_type lid.txt))
+  | pat :: pats ->
+      let r =
+        List.fold_left
+          (fun pat pat0 ->
+            {pat_desc=Tpat_or(pat0,pat,Some row0); pat_extra=[];
+             pat_loc=gloc; pat_env=env; pat_type=ty; pat_attributes=[]})
+          pat pats in
+      (path, rp { r with pat_loc = loc },ty)
+
+let split_cases env cases =
+  let add_case lst case = function
+    | None -> lst
+    | Some c_lhs -> { case with c_lhs } :: lst
+  in
+  List.fold_right (fun ({ c_lhs; c_guard } as case) (vals, exns) ->
+    match split_pattern c_lhs with
+    | Some _, Some _ when c_guard <> None ->
+      raise (error (c_lhs.pat_loc, env,
+                    Mixed_value_and_exception_patterns_under_guard))
+    | vp, ep -> add_case vals case vp, add_case exns case ep
+  ) cases ([], [])
+
+(* Type paths *)
+
+let rec expand_path env p =
+  let decl =
+    try Some (Env.find_type p env) with Not_found -> None
+  in
+  match decl with
+    Some {type_manifest = Some ty} ->
+      begin match repr ty with
+        {desc=Tconstr(p,_,_)} -> expand_path env p
+      | _ -> assert false
+      end
+  | _ ->
+      let p' = Env.normalize_type_path None env p in
+      if Path.same p p' then p else expand_path env p'
+
+let compare_type_path env tpath1 tpath2 =
+  Path.same (expand_path env tpath1) (expand_path env tpath2)
+
+(* Records *)
+let label_of_kind kind =
+  if kind = "record" then "field" else "constructor"
+
+module NameChoice(Name : sig
+  type t
+  type usage
+  val type_kind: string
+  val get_name: t -> string
+  val get_type: t -> type_expr
+  val lookup_all_from_type:
+    Location.t -> usage -> Path.t -> Env.t -> (t * (unit -> unit)) list
+  val in_env: t -> bool
+end) = struct
+  open Name
+
+  let get_type_path d =
+    match (repr (get_type d)).desc with
+    | Tconstr(p, _, _) -> p
+    | _ -> assert false
+
+  let lookup_from_type env tpath usage lid =
+    let descrs = lookup_all_from_type lid.loc usage tpath env in
+    match lid.txt with
+    | Longident.Lident s -> begin
+        match
+          List.find (fun (nd, _) -> get_name nd = s) descrs
+        with
+        | descr, use ->
+            use ();
+            descr
+        | exception Not_found ->
+            let names = List.map (fun (nd, _) -> get_name nd) descrs in
+            raise (error (lid.loc, env,
+                          Wrong_name ("", mk_expected (newvar ()),
+                                      type_kind, tpath, s, names)))
+      end
+    | _ -> raise Not_found
+
+  let rec unique eq acc = function
+      [] -> List.rev acc
+    | x :: rem ->
+        if List.exists (eq x) acc then unique eq acc rem
+        else unique eq (x :: acc) rem
+
+  let ambiguous_types env lbl others =
+    let tpath = get_type_path lbl in
+    let others =
+      List.map (fun (lbl, _) -> get_type_path lbl) others in
+    let tpaths = unique (compare_type_path env) [tpath] others in
+    match tpaths with
+      [_] -> []
+    | _ -> let open Printtyp in
+        wrap_printing_env ~error:true env (fun () ->
+            reset(); strings_of_paths Type tpaths)
+
+  let disambiguate_by_type env tpath lbls =
+    match lbls with
+    | (Error _ : _ result) -> raise Not_found
+    | Ok lbls ->
+        let check_type (lbl, _) =
+          let lbl_tpath = get_type_path lbl in
+          compare_type_path env tpath lbl_tpath
+        in
+        List.find check_type lbls
+
+  let disambiguate ?(warn=Location.prerr_warning) ?scope
+                   usage lid env opath lbls =
+    let scope = match scope with None -> lbls | Some l -> l in
+    let lbl = match opath with
+      None ->
+        begin match lbls with
+        | (Error(loc', env', err) : _ result) ->
+            Env.lookup_error loc' env' err
+        | Ok [] -> assert false
+        | Ok((lbl, use) :: rest) ->
+            use ();
+            Printtyp.Conflicts.reset ();
+            let paths = ambiguous_types env lbl rest in
+            let expansion =
+              Format.asprintf "%t" Printtyp.Conflicts.print_explanations in
+            if paths <> [] then
+              warn lid.loc
+                (Warnings.Ambiguous_name ([Longident.last lid.txt],
+                                          paths, false, expansion));
+            lbl
+        end
+    | Some(tpath0, tpath, pr) ->
+        let warn_pr () =
+          let label = label_of_kind type_kind in
+          warn lid.loc
+            (Warnings.Not_principal
+               ("this type-based " ^ label ^ " disambiguation"))
+        in
+        try
+          let lbl, use = disambiguate_by_type env tpath scope in
+          use ();
+          if not pr then begin
+            (* Check if non-principal type is affecting result *)
+            match lbls with
+            | (Error _ : _ result) | Ok [] -> warn_pr ()
+            | Ok ((lbl', _use') :: rest) ->
+                let lbl_tpath = get_type_path lbl' in
+                if not (compare_type_path env tpath lbl_tpath) then warn_pr ()
+                else
+                  Printtyp.Conflicts.reset ();
+                  let paths = ambiguous_types env lbl rest in
+                  let expansion =
+                    Format.asprintf "%t"
+                      Printtyp.Conflicts.print_explanations in
+                  if paths <> [] then
+                    warn lid.loc
+                      (Warnings.Ambiguous_name ([Longident.last lid.txt],
+                                                paths, false, expansion))
+          end;
+          lbl
+        with Not_found -> try
+          let lbl = lookup_from_type env tpath usage lid in
+          if in_env lbl then
+          begin
+          let s =
+            Printtyp.wrap_printing_env ~error:true env
+              (fun () -> Printtyp.string_of_path tpath) in
+          warn lid.loc
+            (Warnings.Name_out_of_scope (s, [Longident.last lid.txt], false));
+          end;
+          if not pr then warn_pr ();
+          lbl
+        with Not_found ->
+          match lbls with
+          | (Error(loc', env', err) : _ result) ->
+              Env.lookup_error loc' env' err
+          | Ok lbls ->
+              let tp = (tpath0, expand_path env tpath) in
+              let tpl =
+                List.map
+                  (fun (lbl, _) ->
+                     let tp0 = get_type_path lbl in
+                     let tp = expand_path env tp0 in
+                     (tp0, tp))
+                  lbls
+              in
+              raise (error (lid.loc, env,
+                            Name_type_mismatch (type_kind, lid.txt, tp, tpl)))
+    in
+    if in_env lbl then
+    begin match scope with
+    | Ok ((lab1,_)::_) when lab1 == lbl -> ()
+    | _ ->
+        Location.prerr_warning lid.loc
+          (Warnings.Disambiguated_name(get_name lbl))
+    end;
+    lbl
+end
+
+let wrap_disambiguate kind ty f x =
+  try f x with Error (loc, env, Wrong_name ("",_,tk,tp,name,valid_names)) ->
+    raise (error (loc, env, Wrong_name (kind,ty,tk,tp,name,valid_names)))
+
+module Label = NameChoice (struct
+  type t = label_description
+  type usage = unit
+  let type_kind = "record"
+  let get_name lbl = lbl.lbl_name
+  let get_type lbl = lbl.lbl_res
+  let lookup_all_from_type loc () path env =
+    Env.lookup_all_labels_from_type ~loc path env
+  let in_env lbl =
+    match lbl.lbl_repres with
+    | Record_regular | Record_float | Record_unboxed false -> true
+    | Record_unboxed true | Record_inlined _ | Record_extension _ -> false
+end)
+
+let disambiguate_label_by_ids keep closed ids labels =
+  let check_ids (lbl, _) =
+    let lbls = Hashtbl.create 8 in
+    Array.iter (fun lbl -> Hashtbl.add lbls lbl.lbl_name ()) lbl.lbl_all;
+    List.for_all (Hashtbl.mem lbls) ids
+  and check_closed (lbl, _) =
+    (not closed || List.length ids = Array.length lbl.lbl_all)
+  in
+  let labels' = List.filter check_ids labels in
+  if keep && labels' = [] then (false, labels) else
+  let labels'' = List.filter check_closed labels' in
+  if keep && labels'' = [] then (false, labels') else (true, labels'')
+
+(* Only issue warnings once per record constructor/pattern *)
+let disambiguate_lid_a_list loc closed env opath lid_a_list =
+  let ids = List.map (fun (lid, _) -> Longident.last lid.txt) lid_a_list in
+  let w_pr = ref false and w_amb = ref []
+  and w_scope = ref [] and w_scope_ty = ref "" in
+  let warn loc msg =
+    let open Warnings in
+    match msg with
+    | Not_principal _ -> w_pr := true
+    | Ambiguous_name([s], l, _, ex) -> w_amb := (s, l, ex) :: !w_amb
+    | Name_out_of_scope(ty, [s], _) ->
+        w_scope := s :: !w_scope; w_scope_ty := ty
+    | _ -> Location.prerr_warning loc msg
+  in
+  let process_label lid =
+    (* Strategy for each field:
+       * collect all the labels in scope for that name
+       * if the type is known and principal, just eventually warn
+         if the real label was not in scope
+       * fail if there is no known type and no label found
+       * otherwise use other fields to reduce the list of candidates
+       * if there is no known type reduce it incrementally, so that
+         there is still at least one candidate (for error message)
+       * if the reduced list is valid, call Label.disambiguate
+     *)
+    let scope = Env.lookup_all_labels ~loc:lid.loc lid.txt env in
+    match opath, scope with
+    | None, Error(loc, env, err) ->
+        Env.lookup_error loc env err
+    | Some _, Error _ ->
+        Label.disambiguate () lid env opath scope ~warn ~scope
+    | _, Ok lbls ->
+       let (ok, lbls) =
+         match opath with
+         | Some (_, _, true) ->
+             (true, lbls) (* disambiguate only checks scope *)
+         | _  -> disambiguate_label_by_ids (opath=None) closed ids lbls
+       in
+       if ok then Label.disambiguate () lid env opath (Ok lbls) ~warn ~scope
+       else fst (List.hd lbls) (* will fail later *)
+  in
+  let lbl_a_list =
+    List.map (fun (lid,a) -> lid, process_label lid, a) lid_a_list in
+  if !w_pr then
+    Location.prerr_warning loc
+      (Warnings.Not_principal "this type-based record disambiguation")
+  else begin
+    match List.rev !w_amb with
+      (_,types,ex)::_ as amb ->
+        let paths =
+          List.map (fun (_,lbl,_) -> Label.get_type_path lbl) lbl_a_list in
+        let path = List.hd paths in
+        let fst3 (x,_,_) = x in
+        if List.for_all (compare_type_path env path) (List.tl paths) then
+          Location.prerr_warning loc
+            (Warnings.Ambiguous_name (List.map fst3 amb, types, true, ex))
+        else
+          List.iter
+            (fun (s,l,ex) -> Location.prerr_warning loc
+                (Warnings.Ambiguous_name ([s],l,false, ex)))
+            amb
+    | _ -> ()
+  end;
+  if !w_scope <> [] then
+    Location.prerr_warning loc
+      (Warnings.Name_out_of_scope (!w_scope_ty, List.rev !w_scope, true));
+  lbl_a_list
+
+let rec find_record_qual = function
+  | [] -> None
+  | ({ txt = Longident.Ldot (modname, _) }, _) :: _ -> Some modname
+  | _ :: rest -> find_record_qual rest
+
+let map_fold_cont f xs k =
+  List.fold_right (fun x k ys -> f x (fun y -> k (y :: ys)))
+    xs (fun ys -> k (List.rev ys)) []
+
+let type_label_a_list ?labels loc closed env type_lbl_a opath lid_a_list k =
+  let lbl_a_list =
+    match lid_a_list, labels with
+      ({txt=Longident.Lident s}, _)::_, Some labels when Hashtbl.mem labels s ->
+        (* Special case for rebuilt syntax trees *)
+        List.map
+          (function lid, a -> match lid.txt with
+            Longident.Lident s -> lid, Hashtbl.find labels s, a
+          | _ -> assert false)
+          lid_a_list
+    | _ ->
+        let lid_a_list =
+          match find_record_qual lid_a_list with
+            None -> lid_a_list
+          | Some modname ->
+              List.map
+                (fun (lid, a as lid_a) ->
+                  match lid.txt with Longident.Lident s ->
+                    {lid with txt=Longident.Ldot (modname, s)}, a
+                  | _ -> lid_a)
+                lid_a_list
+        in
+        disambiguate_lid_a_list loc closed env opath lid_a_list
+  in
+  (* Invariant: records are sorted in the typed tree *)
+  let lbl_a_list =
+    List.sort
+      (fun (_,lbl1,_) (_,lbl2,_) -> compare lbl1.lbl_pos lbl2.lbl_pos)
+      lbl_a_list
+  in
+  map_fold_cont type_lbl_a lbl_a_list k
+;;
+
+(* Checks over the labels mentioned in a record pattern:
+   no duplicate definitions (error); properly closed (warning) *)
+
+let check_recordpat_labels loc lbl_pat_list closed =
+  match lbl_pat_list with
+  | [] -> ()                            (* should not happen *)
+  | (_, label1, _) :: _ ->
+      let all = label1.lbl_all in
+      let defined = Array.make (Array.length all) false in
+      let check_defined (_, label, _) =
+        if defined.(label.lbl_pos)
+        then raise(error(loc, Env.empty, Label_multiply_defined label.lbl_name))
+        else defined.(label.lbl_pos) <- true in
+      List.iter check_defined lbl_pat_list;
+      if closed = Closed
+      && Warnings.is_active (Warnings.Non_closed_record_pattern "")
+      then begin
+        let undefined = ref [] in
+        for i = 0 to Array.length all - 1 do
+          if not defined.(i) then undefined := all.(i).lbl_name :: !undefined
+        done;
+        if !undefined <> [] then begin
+          let u = String.concat ", " (List.rev !undefined) in
+          Location.prerr_warning loc (Warnings.Non_closed_record_pattern u)
+        end
+      end
+
+(* Constructors *)
+
+module Constructor = NameChoice (struct
+  type t = constructor_description
+  type usage = Env.constructor_usage
+  let type_kind = "variant"
+  let get_name cstr = cstr.cstr_name
+  let get_type cstr = cstr.cstr_res
+  let lookup_all_from_type loc usage path env =
+    Env.lookup_all_constructors_from_type ~loc usage path env
+  let in_env _ = true
+end)
+
+(* unification of a type with a tconstr with
+   freshly created arguments *)
+let unify_head_only ~refine loc env ty constr =
+  let (_, ty_res) = instance_constructor constr in
+  let ty_res = repr ty_res in
+  match ty_res.desc with
+  | Tconstr(p,args,m) ->
+      ty_res.desc <- Tconstr(p,List.map (fun _ -> newvar ()) args,m);
+      enforce_constraints !env ty_res;
+      unify_pat_types ~refine loc env ty_res ty
+  | _ -> assert false
+
+(* Typing of patterns *)
+
+(* "half typed" cases are produced in [type_cases] when we've just typechecked
+   the pattern but haven't type-checked the body yet.
+   At this point we might have added some type equalities to the environment,
+   but haven't yet added identifiers bound by the pattern. *)
+type half_typed_case =
+  { typed_pat: pattern;
+    pat_type_for_unif: type_expr;
+    untyped_case: Parsetree.case;
+    branch_env: Env.t;
+    pat_vars: pattern_variable list;
+    unpacks: module_variable list;
+    contains_gadt: bool; }
+
+let rec has_literal_pattern p = match p.ppat_desc with
+  | Ppat_constant _
+  | Ppat_interval _ ->
+     true
+  | Ppat_any
+  | Ppat_variant (_, None)
+  | Ppat_construct (_, None)
+  | Ppat_type _
+  | Ppat_var _
+  | Ppat_unpack _
+  | Ppat_extension _ ->
+     false
+  | Ppat_exception p
+  | Ppat_variant (_, Some p)
+  | Ppat_construct (_, Some p)
+  | Ppat_constraint (p, _)
+  | Ppat_alias (p, _)
+  | Ppat_lazy p
+  | Ppat_open (_, p) ->
+     has_literal_pattern p
+  | Ppat_tuple ps
+  | Ppat_array ps ->
+     List.exists has_literal_pattern ps
+  | Ppat_record (ps, _) ->
+     List.exists (fun (_,p) -> has_literal_pattern p) ps
+  | Ppat_or (p, q) ->
+     has_literal_pattern p || has_literal_pattern q
+
+let check_scope_escape loc env level ty =
+  try Ctype.check_scope_escape env level ty
+  with Unify trace ->
+    raise(error(loc, env, Pattern_type_clash(trace, None)))
+
+type pattern_checking_mode =
+  | Normal
+  (** We are checking user code. *)
+  | Counter_example of counter_example_checking_info
+  (** In [Counter_example] mode, we are checking a counter-example
+      candidate produced by Parmatch. This is a syntactic pattern that
+      represents a set of values by using or-patterns (p_1 | ... | p_n)
+      to enumerate all alternatives in the counter-example
+      search. These or-patterns occur at every choice point, possibly
+      deep inside the pattern.
+
+      Parmatch does not use type information, so this pattern may
+      exhibit two issues:
+      - some parts of the pattern may be ill-typed due to GADTs, and
+      - some wildcard patterns may not match any values: their type is
+        empty.
+
+      The aim of [type_pat] in the [Counter_example] mode is to refine
+      this syntactic pattern into a well-typed pattern, and ensure
+      that it matches at least one concrete value.
+      - It filters ill-typed branches of or-patterns.
+        (see {!splitting_mode} below)
+      - It tries to check that wildcard patterns are non-empty.
+        (see {!explosion_fuel})
+  *)
+
+and counter_example_checking_info = {
+    explosion_fuel: int;
+    splitting_mode: splitting_mode;
+    constrs: (string, Types.constructor_description) Hashtbl.t;
+    labels: (string, Types.label_description) Hashtbl.t;
+  }
+(**
+    [explosion_fuel] controls the checking of wildcard patterns.  We
+    eliminate potentially-empty wildcard patterns by exploding them
+    into concrete sub-patterns, for example (K1 _ | K2 _) or
+    { l1: _; l2: _ }. [explosion_fuel] is the depth limit on wildcard
+    explosion. Such depth limit is required to avoid non-termination
+    and compilation-time blowups.
+
+    [splitting_mode] controls the handling of or-patterns.  In
+    [Counter_example] mode, we only need to select one branch that
+    leads to a well-typed pattern. Checking all branches is expensive,
+    we use different search strategies (see {!splitting_mode}) to
+    reduce the number of explored alternatives.
+
+    [constrs] and [labels] contain metadata produced by [Parmatch] to
+    type-check the given syntactic pattern. [Parmatch] produces
+    counter-examples by turning typed patterns into
+    [Parsetree.pattern]. In this process, constructor and label paths
+    are lost, and are replaced by generated strings. [constrs] and
+    [labels] map those synthetic names back to the typed descriptions
+    of the original names.
+ *)
+
+(** Due to GADT constraints, an or-pattern produced within
+    a counter-example may have ill-typed branches. Consider for example
+
+      type _ tag = Int : int tag | Bool : bool tag
+
+    then [Parmatch] will propose the or-pattern [Int | Bool] whenever
+    a pattern of type [tag] is required to form a counter-example. For
+    example, a function expects a (int tag option) and only [None] is
+    handled by the user-written pattern. [Some (Int | Bool)] is not
+    well-typed in this context, only the sub-pattern [Some Int] is.
+    In this example, the expected type coming from the context
+    suffices to know which or-pattern branch must be chosen.
+
+    In the general case, choosing a branch can have non-local effects
+    on the typability of the term. For example, consider a tuple type
+    ['a tag * ...'a...], where the first component is a GADT.  All
+    constructor choices for this GADT lead to a well-typed branch in
+    isolation (['a] is unconstrained), but choosing one of them adds
+    a constraint on ['a] that may make the other tuple elements
+    ill-typed.
+
+    In general, after choosing each possible branch of the or-pattern,
+    [type_pat] has to check the rest of the pattern to tell if this
+    choice leads to a well-typed term. This may lead to an explosion
+    of typing/search work -- the rest of the term may in turn contain
+    alternatives.
+
+    We use careful strategies to try to limit counterexample-checking
+    time; [splitting_mode] represents those strategies.
+*)
+and splitting_mode =
+  | Backtrack_or
+  (** Always backtrack in or-patterns.
+
+      [Backtrack_or] selects a single alternative from an or-pattern
+      by using backtracking, trying to choose each branch in turn, and
+      to complete it into a valid sub-pattern. We call this
+      "splitting" the or-pattern.
+
+      We use this mode when looking for unused patterns or sub-patterns,
+      in particular to check a refutation clause (p -> .).
+    *)
+  | Refine_or of { inside_nonsplit_or: bool; }
+  (** Only backtrack when needed.
+
+     [Refine_or] tries another approach for refining or-pattern.
+
+     Instead of always splitting each or-pattern, It first attempts to
+     find branches that do not introduce new constraints (because they
+     do not contain GADT constructors). Those branches are such that,
+     if they fail, all other branches will fail.
+
+     If we find one such branch, we attempt to complete the subpattern
+     (checking what's outside the or-pattern), ignoring other
+     branches -- we never consider another branch choice again. If all
+     branches are constrained, it falls back to splitting the
+     or-pattern.
+
+     We use this mode when checking exhaustivity of pattern matching.
+    *)
+
+(** This exception is only used internally within [type_pat_aux], to jump
+   back to the parent or-pattern in the [Refine_or] strategy.
+
+   Such a parent exists precisely when [inside_nonsplit_or = true];
+   it's an invariant that we always setup an exception handler for
+   [Need_backtrack] when we set this flag. *)
+ exception Need_backtrack
+
+(** Remember current typing state for backtracking.
+   No variable information, as we only backtrack on
+   patterns without variables (cf. assert statements). *)
+type state =
+ { snapshot: Btype.snapshot;
+   levels: Ctype.levels;
+   env: Env.t; }
+let save_state env =
+  { snapshot = Btype.snapshot ();
+    levels = Ctype.save_levels ();
+    env = !env; }
+let set_state s env =
+  Btype.backtrack s.snapshot;
+  Ctype.set_levels s.levels;
+  env := s.env
+
+(** Find the first alternative in the tree of or-patterns for which
+   [f] does not raise an error. If all fail, the last error is
+   propagated *)
+let rec find_valid_alternative f pat =
+  match pat.ppat_desc with
+  | Ppat_or(p1,p2) ->
+      (try find_valid_alternative f p1
+       with Error _ -> find_valid_alternative f p2)
+  | _ -> f pat
+
+let no_explosion = function
+  | Normal -> Normal
+  | Counter_example info ->
+     Counter_example { info with explosion_fuel = 0 }
+
+let get_splitting_mode = function
+  | Normal -> None
+  | Counter_example {splitting_mode} -> Some splitting_mode
+
+let enter_nonsplit_or mode = match mode with
+  | Normal -> Normal
+  | Counter_example info ->
+     let splitting_mode = match info.splitting_mode with
+       | Backtrack_or ->
+          (* in Backtrack_or mode, or-patterns are always split *)
+          assert false
+       | Refine_or _ ->
+          Refine_or {inside_nonsplit_or = true}
+     in Counter_example { info with splitting_mode }
+
+let rec type_pat ?(exception_allowed=false) ~no_existentials ~mode
+    ~env sp expected_ty k =
+  Builtin_attributes.warning_scope sp.ppat_attributes
+    (fun () ->
+       type_pat_aux ~exception_allowed ~no_existentials ~mode
+         ~env sp expected_ty k
+    )
+
+and type_pat_aux ~exception_allowed ~no_existentials ~mode
+      ~env sp expected_ty k =
+  let type_pat ?(exception_allowed=false) ?(mode=mode) ?(env=env) =
+    type_pat ~exception_allowed ~no_existentials ~mode ~env
+  in
+  let loc = sp.ppat_loc in
+  let refine = match mode with Normal -> false | Counter_example _ -> true in
+  let rup k x =
+    if mode = Normal then (ignore (rp x));
+    unify_pat ~refine env x (instance expected_ty);
+    k x
+  in
+  let rp k x : pattern = if mode = Normal then k (rp x) else k x in
+  let construction_not_used_in_counterexamples = (mode = Normal) in
+  let must_backtrack_on_gadt = match get_splitting_mode mode with
+    | None -> false
+    | Some Backtrack_or -> false
+    | Some (Refine_or {inside_nonsplit_or}) -> inside_nonsplit_or
+  in
+  match sp.ppat_desc with
+    Ppat_any ->
+      let k' d = rp k {
+        pat_desc = d;
+        pat_loc = loc; pat_extra=[];
+        pat_type = instance expected_ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env }
+      in
+      begin match mode with
+      | Normal -> k' Tpat_any
+      | Counter_example {explosion_fuel; _} when explosion_fuel <= 0 ->
+          k' Tpat_any
+      | Counter_example ({explosion_fuel; _} as info) ->
+         begin match Parmatch.ppat_of_type !env expected_ty with
+         | exception Parmatch.Empty -> raise (Error (loc, !env, Empty_pattern))
+         | (sp, constrs, labels) ->
+            if sp.ppat_desc = Parsetree.Ppat_any then k' Tpat_any else
+            if must_backtrack_on_gadt then raise Need_backtrack else
+            let explosion_fuel =
+              match sp.ppat_desc with
+                Parsetree.Ppat_or _ -> explosion_fuel - 5
+              | _ -> explosion_fuel - 1
+            in
+            let mode =
+              Counter_example { info with explosion_fuel; constrs; labels }
+            in
+            type_pat ~mode sp expected_ty k
+         end
+      end
+  | Ppat_var name ->
+      let ty = instance expected_ty in
+      let id = (* PR#7330 *)
+        if name.txt = "*extension*" then
+          Ident.create_local name.txt
+        else
+          enter_variable loc name ty sp.ppat_attributes
+      in
+      rp k {
+        pat_desc = Tpat_var (id, name);
+        pat_loc = loc; pat_extra=[];
+        pat_type = ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env }
+  | Ppat_unpack name ->
+      assert construction_not_used_in_counterexamples;
+      let t = instance expected_ty in
+      begin match name.txt with
+      | None ->
+          rp k {
+            pat_desc = Tpat_any;
+            pat_loc = sp.ppat_loc;
+            pat_extra=[Tpat_unpack, name.loc, sp.ppat_attributes];
+            pat_type = t;
+            pat_attributes = [];
+            pat_env = !env }
+      | Some s ->
+          let v = { name with txt = s } in
+          let id = enter_variable loc v t ~is_module:true sp.ppat_attributes in
+          rp k {
+            pat_desc = Tpat_var (id, v);
+            pat_loc = sp.ppat_loc;
+            pat_extra=[Tpat_unpack, loc, sp.ppat_attributes];
+            pat_type = t;
+            pat_attributes = [];
+            pat_env = !env }
+      end
+  | Ppat_constraint(
+      {ppat_desc=Ppat_var name; ppat_loc=lloc; ppat_attributes = attrs},
+      ({ptyp_desc=Ptyp_poly _} as sty)) ->
+      (* explicitly polymorphic type *)
+      assert construction_not_used_in_counterexamples;
+      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
+      let ty = cty.ctyp_type in
+      unify_pat_types ~refine lloc env ty (instance expected_ty);
+      pattern_force := force :: !pattern_force;
+      begin match ty.desc with
+      | Tpoly (body, tyl) ->
+          begin_def ();
+          let _, ty' = instance_poly ~keep_names:true false tyl body in
+          end_def ();
+          generalize ty';
+          let id = enter_variable lloc name ty' attrs in
+          rp k {
+            pat_desc = Tpat_var (id, name);
+            pat_loc = lloc;
+            pat_extra = [Tpat_constraint cty, loc, sp.ppat_attributes];
+            pat_type = ty;
+            pat_attributes = [];
+            pat_env = !env
+          }
+      | _ -> assert false
+      end
+  | Ppat_alias(sq, name) ->
+      assert construction_not_used_in_counterexamples;
+      type_pat sq expected_ty (fun q ->
+        begin_def ();
+        let ty_var = build_as_type env q in
+        end_def ();
+        generalize ty_var;
+        let id =
+          enter_variable ~is_as_variable:true loc name ty_var sp.ppat_attributes
+        in
+        rp k {
+          pat_desc = Tpat_alias(q, id, name);
+          pat_loc = loc; pat_extra=[];
+          pat_type = q.pat_type;
+          pat_attributes = sp.ppat_attributes;
+          pat_env = !env })
+  | Ppat_constant cst ->
+      let cst = constant_or_raise !env loc cst in
+      rup k {
+        pat_desc = Tpat_constant cst;
+        pat_loc = loc; pat_extra=[];
+        pat_type = type_constant cst;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env }
+  | Ppat_interval (Pconst_char c1, Pconst_char c2) ->
+      let open Ast_helper.Pat in
+      let gloc = {loc with Location.loc_ghost=true} in
+      let rec loop c1 c2 =
+        if c1 = c2 then constant ~loc:gloc (Pconst_char c1)
+        else
+          or_ ~loc:gloc
+            (constant ~loc:gloc (Pconst_char c1))
+            (loop (Char.chr(Char.code c1 + 1)) c2)
+      in
+      let p = if c1 <= c2 then loop c1 c2 else loop c2 c1 in
+      let p = {p with ppat_loc=loc} in
+      type_pat ~mode:(no_explosion mode) p expected_ty k
+        (* TODO: record 'extra' to remember about interval *)
+  | Ppat_interval _ ->
+      raise (error (loc, !env, Invalid_interval))
+  | Ppat_tuple spl ->
+      assert (List.length spl >= 2);
+      let spl_ann = List.map (fun p -> (p,newgenvar ())) spl in
+      let ty = newgenty (Ttuple(List.map snd spl_ann)) in
+      begin_def ();
+      let expected_ty = instance expected_ty in
+      end_def ();
+      generalize_structure expected_ty;
+      unify_pat_types ~refine loc env ty expected_ty;
+      map_fold_cont (fun (p,t) -> type_pat p t) spl_ann (fun pl ->
+        rp k {
+        pat_desc = Tpat_tuple pl;
+        pat_loc = loc; pat_extra=[];
+        pat_type = newty (Ttuple(List.map (fun p -> p.pat_type) pl));
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env })
+  | Ppat_construct(lid, sarg) ->
+      let opath =
+        try
+          let (p0, p, _) = extract_concrete_variant !env expected_ty in
+            Some (p0, p, true)
+        with Not_found -> None
+      in
+      let constr =
+        match lid.txt, mode with
+        | Longident.Lident s, Counter_example {constrs; _} ->
+           (* assert: cf. {!counter_example_checking_info} documentation *)
+            assert (Hashtbl.mem constrs s);
+            Hashtbl.find constrs s
+        | _ ->
+        let candidates =
+          Env.lookup_all_constructors Env.Pattern ~loc:lid.loc lid.txt !env in
+        wrap_disambiguate "This variant pattern is expected to have"
+          (mk_expected expected_ty)
+          (Constructor.disambiguate Env.Pattern lid !env opath) candidates
+      in
+      if constr.cstr_generalized && must_backtrack_on_gadt then
+        raise Need_backtrack;
+      begin match no_existentials, constr.cstr_existentials with
+      | None, _ | _, [] -> ()
+      | Some r, (_ :: _ as exs)  ->
+          let exs = List.map (Ctype.existential_name constr) exs in
+          let name = constr.cstr_name in
+          raise (error (loc, !env, Unexpected_existential (r,name, exs)))
+      end;
+      (* if constructor is gadt, we must verify that the expected type has the
+         correct head *)
+      if constr.cstr_generalized then
+        unify_head_only ~refine loc env (instance expected_ty) constr;
+      let sargs =
+        match sarg with
+          None -> []
+        | Some {ppat_desc = Ppat_tuple spl} when
+            constr.cstr_arity > 1 ||
+            Builtin_attributes.explicit_arity sp.ppat_attributes
+          -> spl
+        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity <> 1 ->
+            if constr.cstr_arity = 0 then
+              Location.prerr_warning sp.ppat_loc
+                                     Warnings.Wildcard_arg_to_constant_constr;
+            replicate_list sp constr.cstr_arity
+        | Some sp -> [sp] in
+      if Builtin_attributes.warn_on_literal_pattern constr.cstr_attributes then
+        begin match List.filter has_literal_pattern sargs with
+        | sp :: _ ->
+           Location.prerr_warning sp.ppat_loc Warnings.Fragile_literal_pattern
+        | _ -> ()
+        end;
+      if List.length sargs <> constr.cstr_arity then
+        raise(error(loc, !env, Constructor_arity_mismatch(lid.txt,
+                                     constr.cstr_arity, List.length sargs)));
+      begin_def ();
+      let (ty_args, ty_res) =
+        instance_constructor ~in_pattern:(env, get_gadt_equations_level ())
+          constr
+      in
+      let expected_ty = instance expected_ty in
+      (* PR#7214: do not use gadt unification for toplevel lets *)
+      unify_pat_types loc env ty_res expected_ty
+        ~refine:(refine || constr.cstr_generalized && no_existentials = None);
+      end_def ();
+      generalize_structure expected_ty;
+      generalize_structure ty_res;
+      List.iter generalize_structure ty_args;
+
+      let rec check_non_escaping p =
+        match p.ppat_desc with
+        | Ppat_or (p1, p2) ->
+            check_non_escaping p1;
+            check_non_escaping p2
+        | Ppat_alias (p, _) ->
+            check_non_escaping p
+        | Ppat_constraint _ ->
+            raise (error (p.ppat_loc, !env, Inlined_record_escape))
+        | _ ->
+            ()
+      in
+      if constr.cstr_inlined <> None then List.iter check_non_escaping sargs;
+
+      map_fold_cont (fun (p,t) -> type_pat p t) (List.combine sargs ty_args)
+      (fun args ->
+        rp k {
+          pat_desc=Tpat_construct(lid, constr, args);
+          pat_loc = loc; pat_extra=[];
+          pat_type = instance expected_ty;
+          pat_attributes = sp.ppat_attributes;
+          pat_env = !env })
+  | Ppat_variant(l, sarg) ->
+      let arg_type = match sarg with None -> [] | Some _ -> [newgenvar()] in
+      let row = { row_fields =
+                    [l, Reither(sarg = None, arg_type, true, ref None)];
+                  row_bound = ();
+                  row_closed = false;
+                  row_more = newgenvar ();
+                  row_fixed = None;
+                  row_name = None } in
+      begin_def ();
+      let expected_ty = instance expected_ty in
+      end_def ();
+      generalize_structure expected_ty;
+      (* PR#7404: allow some_private_tag blindly, as it would not unify with
+         the abstract row variable *)
+      if l = Parmatch.some_private_tag
+      then assert (match mode with Normal -> false | Counter_example _ -> true)
+      else unify_pat_types ~refine loc env (newgenty(Tvariant row)) expected_ty;
+      let k arg =
+        rp k {
+        pat_desc = Tpat_variant(l, arg, ref {row with row_more = newvar()});
+        pat_loc = loc; pat_extra=[];
+        pat_type = instance expected_ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env }
+      in begin
+        (* PR#6235: propagate type information *)
+        match sarg, arg_type with
+          Some p, [ty] -> type_pat p ty (fun p -> k (Some p))
+        | _            -> k None
+      end
+  | Ppat_record(lid_sp_list, closed) ->
+      assert (lid_sp_list <> []);
+      let opath, record_ty =
+        try
+          let (p0, p,_) = extract_concrete_record !env expected_ty in
+          begin_def ();
+          let ty = instance expected_ty in
+          end_def ();
+          generalize_structure ty;
+          Some (p0, p, true), ty
+        with Not_found -> None, newvar ()
+      in
+      let type_label_pat (label_lid, label, sarg) k =
+        begin_def ();
+        let (_, ty_arg, ty_res) = instance_label false label in
+        begin try
+          unify_pat_types ~refine loc env ty_res (instance record_ty)
+        with Error(_loc, _env, Pattern_type_clash(trace, _)) ->
+          raise(error(label_lid.loc, !env,
+                      Label_mismatch(label_lid.txt, trace)))
+        end;
+        end_def ();
+        generalize_structure ty_res;
+        generalize_structure ty_arg;
+        type_pat sarg ty_arg (fun arg ->
+          k (label_lid, label, arg))
+      in
+      let k' k lbl_pat_list =
+        check_recordpat_labels loc lbl_pat_list closed;
+        rup k {
+        pat_desc = Tpat_record (lbl_pat_list, closed);
+        pat_loc = loc; pat_extra=[];
+        pat_type = instance record_ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env }
+      in
+      begin match mode with
+      | Normal ->
+          k (wrap_disambiguate "This record pattern is expected to have"
+               (mk_expected expected_ty)
+               (type_label_a_list loc false !env type_label_pat opath
+                  lid_sp_list)
+               (k' (fun x -> x)))
+      | Counter_example {labels; _} ->
+          type_label_a_list ~labels loc false !env type_label_pat opath
+            lid_sp_list (k' k)
+      end
+  | Ppat_array spl ->
+      let ty_elt = newgenvar() in
+      begin_def ();
+      let expected_ty = instance expected_ty in
+      end_def ();
+      generalize_structure expected_ty;
+      unify_pat_types ~refine
+        loc env (Predef.type_array ty_elt) expected_ty;
+      map_fold_cont (fun p -> type_pat p ty_elt) spl (fun pl ->
+        rp k {
+        pat_desc = Tpat_array pl;
+        pat_loc = loc; pat_extra=[];
+        pat_type = instance expected_ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env })
+  | Ppat_or(sp1, sp2) ->
+      let may_split, must_split =
+        match get_splitting_mode mode with
+        | None -> false, false
+        | Some Backtrack_or -> true, true
+        | Some (Refine_or _) -> true, false in
+      let state = save_state env in
+      let split_or sp =
+        assert may_split;
+        let typ pat = type_pat ~exception_allowed pat expected_ty k in
+        find_valid_alternative (fun pat -> set_state state env; typ pat) sp in
+      if must_split then split_or sp else begin
+        let initial_pattern_variables = !pattern_variables in
+        let initial_module_variables = !module_variables in
+        let equation_level = !gadt_equations_level in
+        let outter_lev = get_current_level () in
+        (* introduce a new scope *)
+        begin_def ();
+        let lev = get_current_level () in
+        gadt_equations_level := Some lev;
+        let env1 = ref !env in
+        let inside_or = enter_nonsplit_or mode in
+        let p1 =
+          try Some (type_pat ~exception_allowed ~mode:inside_or
+                      sp1 expected_ty ~env:env1 (fun x -> x))
+          with Need_backtrack -> None in
+        let p1_variables = !pattern_variables in
+        let p1_module_variables = !module_variables in
+        pattern_variables := initial_pattern_variables;
+        module_variables := initial_module_variables;
+        let env2 = ref !env in
+        let p2 =
+          try Some (type_pat ~exception_allowed ~mode:inside_or
+                      sp2 expected_ty ~env:env2 (fun x -> x))
+          with Need_backtrack -> None in
+        end_def ();
+        gadt_equations_level := equation_level;
+        let p2_variables = !pattern_variables in
+        (* Make sure no variable with an ambiguous type gets added to the
+           environment. *)
+        List.iter (fun { pv_type; pv_loc; _ } ->
+          check_scope_escape pv_loc !env1 outter_lev pv_type
+        ) p1_variables;
+        List.iter (fun { pv_type; pv_loc; _ } ->
+          check_scope_escape pv_loc !env2 outter_lev pv_type
+        ) p2_variables;
+        begin match p1, p2 with
+        | None, None ->
+           let inside_nonsplit_or =
+             match get_splitting_mode mode with
+             | None | Some Backtrack_or -> false
+             | Some (Refine_or {inside_nonsplit_or}) -> inside_nonsplit_or in
+           if inside_nonsplit_or
+           then raise Need_backtrack
+           else split_or sp
+        | Some p, None | None, Some p -> rp k p (* no variables in this case *)
+        | Some p1, Some p2 ->
+        let alpha_env =
+          enter_orpat_variables loc !env p1_variables p2_variables in
+        pattern_variables := p1_variables;
+        module_variables := p1_module_variables;
+        rp k { pat_desc = Tpat_or(p1, alpha_pat alpha_env p2, None);
+               pat_loc = loc;
+               pat_extra=[];
+               pat_type = instance expected_ty;
+               pat_attributes = sp.ppat_attributes;
+               pat_env = !env }
+        end
+      end
+  | Ppat_lazy sp1 ->
+      let nv = newgenvar () in
+      unify_pat_types ~refine loc env (Predef.type_lazy_t nv) expected_ty;
+      (* do not explode under lazy: PR#7421 *)
+      type_pat ~mode:(no_explosion mode) sp1 nv (fun p1 ->
+        rp k {
+        pat_desc = Tpat_lazy p1;
+        pat_loc = loc; pat_extra=[];
+        pat_type = instance expected_ty;
+        pat_attributes = sp.ppat_attributes;
+        pat_env = !env })
+  | Ppat_constraint(sp, sty) ->
+      (* Pretend separate = true *)
+      begin_def();
+      let cty, force = Typetexp.transl_simple_type_delayed !env sty in
+      let ty = cty.ctyp_type in
+      end_def();
+      generalize_structure ty;
+      let ty, expected_ty' = instance ty, ty in
+      unify_pat_types ~refine loc env ty (instance expected_ty);
+      type_pat ~exception_allowed sp expected_ty' (fun p ->
+        (*Format.printf "%a@.%a@."
+          Printtyp.raw_type_expr ty
+          Printtyp.raw_type_expr p.pat_type;*)
+        pattern_force := force :: !pattern_force;
+        let extra = (Tpat_constraint cty, loc, sp.ppat_attributes) in
+        let p =
+          match p.pat_desc with
+            Tpat_var (id,s) ->
+              {p with pat_type = ty;
+               pat_desc = Tpat_alias
+                 ({p with pat_desc = Tpat_any; pat_attributes = []}, id,s);
+               pat_extra = [extra];
+             }
+          | _ -> {p with pat_type = ty;
+                  pat_extra = extra :: p.pat_extra}
+        in k p)
+  | Ppat_type lid ->
+      let (path, p,ty) = build_or_pat !env loc lid in
+      unify_pat_types ~refine loc env ty (instance expected_ty);
+      k { p with pat_extra =
+        (Tpat_type (path, lid), loc, sp.ppat_attributes) :: p.pat_extra }
+  | Ppat_open (lid,p) ->
+      let path, new_env =
+        !type_open Asttypes.Fresh !env sp.ppat_loc lid in
+      let new_env = ref new_env in
+      type_pat ~exception_allowed ~env:new_env p expected_ty ( fun p ->
+        env := Env.copy_local !env ~from:!new_env;
+        k { p with pat_extra =( Tpat_open (path,lid,!new_env),
+                            loc, sp.ppat_attributes) :: p.pat_extra }
+      )
+  | Ppat_exception p ->
+      if not exception_allowed then
+        raise (error (loc, !env, Exception_pattern_disallowed))
+      else begin
+        type_pat p Predef.type_exn (fun p_exn ->
+        rp k {
+          pat_desc = Tpat_exception p_exn;
+          pat_loc = sp.ppat_loc;
+          pat_extra = [];
+          pat_type = expected_ty;
+          pat_env = !env;
+          pat_attributes = sp.ppat_attributes;
+        })
+      end
+  | Ppat_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+let type_pat ?exception_allowed ?no_existentials ?(mode=Normal)
+    ?(lev=get_current_level()) env sp expected_ty =
+  Misc.protect_refs [Misc.R (gadt_equations_level, Some lev)] (fun () ->
+      let r =
+        type_pat ?exception_allowed ~no_existentials ~mode
+          ~env sp expected_ty (fun x -> x)
+      in
+      iter_pattern (fun p -> p.pat_env <- !env) r;
+      r
+    )
+
+(* this function is passed to Partial.parmatch
+   to type check gadt nonexhaustiveness *)
+let partial_pred ~lev ~splitting_mode ?(explode=0)
+      env expected_ty constrs labels p =
+  let env = ref env in
+  let state = save_state env in
+  let mode =
+    Counter_example {
+        splitting_mode;
+        explosion_fuel = explode;
+        constrs; labels;
+      } in
+  try
+    reset_pattern None true;
+    let typed_p =
+      Ctype.with_passive_variants (type_pat ~lev ~mode env p) expected_ty
+    in
+    set_state state env;
+    (* types are invalidated but we don't need them here *)
+    Some typed_p
+  with Error _ ->
+    set_state state env;
+    None
+
+let check_partial ?(lev=get_current_level ()) env expected_ty loc cases =
+  let explode = match cases with [_] -> 5 | _ -> 0 in
+  let splitting_mode = Refine_or {inside_nonsplit_or = false} in
+  Parmatch.check_partial
+    (partial_pred ~lev ~splitting_mode ~explode env expected_ty) loc cases
+
+let check_unused ?(lev=get_current_level ()) env expected_ty cases =
+  Parmatch.check_unused
+    (fun refute constrs labels spat ->
+      match
+        partial_pred ~lev ~splitting_mode:Backtrack_or ~explode:5
+          env expected_ty constrs labels spat
+      with
+        Some pat when refute ->
+          raise (error (spat.ppat_loc, env, Unrefuted_pattern pat))
+      | r -> r)
+    cases
+
+let iter_pattern_variables_type f : pattern_variable list -> unit =
+  List.iter (fun {pv_type; _} -> f pv_type)
+
+let add_pattern_variables ?check ?check_as env pv =
+  List.fold_right
+    (fun {pv_id; pv_type; pv_loc; pv_as_var; pv_attributes} env ->
+       let check = if pv_as_var then check_as else check in
+       Env.add_value ?check pv_id
+         {val_type = pv_type; val_kind = Val_reg; Types.val_loc = pv_loc;
+          val_attributes = pv_attributes;
+         } env
+    )
+    pv env
+
+let type_pattern ?exception_allowed ~lev env spat scope expected_ty =
+  reset_pattern scope true;
+  let new_env = ref env in
+  let pat = type_pat ?exception_allowed ~lev new_env spat expected_ty in
+  let pvs = get_ref pattern_variables in
+  let unpacks = get_ref module_variables in
+  (pat, !new_env, get_ref pattern_force, pvs, unpacks)
+
+let type_pattern_list no_existentials env spatl scope expected_tys allow =
+  reset_pattern scope allow;
+  let new_env = ref env in
+  let type_pat (attrs, pat) ty =
+    Builtin_attributes.warning_scope ~ppwarning:false attrs
+      (fun () ->
+         type_pat ~no_existentials new_env pat ty
+      )
+  in
+  let patl = List.map2 type_pat spatl expected_tys in
+  let pvs = get_ref pattern_variables in
+  let unpacks = get_ref module_variables in
+  let new_env = add_pattern_variables !new_env pvs in
+  (patl, new_env, get_ref pattern_force, pvs, unpacks)
+
+let type_class_arg_pattern cl_num val_env met_env l spat =
+  reset_pattern None false;
+  let nv = newvar () in
+  let pat = type_pat ~no_existentials:In_class_args (ref val_env) spat nv in
+  if has_variants pat then begin
+    Parmatch.pressure_variants val_env [pat];
+    iter_pattern finalize_variant pat
+  end;
+  List.iter (fun f -> f()) (get_ref pattern_force);
+  if is_optional l then unify_pat (ref val_env) pat (type_option (newvar ()));
+  let (pv, met_env) =
+    List.fold_right
+      (fun {pv_id; pv_type; pv_loc; pv_as_var; pv_attributes} (pv, env) ->
+         let check s =
+           if pv_as_var then Warnings.Unused_var s
+           else Warnings.Unused_var_strict s in
+         let id' = Ident.create_local (Ident.name pv_id) in
+         ((id', pv_id, pv_type)::pv,
+          Env.add_value id' {val_type = pv_type;
+                             val_kind = Val_ivar (Immutable, cl_num);
+                             val_attributes = pv_attributes;
+                             Types.val_loc = pv_loc;
+                            } ~check
+            env))
+      !pattern_variables ([], met_env)
+  in
+  let val_env = add_pattern_variables val_env (get_ref pattern_variables) in
+  (pat, pv, val_env, met_env)
+
+let type_self_pattern cl_num privty val_env met_env par_env spat =
+  let open Ast_helper in
+  let spat =
+    Pat.mk (Ppat_alias (Pat.mk(Ppat_alias (spat, mknoloc "selfpat-*")),
+                        mknoloc ("selfpat-" ^ cl_num)))
+  in
+  reset_pattern None false;
+  let nv = newvar() in
+  let pat = type_pat ~no_existentials:In_self_pattern (ref val_env) spat nv in
+  List.iter (fun f -> f()) (get_ref pattern_force);
+  let meths = ref Meths.empty in
+  let vars = ref Vars.empty in
+  let pv = !pattern_variables in
+  pattern_variables := [];
+  let (val_env, met_env, par_env) =
+    List.fold_right
+      (fun {pv_id; pv_type; pv_loc; pv_as_var; pv_attributes}
+           (val_env, met_env, par_env) ->
+         let name = Ident.name pv_id in
+         (Env.enter_unbound_value name Val_unbound_self val_env,
+          Env.add_value pv_id {val_type = pv_type;
+                               val_kind =
+                                 Val_self (meths, vars, cl_num, privty);
+                               val_attributes = pv_attributes;
+                               Types.val_loc = pv_loc;
+                              }
+            ~check:(fun s -> if pv_as_var then Warnings.Unused_var s
+                             else Warnings.Unused_var_strict s)
+            met_env,
+          Env.enter_unbound_value name Val_unbound_self par_env))
+      pv (val_env, met_env, par_env)
+  in
+  (pat, meths, vars, val_env, met_env, par_env)
+
+type delayed_check = ((unit -> unit) * Warnings.state)
+
+let delayed_checks = ref []
+let reset_delayed_checks () = delayed_checks := []
+let add_delayed_check f =
+  delayed_checks := (f, Warnings.backup ()) :: !delayed_checks
+
+let force_delayed_checks () =
+  (* checks may change type levels *)
+  let snap = Btype.snapshot () in
+  let w_old = Warnings.backup () in
+  List.iter
+    (fun (f, w) -> Warnings.restore w;
+      try f () with exn -> Msupport.raise_error exn)
+    (List.rev !delayed_checks);
+  Warnings.restore w_old;
+  reset_delayed_checks ();
+  Btype.backtrack snap
+
+let rec final_subexpression exp =
+  match exp.exp_desc with
+    Texp_let (_, _, e)
+  | Texp_sequence (_, e)
+  | Texp_try (e, _)
+  | Texp_ifthenelse (_, e, _)
+  | Texp_match (_, {c_rhs=e} :: _, _)
+  | Texp_letmodule (_, _, _, _, e)
+  | Texp_letexception (_, e)
+  | Texp_open (_, e)
+    -> final_subexpression e
+  | _ -> exp
+
+(* Generalization criterion for expressions *)
+
+let rec is_nonexpansive exp =
+  match exp.exp_desc with
+  | Texp_ident _
+  | Texp_constant _
+  | Texp_unreachable
+  | Texp_function _
+  | Texp_array [] -> true
+  | Texp_let(_rec_flag, pat_exp_list, body) ->
+      List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list &&
+      is_nonexpansive body
+  | Texp_apply(e, (_,None)::el) ->
+      is_nonexpansive e && List.for_all is_nonexpansive_opt (List.map snd el)
+  | Texp_match(e, cases, _) ->
+     (* Not sure this is necessary, if [e] is nonexpansive then we shouldn't
+         care if there are exception patterns. But the previous version enforced
+         that there be none, so... *)
+      let contains_exception_pat p =
+        let res = ref false in
+        iter_pattern (fun p ->
+          match p.pat_desc with
+          | Tpat_exception _ -> res := true
+          | _ -> ()
+        ) p;
+        !res
+      in
+      is_nonexpansive e &&
+      List.for_all
+        (fun {c_lhs; c_guard; c_rhs} ->
+           is_nonexpansive_opt c_guard && is_nonexpansive c_rhs
+           && not (contains_exception_pat c_lhs)
+        ) cases
+  | Texp_tuple el ->
+      List.for_all is_nonexpansive el
+  | Texp_construct( _, _, el) ->
+      List.for_all is_nonexpansive el
+  | Texp_variant(_, arg) -> is_nonexpansive_opt arg
+  | Texp_record { fields; extended_expression } ->
+      Array.for_all
+        (fun (lbl, definition) ->
+           match definition with
+           | Overridden (_, exp) ->
+               lbl.lbl_mut = Immutable && is_nonexpansive exp
+           | Kept _ -> true)
+        fields
+      && is_nonexpansive_opt extended_expression
+  | Texp_field(exp, _, _) -> is_nonexpansive exp
+  | Texp_ifthenelse(_cond, ifso, ifnot) ->
+      is_nonexpansive ifso && is_nonexpansive_opt ifnot
+  | Texp_sequence (_e1, e2) -> is_nonexpansive e2  (* PR#4354 *)
+  | Texp_new (_, _, cl_decl) -> Ctype.class_type_arity cl_decl.cty_type > 0
+  (* Note: nonexpansive only means no _observable_ side effects *)
+  | Texp_lazy e -> is_nonexpansive e
+  | Texp_object ({cstr_fields=fields; cstr_type = { csig_vars=vars}}, _) ->
+      let count = ref 0 in
+      List.for_all
+        (fun field -> match field.cf_desc with
+            Tcf_method _ -> true
+          | Tcf_val (_, _, _, Tcfk_concrete (_, e), _) ->
+              incr count; is_nonexpansive e
+          | Tcf_val (_, _, _, Tcfk_virtual _, _) ->
+              incr count; true
+          | Tcf_initializer e -> is_nonexpansive e
+          | Tcf_constraint _ -> true
+          | Tcf_inherit _ -> false
+          | Tcf_attribute _ -> true)
+        fields &&
+      Vars.fold (fun _ (mut,_,_) b -> decr count; b && mut = Immutable)
+        vars true &&
+      !count = 0
+  | Texp_letmodule (_, _, _, mexp, e)
+  | Texp_open ({ open_expr = mexp; _}, e) ->
+      is_nonexpansive_mod mexp && is_nonexpansive e
+  | Texp_pack mexp ->
+      is_nonexpansive_mod mexp
+  (* Computations which raise exceptions are nonexpansive, since (raise e) is
+     equivalent to (raise e; diverge), and a nonexpansive "diverge" can be
+     produced using lazy values or the relaxed value restriction.
+     See GPR#1142 *)
+  | Texp_assert exp ->
+      is_nonexpansive exp
+  | Texp_apply (
+      { exp_desc = Texp_ident (_, _, {val_kind =
+             Val_prim {Primitive.prim_name =
+                         ("%raise" | "%reraise" | "%raise_notrace")}}) },
+      [Nolabel, Some e]) ->
+     is_nonexpansive e
+  | Texp_array (_ :: _)
+  | Texp_apply _
+  | Texp_try _
+  | Texp_setfield _
+  | Texp_while _
+  | Texp_for _
+  | Texp_send _
+  | Texp_instvar _
+  | Texp_setinstvar _
+  | Texp_override _
+  | Texp_letexception _
+  | Texp_letop _
+  | Texp_extension_constructor _ ->
+    false
+
+and is_nonexpansive_mod mexp =
+  match mexp.mod_desc with
+  | Tmod_ident _
+  | Tmod_functor _ -> true
+  | Tmod_unpack (e, _) -> is_nonexpansive e
+  | Tmod_constraint (m, _, _, _) -> is_nonexpansive_mod m
+  | Tmod_structure str ->
+      List.for_all
+        (fun item -> match item.str_desc with
+          | Tstr_eval _ | Tstr_primitive _ | Tstr_type _
+          | Tstr_modtype _ | Tstr_class_type _  -> true
+          | Tstr_value (_, pat_exp_list) ->
+              List.for_all (fun vb -> is_nonexpansive vb.vb_expr) pat_exp_list
+          | Tstr_module {mb_expr=m;_}
+          | Tstr_open {open_expr=m;_}
+          | Tstr_include {incl_mod=m;_} -> is_nonexpansive_mod m
+          | Tstr_recmodule id_mod_list ->
+              List.for_all (fun {mb_expr=m;_} -> is_nonexpansive_mod m)
+                id_mod_list
+          | Tstr_exception {tyexn_constructor = {ext_kind = Text_decl _}} ->
+              false (* true would be unsound *)
+          | Tstr_exception {tyexn_constructor = {ext_kind = Text_rebind _}} ->
+              true
+          | Tstr_typext te ->
+              List.for_all
+                (function {ext_kind = Text_decl _} -> false
+                        | {ext_kind = Text_rebind _} -> true)
+                te.tyext_constructors
+          | Tstr_class _ -> false (* could be more precise *)
+          | Tstr_attribute _ -> true
+        )
+        str.str_items
+  | Tmod_apply _ -> false
+
+and is_nonexpansive_opt = function
+  | None -> true
+  | Some e -> is_nonexpansive e
+
+let maybe_expansive e = not (is_nonexpansive e)
+
+let check_recursive_bindings env valbinds =
+  let ids = let_bound_idents valbinds in
+  List.iter
+    (fun {vb_expr} ->
+       if not (Rec_check.is_valid_recursive_expression ids vb_expr) then
+         raise(error(vb_expr.exp_loc, env, Illegal_letrec_expr))
+    )
+    valbinds
+
+let check_recursive_class_bindings env ids exprs =
+  List.iter
+    (fun expr ->
+       if not (Rec_check.is_valid_class_expr ids expr) then
+         raise(error(expr.cl_loc, env, Illegal_class_expr)))
+    exprs
+
+(* Approximate the type of an expression, for better recursion *)
+
+let rec approx_type env sty =
+  match sty.ptyp_desc with
+    Ptyp_arrow (p, _, sty) ->
+      let ty1 = if is_optional p then type_option (newvar ()) else newvar () in
+      newty (Tarrow (p, ty1, approx_type env sty, Cok))
+  | Ptyp_tuple args ->
+      newty (Ttuple (List.map (approx_type env) args))
+  | Ptyp_constr (lid, ctl) ->
+      let path, decl = Env.lookup_type ~use:false ~loc:lid.loc lid.txt env in
+      if List.length ctl <> decl.type_arity then newvar ()
+      else begin
+        let tyl = List.map (approx_type env) ctl in
+        newconstr path tyl
+      end
+  | Ptyp_poly (_, sty) ->
+      approx_type env sty
+  | _ -> newvar ()
+
+let rec type_approx env sexp =
+  match sexp.pexp_desc with
+    Pexp_let (_, _, e) -> type_approx env e
+  | Pexp_fun (p, _, _, e) ->
+      let ty = if is_optional p then type_option (newvar ()) else newvar () in
+      newty (Tarrow(p, ty, type_approx env e, Cok))
+  | Pexp_function ({pc_rhs=e}::_) ->
+      newty (Tarrow(Nolabel, newvar (), type_approx env e, Cok))
+  | Pexp_match (_, {pc_rhs=e}::_) -> type_approx env e
+  | Pexp_try (e, _) -> type_approx env e
+  | Pexp_tuple l -> newty (Ttuple(List.map (type_approx env) l))
+  | Pexp_ifthenelse (_,e,_) -> type_approx env e
+  | Pexp_sequence (_,e) -> type_approx env e
+  | Pexp_constraint (e, sty) ->
+      let ty = type_approx env e in
+      let ty1 = approx_type env sty in
+      begin try unify env ty ty1 with Unify trace ->
+        raise(error(sexp.pexp_loc, env, Expr_type_clash (trace, None, None)))
+      end;
+      ty1
+  | Pexp_coerce (e, sty1, sty2) ->
+      let approx_ty_opt = function
+        | None -> newvar ()
+        | Some sty -> approx_type env sty
+      in
+      let ty = type_approx env e
+      and ty1 = approx_ty_opt sty1
+      and ty2 = approx_type env sty2 in
+      begin try unify env ty ty1 with Unify trace ->
+        raise(error(sexp.pexp_loc, env, Expr_type_clash (trace, None, None)))
+      end;
+      ty2
+  | _ -> newvar ()
+
+(* List labels in a function type, and whether return type is a variable *)
+let rec list_labels_aux env visited ls ty_fun =
+  let ty = expand_head env ty_fun in
+  if List.memq ty visited then
+    List.rev ls, false
+  else match ty.desc with
+    Tarrow (l, _, ty_res, _) ->
+      list_labels_aux env (ty::visited) (l::ls) ty_res
+  | _ ->
+      List.rev ls, is_Tvar ty
+
+let list_labels env ty =
+  wrap_trace_gadt_instances env (list_labels_aux env [] []) ty
+
+(* Check that all univars are safe in a type *)
+let check_univars env expans kind exp ty_expected vars =
+  if expans && maybe_expansive exp then
+    lower_contravariant env exp.exp_type;
+  (* need to expand twice? cf. Ctype.unify2 *)
+  let vars = List.map (expand_head env) vars in
+  let vars = List.map (expand_head env) vars in
+  let vars' =
+    List.filter
+      (fun t ->
+        let t = repr t in
+        generalize t;
+        match t.desc with
+          Tvar name when t.level = generic_level ->
+            set_type_desc t (Tunivar name); true
+        | _ -> false)
+      vars in
+  if List.length vars = List.length vars' then () else
+  let ty = newgenty (Tpoly(repr exp.exp_type, vars'))
+  and ty_expected = repr ty_expected in
+  raise (error (exp.exp_loc, env,
+                Less_general(kind, [Unification_trace.diff ty ty_expected])))
+
+let check_partial_application statement exp =
+  let rec f delay =
+    let ty = (expand_head exp.exp_env exp.exp_type).desc in
+    let check_statement () =
+      match ty with
+      | Tconstr (p, _, _)  when Path.same p Predef.path_unit ->
+          ()
+      | _ ->
+          if statement then
+            let rec loop {exp_loc; exp_desc; exp_extra; _} =
+              match exp_desc with
+              | Texp_let (_, _, e)
+              | Texp_sequence (_, e)
+              | Texp_letexception (_, e)
+              | Texp_letmodule (_, _, _, _, e) ->
+                  loop e
+              | _ ->
+                  let loc =
+                    match List.find_opt (function
+                        | (Texp_constraint _, _, _) -> true
+                        | _ -> false) exp_extra
+                    with
+                    | Some (_, loc, _) -> loc
+                    | None -> exp_loc
+                  in
+                  Location.prerr_warning loc Warnings.Statement_type
+            in
+            loop exp
+    in
+    match ty, exp.exp_desc with
+    | Tarrow _, _ ->
+        let rec check {exp_desc; exp_loc; exp_extra; _} =
+          if List.exists (function
+              | (Texp_constraint _, _, _) -> true
+              | _ -> false) exp_extra then check_statement ()
+          else begin
+            match exp_desc with
+            | Texp_ident _ | Texp_constant _ | Texp_tuple _
+            | Texp_construct _ | Texp_variant _ | Texp_record _
+            | Texp_field _ | Texp_setfield _ | Texp_array _
+            | Texp_while _ | Texp_for _ | Texp_instvar _
+            | Texp_setinstvar _ | Texp_override _ | Texp_assert _
+            | Texp_lazy _ | Texp_object _ | Texp_pack _ | Texp_unreachable
+            | Texp_extension_constructor _ | Texp_ifthenelse (_, _, None)
+            | Texp_function _ ->
+                check_statement ()
+            | Texp_match (_, cases, _) ->
+                List.iter (fun {c_rhs; _} -> check c_rhs) cases
+            | Texp_try (e, cases) ->
+                check e; List.iter (fun {c_rhs; _} -> check c_rhs) cases
+            | Texp_ifthenelse (_, e1, Some e2) ->
+                check e1; check e2
+            | Texp_let (_, _, e) | Texp_sequence (_, e) | Texp_open (_, e)
+            | Texp_letexception (_, e) | Texp_letmodule (_, _, _, _, e) ->
+                check e
+            | Texp_apply _ | Texp_send _ | Texp_new _ | Texp_letop _ ->
+                Location.prerr_warning exp_loc Warnings.Partial_application
+          end
+        in
+        check exp
+    | Tvar _, _ ->
+        if delay then add_delayed_check (fun () -> f false)
+    | _ ->
+        check_statement ()
+  in
+  f true
+
+(* Check that a type is generalizable at some level *)
+let generalizable level ty =
+  let rec check ty =
+    let ty = repr ty in
+    if ty.level < lowest_level then () else
+    if ty.level <= level then raise Exit else
+    (mark_type_node ty; iter_type_expr check ty)
+  in
+  try check ty; unmark_type ty; true
+  with Exit -> unmark_type ty; false
+
+(* Hack to allow coercion of self. Will clean-up later. *)
+let self_coercion = ref ([] : (Path.t * Location.t list ref) list)
+
+(* Helpers for packaged modules. *)
+let create_package_type loc env (p, l) =
+  let s = !Typetexp.transl_modtype_longident loc env p in
+  let fields = List.map (fun (name, ct) ->
+                           name, Typetexp.transl_simple_type env false ct) l in
+  let ty = newty (Tpackage (s,
+                    List.map fst l,
+                   List.map (fun (_, cty) -> cty.ctyp_type) fields))
+  in
+   (s, fields, ty)
+
+ let wrap_unpacks sexp unpacks =
+   let open Ast_helper in
+   List.fold_left
+     (fun sexp (name, loc) ->
+        Exp.letmodule ~loc:{ sexp.pexp_loc with loc_ghost = true }
+         ~attrs:[Attr.mk (mknoloc "#modulepat") (PStr [])]
+         { name with txt = Some name.txt }
+         (Mod.unpack ~loc
+            (Exp.ident ~loc:name.loc (mkloc (Longident.Lident name.txt)
+                                            name.loc)))
+         sexp
+     )
+    sexp unpacks
+
+(* Helpers for type_cases *)
+
+let contains_variant_either ty =
+  let rec loop ty =
+    let ty = repr ty in
+    if ty.level >= lowest_level then begin
+      mark_type_node ty;
+      match ty.desc with
+        Tvariant row ->
+          let row = row_repr row in
+          if not (is_fixed row) then
+            List.iter
+              (fun (_,f) ->
+                match row_field_repr f with Reither _ -> raise Exit | _ -> ())
+              row.row_fields;
+          iter_row loop row
+      | _ ->
+          iter_type_expr loop ty
+    end
+  in
+  try loop ty; unmark_type ty; false
+  with Exit -> unmark_type ty; true
+
+let shallow_iter_ppat f p =
+  match p.ppat_desc with
+  | Ppat_any | Ppat_var _ | Ppat_constant _ | Ppat_interval _
+  | Ppat_extension _
+  | Ppat_type _ | Ppat_unpack _ -> ()
+  | Ppat_array pats -> List.iter f pats
+  | Ppat_or (p1,p2) -> f p1; f p2
+  | Ppat_variant (_, arg) | Ppat_construct (_, arg) -> Option.iter f arg
+  | Ppat_tuple lst ->  List.iter f lst
+  | Ppat_exception p | Ppat_alias (p,_)
+  | Ppat_open (_,p)
+  | Ppat_constraint (p,_) | Ppat_lazy p -> f p
+  | Ppat_record (args, _flag) -> List.iter (fun (_,p) -> f p) args
+
+let exists_ppat f p =
+  let exception Found in
+  let rec loop p =
+    if f p then raise Found else ();
+    shallow_iter_ppat loop p in
+  match loop p with
+  | exception Found -> true
+  | () -> false
+
+let contains_polymorphic_variant p =
+  exists_ppat
+    (function
+     | {ppat_desc = (Ppat_variant _ | Ppat_type _)} -> true
+     | _ -> false)
+    p
+
+let contains_gadt cp =
+  exists_pattern
+    (function
+     | {pat_desc = Tpat_construct (_, cd, _)} when cd.cstr_generalized -> true
+     | _ -> false)
+    cp
+
+(* There are various things that we need to do in presence of GADT constructors
+   that aren't required if there are none.
+   However, because of disambiguation, we can't know for sure whether the
+   patterns contain some GADT constructors. So we conservatively assume that
+   any constructor might be a GADT constructor. *)
+let may_contain_gadts p =
+  exists_ppat
+  (function
+   | {ppat_desc = Ppat_construct (_, _)} -> true
+   | _ -> false)
+  p
+
+let check_absent_variant env =
+  iter_pattern
+    (function {pat_desc = Tpat_variant (s, arg, row)} as pat ->
+      let row = row_repr !row in
+      if List.exists (fun (s',fi) -> s = s' && row_field_repr fi <> Rabsent)
+          row.row_fields
+      || not (is_fixed row) && not (static_row row)  (* same as Ctype.poly *)
+      then () else
+      let ty_arg =
+        match arg with None -> [] | Some p -> [correct_levels p.pat_type] in
+      let row' = {row_fields = [s, Reither(arg=None,ty_arg,true,ref None)];
+                  row_more = newvar (); row_bound = ();
+                  row_closed = false; row_fixed = None; row_name = None} in
+      (* Should fail *)
+      unify_pat (ref env) {pat with pat_type = newty (Tvariant row')}
+                          (correct_levels pat.pat_type)
+      | _ -> ())
+
+(* Getting proper location of already typed expressions.
+
+   Used to avoid confusing locations on type error messages in presence of
+   type constraints.
+   For example:
+
+       (* Before patch *)
+       # let x : string = (5 : int);;
+                           ^
+       (* After patch *)
+       # let x : string = (5 : int);;
+                          ^^^^^^^^^
+*)
+let proper_exp_loc exp =
+  let rec aux = function
+    | [] -> exp.exp_loc
+    | ((Texp_constraint _ | Texp_coerce _), loc, _) :: _ -> loc
+    | _ :: rest -> aux rest
+  in
+  aux exp.exp_extra
+
+(* To find reasonable names for let-bound and lambda-bound idents *)
+
+let rec name_pattern default = function
+    [] -> Ident.create_local default
+  | p :: rem ->
+    match p.pat_desc with
+      Tpat_var (id, _) -> id
+    | Tpat_alias(_, id, _) -> id
+    | _ -> name_pattern default rem
+
+let name_cases default lst =
+  name_pattern default (List.map (fun c -> c.c_lhs) lst)
+
+(* Typing of expressions *)
+
+let unify_exp env exp expected_ty =
+  let loc = proper_exp_loc exp in
+  try
+    unify_exp_types loc env exp.exp_type expected_ty
+  with Error(loc, env, Expr_type_clash(trace, tfc, None)) ->
+    raise (Error(loc, env, Expr_type_clash(trace, tfc, Some exp.exp_desc)))
+
+let rec type_exp ?recarg env sexp =
+  (* We now delegate everything to type_expect *)
+  type_expect ?recarg env sexp (mk_expected (newvar ()))
+
+(* Typing of an expression with an expected type.
+   This provide better error messages, and allows controlled
+   propagation of return type information.
+   In the principal case, [type_expected'] may be at generic_level.
+ *)
+
+and type_expect ?in_function ?recarg env sexp ty_expected_explained =
+  Msupport.with_saved_types
+    ~warning_attribute:sexp.pexp_attributes ?save_part:None
+    (fun () ->
+       let saved = save_levels () in
+       try
+         type_expect_ ?in_function ?recarg env sexp ty_expected_explained
+       with exn ->
+        Msupport.erroneous_type_register ty_expected_explained.ty;
+        raise_error exn;
+        set_levels saved;
+        let loc = sexp.pexp_loc in
+        {
+          exp_desc = Texp_ident
+                       (Path.Pident (Ident.create_local "*type-error*"),
+                        Location.mkloc (Longident.Lident "*type-error*") loc,
+                        { Types.
+                          val_type = ty_expected_explained.ty;
+                          val_kind = Val_reg;
+                          val_loc = loc;
+                          val_attributes = [];
+                        });
+          exp_loc = loc;
+          exp_extra = [];
+          exp_type = ty_expected_explained.ty;
+          exp_env = env;
+          exp_attributes = merlin_recovery_attributes [];
+	})
+
+and with_explanation explanation f =
+  match explanation with
+  | None -> f ()
+  | Some explanation ->
+      try f ()
+      with Error (loc', env', Expr_type_clash(trace', None, exp'))
+        when not loc'.Location.loc_ghost ->
+        let err = Expr_type_clash(trace', Some explanation, exp') in
+        raise (Error (loc', env', err))
+
+and type_expect_
+    ?in_function ?(recarg=Rejected)
+    env sexp ty_expected_explained =
+  let { ty = ty_expected; explanation } = ty_expected_explained in
+  let loc = sexp.pexp_loc in
+  (* Record the expression type before unifying it with the expected type *)
+  let with_explanation = with_explanation explanation in
+  let rue exp =
+    with_explanation (fun () ->
+      unify_exp env (re exp) (instance ty_expected));
+    exp
+  in
+  match sexp.pexp_desc with
+  | Pexp_ident lid ->
+      let path, desc = type_ident env ~recarg lid in
+      let exp_desc =
+        match desc.val_kind with
+        | Val_ivar (_, cl_num) ->
+            let (self_path, _) =
+              Env.find_value_by_name
+                (Longident.Lident ("self-" ^ cl_num)) env
+            in
+            Texp_instvar(self_path, path,
+                         match lid.txt with
+                             Longident.Lident txt -> { txt; loc = lid.loc }
+                           | _ -> assert false)
+        | Val_self (_, _, cl_num, _) ->
+            let (path, _) =
+              Env.find_value_by_name (Longident.Lident ("self-" ^ cl_num)) env
+            in
+            Texp_ident(path, lid, desc)
+        | _ ->
+            Texp_ident(path, lid, desc)
+      in
+      rue {
+        exp_desc; exp_loc = loc; exp_extra = [];
+        exp_type = instance desc.val_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_constant(Pconst_string (str, _) as cst) -> (
+    let cst = constant_or_raise env loc cst in
+    (* Terrible hack for format strings *)
+    let ty_exp = expand_head env ty_expected in
+    let fmt6_path =
+      Path.(Pdot (Pident (Ident.create_persistent "CamlinternalFormatBasics"),
+                  "format6"))
+    in
+    let is_format = match ty_exp.desc with
+      | Tconstr(path, _, _) when Path.same path fmt6_path ->
+        if !Clflags.principal && ty_exp.level <> generic_level then
+          Location.prerr_warning loc
+            (Warnings.Not_principal "this coercion to format6");
+        true
+      | _ -> false
+    in
+    if is_format then
+      let format_parsetree =
+        { (type_format loc str env) with pexp_loc = sexp.pexp_loc }  in
+      type_expect ?in_function env format_parsetree ty_expected_explained
+    else
+      rue {
+        exp_desc = Texp_constant cst;
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance Predef.type_string;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  )
+  | Pexp_constant cst ->
+      let cst = constant_or_raise env loc cst in
+      rue {
+        exp_desc = Texp_constant cst;
+        exp_loc = loc; exp_extra = [];
+        exp_type = type_constant cst;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_let(Nonrecursive,
+             [{pvb_pat=spat; pvb_expr=sval; pvb_attributes=[]}], sbody)
+    when may_contain_gadts spat ->
+    (* TODO: allow non-empty attributes? *)
+      type_expect ?in_function env
+        {sexp with
+         pexp_desc = Pexp_match (sval, [Ast_helper.Exp.case spat sbody])}
+        ty_expected_explained
+  | Pexp_let(rec_flag, spat_sexp_list, sbody) ->
+      let existential_context =
+        if rec_flag = Recursive then In_rec
+        else if List.compare_length_with spat_sexp_list 1 > 0 then In_group
+        else With_attributes in
+      let scp =
+        match sexp.pexp_attributes, rec_flag with
+        | [{attr_name = {txt="#default"}; _}], _ -> None
+        | _, Recursive -> Some (Annot.Idef loc)
+        | _, Nonrecursive -> Some (Annot.Idef sbody.pexp_loc)
+      in
+      let (pat_exp_list, new_env, unpacks) =
+        type_let existential_context env rec_flag spat_sexp_list scp true in
+      let body =
+        type_expect new_env (wrap_unpacks sbody unpacks)
+          ty_expected_explained in
+      let () =
+        if rec_flag = Recursive then
+          check_recursive_bindings env pat_exp_list
+      in
+      re {
+        exp_desc = Texp_let(rec_flag, pat_exp_list, body);
+        exp_loc = loc; exp_extra = [];
+        exp_type = body.exp_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_fun (l, Some default, spat, sbody) ->
+      assert(is_optional l); (* default allowed only with optional argument *)
+      let open Ast_helper in
+      let default_loc = default.pexp_loc in
+      let scases = [
+        Exp.case
+          (Pat.construct ~loc:default_loc
+             (mknoloc (Longident.(Ldot (Lident "*predef*", "Some"))))
+             (Some (Pat.var ~loc:default_loc (mknoloc "*sth*"))))
+          (Exp.ident ~loc:default_loc (mknoloc (Longident.Lident "*sth*")));
+
+        Exp.case
+          (Pat.construct ~loc:default_loc
+             (mknoloc (Longident.(Ldot (Lident "*predef*", "None"))))
+             None)
+          default;
+       ]
+      in
+      let sloc =
+        { Location.loc_start = spat.ppat_loc.Location.loc_start;
+          loc_end = default_loc.Location.loc_end;
+          loc_ghost = true }
+      in
+      let smatch =
+        Exp.match_ ~loc:sloc
+          (Exp.ident ~loc (mknoloc (Longident.Lident "*opt*")))
+          scases
+      in
+      let pat = Pat.var ~loc:sloc (mknoloc "*opt*") in
+      let body =
+        Exp.let_ ~loc Nonrecursive
+          ~attrs:[Attr.mk (mknoloc "#default") (PStr [])]
+          [Vb.mk spat smatch] sbody
+      in
+      type_function ?in_function loc sexp.pexp_attributes env
+                    ty_expected_explained l [Exp.case pat body]
+  | Pexp_fun (l, None, spat, sbody) ->
+      type_function ?in_function loc sexp.pexp_attributes env
+                    ty_expected_explained l [Ast_helper.Exp.case spat sbody]
+  | Pexp_function caselist ->
+      type_function ?in_function
+        loc sexp.pexp_attributes env ty_expected_explained Nolabel caselist
+  | Pexp_apply(sfunct, sargs) ->
+      assert (sargs <> []);
+      begin_def (); (* one more level for non-returning functions *)
+      if !Clflags.principal then begin_def ();
+      let funct = type_exp env sfunct in
+      if !Clflags.principal then begin
+          end_def ();
+          generalize_structure funct.exp_type
+        end;
+      let rec lower_args seen ty_fun =
+        let ty = expand_head env ty_fun in
+        if List.memq ty seen then () else
+        match ty.desc with
+          Tarrow (_l, ty_arg, ty_fun, _com) ->
+            (try unify_var env (newvar()) ty_arg with Unify _ -> assert false);
+            lower_args (ty::seen) ty_fun
+        | _ -> ()
+      in
+      let ty = instance funct.exp_type in
+      end_def ();
+      wrap_trace_gadt_instances env (lower_args []) ty;
+      begin_def ();
+      let (args, ty_res) = type_application env funct sargs in
+      end_def ();
+      unify_var env (newvar()) funct.exp_type;
+      rue {
+        exp_desc = Texp_apply(funct, args);
+        exp_loc = loc; exp_extra = [];
+        exp_type = ty_res;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_match(sarg, caselist) ->
+      begin_def ();
+      let arg = type_exp env sarg in
+      end_def ();
+      if maybe_expansive arg then lower_contravariant env arg.exp_type;
+      generalize arg.exp_type;
+      let cases, partial =
+        type_cases ~exception_allowed:true env arg.exp_type ty_expected true loc
+          caselist
+      in
+      re {
+        exp_desc = Texp_match(arg, cases, partial);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance ty_expected;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_try(sbody, caselist) ->
+      let body = type_expect env sbody ty_expected_explained in
+      let cases, _ =
+        type_cases env Predef.type_exn ty_expected false loc caselist in
+      re {
+        exp_desc = Texp_try(body, cases);
+        exp_loc = loc; exp_extra = [];
+        exp_type = body.exp_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_tuple sexpl ->
+      assert (List.length sexpl >= 2);
+      let subtypes = List.map (fun _ -> newgenvar ()) sexpl in
+      let to_unify = newgenty (Ttuple subtypes) in
+      with_explanation (fun () ->
+        unify_exp_types loc env to_unify ty_expected);
+      let expl =
+        List.map2 (fun body ty -> type_expect env body (mk_expected ty))
+          sexpl subtypes
+      in
+      re {
+        exp_desc = Texp_tuple expl;
+        exp_loc = loc; exp_extra = [];
+        (* Keep sharing *)
+        exp_type = newty (Ttuple (List.map (fun e -> e.exp_type) expl));
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_construct(lid, sarg) ->
+      type_construct env loc lid sarg ty_expected_explained sexp.pexp_attributes
+  | Pexp_variant(l, sarg) ->
+      (* Keep sharing *)
+      let ty_expected0 = instance ty_expected in
+      begin try match
+        sarg, expand_head env ty_expected, expand_head env ty_expected0 with
+      | Some sarg, {desc = Tvariant row}, {desc = Tvariant row0} ->
+          let row = row_repr row in
+          begin match row_field_repr (List.assoc l row.row_fields),
+          row_field_repr (List.assoc l row0.row_fields) with
+            Rpresent (Some ty), Rpresent (Some ty0) ->
+              let arg = type_argument env sarg ty ty0 in
+              re { exp_desc = Texp_variant(l, Some arg);
+                   exp_loc = loc; exp_extra = [];
+                   exp_type = ty_expected0;
+                   exp_attributes = sexp.pexp_attributes;
+                   exp_env = env }
+          | _ -> raise Not_found
+          end
+      | _ -> raise Not_found
+      with Not_found ->
+        let arg = Option.map (type_exp env) sarg in
+        let arg_type = Option.map (fun arg -> arg.exp_type) arg in
+        rue {
+          exp_desc = Texp_variant(l, arg);
+          exp_loc = loc; exp_extra = [];
+          exp_type= newty (Tvariant{row_fields = [l, Rpresent arg_type];
+                                    row_more = newvar ();
+                                    row_bound = ();
+                                    row_closed = false;
+                                    row_fixed = None;
+                                    row_name = None});
+          exp_attributes = sexp.pexp_attributes;
+          exp_env = env }
+      end
+  | Pexp_record(lid_sexp_list, opt_sexp) ->
+      assert (lid_sexp_list <> []);
+      let opt_exp =
+        match opt_sexp with
+          None -> None
+        | Some sexp ->
+            if !Clflags.principal then begin_def ();
+            let exp = type_exp ~recarg env sexp in
+            if !Clflags.principal then begin
+              end_def ();
+              generalize_structure exp.exp_type
+            end;
+            Some exp
+      in
+      let ty_record, opath =
+        let get_path ty =
+          try
+            let (p0, p,_) = extract_concrete_record env ty in
+            let principal =
+              (repr ty).level = generic_level || not !Clflags.principal
+            in
+            Some (p0, p, principal)
+          with Not_found -> None
+        in
+        match get_path ty_expected with
+          None ->
+            begin match opt_exp with
+              None -> newvar (), None
+            | Some exp ->
+                match get_path exp.exp_type with
+                  None -> newvar (), None
+                | Some (_, p', _) as op ->
+                    let decl = Env.find_type p' env in
+                    begin_def ();
+                    let ty =
+                      newconstr p' (instance_list decl.type_params) in
+                    end_def ();
+                    generalize_structure ty;
+                    ty, op
+            end
+        | op -> ty_expected, op
+      in
+      let closed = (opt_sexp = None) in
+      let lbl_exp_list =
+        wrap_disambiguate "This record expression is expected to have"
+          (mk_expected ty_record)
+          (type_label_a_list loc closed env
+             (fun e k -> k (type_label_exp true env loc ty_record e))
+             opath lid_sexp_list)
+          (fun x -> x)
+      in
+      with_explanation (fun () ->
+        unify_exp_types loc env ty_record (instance ty_expected));
+
+      (* type_label_a_list returns a list of labels sorted by lbl_pos *)
+      (* note: check_duplicates would better be implemented in
+         type_label_a_list directly *)
+      let rec check_duplicates = function
+        | (_, lbl1, _) :: (_, lbl2, _) :: _ when lbl1.lbl_pos = lbl2.lbl_pos ->
+          raise(error(loc, env, Label_multiply_defined lbl1.lbl_name))
+        | _ :: rem ->
+            check_duplicates rem
+        | [] -> ()
+      in
+      check_duplicates lbl_exp_list;
+      let opt_exp, label_definitions =
+        let (_lid, lbl, _lbl_exp) = List.hd lbl_exp_list in
+        let matching_label lbl =
+          List.find
+            (fun (_, lbl',_) -> lbl'.lbl_pos = lbl.lbl_pos)
+            lbl_exp_list
+        in
+        match opt_exp with
+          None ->
+            let label_definitions =
+              Array.map (fun lbl ->
+                  match matching_label lbl with
+                  | (lid, _lbl, lbl_exp) ->
+                      Overridden (lid, lbl_exp)
+                  | exception Not_found ->
+                      let present_indices =
+                        List.map (fun (_, lbl, _) -> lbl.lbl_pos) lbl_exp_list
+                      in
+                      let label_names = extract_label_names env ty_expected in
+                      let rec missing_labels n = function
+                          [] -> []
+                        | lbl :: rem ->
+                            if List.mem n present_indices
+                            then missing_labels (n + 1) rem
+                            else lbl :: missing_labels (n + 1) rem
+                      in
+                      let missing = missing_labels 0 label_names in
+                      raise(error(loc, env, Label_missing missing)))
+                lbl.lbl_all
+            in
+            None, label_definitions
+        | Some exp ->
+            let ty_exp = instance exp.exp_type in
+            let unify_kept lbl =
+              let _, ty_arg1, ty_res1 = instance_label false lbl in
+              unify_exp_types exp.exp_loc env ty_exp ty_res1;
+              match matching_label lbl with
+              | lid, _lbl, lbl_exp ->
+                  (* do not connect result types for overridden labels *)
+                  Overridden (lid, lbl_exp)
+              | exception Not_found -> begin
+                  let _, ty_arg2, ty_res2 = instance_label false lbl in
+                  unify_exp_types loc env ty_arg1 ty_arg2;
+                  with_explanation (fun () ->
+                    unify_exp_types loc env (instance ty_expected) ty_res2);
+                  Kept ty_arg1
+                end
+            in
+            let label_definitions = Array.map unify_kept lbl.lbl_all in
+            Some {exp with exp_type = ty_exp}, label_definitions
+      in
+      let num_fields =
+        match lbl_exp_list with [] -> assert false
+        | (_, lbl,_)::_ -> Array.length lbl.lbl_all in
+      let opt_exp =
+        if opt_sexp <> None && List.length lid_sexp_list = num_fields then
+          (Location.prerr_warning loc Warnings.Useless_record_with; None)
+        else opt_exp
+      in
+      let label_descriptions, representation =
+        let (_, { lbl_all; lbl_repres }, _) = List.hd lbl_exp_list in
+        lbl_all, lbl_repres
+      in
+      let fields =
+        Array.map2 (fun descr def -> descr, def)
+          label_descriptions label_definitions
+      in
+      re {
+        exp_desc = Texp_record {
+            fields; representation;
+            extended_expression = opt_exp
+          };
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance ty_expected;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_field(srecord, lid) ->
+      let (record, label, _) = type_label_access env srecord lid in
+      let (_, ty_arg, ty_res) = instance_label false label in
+      unify_exp env record ty_res;
+      rue {
+        exp_desc = Texp_field(record, lid, label);
+        exp_loc = loc; exp_extra = [];
+        exp_type = ty_arg;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_setfield(srecord, lid, snewval) ->
+      let (record, label, opath) = type_label_access env srecord lid in
+      let ty_record = if opath = None then newvar () else record.exp_type in
+      let (label_loc, label, newval) =
+        type_label_exp false env loc ty_record (lid, label, snewval) in
+      unify_exp env record ty_record;
+      if label.lbl_mut = Immutable then
+        raise(error(loc, env, Label_not_mutable lid.txt));
+      rue {
+        exp_desc = Texp_setfield(record, label_loc, label, newval);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance Predef.type_unit;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_array(sargl) ->
+      let ty = newgenvar() in
+      let to_unify = Predef.type_array ty in
+      with_explanation (fun () ->
+        unify_exp_types loc env to_unify ty_expected);
+      let argl =
+        List.map (fun sarg -> type_expect env sarg (mk_expected ty)) sargl in
+      re {
+        exp_desc = Texp_array argl;
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance ty_expected;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_ifthenelse(scond, sifso, sifnot) ->
+      let cond = type_expect env scond
+          (mk_expected ~explanation:If_conditional Predef.type_bool) in
+      begin match sifnot with
+        None ->
+          let ifso = type_expect env sifso
+              (mk_expected ~explanation:If_no_else_branch Predef.type_unit) in
+          rue {
+            exp_desc = Texp_ifthenelse(cond, ifso, None);
+            exp_loc = loc; exp_extra = [];
+            exp_type = ifso.exp_type;
+            exp_attributes = sexp.pexp_attributes;
+            exp_env = env }
+      | Some sifnot ->
+          let ifso = type_expect env sifso ty_expected_explained in
+          let ifnot = type_expect env sifnot ty_expected_explained in
+          (* Keep sharing *)
+          unify_exp env ifnot ifso.exp_type;
+          re {
+            exp_desc = Texp_ifthenelse(cond, ifso, Some ifnot);
+            exp_loc = loc; exp_extra = [];
+            exp_type = ifso.exp_type;
+            exp_attributes = sexp.pexp_attributes;
+            exp_env = env }
+      end
+  | Pexp_sequence(sexp1, sexp2) ->
+      let exp1 = type_statement ~explanation:Sequence_left_hand_side
+          env sexp1 in
+      let exp2 = type_expect env sexp2 ty_expected_explained in
+      re {
+        exp_desc = Texp_sequence(exp1, exp2);
+        exp_loc = loc; exp_extra = [];
+        exp_type = exp2.exp_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_while(scond, sbody) ->
+      let cond = type_expect env scond
+          (mk_expected ~explanation:While_loop_conditional Predef.type_bool) in
+      let body = type_statement ~explanation:While_loop_body env sbody in
+      rue {
+        exp_desc = Texp_while(cond, body);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance Predef.type_unit;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_for(param, slow, shigh, dir, sbody) ->
+      let low = type_expect env slow
+          (mk_expected ~explanation:For_loop_start_index Predef.type_int) in
+      let high = type_expect env shigh
+          (mk_expected ~explanation:For_loop_stop_index Predef.type_int) in
+      let id, new_env =
+        match param.ppat_desc with
+        | Ppat_any -> Ident.create_local "_for", env
+        | Ppat_var {txt} ->
+            Env.enter_value txt {val_type = instance Predef.type_int;
+                                 val_attributes = [];
+                                 val_kind = Val_reg; Types.val_loc = loc; } env
+              ~check:(fun s -> Warnings.Unused_for_index s)
+        | _ ->
+            raise (error (param.ppat_loc, env, Invalid_for_loop_index))
+      in
+      let body = type_statement ~explanation:For_loop_body new_env sbody in
+      rue {
+        exp_desc = Texp_for(id, param, low, high, dir, body);
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance Predef.type_unit;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_constraint (sarg, sty) ->
+      (* Pretend separate = true, 1% slowdown for lablgtk *)
+      begin_def ();
+      let cty = Typetexp.transl_simple_type env false sty in
+      let ty = cty.ctyp_type in
+      end_def ();
+      generalize_structure ty;
+      let (arg, ty') = (type_argument env sarg ty (instance ty), instance ty) in
+      rue {
+        exp_desc = arg.exp_desc;
+        exp_loc = arg.exp_loc;
+        exp_type = ty';
+        exp_attributes = arg.exp_attributes;
+        exp_env = env;
+        exp_extra =
+          (Texp_constraint cty, loc, sexp.pexp_attributes) :: arg.exp_extra;
+      }
+  | Pexp_coerce(sarg, sty, sty') ->
+      (* Pretend separate = true, 1% slowdown for lablgtk *)
+      (* Also see PR#7199 for a problem with the following:
+         let separate = !Clflags.principal || Env.has_local_constraints env in*)
+      let (arg, ty',cty,cty') =
+        match sty with
+        | None ->
+            let (cty', force) =
+              Typetexp.transl_simple_type_delayed env sty'
+            in
+            let ty' = cty'.ctyp_type in
+            begin_def ();
+            let arg = type_exp env sarg in
+            end_def ();
+            let tv = newvar () in
+            let gen = generalizable tv.level arg.exp_type in
+            unify_var env tv arg.exp_type;
+            begin match arg.exp_desc, !self_coercion, (repr ty').desc with
+              Texp_ident(_, _, {val_kind=Val_self _}), (path,r) :: _,
+              Tconstr(path',_,_) when Path.same path path' ->
+                (* prerr_endline "self coercion"; *)
+                r := loc :: !r;
+                force ()
+            | _ when free_variables ~env arg.exp_type = []
+                  && free_variables ~env ty' = [] ->
+                if not gen && (* first try a single coercion *)
+                  let snap = snapshot () in
+                  let ty, _b = enlarge_type env ty' in
+                  try
+                    force (); Ctype.unify env arg.exp_type ty; true
+                  with Unify _ ->
+                    backtrack snap; false
+                then ()
+                else begin try
+                  let force' = subtype env arg.exp_type ty' in
+                  force (); force' ();
+                  if not gen && !Clflags.principal then
+                    Location.prerr_warning loc
+                      (Warnings.Not_principal "this ground coercion");
+                with Subtype (tr1, tr2) ->
+                  (* prerr_endline "coercion failed"; *)
+                  raise(error(loc, env, Not_subtype(tr1, tr2)))
+                end;
+            | _ ->
+                let ty, b = enlarge_type env ty' in
+                force ();
+                begin try Ctype.unify env arg.exp_type ty with Unify trace ->
+                  raise(error(sarg.pexp_loc, env,
+                        Coercion_failure(ty', full_expand env ty', trace, b)))
+                end
+            end;
+            (arg, ty', None, cty')
+        | Some sty ->
+            begin_def ();
+            let (cty, force) =
+              Typetexp.transl_simple_type_delayed env sty
+            and (cty', force') =
+              Typetexp.transl_simple_type_delayed env sty'
+            in
+            let ty = cty.ctyp_type in
+            let ty' = cty'.ctyp_type in
+            begin try
+              let force'' = subtype env ty ty' in
+              force (); force' (); force'' ()
+            with Subtype (tr1, tr2) ->
+              raise(error(loc, env, Not_subtype(tr1, tr2)))
+            end;
+            end_def ();
+            generalize_structure ty;
+            generalize_structure ty';
+            (type_argument env sarg ty (instance ty),
+             instance ty', Some cty, cty')
+      in
+      rue {
+        exp_desc = arg.exp_desc;
+        exp_loc = arg.exp_loc;
+        exp_type = ty';
+        exp_attributes = arg.exp_attributes;
+        exp_env = env;
+        exp_extra = (Texp_coerce (cty, cty'), loc, sexp.pexp_attributes) ::
+                       arg.exp_extra;
+      }
+  | Pexp_send (e, {txt=met}) ->
+      if !Clflags.principal then begin_def ();
+      let obj = type_exp env e in
+      let obj_meths = ref None in
+      begin try
+        let (meth, exp, typ) =
+          match obj.exp_desc with
+            Texp_ident(_path, _, {val_kind = Val_self (meths, _, _, privty)}) ->
+              obj_meths := Some meths;
+              let (id, typ) =
+                filter_self_method env met Private meths privty
+              in
+              if is_Tvar (repr typ) then
+                Location.prerr_warning loc
+                  (Warnings.Undeclared_virtual_method met);
+              (Tmeth_val id, None, typ)
+          | Texp_ident(_path, lid, {val_kind = Val_anc (methods, cl_num)}) ->
+              let method_id =
+                begin try List.assoc met methods with Not_found ->
+                  let valid_methods = List.map fst methods in
+                  raise(error(e.pexp_loc, env,
+                              Undefined_inherited_method (met, valid_methods)))
+                end
+              in
+              begin match
+                Env.find_value_by_name
+                  (Longident.Lident ("selfpat-" ^ cl_num)) env,
+                Env.find_value_by_name
+                  (Longident.Lident ("self-" ^cl_num)) env
+              with
+              | (_, ({val_kind = Val_self (meths, _, _, privty)} as desc)),
+                (path, _) ->
+                  obj_meths := Some meths;
+                  let (_, typ) =
+                    filter_self_method env met Private meths privty
+                  in
+                  let method_type = newvar () in
+                  let (obj_ty, res_ty) = filter_arrow env method_type Nolabel in
+                  unify env obj_ty desc.val_type;
+                  unify env res_ty (instance typ);
+                  let method_desc =
+                    {val_type = method_type;
+                     val_kind = Val_reg;
+                     val_attributes = [];
+                     Types.val_loc = Location.none}
+                  in
+                  let exp_env = Env.add_value method_id method_desc env in
+                  let exp =
+                    Texp_apply({exp_desc =
+                                Texp_ident(Path.Pident method_id,
+                                           lid, method_desc);
+                                exp_loc = loc; exp_extra = [];
+                                exp_type = method_type;
+                                exp_attributes = []; (* check *)
+                                exp_env = exp_env},
+                          [ Nolabel,
+                            Some {exp_desc = Texp_ident(path, lid, desc);
+                                  exp_loc = obj.exp_loc; exp_extra = [];
+                                  exp_type = desc.val_type;
+                                  exp_attributes = []; (* check *)
+                                  exp_env = exp_env}
+                          ])
+                  in
+                  (Tmeth_name met, Some (re {exp_desc = exp;
+                                             exp_loc = loc; exp_extra = [];
+                                             exp_type = typ;
+                                             exp_attributes = []; (* check *)
+                                             exp_env = exp_env}), typ)
+              |  _ ->
+                  assert false
+              end
+          | _ ->
+              (Tmeth_name met, None,
+               filter_method env met Public obj.exp_type)
+        in
+        if !Clflags.principal then begin
+          end_def ();
+          generalize_structure typ;
+        end;
+        let typ =
+          match repr typ with
+            {desc = Tpoly (ty, [])} ->
+              instance ty
+          | {desc = Tpoly (ty, tl); level = l} ->
+              if !Clflags.principal && l <> generic_level then
+                Location.prerr_warning loc
+                  (Warnings.Not_principal "this use of a polymorphic method");
+              snd (instance_poly false tl ty)
+          | {desc = Tvar _} as ty ->
+              let ty' = newvar () in
+              unify env (instance ty) (newty(Tpoly(ty',[])));
+              (* if not !Clflags.nolabels then
+                 Location.prerr_warning loc (Warnings.Unknown_method met); *)
+              ty'
+          | _ ->
+              assert false
+        in
+        rue {
+          exp_desc = Texp_send(obj, meth, exp);
+          exp_loc = loc; exp_extra = [];
+          exp_type = typ;
+          exp_attributes = sexp.pexp_attributes;
+          exp_env = env }
+      with Unify _ ->
+        let valid_methods =
+          match !obj_meths with
+          | Some meths ->
+             Some (Meths.fold (fun meth _meth_ty li -> meth::li) !meths [])
+          | None ->
+             match (expand_head env obj.exp_type).desc with
+             | Tobject (fields, _) ->
+                let (fields, _) = Ctype.flatten_fields fields in
+                let collect_fields li (meth, meth_kind, _meth_ty) =
+                  if meth_kind = Fpresent then meth::li else li in
+                Some (List.fold_left collect_fields [] fields)
+             | _ -> None
+        in
+        Msupport.erroneous_type_register ty_expected;
+        raise_error
+          (error(e.pexp_loc, env,
+                 Undefined_method (obj.exp_type, met, valid_methods)));
+        rue {
+          exp_desc = Texp_send(obj, Tmeth_name met, None);
+          exp_loc = loc; exp_extra = [];
+          exp_type = ty_expected;
+          exp_attributes = merlin_recovery_attributes sexp.pexp_attributes;
+          exp_env = env;
+        }
+      end
+  | Pexp_new cl ->
+      let (cl_path, cl_decl) = Env.lookup_class ~loc:cl.loc cl.txt env in
+      begin match cl_decl.cty_new with
+          None ->
+            raise(error(loc, env, Virtual_class cl.txt))
+        | Some ty ->
+            rue {
+              exp_desc = Texp_new (cl_path, cl, cl_decl);
+              exp_loc = loc; exp_extra = [];
+              exp_type = instance ty;
+              exp_attributes = sexp.pexp_attributes;
+              exp_env = env }
+        end
+  | Pexp_setinstvar (lab, snewval) -> begin
+      let (path, mut, cl_num, ty) =
+        Env.lookup_instance_variable ~loc lab.txt env
+      in
+      match mut with
+      | Mutable ->
+          let newval =
+            type_expect env snewval (mk_expected (instance ty))
+          in
+          let (path_self, _) =
+            Env.find_value_by_name (Longident.Lident ("self-" ^ cl_num)) env
+          in
+          rue {
+            exp_desc = Texp_setinstvar(path_self, path, lab, newval);
+            exp_loc = loc; exp_extra = [];
+            exp_type = instance Predef.type_unit;
+            exp_attributes = sexp.pexp_attributes;
+            exp_env = env }
+      | _ ->
+          raise(error(loc, env, Instance_variable_not_mutable lab.txt))
+    end
+  | Pexp_override lst ->
+      let _ =
+       List.fold_right
+        (fun (lab, _) l ->
+           if List.exists (fun l -> l.txt = lab.txt) l then
+             raise(error(loc, env,
+                         Value_multiply_overridden lab.txt));
+           lab::l)
+        lst
+        [] in
+      begin match
+        try
+          Env.find_value_by_name (Longident.Lident "selfpat-*") env,
+          Env.find_value_by_name (Longident.Lident "self-*") env
+        with Not_found ->
+          raise(error(loc, env, Outside_class))
+      with
+        (_, {val_type = self_ty; val_kind = Val_self (_, vars, _, _)}),
+        (path_self, _) ->
+          let type_override (lab, snewval) =
+            begin try
+              let (id, _, _, ty) = Vars.find lab.txt !vars in
+              (Path.Pident id, lab,
+               type_expect env snewval (mk_expected (instance ty)))
+            with
+              Not_found ->
+                let vars = Vars.fold (fun var _ li -> var::li) !vars [] in
+                raise(error(loc, env,
+                            Unbound_instance_variable (lab.txt, vars)))
+            end
+          in
+          let modifs = List.map type_override lst in
+          rue {
+            exp_desc = Texp_override(path_self, modifs);
+            exp_loc = loc; exp_extra = [];
+            exp_type = self_ty;
+            exp_attributes = sexp.pexp_attributes;
+            exp_env = env }
+      | _ ->
+          assert false
+      end
+  | Pexp_letmodule(name, smodl, sbody) ->
+      let ty = newvar() in
+      (* remember original level *)
+      begin_def ();
+      let context = Typetexp.narrow () in
+      let modl = !type_module env smodl in
+      Mtype.lower_nongen ty.level modl.mod_type;
+      let pres =
+        match modl.mod_type with
+        | Mty_alias _ -> Mp_absent
+        | _ -> Mp_present
+      in
+      let scope = create_scope () in
+      let md =
+        { md_type = modl.mod_type; md_attributes = []; md_loc = name.loc }
+      in
+      let (id, new_env) =
+        match name.txt with
+        | None -> None, env
+        | Some name ->
+          let id, env = Env.enter_module_declaration ~scope name pres md env in
+          Some id, env
+      in
+      Typetexp.widen context;
+      (* ideally, we should catch Expr_type_clash errors
+         in type_expect triggered by escaping identifiers from the local module
+         and refine them into Scoping_let_module errors
+      *)
+      let body = type_expect new_env sbody ty_expected_explained in
+      (* go back to original level *)
+      end_def ();
+      Ctype.unify_var new_env ty body.exp_type;
+      re {
+        exp_desc = Texp_letmodule(id, name, pres, modl, body);
+        exp_loc = loc; exp_extra = [];
+        exp_type = ty;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_letexception(cd, sbody) ->
+      let (cd, newenv) = Typedecl.transl_exception env cd in
+      let body = type_expect newenv sbody ty_expected_explained in
+      re {
+        exp_desc = Texp_letexception(cd, body);
+        exp_loc = loc; exp_extra = [];
+        exp_type = body.exp_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+
+  | Pexp_assert (e) ->
+      let cond = type_expect env e
+          (mk_expected ~explanation:Assert_condition Predef.type_bool) in
+      let exp_type =
+        match cond.exp_desc with
+        | Texp_construct(_, {cstr_name="false"}, _) ->
+            instance ty_expected
+        | _ ->
+            instance Predef.type_unit
+      in
+      rue {
+        exp_desc = Texp_assert cond;
+        exp_loc = loc; exp_extra = [];
+        exp_type;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env;
+      }
+  | Pexp_lazy e ->
+      let ty = newgenvar () in
+      let to_unify = Predef.type_lazy_t ty in
+      with_explanation (fun () ->
+        unify_exp_types loc env to_unify ty_expected);
+      let arg = type_expect env e (mk_expected ty) in
+      re {
+        exp_desc = Texp_lazy arg;
+        exp_loc = loc; exp_extra = [];
+        exp_type = instance ty_expected;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env;
+      }
+  | Pexp_object s ->
+      let desc, sign, meths = !type_object env loc s in
+      rue {
+        exp_desc = Texp_object (desc, (*sign,*) meths);
+        exp_loc = loc; exp_extra = [];
+        exp_type = sign.csig_self;
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env;
+      }
+  | Pexp_poly(sbody, sty) ->
+      if !Clflags.principal then begin_def ();
+      let ty, cty =
+        match sty with None -> repr ty_expected, None
+        | Some sty ->
+            let sty = Ast_helper.Typ.force_poly sty in
+            let cty = Typetexp.transl_simple_type env false sty in
+            repr cty.ctyp_type, Some cty
+      in
+      if !Clflags.principal then begin
+        end_def ();
+        generalize_structure ty
+      end;
+      if sty <> None then
+        with_explanation (fun () ->
+          unify_exp_types loc env (instance ty) (instance ty_expected));
+      let exp =
+        match (expand_head env ty).desc with
+          Tpoly (ty', []) ->
+            let exp = type_expect env sbody (mk_expected ty') in
+            { exp with exp_type = instance ty }
+        | Tpoly (ty', tl) ->
+            (* One more level to generalize locally *)
+            begin_def ();
+            if !Clflags.principal then begin_def ();
+            let vars, ty'' = instance_poly true tl ty' in
+            if !Clflags.principal then begin
+              end_def ();
+              generalize_structure ty''
+            end;
+            let exp = type_expect env sbody (mk_expected ty'') in
+            end_def ();
+            check_univars env false "method" exp ty_expected vars;
+            { exp with exp_type = instance ty }
+        | Tvar _ ->
+            let exp = type_exp env sbody in
+            let exp = {exp with exp_type = newty (Tpoly (exp.exp_type, []))} in
+            unify_exp env exp ty;
+            exp
+        | _ -> assert false
+      in
+      re { exp with exp_extra =
+             (Texp_poly cty, loc, sexp.pexp_attributes) :: exp.exp_extra }
+  | Pexp_newtype({txt=name}, sbody) ->
+      let ty =
+        if Typetexp.valid_tyvar_name name then
+          newvar ~name ()
+        else
+          newvar ()
+      in
+      (* remember original level *)
+      begin_def ();
+      (* Create a fake abstract type declaration for name. *)
+      let decl = {
+        type_params = [];
+        type_arity = 0;
+        type_kind = Type_abstract;
+        type_private = Public;
+        type_manifest = None;
+        type_variance = [];
+        type_is_newtype = true;
+        type_expansion_scope = Btype.lowest_level;
+        type_loc = loc;
+        type_attributes = [];
+        type_immediate = Unknown;
+        type_unboxed = unboxed_false_default_false;
+      }
+      in
+      let scope = create_scope () in
+      let (id, new_env) = Env.enter_type ~scope name decl env in
+
+      let body = type_exp new_env sbody in
+      (* Replace every instance of this type constructor in the resulting
+         type. *)
+      let seen = Hashtbl.create 8 in
+      let rec replace t =
+        if Hashtbl.mem seen t.id then ()
+        else begin
+          Hashtbl.add seen t.id ();
+          match t.desc with
+          | Tconstr (Path.Pident id', _, _) when id == id' -> link_type t ty
+          | _ -> Btype.iter_type_expr replace t
+        end
+      in
+      let ety = Subst.type_expr Subst.identity body.exp_type in
+      replace ety;
+      (* back to original level *)
+      end_def ();
+      (* lower the levels of the result type *)
+      (* unify_var env ty ety; *)
+
+      (* non-expansive if the body is non-expansive, so we don't introduce
+         any new extra node in the typed AST. *)
+      rue { body with exp_loc = loc; exp_type = ety;
+            exp_extra =
+            (Texp_newtype name, loc, sexp.pexp_attributes) :: body.exp_extra }
+  | Pexp_pack m ->
+      let (p, nl) =
+        match Ctype.expand_head env (instance ty_expected) with
+          {desc = Tpackage (p, nl, _tl)} ->
+            if !Clflags.principal &&
+              (Ctype.expand_head env ty_expected).level < Btype.generic_level
+            then
+              Location.prerr_warning loc
+                (Warnings.Not_principal "this module packing");
+            (p, nl)
+        | {desc = Tvar _} ->
+            raise (error (loc, env, Cannot_infer_signature))
+        | _ ->
+            raise (error (loc, env, Not_a_packed_module ty_expected))
+      in
+      let (modl, tl') = !type_package env m p nl in
+      rue {
+        exp_desc = Texp_pack modl;
+        exp_loc = loc; exp_extra = [];
+        exp_type = newty (Tpackage (p, nl, tl'));
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env }
+  | Pexp_open (od, e) ->
+      let (od, _, newenv) = !type_open_decl env od in
+      let exp = type_expect newenv e ty_expected_explained in
+      rue {
+        exp_desc = Texp_open (od, exp);
+        exp_type = exp.exp_type;
+        exp_loc = loc;
+        exp_extra = [];
+        exp_attributes = sexp.pexp_attributes;
+        exp_env = env;
+      }
+  | Pexp_letop{ let_ = slet; ands = sands; body = sbody } ->
+      let rec loop spat_acc ty_acc sands =
+        match sands with
+        | [] -> spat_acc, ty_acc
+        | { pbop_pat = spat; _} :: rest ->
+            let ty = newvar () in
+            let loc = { slet.pbop_op.loc with Location.loc_ghost = true } in
+            let spat_acc = Ast_helper.Pat.tuple ~loc [spat_acc; spat] in
+            let ty_acc = newty (Ttuple [ty_acc; ty]) in
+            loop spat_acc ty_acc rest
+      in
+      if !Clflags.principal then begin_def ();
+      let let_loc = slet.pbop_op.loc in
+      let op_path, op_desc = type_binding_op_ident env slet.pbop_op in
+      let op_type = instance op_desc.val_type in
+      let spat_params, ty_params = loop slet.pbop_pat (newvar ()) sands in
+      let ty_func_result = newvar () in
+      let ty_func = newty (Tarrow(Nolabel, ty_params, ty_func_result, Cok)) in
+      let ty_result = newvar () in
+      let ty_andops = newvar () in
+      let ty_op =
+        newty (Tarrow(Nolabel, ty_andops,
+          newty (Tarrow(Nolabel, ty_func, ty_result, Cok)), Cok))
+      in
+      begin try
+        unify env op_type ty_op
+      with Unify trace ->
+        raise(error(let_loc, env, Letop_type_clash(slet.pbop_op.txt, trace)))
+      end;
+      if !Clflags.principal then begin
+        end_def ();
+        generalize_structure ty_andops;
+        generalize_structure ty_params;
+        generalize_structure ty_func_result;
+        generalize_structure ty_result
+      end;
+      let exp, ands = type_andops env slet.pbop_exp sands ty_andops in
+      let scase = Ast_helper.Exp.case spat_params sbody in
+      let cases, partial =
+        type_cases env ty_params ty_func_result true loc [scase]
+      in
+      let body =
+        match cases with
+        | [case] -> case
+        | _ -> assert false
+      in
+      let param = name_cases "param" cases in
+      let let_ =
+        { bop_op_name = slet.pbop_op;
+          bop_op_path = op_path;
+          bop_op_val = op_desc;
+          bop_op_type = op_type;
+          bop_exp = exp;
+          bop_loc = slet.pbop_loc; }
+      in
+      let desc =
+        Texp_letop{let_; ands; param; body; partial}
+      in
+      rue { exp_desc = desc;
+            exp_loc = sexp.pexp_loc;
+            exp_extra = [];
+            exp_type = instance ty_result;
+            exp_env = env;
+            exp_attributes = sexp.pexp_attributes; }
+
+  | Pexp_extension ({ txt = ("ocaml.extension_constructor"
+                             |"extension_constructor"); _ },
+                    payload) ->
+      begin match payload with
+      | PStr [ { pstr_desc =
+                   Pstr_eval ({ pexp_desc = Pexp_construct (lid, None); _ }, _)
+               } ] ->
+          let path =
+            let cd =
+              Env.lookup_constructor Env.Positive ~loc:lid.loc lid.txt env
+            in
+            match cd.cstr_tag with
+            | Cstr_extension (path, _) -> path
+            | _ -> raise (error (lid.loc, env, Not_an_extension_constructor))
+          in
+          rue {
+            exp_desc = Texp_extension_constructor (lid, path);
+            exp_loc = loc; exp_extra = [];
+            exp_type = instance Predef.type_extension_constructor;
+            exp_attributes = sexp.pexp_attributes;
+            exp_env = env }
+      | _ ->
+          raise (error (loc, env, Invalid_extension_constructor_payload))
+      end
+
+  | Pexp_extension ({ txt = "merlin.hole"; _ } as s, payload) ->
+    let attr = Ast_helper.Attr.mk s payload in
+    re { exp_desc = Texp_ident
+                      (Path.Pident (Ident.create_local "*type-hole*"),
+                       Location.mkloc (Longident.Lident "*type-hole*") loc,
+                       { Types.
+                         val_type = ty_expected;
+                         val_kind = Val_reg;
+                         val_loc = loc;
+                         val_attributes = [];
+                       });
+         exp_loc = loc; exp_extra = [];
+         exp_type = instance ty_expected;
+         exp_attributes = attr :: sexp.pexp_attributes;
+         exp_env = env }
+
+  | Pexp_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+  | Pexp_unreachable ->
+      re { exp_desc = Texp_unreachable;
+           exp_loc = loc; exp_extra = [];
+           exp_type = instance ty_expected;
+           exp_attributes = sexp.pexp_attributes;
+           exp_env = env }
+
+and type_ident env ?(recarg=Rejected) lid =
+  let (path, desc) = Env.lookup_value ~loc:lid.loc lid.txt env in
+  if !Clflags.annotations then begin
+    let dloc = desc.Types.val_loc in
+    let annot =
+      if dloc.Location.loc_ghost then Annot.Iref_external
+      else Annot.Iref_internal dloc
+    in
+    let name = Path.name ~paren:Oprint.parenthesized_ident path in
+    Stypes.record (Stypes.An_ident (lid.loc, name, annot))
+  end;
+  let is_recarg =
+    match (repr desc.val_type).desc with
+    | Tconstr(p, _, _) -> Path.is_constructor_typath p
+    | _ -> false
+  in
+  begin match is_recarg, recarg, (repr desc.val_type).desc with
+  | _, Allowed, _
+  | true, Required, _
+  | false, Rejected, _ -> ()
+  | true, Rejected, _
+  | false, Required, (Tvar _ | Tconstr _) ->
+      raise (error (lid.loc, env, Inlined_record_escape))
+  | false, Required, _  -> () (* will fail later *)
+  end;
+  path, desc
+
+and type_binding_op_ident env s =
+  let loc = s.loc in
+  let lid = Location.mkloc (Longident.Lident s.txt) loc in
+  let path, desc = type_ident env lid in
+  let path =
+    match desc.val_kind with
+    | Val_ivar _ ->
+        fatal_error "Illegal name for instance variable"
+    | Val_self (_, _, cl_num, _) ->
+        let path, _ =
+          Env.find_value_by_name (Longident.Lident ("self-" ^ cl_num)) env
+        in
+        path
+    | _ -> path
+  in
+  path, desc
+
+and type_function ?in_function loc attrs env ty_expected_explained l caselist =
+  let { ty = ty_expected; explanation } = ty_expected_explained in
+  let (loc_fun, ty_fun) =
+    match in_function with Some p -> p
+    | None -> (loc, instance ty_expected)
+  in
+  let separate = !Clflags.principal || Env.has_local_constraints env in
+  if separate then begin_def ();
+  let (ty_arg, ty_res) =
+    try filter_arrow env (instance ty_expected) l
+    with Unify _ ->
+      match expand_head env ty_expected with
+        {desc = Tarrow _} as ty ->
+          raise(error(loc, env, Abstract_wrong_label(l, ty, explanation)))
+      | _ ->
+          raise(error(loc_fun, env,
+                      Too_many_arguments (in_function <> None,
+                                          ty_fun,
+                                          explanation)))
+  in
+  let ty_arg =
+    if is_optional l then
+      let tv = newvar() in
+      begin
+        try unify env ty_arg (type_option tv)
+        with Unify _ -> assert false
+      end;
+      type_option tv
+    else ty_arg
+  in
+  if separate then begin
+    end_def ();
+    generalize_structure ty_arg;
+    generalize_structure ty_res
+  end;
+  let cases, partial =
+    type_cases ~in_function:(loc_fun,ty_fun) env ty_arg ty_res
+      true loc caselist in
+  let not_function ty =
+    let ls, tvar = list_labels env ty in
+    ls = [] && not tvar
+  in
+  if is_optional l && not_function ty_res then
+    Location.prerr_warning (List.hd cases).c_lhs.pat_loc
+      Warnings.Unerasable_optional_argument;
+  let param = name_cases "param" cases in
+  re {
+    exp_desc = Texp_function { arg_label = l; param; cases; partial; };
+    exp_loc = loc; exp_extra = [];
+    exp_type = instance (newgenty (Tarrow(l, ty_arg, ty_res, Cok)));
+    exp_attributes = attrs;
+    exp_env = env }
+
+
+and type_label_access env srecord lid =
+  if !Clflags.principal then begin_def ();
+  let record = type_exp ~recarg:Allowed env srecord in
+  if !Clflags.principal then begin
+    end_def ();
+    generalize_structure record.exp_type
+  end;
+  let ty_exp = record.exp_type in
+  let opath =
+    try
+      let (p0, p,_) = extract_concrete_record env ty_exp in
+      Some(p0, p, (repr ty_exp).level = generic_level || not !Clflags.principal)
+    with Not_found -> None
+  in
+  try
+    let labels = Env.lookup_all_labels ~loc:lid.loc lid.txt env in
+    let label =
+      wrap_disambiguate "This expression has" (mk_expected ty_exp)
+        (Label.disambiguate () lid env opath) labels in
+    (record, label, opath)
+  with exn ->
+    raise_error exn;
+    let fake_label = {
+      lbl_name = "";
+      lbl_res = ty_exp;
+      lbl_arg = newvar ();
+      lbl_mut = Mutable;
+      lbl_pos = 0;
+      lbl_all = [||];
+      lbl_repres = Record_regular;
+      lbl_private = Public;
+      lbl_loc = lid.loc;
+      lbl_attributes = [];
+
+    } in
+    (record, fake_label, opath)
+
+(* Typing format strings for printing or reading.
+   These formats are used by functions in modules Printf, Format, and Scanf.
+   (Handling of * modifiers contributed by Thorsten Ohl.) *)
+
+and type_format loc str env =
+  let loc = {loc with Location.loc_ghost = true} in
+  try
+    CamlinternalFormatBasics.(CamlinternalFormat.(
+      let mk_exp_loc pexp_desc = {
+        pexp_desc = pexp_desc;
+        pexp_loc = loc;
+        pexp_loc_stack = [];
+        pexp_attributes = [];
+      } and mk_lid_loc lid = {
+        txt = lid;
+        loc = loc;
+      } in
+      let mk_constr name args =
+        let lid = Longident.(Ldot(Lident "CamlinternalFormatBasics", name)) in
+        let arg = match args with
+          | []          -> None
+          | [ e ]       -> Some e
+          | _ :: _ :: _ -> Some (mk_exp_loc (Pexp_tuple args)) in
+        mk_exp_loc (Pexp_construct (mk_lid_loc lid, arg)) in
+      let mk_cst cst = mk_exp_loc (Pexp_constant cst) in
+      let mk_int n = mk_cst (Pconst_integer (Int.to_string n, None))
+      and mk_string str = mk_cst (Pconst_string (str, None))
+      and mk_char chr = mk_cst (Pconst_char chr) in
+      let rec mk_formatting_lit fmting = match fmting with
+        | Close_box ->
+          mk_constr "Close_box" []
+        | Close_tag ->
+          mk_constr "Close_tag" []
+        | Break (org, ns, ni) ->
+          mk_constr "Break" [ mk_string org; mk_int ns; mk_int ni ]
+        | FFlush ->
+          mk_constr "FFlush" []
+        | Force_newline ->
+          mk_constr "Force_newline" []
+        | Flush_newline ->
+          mk_constr "Flush_newline" []
+        | Magic_size (org, sz) ->
+          mk_constr "Magic_size" [ mk_string org; mk_int sz ]
+        | Escaped_at ->
+          mk_constr "Escaped_at" []
+        | Escaped_percent ->
+          mk_constr "Escaped_percent" []
+        | Scan_indic c ->
+          mk_constr "Scan_indic" [ mk_char c ]
+      and mk_formatting_gen : type a b c d e f .
+          (a, b, c, d, e, f) formatting_gen -> Parsetree.expression =
+        fun fmting -> match fmting with
+        | Open_tag (Format (fmt', str')) ->
+          mk_constr "Open_tag" [ mk_format fmt' str' ]
+        | Open_box (Format (fmt', str')) ->
+          mk_constr "Open_box" [ mk_format fmt' str' ]
+      and mk_format : type a b c d e f .
+          (a, b, c, d, e, f) CamlinternalFormatBasics.fmt -> string ->
+          Parsetree.expression = fun fmt str ->
+        mk_constr "Format" [ mk_fmt fmt; mk_string str ]
+      and mk_side side = match side with
+        | Left  -> mk_constr "Left"  []
+        | Right -> mk_constr "Right" []
+        | Zeros -> mk_constr "Zeros" []
+      and mk_iconv iconv = match iconv with
+        | Int_d  -> mk_constr "Int_d"  [] | Int_pd -> mk_constr "Int_pd" []
+        | Int_sd -> mk_constr "Int_sd" [] | Int_i  -> mk_constr "Int_i"  []
+        | Int_pi -> mk_constr "Int_pi" [] | Int_si -> mk_constr "Int_si" []
+        | Int_x  -> mk_constr "Int_x"  [] | Int_Cx -> mk_constr "Int_Cx" []
+        | Int_X  -> mk_constr "Int_X"  [] | Int_CX -> mk_constr "Int_CX" []
+        | Int_o  -> mk_constr "Int_o"  [] | Int_Co -> mk_constr "Int_Co" []
+        | Int_u  -> mk_constr "Int_u"  [] | Int_Cd -> mk_constr "Int_Cd" []
+        | Int_Ci -> mk_constr "Int_Ci" [] | Int_Cu -> mk_constr "Int_Cu" []
+      and mk_fconv fconv =
+        let flag = match fst fconv with
+        | Float_flag_ -> mk_constr "Float_flag_" []
+        | Float_flag_p -> mk_constr "Float_flag_p" []
+        | Float_flag_s -> mk_constr "Float_flag_s" [] in
+        let kind = match snd fconv with
+        | Float_f  -> mk_constr "Float_f"  []
+        | Float_e  -> mk_constr "Float_e"  []
+        | Float_E  -> mk_constr "Float_E"  []
+        | Float_g  -> mk_constr "Float_g"  []
+        | Float_G  -> mk_constr "Float_G"  []
+        | Float_h  -> mk_constr "Float_h"  []
+        | Float_H  -> mk_constr "Float_H"  []
+        | Float_F  -> mk_constr "Float_F"  []
+        | Float_CF -> mk_constr "Float_CF" [] in
+        mk_exp_loc (Pexp_tuple [flag; kind])
+      and mk_counter cnt = match cnt with
+        | Line_counter  -> mk_constr "Line_counter"  []
+        | Char_counter  -> mk_constr "Char_counter"  []
+        | Token_counter -> mk_constr "Token_counter" []
+      and mk_int_opt n_opt = match n_opt with
+        | None ->
+          let lid_loc = mk_lid_loc (Longident.Lident "None") in
+          mk_exp_loc (Pexp_construct (lid_loc, None))
+        | Some n ->
+          let lid_loc = mk_lid_loc (Longident.Lident "Some") in
+          mk_exp_loc (Pexp_construct (lid_loc, Some (mk_int n)))
+      and mk_fmtty : type a b c d e f g h i j k l .
+          (a, b, c, d, e, f, g, h, i, j, k, l) fmtty_rel -> Parsetree.expression
+          =
+      fun fmtty -> match fmtty with
+        | Char_ty rest      -> mk_constr "Char_ty"      [ mk_fmtty rest ]
+        | String_ty rest    -> mk_constr "String_ty"    [ mk_fmtty rest ]
+        | Int_ty rest       -> mk_constr "Int_ty"       [ mk_fmtty rest ]
+        | Int32_ty rest     -> mk_constr "Int32_ty"     [ mk_fmtty rest ]
+        | Nativeint_ty rest -> mk_constr "Nativeint_ty" [ mk_fmtty rest ]
+        | Int64_ty rest     -> mk_constr "Int64_ty"     [ mk_fmtty rest ]
+        | Float_ty rest     -> mk_constr "Float_ty"     [ mk_fmtty rest ]
+        | Bool_ty rest      -> mk_constr "Bool_ty"      [ mk_fmtty rest ]
+        | Alpha_ty rest     -> mk_constr "Alpha_ty"     [ mk_fmtty rest ]
+        | Theta_ty rest     -> mk_constr "Theta_ty"     [ mk_fmtty rest ]
+        | Any_ty rest       -> mk_constr "Any_ty"       [ mk_fmtty rest ]
+        | Reader_ty rest    -> mk_constr "Reader_ty"    [ mk_fmtty rest ]
+        | Ignored_reader_ty rest ->
+          mk_constr "Ignored_reader_ty" [ mk_fmtty rest ]
+        | Format_arg_ty (sub_fmtty, rest) ->
+          mk_constr "Format_arg_ty" [ mk_fmtty sub_fmtty; mk_fmtty rest ]
+        | Format_subst_ty (sub_fmtty1, sub_fmtty2, rest) ->
+          mk_constr "Format_subst_ty"
+            [ mk_fmtty sub_fmtty1; mk_fmtty sub_fmtty2; mk_fmtty rest ]
+        | End_of_fmtty -> mk_constr "End_of_fmtty" []
+      and mk_ignored : type a b c d e f .
+          (a, b, c, d, e, f) ignored -> Parsetree.expression =
+      fun ign -> match ign with
+        | Ignored_char ->
+          mk_constr "Ignored_char" []
+        | Ignored_caml_char ->
+          mk_constr "Ignored_caml_char" []
+        | Ignored_string pad_opt ->
+          mk_constr "Ignored_string" [ mk_int_opt pad_opt ]
+        | Ignored_caml_string pad_opt ->
+          mk_constr "Ignored_caml_string" [ mk_int_opt pad_opt ]
+        | Ignored_int (iconv, pad_opt) ->
+          mk_constr "Ignored_int" [ mk_iconv iconv; mk_int_opt pad_opt ]
+        | Ignored_int32 (iconv, pad_opt) ->
+          mk_constr "Ignored_int32" [ mk_iconv iconv; mk_int_opt pad_opt ]
+        | Ignored_nativeint (iconv, pad_opt) ->
+          mk_constr "Ignored_nativeint" [ mk_iconv iconv; mk_int_opt pad_opt ]
+        | Ignored_int64 (iconv, pad_opt) ->
+          mk_constr "Ignored_int64" [ mk_iconv iconv; mk_int_opt pad_opt ]
+        | Ignored_float (pad_opt, prec_opt) ->
+          mk_constr "Ignored_float" [ mk_int_opt pad_opt; mk_int_opt prec_opt ]
+        | Ignored_bool pad_opt ->
+          mk_constr "Ignored_bool" [ mk_int_opt pad_opt ]
+        | Ignored_format_arg (pad_opt, fmtty) ->
+          mk_constr "Ignored_format_arg" [ mk_int_opt pad_opt; mk_fmtty fmtty ]
+        | Ignored_format_subst (pad_opt, fmtty) ->
+          mk_constr "Ignored_format_subst" [
+            mk_int_opt pad_opt; mk_fmtty fmtty ]
+        | Ignored_reader ->
+          mk_constr "Ignored_reader" []
+        | Ignored_scan_char_set (width_opt, char_set) ->
+          mk_constr "Ignored_scan_char_set" [
+            mk_int_opt width_opt; mk_string char_set ]
+        | Ignored_scan_get_counter counter ->
+          mk_constr "Ignored_scan_get_counter" [
+            mk_counter counter
+          ]
+        | Ignored_scan_next_char ->
+          mk_constr "Ignored_scan_next_char" []
+      and mk_padding : type x y . (x, y) padding -> Parsetree.expression =
+      fun pad -> match pad with
+        | No_padding         -> mk_constr "No_padding" []
+        | Lit_padding (s, w) -> mk_constr "Lit_padding" [ mk_side s; mk_int w ]
+        | Arg_padding s      -> mk_constr "Arg_padding" [ mk_side s ]
+      and mk_precision : type x y . (x, y) precision -> Parsetree.expression =
+      fun prec -> match prec with
+        | No_precision    -> mk_constr "No_precision" []
+        | Lit_precision w -> mk_constr "Lit_precision" [ mk_int w ]
+        | Arg_precision   -> mk_constr "Arg_precision" []
+      and mk_fmt : type a b c d e f .
+          (a, b, c, d, e, f) fmt -> Parsetree.expression =
+      fun fmt -> match fmt with
+        | Char rest ->
+          mk_constr "Char" [ mk_fmt rest ]
+        | Caml_char rest ->
+          mk_constr "Caml_char" [ mk_fmt rest ]
+        | String (pad, rest) ->
+          mk_constr "String" [ mk_padding pad; mk_fmt rest ]
+        | Caml_string (pad, rest) ->
+          mk_constr "Caml_string" [ mk_padding pad; mk_fmt rest ]
+        | Int (iconv, pad, prec, rest) ->
+          mk_constr "Int" [
+            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
+        | Int32 (iconv, pad, prec, rest) ->
+          mk_constr "Int32" [
+            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
+        | Nativeint (iconv, pad, prec, rest) ->
+          mk_constr "Nativeint" [
+            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
+        | Int64 (iconv, pad, prec, rest) ->
+          mk_constr "Int64" [
+            mk_iconv iconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
+        | Float (fconv, pad, prec, rest) ->
+          mk_constr "Float" [
+            mk_fconv fconv; mk_padding pad; mk_precision prec; mk_fmt rest ]
+        | Bool (pad, rest) ->
+          mk_constr "Bool" [ mk_padding pad; mk_fmt rest ]
+        | Flush rest ->
+          mk_constr "Flush" [ mk_fmt rest ]
+        | String_literal (s, rest) ->
+          mk_constr "String_literal" [ mk_string s; mk_fmt rest ]
+        | Char_literal (c, rest) ->
+          mk_constr "Char_literal" [ mk_char c; mk_fmt rest ]
+        | Format_arg (pad_opt, fmtty, rest) ->
+          mk_constr "Format_arg" [
+            mk_int_opt pad_opt; mk_fmtty fmtty; mk_fmt rest ]
+        | Format_subst (pad_opt, fmtty, rest) ->
+          mk_constr "Format_subst" [
+            mk_int_opt pad_opt; mk_fmtty fmtty; mk_fmt rest ]
+        | Alpha rest ->
+          mk_constr "Alpha" [ mk_fmt rest ]
+        | Theta rest ->
+          mk_constr "Theta" [ mk_fmt rest ]
+        | Formatting_lit (fmting, rest) ->
+          mk_constr "Formatting_lit" [ mk_formatting_lit fmting; mk_fmt rest ]
+        | Formatting_gen (fmting, rest) ->
+          mk_constr "Formatting_gen" [ mk_formatting_gen fmting; mk_fmt rest ]
+        | Reader rest ->
+          mk_constr "Reader" [ mk_fmt rest ]
+        | Scan_char_set (width_opt, char_set, rest) ->
+          mk_constr "Scan_char_set" [
+            mk_int_opt width_opt; mk_string char_set; mk_fmt rest ]
+        | Scan_get_counter (cnt, rest) ->
+          mk_constr "Scan_get_counter" [ mk_counter cnt; mk_fmt rest ]
+        | Scan_next_char rest ->
+          mk_constr "Scan_next_char" [ mk_fmt rest ]
+        | Ignored_param (ign, rest) ->
+          mk_constr "Ignored_param" [ mk_ignored ign; mk_fmt rest ]
+        | End_of_format ->
+          mk_constr "End_of_format" []
+        | Custom _ ->
+          (* Custom formatters have no syntax so they will never appear
+             in formats parsed from strings. *)
+          assert false
+      in
+      let legacy_behavior = not !Clflags.strict_formats in
+      let Fmt_EBB fmt = fmt_ebb_of_string ~legacy_behavior str in
+      mk_constr "Format" [ mk_fmt fmt; mk_string str ]
+    ))
+  with Failure msg ->
+    raise (error (loc, env, Invalid_format msg))
+
+and type_label_exp create env loc ty_expected
+          (lid, label, sarg) =
+  (* Here also ty_expected may be at generic_level *)
+  begin_def ();
+  let separate = !Clflags.principal || Env.has_local_constraints env in
+  if separate then (begin_def (); begin_def ());
+  let (vars, ty_arg, ty_res) = instance_label true label in
+  if separate then begin
+    end_def ();
+    (* Generalize label information *)
+    generalize_structure ty_arg;
+    generalize_structure ty_res
+  end;
+  begin try
+    unify env (instance ty_res) (instance ty_expected)
+  with Unify trace ->
+    raise (error(lid.loc, env, Label_mismatch(lid.txt, trace)))
+  end;
+  (* Instantiate so that we can generalize internal nodes *)
+  let ty_arg = instance ty_arg in
+  if separate then begin
+    end_def ();
+    (* Generalize information merged from ty_expected *)
+    generalize_structure ty_arg
+  end;
+  if label.lbl_private = Private then
+    if create then
+      raise (error(loc, env, Private_type ty_expected))
+    else
+      raise (error(lid.loc, env, Private_label(lid.txt, ty_expected)));
+  let arg =
+    let snap = if vars = [] then None else Some (Btype.snapshot ()) in
+    let arg = type_argument env sarg ty_arg (instance ty_arg) in
+    end_def ();
+    try
+      check_univars env (vars <> []) "field value" arg label.lbl_arg vars;
+      arg
+    with exn when maybe_expansive arg -> try
+      (* Try to retype without propagating ty_arg, cf PR#4862 *)
+      Option.iter Btype.backtrack snap;
+      begin_def ();
+      let arg = type_exp env sarg in
+      end_def ();
+      lower_contravariant env arg.exp_type;
+      unify_exp env arg ty_arg;
+      check_univars env false "field value" arg label.lbl_arg vars;
+      arg
+    with Error (_, _, Less_general _) as e -> raise e
+    | _ -> raise exn    (* In case of failure return the first error *)
+  in
+  (lid, label, {arg with exp_type = instance arg.exp_type})
+
+and type_argument ?explanation ?recarg env sarg ty_expected' ty_expected =
+  (* ty_expected' may be generic *)
+  let no_labels ty =
+    let ls, tvar = list_labels env ty in
+    not tvar && List.for_all ((=) Nolabel) ls
+  in
+  let rec is_inferred sexp =
+    match sexp.pexp_desc with
+      Pexp_ident _ | Pexp_apply _ | Pexp_field _ | Pexp_constraint _
+    | Pexp_coerce _ | Pexp_send _ | Pexp_new _ -> true
+    | Pexp_sequence (_, e) | Pexp_open (_, e) -> is_inferred e
+    | Pexp_ifthenelse (_, e1, Some e2) -> is_inferred e1 && is_inferred e2
+    | _ -> false
+  in
+  match expand_head env ty_expected' with
+    {desc = Tarrow(Nolabel,ty_arg,ty_res,_); level = lv}
+    when is_inferred sarg ->
+      (* apply optional arguments when expected type is "" *)
+      (* we must be very careful about not breaking the semantics *)
+      if !Clflags.principal then begin_def ();
+      let texp = type_exp env sarg in
+      if !Clflags.principal then begin
+        end_def ();
+        generalize_structure texp.exp_type
+      end;
+      let rec make_args args ty_fun =
+        match (expand_head env ty_fun).desc with
+        | Tarrow (l,ty_arg,ty_fun,_) when is_optional l ->
+            let ty = option_none env (instance ty_arg) sarg.pexp_loc in
+            make_args ((l, Some ty) :: args) ty_fun
+        | Tarrow (l,_,ty_res',_) when l = Nolabel || !Clflags.classic ->
+            List.rev args, ty_fun, no_labels ty_res'
+        | Tvar _ ->  List.rev args, ty_fun, false
+        |  _ -> [], texp.exp_type, false
+      in
+      let args, ty_fun', simple_res = make_args [] texp.exp_type in
+      let warn = !Clflags.principal &&
+        (lv <> generic_level || (repr ty_fun').level <> generic_level)
+      and texp = {texp with exp_type = instance texp.exp_type}
+      and ty_fun = instance ty_fun' in
+      if not (simple_res || no_labels ty_res) then begin
+        unify_exp env texp ty_expected;
+        texp
+      end else begin
+      unify_exp env {texp with exp_type = ty_fun} ty_expected;
+      if args = [] then texp else
+      (* eta-expand to avoid side effects *)
+      let var_pair name ty =
+        let id = Ident.create_local name in
+        let desc =
+          { val_type = ty; val_kind = Val_reg;
+            val_attributes = [];
+            Types.val_loc = Location.none}
+        in
+        let exp_env = Env.add_value id desc env in
+        {pat_desc = Tpat_var (id, mknoloc name); pat_type = ty;pat_extra=[];
+         pat_attributes = [];
+         pat_loc = Location.none; pat_env = env},
+        {exp_type = ty; exp_loc = Location.none; exp_env = exp_env;
+         exp_extra = []; exp_attributes = [];
+         exp_desc =
+         Texp_ident(Path.Pident id, mknoloc (Longident.Lident name), desc)}
+      in
+      let eta_pat, eta_var = var_pair "eta" ty_arg in
+      let func texp =
+        let e =
+          {texp with exp_type = ty_res; exp_desc =
+           Texp_apply
+             (texp,
+              args @ [Nolabel, Some eta_var])}
+        in
+        let cases = [case eta_pat e] in
+        let param = name_cases "param" cases in
+        { texp with exp_type = ty_fun; exp_desc =
+          Texp_function { arg_label = Nolabel; param; cases;
+            partial = Total; } }
+      in
+      Location.prerr_warning texp.exp_loc
+        (Warnings.Eliminated_optional_arguments
+           (List.map (fun (l, _) -> Printtyp.string_of_label l) args));
+      if warn then Location.prerr_warning texp.exp_loc
+          (Warnings.Without_principality "eliminated optional argument");
+      (* let-expand to have side effects *)
+      let let_pat, let_var = var_pair "arg" texp.exp_type in
+      re { texp with exp_type = ty_fun; exp_desc =
+           Texp_let (Nonrecursive,
+                     [{vb_pat=let_pat; vb_expr=texp; vb_attributes=[];
+                       vb_loc=Location.none;
+                      }],
+                     func let_var) }
+      end
+  | _ ->
+      let texp = type_expect ?recarg env sarg
+        (mk_expected ?explanation ty_expected') in
+      unify_exp env texp ty_expected;
+      texp
+
+and type_application env funct sargs =
+  (* funct.exp_type may be generic *)
+  let result_type omitted ty_fun =
+    List.fold_left
+      (fun ty_fun (l,ty,lv) -> newty2 lv (Tarrow(l,ty,ty_fun,Cok)))
+      ty_fun omitted
+  in
+  let has_label l ty_fun =
+    let ls, tvar = list_labels env ty_fun in
+    tvar || List.mem l ls
+  in
+  let ignored = ref [] in
+  let rec type_unknown_args
+      (args :
+      (Asttypes.arg_label * (unit -> Typedtree.expression) option) list)
+    omitted ty_fun = function
+      [] ->
+        (List.map
+            (function l, None -> l, None
+                | l, Some f -> l, Some (f ()))
+           (List.rev args),
+         instance (result_type omitted ty_fun))
+    | (l1, sarg1) :: sargl ->
+        let (ty1, ty2) =
+        try
+          let ty_fun = expand_head env ty_fun in
+          match ty_fun.desc with
+            Tvar _ ->
+              let t1 = newvar () and t2 = newvar () in
+              let not_identity = function
+                  Texp_ident(_,_,{val_kind=Val_prim
+                                  {Primitive.prim_name="%identity"}}) ->
+                    false
+                | _ -> true
+              in
+              if ty_fun.level >= t1.level && not_identity funct.exp_desc
+                 && not (Msupport.erroneous_expr_check funct) then
+                Location.prerr_warning sarg1.pexp_loc Warnings.Unused_argument;
+              unify env ty_fun (newty (Tarrow(l1,t1,t2,Clink(ref Cunknown))));
+              (t1, t2)
+          | Tarrow (l,t1,t2,_) when l = l1
+            || !Clflags.classic && l1 = Nolabel && not (is_optional l) ->
+              (t1, t2)
+          | td ->
+              let ty_fun =
+                match td with Tarrow _ -> newty td | _ -> ty_fun in
+              let ty_res = result_type (omitted @ !ignored) ty_fun in
+              match ty_res.desc with
+                Tarrow _ ->
+                  if (!Clflags.classic || not (has_label l1 ty_fun)) then
+                    Msupport.resume_raise
+                      (error(sarg1.pexp_loc, env,
+                             Apply_wrong_label(l1, ty_res)))
+                  else
+                    Msupport.resume_raise
+                      (error(funct.exp_loc, env, Incoherent_label_order))
+              | _ ->
+                  Msupport.resume_raise
+                    (error(funct.exp_loc, env,
+                           Apply_non_function (expand_head env funct.exp_type)))
+        with Msupport.Resume ->
+          newvar(), ty_fun
+        in
+        let optional = is_optional l1 in
+        let arg1 () =
+          let arg1 = type_expect env sarg1 (mk_expected ty1) in
+          if optional then
+            unify_exp env arg1 (type_option(newvar()));
+          arg1
+        in
+        type_unknown_args ((l1, Some arg1) :: args) omitted ty2 sargl
+  in
+  let ignore_labels =
+    !Clflags.classic ||
+    begin
+      let ls, tvar = list_labels env funct.exp_type in
+      not tvar &&
+      let labels = List.filter (fun l -> not (is_optional l)) ls in
+      List.length labels = List.length sargs &&
+      List.for_all (fun (l,_) -> l = Nolabel) sargs &&
+      List.exists (fun l -> l <> Nolabel) labels &&
+      (Location.prerr_warning
+         funct.exp_loc
+         (Warnings.Labels_omitted
+            (List.map Printtyp.string_of_label
+                      (List.filter ((<>) Nolabel) labels)));
+       true)
+    end
+  in
+  let warned = ref false in
+  let rec type_args args omitted ty_fun ty_fun0 ty_old sargs more_sargs =
+    match expand_head env ty_fun, expand_head env ty_fun0 with
+      {desc=Tarrow (l, ty, ty_fun, com); level=lv} as ty_fun',
+      {desc=Tarrow (_, ty0, ty_fun0, _)}
+      when (sargs <> [] || more_sargs <> []) && commu_repr com = Cok ->
+        let may_warn loc w =
+          if not !warned && !Clflags.principal && lv <> generic_level
+          then begin
+            warned := true;
+            Location.prerr_warning loc w
+          end
+        in
+        let name = label_name l
+        and optional = is_optional l in
+        let sargs, more_sargs, arg =
+          if ignore_labels && not (is_optional l) then begin
+            (* In classic mode, omitted = [] *)
+            match sargs, more_sargs with
+              (l', sarg0) :: _, _ ->
+                raise(error(sarg0.pexp_loc, env,
+                            Apply_wrong_label(l', ty_old)))
+            | _, (l', sarg0) :: more_sargs ->
+                if l <> l' && l' <> Nolabel then
+                  raise(error(sarg0.pexp_loc, env,
+                              Apply_wrong_label(l', ty_fun')))
+                else
+                  ([], more_sargs,
+                   Some (fun () -> type_argument env sarg0 ty ty0))
+            | _ ->
+                assert false
+          end else try
+            let (l', sarg0, sargs, more_sargs) =
+              try
+                let (l', sarg0, sargs1, sargs2) = extract_label name sargs in
+                if sargs1 <> [] then
+                  may_warn sarg0.pexp_loc
+                    (Warnings.Not_principal "commuting this argument");
+                (l', sarg0, sargs1 @ sargs2, more_sargs)
+              with Not_found ->
+                let (l', sarg0, sargs1, sargs2) =
+                  extract_label name more_sargs in
+                if sargs1 <> [] || sargs <> [] then
+                  may_warn sarg0.pexp_loc
+                    (Warnings.Not_principal "commuting this argument");
+                (l', sarg0, sargs @ sargs1, sargs2)
+            in
+            if not optional && is_optional l' then
+              Location.prerr_warning sarg0.pexp_loc
+                (Warnings.Nonoptional_label (Printtyp.string_of_label l));
+            sargs, more_sargs,
+            if not optional || is_optional l' then
+              Some (fun () -> type_argument env sarg0 ty ty0)
+            else begin
+              may_warn sarg0.pexp_loc
+                (Warnings.Not_principal "using an optional argument here");
+              Some (fun () -> option_some env (type_argument env sarg0
+                                             (extract_option_type env ty)
+                                             (extract_option_type env ty0)))
+            end
+          with Not_found ->
+            sargs, more_sargs,
+            if optional &&
+              (List.mem_assoc Nolabel sargs
+               || List.mem_assoc Nolabel more_sargs)
+            then begin
+              may_warn funct.exp_loc
+                (Warnings.Without_principality "eliminated optional argument");
+              ignored := (l,ty,lv) :: !ignored;
+              Some (fun () -> option_none env (instance ty) Location.none)
+            end else begin
+              may_warn funct.exp_loc
+                (Warnings.Without_principality "commuted an argument");
+              None
+            end
+        in
+        let omitted =
+          if arg = None then (l,ty,lv) :: omitted else omitted in
+        let ty_old = if sargs = [] then ty_fun else ty_old in
+        type_args ((l,arg)::args) omitted ty_fun ty_fun0
+          ty_old sargs more_sargs
+    | _ ->
+        match sargs with
+          (l, sarg0) :: _ when ignore_labels ->
+            raise(error(sarg0.pexp_loc, env,
+                        Apply_wrong_label(l, ty_old)))
+        | _ ->
+            type_unknown_args args omitted ty_fun0
+              (sargs @ more_sargs)
+  in
+  let is_ignore funct =
+    match funct.exp_desc with
+      Texp_ident (_, _, {val_kind=Val_prim{Primitive.prim_name="%ignore"}}) ->
+        (try ignore (filter_arrow env (instance funct.exp_type) Nolabel);
+             true
+        with Unify _ -> false)
+    | _ -> false
+  in
+  match sargs with
+    (* Special case for ignore: avoid discarding warning *)
+    [Nolabel, sarg] when is_ignore funct ->
+      let ty_arg, ty_res =
+        filter_arrow env (instance funct.exp_type) Nolabel
+      in
+      let exp = type_expect env sarg (mk_expected ty_arg) in
+      check_partial_application false exp;
+      ([Nolabel, Some exp], ty_res)
+  | _ ->
+    let ty = funct.exp_type in
+    if ignore_labels then
+      type_args [] [] ty (instance ty) ty [] sargs
+    else
+      type_args [] [] ty (instance ty) ty sargs []
+
+and type_construct env loc lid sarg ty_expected_explained attrs =
+  let { ty = ty_expected; explanation } = ty_expected_explained in
+  let opath =
+    try
+      let (p0, p,_) = extract_concrete_variant env ty_expected in
+      let principal =
+        (repr ty_expected).level = generic_level || not !Clflags.principal
+      in
+      Some(p0, p, principal)
+    with Not_found -> None
+  in
+  let constrs =
+    Env.lookup_all_constructors ~loc:lid.loc Env.Positive lid.txt env
+  in
+  let constr =
+    wrap_disambiguate "This variant expression is expected to have"
+      ty_expected_explained
+      (Constructor.disambiguate Env.Positive lid env opath) constrs
+  in
+  let sargs =
+    match sarg with
+      None -> []
+    | Some {pexp_desc = Pexp_tuple sel} when
+        constr.cstr_arity > 1 || Builtin_attributes.explicit_arity attrs
+      -> sel
+    | Some se -> [se] in
+  if List.length sargs <> constr.cstr_arity then
+    raise(error(loc, env, Constructor_arity_mismatch
+                            (lid.txt, constr.cstr_arity, List.length sargs)));
+  let separate = !Clflags.principal || Env.has_local_constraints env in
+  if separate then (begin_def (); begin_def ());
+  let (ty_args, ty_res) = instance_constructor constr in
+  let texp =
+    re {
+      exp_desc = Texp_construct(lid, constr, []);
+      exp_loc = loc; exp_extra = [];
+      exp_type = ty_res;
+      exp_attributes = attrs;
+      exp_env = env } in
+  if separate then begin
+    end_def ();
+    generalize_structure ty_res;
+    with_explanation explanation (fun () ->
+      unify_exp env {texp with exp_type = instance ty_res}
+        (instance ty_expected));
+    end_def ();
+    List.iter generalize_structure ty_args;
+    generalize_structure ty_res;
+  end;
+  let ty_args0, ty_res =
+    match instance_list (ty_res :: ty_args) with
+      t :: tl -> tl, t
+    | _ -> assert false
+  in
+  let texp = {texp with exp_type = ty_res} in
+  if not separate then unify_exp env texp (instance ty_expected);
+  let recarg =
+    match constr.cstr_inlined with
+    | None -> Rejected
+    | Some _ ->
+      begin match sargs with
+      | [{pexp_desc =
+            Pexp_ident _ |
+            Pexp_record (_, (Some {pexp_desc = Pexp_ident _}| None))}] ->
+        Required
+      | _ ->
+        raise (error(loc, env, Inlined_record_expected))
+      end
+  in
+  let args =
+    List.map2 (fun e (t,t0) -> type_argument ~recarg env e t t0) sargs
+      (List.combine ty_args ty_args0) in
+  if constr.cstr_private = Private then
+    begin match constr.cstr_tag with
+    | Cstr_extension _ ->
+        raise_error (error(loc, env, Private_constructor (constr, ty_res)))
+    | Cstr_constant _ | Cstr_block _ | Cstr_unboxed ->
+        raise_error (error(loc, env, Private_type ty_res));
+    end;
+  (* NOTE: shouldn't we call "re" on this final expression? -- AF *)
+  { texp with
+    exp_desc = Texp_construct(lid, constr, args) }
+
+(* Typing of statements (expressions whose values are discarded) *)
+
+and type_statement ?explanation env sexp =
+  let has_errors = Msupport.monitor_errors () in
+  begin_def();
+  let exp = type_exp env sexp in
+  end_def();
+  let ty = expand_head env exp.exp_type and tv = newvar() in
+  if is_Tvar ty && ty.level > tv.level && not !has_errors then
+    Location.prerr_warning
+      (final_subexpression exp).exp_loc
+      Warnings.Nonreturning_statement;
+  if !Clflags.strict_sequence then
+    let expected_ty = instance Predef.type_unit in
+    with_explanation explanation (fun () ->
+      unify_exp env exp expected_ty);
+    exp
+  else begin
+    if not !has_errors then check_partial_application true exp;
+    unify_var env tv ty;
+    exp
+  end
+
+(* Typing of match cases *)
+and type_cases ?exception_allowed ?in_function env ty_arg ty_res partial_flag
+      loc caselist =
+  let has_errors = Msupport.monitor_errors () in
+  (* ty_arg is _fully_ generalized *)
+  let patterns = List.map (fun {pc_lhs=p} -> p) caselist in
+  let contains_polyvars = List.exists contains_polymorphic_variant patterns in
+  let erase_either = contains_polyvars && contains_variant_either ty_arg in
+  let may_contain_gadts = List.exists may_contain_gadts patterns in
+  let ty_arg =
+    if (may_contain_gadts || erase_either) && not !Clflags.principal
+    then correct_levels ty_arg else ty_arg
+  in
+  let rec is_var spat =
+    match spat.ppat_desc with
+      Ppat_any | Ppat_var _ -> true
+    | Ppat_alias (spat, _) -> is_var spat
+    | _ -> false in
+  let needs_exhaust_check =
+    match caselist with
+      [{pc_rhs = {pexp_desc = Pexp_unreachable}}] -> true
+    | [{pc_lhs}] when is_var pc_lhs -> false
+    | _ -> true
+  in
+  let outer_level = get_current_level () in
+  let lev =
+    if may_contain_gadts then begin_def ();
+    get_current_level ()
+  in
+  let take_partial_instance =
+    if !Clflags.principal || erase_either
+    then Some false else None
+  in
+  begin_def (); (* propagation of the argument *)
+  let pattern_force = ref [] in
+(*  Format.printf "@[%i %i@ %a@]@." lev (get_current_level())
+    Printtyp.raw_type_expr ty_arg; *)
+  let half_typed_cases =
+    List.map
+      (fun ({pc_lhs; pc_guard; pc_rhs} as case) ->
+        let loc =
+          let open Location in
+          match pc_guard with
+          | None -> pc_rhs.pexp_loc
+          | Some g -> {pc_rhs.pexp_loc with loc_start=g.pexp_loc.loc_start}
+        in
+        if !Clflags.principal then begin_def (); (* propagation of pattern *)
+        let scope = Some (Annot.Idef loc) in
+        begin_def ();
+        let ty_arg = instance ?partial:take_partial_instance ty_arg in
+        end_def ();
+        generalize_structure ty_arg;
+        let (pat, ext_env, force, pvs, unpacks) =
+          type_pattern ?exception_allowed ~lev env pc_lhs scope ty_arg
+        in
+        pattern_force := force @ !pattern_force;
+        let pat =
+          if !Clflags.principal then begin
+            end_def ();
+            iter_pattern_variables_type generalize_structure pvs;
+            { pat with pat_type = instance pat.pat_type }
+          end else pat
+        in
+        (* Ensure that no ambivalent pattern type escapes its branch *)
+        check_scope_escape pat.pat_loc env outer_level ty_arg;
+        { typed_pat = pat;
+          pat_type_for_unif = ty_arg;
+          untyped_case = case;
+          branch_env = ext_env;
+          pat_vars = pvs;
+          unpacks;
+          contains_gadt = contains_gadt pat; }
+        )
+      caselist in
+  let patl = List.map (fun { typed_pat; _ } -> typed_pat) half_typed_cases in
+  let does_contain_gadt =
+    List.exists (fun { contains_gadt; _ } -> contains_gadt) half_typed_cases
+  in
+  let ty_res, do_copy_types =
+    if does_contain_gadt && not !Clflags.principal then
+      correct_levels ty_res, Env.make_copy_of_types env
+    else ty_res, (fun env -> env)
+  in
+  (* Unify all cases (delayed to keep it order-free) *)
+  let ty_arg' = newvar () in
+  let unify_pats ty =
+    List.iter (fun { typed_pat = pat; pat_type_for_unif = pat_ty; _ } ->
+      unify_pat_types pat.pat_loc (ref env) pat_ty ty
+    ) half_typed_cases
+  in
+  unify_pats ty_arg';
+  (* Check for polymorphic variants to close *)
+  if List.exists has_variants patl then begin
+    Parmatch.pressure_variants env patl;
+    List.iter (iter_pattern finalize_variant) patl
+  end;
+  (* `Contaminating' unifications start here *)
+  List.iter (fun f -> f()) !pattern_force;
+  (* Post-processing and generalization *)
+  if take_partial_instance <> None then unify_pats (instance ty_arg);
+  List.iter (fun { pat_vars; _ } ->
+    iter_pattern_variables_type (fun t -> unify_var env (newvar()) t) pat_vars
+  ) half_typed_cases;
+  end_def ();
+  generalize ty_arg';
+  List.iter (fun { pat_vars; _ } ->
+    iter_pattern_variables_type generalize pat_vars
+  ) half_typed_cases;
+  (* type bodies *)
+  let in_function = if List.length caselist = 1 then in_function else None in
+  let cases =
+    List.map
+      (fun { typed_pat = pat; branch_env = ext_env; pat_vars = pvs; unpacks;
+             untyped_case = {pc_lhs = _; pc_guard; pc_rhs};
+             contains_gadt; _ }  ->
+        let ext_env =
+          if contains_gadt then
+            do_copy_types ext_env
+          else
+            ext_env
+        in
+        let ext_env =
+          add_pattern_variables ext_env pvs
+            ~check:(fun s -> Warnings.Unused_var_strict s)
+            ~check_as:(fun s -> Warnings.Unused_var s)
+        in
+        let sexp = wrap_unpacks pc_rhs unpacks in
+        let ty_res' =
+          if !Clflags.principal then begin
+            begin_def ();
+            let ty = instance ~partial:true ty_res in
+            end_def ();
+            generalize_structure ty; ty
+          end
+          else if contains_gadt then
+            (* Even though we've already done that, apparently we need to do it
+               again.
+               stdlib/camlinternalFormat.ml:2288 is an example of use of this
+               call to [correct_levels]... *)
+            correct_levels ty_res
+          else ty_res in
+(*        Format.printf "@[%i %i, ty_res' =@ %a@]@." lev (get_current_level())
+          Printtyp.raw_type_expr ty_res'; *)
+        let guard =
+          match pc_guard with
+          | None -> None
+          | Some scond ->
+              Some
+                (type_expect ext_env (wrap_unpacks scond unpacks)
+                   (mk_expected ~explanation:When_guard Predef.type_bool))
+        in
+        let exp =
+          type_expect ?in_function ext_env sexp (mk_expected ty_res') in
+        {
+         c_lhs = pat;
+         c_guard = guard;
+         c_rhs = {exp with exp_type = instance ty_res'}
+        }
+      )
+      half_typed_cases
+  in
+  if !Clflags.principal || does_contain_gadt then begin
+    let ty_res' = instance ty_res in
+    List.iter (fun c -> unify_exp env c.c_rhs ty_res') cases
+  end;
+  let do_init = may_contain_gadts || needs_exhaust_check in
+  let ty_arg_check =
+    if do_init then
+      (* Hack: use for_saving to copy variables too *)
+      Subst.type_expr (Subst.for_saving Subst.identity) ty_arg'
+    else ty_arg'
+  in
+  let val_cases, exn_cases = split_cases env cases in
+  if val_cases = [] && exn_cases <> [] then
+    raise (error (loc, env, No_value_clauses));
+  let partial =
+    if partial_flag then
+      check_partial ~lev env ty_arg_check loc val_cases
+    else
+      Partial
+  in
+  let unused_check delayed =
+    List.iter (fun { typed_pat; branch_env; _ } ->
+      check_absent_variant branch_env typed_pat
+    ) half_typed_cases;
+    if delayed then (begin_def (); init_def lev);
+    check_unused ~lev env ty_arg_check val_cases ;
+    check_unused ~lev env Predef.type_exn exn_cases ;
+    if delayed then end_def ();
+    Parmatch.check_ambiguous_bindings val_cases ;
+    Parmatch.check_ambiguous_bindings exn_cases
+  in
+  if not !has_errors then (
+    if contains_polyvars then
+      add_delayed_check (fun () -> unused_check true)
+    else
+      (* Check for unused cases, do not delay because of gadts *)
+      unused_check false;
+  );
+  if may_contain_gadts then begin
+    end_def ();
+    (* Ensure that existential types do not escape *)
+    unify_exp_types loc env (instance ty_res) (newvar ()) ;
+  end;
+  cases, partial
+
+(* Typing of let bindings *)
+
+and type_let
+    ?(check = fun s -> Warnings.Unused_var s)
+    ?(check_strict = fun s -> Warnings.Unused_var_strict s)
+    existential_context
+    env rec_flag spat_sexp_list scope allow =
+  let open Ast_helper in
+  begin_def();
+  if !Clflags.principal then begin_def ();
+
+  let is_fake_let =
+    match spat_sexp_list with
+    | [{pvb_expr={pexp_desc=Pexp_match(
+           {pexp_desc=Pexp_ident({ txt = Longident.Lident "*opt*"})},_)}}] ->
+        true (* the fake let-declaration introduced by fun ?(x = e) -> ... *)
+    | _ ->
+        false
+  in
+  let check = if is_fake_let then check_strict else check in
+
+  let spatl =
+    List.map
+      (fun {pvb_pat=spat; pvb_expr=sexp; pvb_attributes=attrs} ->
+        attrs,
+        match spat.ppat_desc, sexp.pexp_desc with
+          (Ppat_any | Ppat_constraint _), _ -> spat
+        | _, Pexp_coerce (_, _, sty)
+        | _, Pexp_constraint (_, sty) when !Clflags.principal ->
+            (* propagate type annotation to pattern,
+               to allow it to be generalized in -principal mode *)
+            Pat.constraint_
+              ~loc:{spat.ppat_loc with Location.loc_ghost=true}
+              spat
+              sty
+        | _ -> spat)
+      spat_sexp_list in
+  let nvs = List.map (fun _ -> newvar ()) spatl in
+  let (pat_list, new_env, force, pvs, unpacks) =
+    type_pattern_list existential_context env spatl scope nvs allow in
+  let attrs_list = List.map fst spatl in
+  let is_recursive = (rec_flag = Recursive) in
+  (* If recursive, first unify with an approximation of the expression *)
+  if is_recursive then
+    List.iter2
+      (fun pat binding ->
+        let pat =
+          match pat.pat_type.desc with
+          | Tpoly (ty, tl) ->
+              {pat with pat_type =
+               snd (instance_poly ~keep_names:true false tl ty)}
+          | _ -> pat
+        in unify_pat (ref env) pat (type_approx env binding.pvb_expr))
+      pat_list spat_sexp_list;
+  (* Polymorphic variant processing *)
+  List.iter
+    (fun pat ->
+      if has_variants pat then begin
+        Parmatch.pressure_variants env [pat];
+        iter_pattern finalize_variant pat
+      end)
+    pat_list;
+  (* Generalize the structure *)
+  let pat_list =
+    if !Clflags.principal then begin
+      end_def ();
+      iter_pattern_variables_type generalize_structure pvs;
+      List.map (fun pat ->
+        generalize_structure pat.pat_type;
+        {pat with pat_type = instance pat.pat_type}
+      ) pat_list
+    end else
+      pat_list
+  in
+  (* Only bind pattern variables after generalizing *)
+  List.iter (fun f -> f()) force;
+  let sexp_is_fun { pvb_expr = sexp; _ } =
+    match sexp.pexp_desc with
+    | Pexp_fun _ | Pexp_function _ -> true
+    | _ -> false
+  in
+  let exp_env =
+    if is_recursive then new_env
+    else if List.for_all sexp_is_fun spat_sexp_list
+    then begin
+      (* Add ghost bindings to help detecting missing "rec" keywords.
+
+         We only add those if the body of the definition is obviously a
+         function. The rationale is that, in other cases, the hint is probably
+         wrong (and the user is using "advanced features" anyway (lazy,
+         recursive values...)).
+
+         [pvb_loc] (below) is the location of the first let-binding (in case of
+         a let .. and ..), and is where the missing "rec" hint suggests to add a
+         "rec" keyword. *)
+      match spat_sexp_list with
+      | {pvb_loc; _} :: _ -> maybe_add_pattern_variables_ghost pvb_loc env pvs
+      | _ -> assert false
+    end
+    else env in
+
+  let current_slot = ref None in
+  let rec_needed = ref false in
+  let warn_about_unused_bindings =
+    List.exists
+      (fun attrs ->
+         Builtin_attributes.warning_scope ~ppwarning:false attrs (fun () ->
+           Warnings.is_active (check "") || Warnings.is_active (check_strict "")
+           || (is_recursive && (Warnings.is_active Warnings.Unused_rec_flag))))
+      attrs_list
+  in
+  let pat_slot_list =
+    (* Algorithm to detect unused declarations in recursive bindings:
+       - During type checking of the definitions, we capture the 'value_used'
+         events on the bound identifiers and record them in a slot corresponding
+         to the current definition (!current_slot).
+         In effect, this creates a dependency graph between definitions.
+
+       - After type checking the definition (!current_slot = None),
+         when one of the bound identifier is effectively used, we trigger
+         again all the events recorded in the corresponding slot.
+         The effect is to traverse the transitive closure of the graph created
+         in the first step.
+
+       We also keep track of whether *all* variables in a given pattern
+       are unused. If this is the case, for local declarations, the issued
+       warning is 26, not 27.
+     *)
+    List.map2
+      (fun attrs pat ->
+         Builtin_attributes.warning_scope ~ppwarning:false attrs (fun () ->
+           if not warn_about_unused_bindings then pat, None
+           else
+             let some_used = ref false in
+             (* has one of the identifier of this pattern been used? *)
+             let slot = ref [] in
+             List.iter
+               (fun id ->
+                  let vd = Env.find_value (Path.Pident id) new_env in
+                  (* note: Env.find_value does not trigger the value_used
+                           event *)
+                  let name = Ident.name id in
+                  let used = ref false in
+                  if not (name = "" || name.[0] = '_' || name.[0] = '#') then
+                    add_delayed_check
+                      (fun () ->
+                         if not !used then
+                           Location.prerr_warning vd.Types.val_loc
+                             ((if !some_used then check_strict else check) name)
+                      );
+                  Env.set_value_used_callback
+                    name vd
+                    (fun () ->
+                       match !current_slot with
+                       | Some slot ->
+                         slot := (name, vd) :: !slot; rec_needed := true
+                       | None ->
+                         List.iter
+                           (fun (name, vd) -> Env.mark_value_used name vd)
+                           (get_ref slot);
+                         used := true;
+                         some_used := true
+                    )
+               )
+               (Typedtree.pat_bound_idents pat);
+             pat, Some slot
+         ))
+      attrs_list
+      pat_list
+  in
+  let exp_list =
+    List.map2
+      (fun {pvb_expr=sexp; pvb_attributes; _} (pat, slot) ->
+        let sexp =
+          if rec_flag = Recursive then wrap_unpacks sexp unpacks else sexp in
+        if is_recursive then current_slot := slot;
+        match pat.pat_type.desc with
+        | Tpoly (ty, tl) ->
+            begin_def ();
+            if !Clflags.principal then begin_def ();
+            let vars, ty' = instance_poly ~keep_names:true true tl ty in
+            if !Clflags.principal then begin
+              end_def ();
+              generalize_structure ty'
+            end;
+            let exp =
+              Builtin_attributes.warning_scope pvb_attributes
+                  (fun () -> type_expect exp_env sexp (mk_expected ty'))
+            in
+            end_def ();
+            check_univars env true "definition" exp pat.pat_type vars;
+            {exp with exp_type = instance exp.exp_type}
+        | _ ->
+            Builtin_attributes.warning_scope pvb_attributes (fun () ->
+              type_expect exp_env sexp (mk_expected pat.pat_type)))
+      spat_sexp_list pat_slot_list in
+  current_slot := None;
+  if is_recursive && not !rec_needed then begin
+    let {pvb_pat; pvb_attributes} = List.hd spat_sexp_list in
+    (* See PR#6677 *)
+    Builtin_attributes.warning_scope ~ppwarning:false pvb_attributes
+      (fun () ->
+         Location.prerr_warning pvb_pat.ppat_loc Warnings.Unused_rec_flag
+      )
+  end;
+  List.iter2
+    (fun pat (attrs, exp) ->
+       Builtin_attributes.warning_scope ~ppwarning:false attrs
+         (fun () ->
+            ignore(check_partial env pat.pat_type pat.pat_loc
+                     [case pat exp])
+         )
+    )
+    pat_list
+    (List.map2 (fun (attrs, _) e -> attrs, e) spatl exp_list);
+  let pvs = List.map (fun pv -> { pv with pv_type = instance pv.pv_type}) pvs in
+  end_def();
+  List.iter2
+    (fun pat exp ->
+       if maybe_expansive exp then
+         lower_contravariant env pat.pat_type)
+    pat_list exp_list;
+  iter_pattern_variables_type generalize pvs;
+  (* We also generalize expressions that are not bound to a variable.
+     This does not matter in general, but those types are shown by the
+     interactive toplevel, for example: {[
+       let _ = Array.get;;
+       - : 'a array -> int -> 'a = <fun>
+     ]} *)
+  List.iter (fun exp -> generalize exp.exp_type) exp_list;
+  let l = List.combine pat_list exp_list in
+  let l =
+    List.map2
+      (fun (p, e) pvb ->
+        {vb_pat=p; vb_expr=e; vb_attributes=pvb.pvb_attributes;
+         vb_loc=pvb.pvb_loc;
+        })
+      l spat_sexp_list
+  in
+  if is_recursive then
+    List.iter
+      (fun {vb_pat=pat} -> match pat.pat_desc with
+           Tpat_var _ -> ()
+         | Tpat_alias ({pat_desc=Tpat_any}, _, _) -> ()
+         | _ -> raise(error(pat.pat_loc, env, Illegal_letrec_pat)))
+      l;
+  List.iter (function
+      | {vb_pat = {pat_desc = Tpat_any; pat_extra; _}; vb_expr; _} ->
+          if not (List.exists (function (Tpat_constraint _, _, _) -> true
+                                      | _ -> false) pat_extra) then
+            check_partial_application false vb_expr
+      | _ -> ()) l;
+  (l, new_env, unpacks)
+
+and type_andops env sarg sands expected_ty =
+  let rec loop env let_sarg rev_sands expected_ty =
+    match rev_sands with
+    | [] -> type_expect env let_sarg (mk_expected expected_ty), []
+    | { pbop_op = sop; pbop_exp = sexp; pbop_loc = loc; _ } :: rest ->
+        if !Clflags.principal then begin_def ();
+        let op_path, op_desc = type_binding_op_ident env sop in
+        let op_type = instance op_desc.val_type in
+        let ty_arg = newvar () in
+        let ty_rest = newvar () in
+        let ty_result = newvar() in
+        let ty_rest_fun = newty (Tarrow(Nolabel, ty_arg, ty_result, Cok)) in
+        let ty_op = newty (Tarrow(Nolabel, ty_rest, ty_rest_fun, Cok)) in
+        begin try
+          unify env op_type ty_op
+        with Unify trace ->
+          raise(error(sop.loc, env, Andop_type_clash(sop.txt, trace)))
+        end;
+        if !Clflags.principal then begin
+          end_def ();
+          generalize_structure ty_rest;
+          generalize_structure ty_arg;
+          generalize_structure ty_result
+        end;
+        let let_arg, rest = loop env let_sarg rest ty_rest in
+        let exp = type_expect env sexp (mk_expected ty_arg) in
+        begin try
+          unify env (instance ty_result) (instance expected_ty)
+        with Unify trace ->
+          raise(error(loc, env, Bindings_type_clash(trace)))
+        end;
+        let andop =
+          { bop_op_name = sop;
+            bop_op_path = op_path;
+            bop_op_val = op_desc;
+            bop_op_type = op_type;
+            bop_exp = exp;
+            bop_loc = loc }
+        in
+        let_arg, andop :: rest
+  in
+  let let_arg, rev_ands = loop env sarg (List.rev sands) expected_ty in
+  let_arg, List.rev rev_ands
+
+(* Typing of toplevel bindings *)
+
+let type_binding env rec_flag spat_sexp_list scope =
+  Typetexp.reset_type_variables();
+  let (pat_exp_list, new_env, _unpacks) =
+    type_let
+      ~check:(fun s -> Warnings.Unused_value_declaration s)
+      ~check_strict:(fun s -> Warnings.Unused_value_declaration s)
+      At_toplevel
+      env rec_flag spat_sexp_list scope false
+  in
+  (pat_exp_list, new_env)
+
+let type_let existential_ctx env rec_flag spat_sexp_list scope =
+  let (pat_exp_list, new_env, _unpacks) =
+    type_let existential_ctx env rec_flag spat_sexp_list scope false in
+  (pat_exp_list, new_env)
+
+(* Typing of toplevel expressions *)
+
+let type_expression env sexp =
+  Typetexp.reset_type_variables();
+  begin_def();
+  let exp = type_exp env sexp in
+  end_def();
+  if maybe_expansive exp then lower_contravariant env exp.exp_type;
+  generalize exp.exp_type;
+  match sexp.pexp_desc with
+    Pexp_ident lid ->
+      let loc = sexp.pexp_loc in
+      (* Special case for keeping type variables when looking-up a variable *)
+      let (_path, desc) = Env.lookup_value ~use:false ~loc lid.txt env in
+      {exp with exp_type = desc.val_type}
+  | _ -> exp
+
+(* Error report *)
+
+let spellcheck ppf unbound_name valid_names =
+  Misc.did_you_mean ppf (fun () ->
+    Misc.spellcheck valid_names unbound_name
+  )
+
+let spellcheck_idents ppf unbound valid_idents =
+  spellcheck ppf (Ident.name unbound) (List.map Ident.name valid_idents)
+
+open Format
+open Printtyp
+
+(* Returns the first diff of the trace *)
+let type_clash_of_trace trace =
+  Ctype.Unification_trace.(explain trace (fun ~prev:_ -> function
+    | Diff diff -> Some diff
+    | _ -> None
+  ))
+
+(* Hint on type error on integer literals
+   To avoid confusion, it is disabled on float literals
+   and when the expected type is `int` *)
+let report_literal_type_constraint expected_type const =
+  let const_str = match const with
+    | Const_int n -> Some (Int.to_string n)
+    | Const_int32 n -> Some (Int32.to_string n)
+    | Const_int64 n -> Some (Int64.to_string n)
+    | Const_nativeint n -> Some (Nativeint.to_string n)
+    | _ -> None
+  in
+  let suffix =
+    if Path.same expected_type Predef.path_int32 then
+      Some 'l'
+    else if Path.same expected_type Predef.path_int64 then
+      Some 'L'
+    else if Path.same expected_type Predef.path_nativeint then
+      Some 'n'
+    else if Path.same expected_type Predef.path_float then
+      Some '.'
+    else None
+  in
+  match const_str, suffix with
+  | Some c, Some s -> [ Location.msg "@[Hint: Did you mean `%s%c'?@]" c s ]
+  | _, _ -> []
+
+let report_literal_type_constraint const = function
+  | Some Unification_trace.
+    { expected = { t = { desc = Tconstr (typ, [], _) } } } ->
+      report_literal_type_constraint typ const
+  | Some _ | None -> []
+
+let report_expr_type_clash_hints exp diff =
+  match exp with
+  | Some (Texp_constant const) -> report_literal_type_constraint const diff
+  | _ -> []
+
+let report_pattern_type_clash_hints pat diff =
+  match pat with
+  | Some (Tpat_constant const) -> report_literal_type_constraint const diff
+  | _ -> []
+
+let report_type_expected_explanation expl ppf =
+  let because expl_str = fprintf ppf "@ because it is in %s" expl_str in
+  match expl with
+  | If_conditional ->
+      because "the condition of an if-statement"
+  | If_no_else_branch ->
+      because "the result of a conditional with no else branch"
+  | While_loop_conditional ->
+      because "the condition of a while-loop"
+  | While_loop_body ->
+      because "the body of a while-loop"
+  | For_loop_start_index ->
+      because "a for-loop start index"
+  | For_loop_stop_index ->
+      because "a for-loop stop index"
+  | For_loop_body ->
+      because "the body of a for-loop"
+  | Assert_condition ->
+      because "the condition of an assertion"
+  | Sequence_left_hand_side ->
+      because "the left-hand side of a sequence"
+  | When_guard ->
+      because "a when-guard"
+
+let report_type_expected_explanation_opt expl ppf =
+  match expl with
+  | None -> ()
+  | Some expl -> report_type_expected_explanation expl ppf
+
+let report_unification_error ~loc ?sub env trace
+    ?type_expected_explanation txt1 txt2 =
+  Location.error_of_printer ~loc ?sub (fun ppf () ->
+    Printtyp.report_unification_error ppf env trace
+      ?type_expected_explanation txt1 txt2
+  ) ()
+
+let report_error ~loc env = function
+  | Constructor_arity_mismatch(lid, expected, provided) ->
+      Location.errorf ~loc
+       "@[The constructor %a@ expects %i argument(s),@ \
+        but is applied here to %i argument(s)@]"
+       longident lid expected provided
+  | Label_mismatch(lid, trace) ->
+      report_unification_error ~loc env trace
+        (function ppf ->
+           fprintf ppf "The record field %a@ belongs to the type"
+                   longident lid)
+        (function ppf ->
+           fprintf ppf "but is mixed here with fields of type")
+  | Pattern_type_clash (trace, pat) ->
+      let diff = type_clash_of_trace trace in
+      let sub = report_pattern_type_clash_hints pat diff in
+      Location.error_of_printer ~loc ~sub (fun ppf () ->
+        Printtyp.report_unification_error ppf env trace
+          (function ppf ->
+            fprintf ppf "This pattern matches values of type")
+          (function ppf ->
+            fprintf ppf "but a pattern was expected which matches values of \
+                         type");
+      ) ()
+  | Or_pattern_type_clash (id, trace) ->
+      report_unification_error ~loc env trace
+        (function ppf ->
+          fprintf ppf "The variable %s on the left-hand side of this \
+                       or-pattern has type" (Ident.name id))
+        (function ppf ->
+          fprintf ppf "but on the right-hand side it has type")
+  | Multiply_bound_variable name ->
+      Location.errorf ~loc
+        "Variable %s is bound several times in this matching"
+        name
+  | Orpat_vars (id, valid_idents) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        fprintf ppf
+          "Variable %s must occur on both sides of this | pattern"
+          (Ident.name id);
+        spellcheck_idents ppf id valid_idents
+      ) ()
+  | Expr_type_clash (trace, explanation, exp) ->
+      let diff = type_clash_of_trace trace in
+      let sub = report_expr_type_clash_hints exp diff in
+      Location.error_of_printer ~loc ~sub (fun ppf () ->
+        Printtyp.report_unification_error ppf env trace
+          ~type_expected_explanation:
+            (report_type_expected_explanation_opt explanation)
+          (function ppf ->
+             fprintf ppf "This expression has type")
+          (function ppf ->
+             fprintf ppf "but an expression was expected of type");
+      ) ()
+  | Apply_non_function typ ->
+      begin match (repr typ).desc with
+        Tarrow _ ->
+          Location.errorf ~loc
+            "@[<v>@[<2>This function has type@ %a@]\
+             @ @[It is applied to too many arguments;@ %s@]@]"
+            type_expr typ "maybe you forgot a `;'.";
+      | _ ->
+          Location.errorf ~loc "@[<v>@[<2>This expression has type@ %a@]@ %s@]"
+            type_expr typ
+            "This is not a function; it cannot be applied."
+      end
+  | Apply_wrong_label (l, ty) ->
+      let print_label ppf = function
+        | Nolabel -> fprintf ppf "without label"
+        | l -> fprintf ppf "with label %s" (prefixed_label_name l)
+      in
+      Location.errorf ~loc
+        "@[<v>@[<2>The function applied to this argument has type@ %a@]@.\
+         This argument cannot be applied %a@]"
+        type_expr ty print_label l
+  | Label_multiply_defined s ->
+      Location.errorf ~loc "The record field label %s is defined several times"
+        s
+  | Label_missing labels ->
+      let print_labels ppf =
+        List.iter (fun lbl -> fprintf ppf "@ %s" (Ident.name lbl)) in
+      Location.errorf ~loc "@[<hov>Some record fields are undefined:%a@]"
+        print_labels labels
+  | Label_not_mutable lid ->
+      Location.errorf ~loc "The record field %a is not mutable" longident lid
+  | Wrong_name (eorp, ty_expected, kind, p, name, valid_names) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        let { ty; explanation } = ty_expected in
+        if Path.is_constructor_typath p then begin
+          fprintf ppf
+            "@[The field %s is not part of the record \
+             argument for the %a constructor@]"
+            name
+            path p;
+        end else begin
+          fprintf ppf
+            "@[@[<2>%s type@ %a%t@]@ \
+             The %s %s does not belong to type %a@]"
+            eorp type_expr ty
+            (report_type_expected_explanation_opt explanation)
+            (label_of_kind kind)
+            name (*kind*) path p;
+        end;
+        spellcheck ppf name valid_names
+      ) ()
+  | Name_type_mismatch (kind, lid, tp, tpl) ->
+      let name = label_of_kind kind in
+      Location.error_of_printer ~loc (fun ppf () ->
+        report_ambiguous_type_error ppf env tp tpl
+          (function ppf ->
+             fprintf ppf "The %s %a@ belongs to the %s type"
+               name longident lid kind)
+          (function ppf ->
+             fprintf ppf "The %s %a@ belongs to one of the following %s types:"
+               name longident lid kind)
+          (function ppf ->
+             fprintf ppf "but a %s was expected belonging to the %s type"
+               name kind)
+      ) ()
+  | Invalid_format msg ->
+      Location.errorf ~loc "%s" msg
+  | Undefined_method (ty, me, valid_methods) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        fprintf ppf
+          "@[<v>@[This expression has type@;<1 2>%a@]@,\
+           It has no method %s@]" type_expr ty me;
+        begin match valid_methods with
+          | None -> ()
+          | Some valid_methods -> spellcheck ppf me valid_methods
+        end
+      ) ()
+  | Undefined_inherited_method (me, valid_methods) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        fprintf ppf "This expression has no method %s" me;
+        spellcheck ppf me valid_methods;
+      ) ()
+  | Virtual_class cl ->
+      Location.errorf ~loc "Cannot instantiate the virtual class %a"
+        longident cl
+  | Unbound_instance_variable (var, valid_vars) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        fprintf ppf "Unbound instance variable %s" var;
+        spellcheck ppf var valid_vars;
+      ) ()
+  | Instance_variable_not_mutable v ->
+      Location.errorf ~loc "The instance variable %s is not mutable" v
+  | Not_subtype(tr1, tr2) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        report_subtyping_error ppf env tr1 "is not a subtype of" tr2
+      ) ()
+  | Outside_class ->
+      Location.errorf ~loc
+        "This object duplication occurs outside a method definition"
+  | Value_multiply_overridden v ->
+      Location.errorf ~loc
+        "The instance variable %s is overridden several times"
+        v
+  | Coercion_failure (ty, ty', trace, b) ->
+      Location.error_of_printer ~loc (fun ppf () ->
+        Printtyp.report_unification_error ppf env trace
+          (function ppf ->
+             let ty, ty' = prepare_expansion (ty, ty') in
+             fprintf ppf "This expression cannot be coerced to type@;<1 2>%a;@ \
+                          it has type"
+             (type_expansion ty) ty')
+          (function ppf ->
+             fprintf ppf "but is here used with type");
+        if b then
+          fprintf ppf ".@.@[<hov>%s@ %s@ %s@]"
+            "This simple coercion was not fully general."
+            "Hint: Consider using a fully explicit coercion"
+            "of the form: `(foo : ty1 :> ty2)'."
+      ) ()
+  | Too_many_arguments (in_function, ty, explanation) ->
+      if in_function then begin
+        Location.errorf ~loc
+          "This function expects too many arguments,@ \
+           it should have type@ %a%t"
+          type_expr ty
+          (report_type_expected_explanation_opt explanation)
+      end else begin
+        Location.errorf ~loc
+          "This expression should not be a function,@ \
+           the expected type is@ %a%t"
+          type_expr ty
+          (report_type_expected_explanation_opt explanation)
+      end
+  | Abstract_wrong_label (l, ty, explanation) ->
+      let label_mark = function
+        | Nolabel -> "but its first argument is not labelled"
+        | l -> sprintf "but its first argument is labelled %s"
+                       (prefixed_label_name l) in
+      Location.errorf ~loc
+        "@[<v>@[<2>This function should have type@ %a%t@]@,%s@]"
+        type_expr ty
+        (report_type_expected_explanation_opt explanation)
+        (label_mark l)
+  | Scoping_let_module(id, ty) ->
+      Location.errorf ~loc
+        "This `let module' expression has type@ %a@ \
+         In this type, the locally bound module name %s escapes its scope"
+        type_expr ty id
+  | Private_type ty ->
+      Location.errorf ~loc "Cannot create values of the private type %a"
+        type_expr ty
+  | Private_label (lid, ty) ->
+      Location.errorf ~loc "Cannot assign field %a of the private type %a"
+        longident lid type_expr ty
+  | Private_constructor (constr, ty) ->
+      Location.errorf ~loc
+        "Cannot use private constructor %s to create values of type %a"
+        constr.cstr_name type_expr ty
+  | Not_a_variant_type lid ->
+      Location.errorf ~loc "The type %a@ is not a variant type" longident lid
+  | Incoherent_label_order ->
+      Location.errorf ~loc
+        "This function is applied to arguments@ \
+        in an order different from other calls.@ \
+        This is only allowed when the real type is known."
+  | Less_general (kind, trace) ->
+      report_unification_error ~loc env trace
+        (fun ppf -> fprintf ppf "This %s has type" kind)
+        (fun ppf -> fprintf ppf "which is less general than")
+  | Modules_not_allowed ->
+      Location.errorf ~loc "Modules are not allowed in this pattern."
+  | Cannot_infer_signature ->
+      Location.errorf ~loc
+        "The signature for this packaged module couldn't be inferred."
+  | Not_a_packed_module ty ->
+      Location.errorf ~loc
+        "This expression is packed module, but the expected type is@ %a"
+        type_expr ty
+  | Unexpected_existential (reason, name, types) ->
+      let reason_str =
+        match reason with
+        | In_class_args ->
+            "Existential types are not allowed in class arguments"
+        | In_class_def ->
+            "Existential types are not allowed in bindings inside \
+             class definition"
+        | In_self_pattern ->
+            "Existential types are not allowed in self patterns"
+        | At_toplevel ->
+            "Existential types are not allowed in toplevel bindings"
+        | In_group ->
+            "Existential types are not allowed in \"let ... and ...\" bindings"
+        | In_rec ->
+            "Existential types are not allowed in recursive bindings"
+        | With_attributes ->
+            "Existential types are not allowed in presence of attributes"
+      in
+      begin match List.find (fun ty -> ty <> "$" ^ name) types with
+      | example ->
+          Location.errorf ~loc
+            "%s,@ but this pattern introduces the existential type %s."
+            reason_str example
+      | exception Not_found ->
+          Location.errorf ~loc
+            "%s,@ but the constructor %s introduces existential types."
+            reason_str name
+      end
+  | Invalid_interval ->
+      Location.errorf ~loc
+        "@[Only character intervals are supported in patterns.@]"
+  | Invalid_for_loop_index ->
+      Location.errorf ~loc
+        "@[Invalid for-loop index: only variables and _ are allowed.@]"
+  | No_value_clauses ->
+      Location.errorf ~loc
+        "None of the patterns in this 'match' expression match values."
+  | Exception_pattern_disallowed ->
+      Location.errorf ~loc
+        "@[Exception patterns are not allowed in this position.@]"
+  | Mixed_value_and_exception_patterns_under_guard ->
+      Location.errorf ~loc
+        "@[Mixing value and exception patterns under when-guards is not \
+         supported.@]"
+  | Inlined_record_escape ->
+      Location.errorf ~loc
+        "@[This form is not allowed as the type of the inlined record could \
+         escape.@]"
+  | Inlined_record_expected ->
+      Location.errorf ~loc
+        "@[This constructor expects an inlined record argument.@]"
+  | Unrefuted_pattern pat ->
+      Location.errorf ~loc
+        "@[%s@ %s@ %a@]"
+        "This match case could not be refuted."
+        "Here is an example of a value that would reach it:"
+        Printpat.top_pretty pat
+  | Invalid_extension_constructor_payload ->
+      Location.errorf ~loc
+        "Invalid [%%extension_constructor] payload, a constructor is expected."
+  | Not_an_extension_constructor ->
+      Location.errorf ~loc
+        "This constructor is not an extension constructor."
+  | Literal_overflow ty ->
+      Location.errorf ~loc
+        "Integer literal exceeds the range of representable integers of type %s"
+        ty
+  | Unknown_literal (n, m) ->
+      Location.errorf ~loc "Unknown modifier '%c' for literal %s%c" m n m
+  | Illegal_letrec_pat ->
+      Location.errorf ~loc
+        "Only variables are allowed as left-hand side of `let rec'"
+  | Illegal_letrec_expr ->
+      Location.errorf ~loc
+        "This kind of expression is not allowed as right-hand side of `let rec'"
+  | Illegal_class_expr ->
+      Location.errorf ~loc
+        "This kind of recursive class expression is not allowed"
+  | Letop_type_clash(name, trace) ->
+      report_unification_error ~loc env trace
+        (function ppf ->
+          fprintf ppf "The operator %s has type" name)
+        (function ppf ->
+          fprintf ppf "but it was expected to have type")
+  | Andop_type_clash(name, trace) ->
+      report_unification_error ~loc env trace
+        (function ppf ->
+          fprintf ppf "The operator %s has type" name)
+        (function ppf ->
+          fprintf ppf "but it was expected to have type")
+  | Bindings_type_clash(trace) ->
+      report_unification_error ~loc env trace
+        (function ppf ->
+          fprintf ppf "These bindings have type")
+        (function ppf ->
+          fprintf ppf "but bindings were expected of type")
+  | Empty_pattern -> assert false
+
+let report_error ~loc env err =
+  wrap_printing_env ~error:true env (fun () -> report_error ~loc env err)
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, env, err) ->
+        Some (report_error ~loc env err)
+      | Error_forward err ->
+        Some err
+      | _ ->
+        None
+    )
+
+let () =
+  Persistent_env.add_delayed_check_forward := add_delayed_check;
+  Env.add_delayed_check_forward := add_delayed_check;
+  ()
+
+(* drop ?recarg argument from the external API *)
+let type_expect ?in_function env e ty = type_expect ?in_function env e ty
+let type_exp env e = type_exp env e
+let type_argument env e t1 t2 = type_argument env e t1 t2
+
+(* Merlin specific *)
+let partial_pred =
+  let splitting_mode = Refine_or {inside_nonsplit_or = false} in
+  partial_pred ~splitting_mode
diff --git a/src/ocaml/typing/410+multicore/typecore.mli b/src/ocaml/typing/410+multicore/typecore.mli
new file mode 100644
index 00000000..e073f072
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typecore.mli
@@ -0,0 +1,228 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Type inference for the core language *)
+
+open Asttypes
+open Types
+
+(* This variant is used to print improved error messages, and does not affect
+   the behavior of the typechecker itself.
+
+   It describes possible explanation for types enforced by a keyword of the
+   language; e.g. "if" requires the condition to be of type bool, and the
+   then-branch to be of type unit if there is no else branch; "for" requires
+   indices to be of type int, and the body to be of type unit.
+*)
+type type_forcing_context =
+  | If_conditional
+  | If_no_else_branch
+  | While_loop_conditional
+  | While_loop_body
+  | For_loop_start_index
+  | For_loop_stop_index
+  | For_loop_body
+  | Assert_condition
+  | Sequence_left_hand_side
+  | When_guard
+
+(* The combination of a type and a "type forcing context". The intent is that it
+   describes a type that is "expected" (required) by the context. If unifying
+   with such a type fails, then the "explanation" field explains why it was
+   required, in order to display a more enlightening error message.
+*)
+type type_expected = private {
+  ty: type_expr;
+  explanation: type_forcing_context option;
+}
+
+val mk_expected:
+  ?explanation:type_forcing_context ->
+  type_expr ->
+  type_expected
+
+val is_nonexpansive: Typedtree.expression -> bool
+
+type existential_restriction =
+  | At_toplevel (** no existential types at the toplevel *)
+  | In_group (** nor with [let ... and ...] *)
+  | In_rec (** or recursive definition *)
+  | With_attributes (** or [let[@any_attribute] = ...] *)
+  | In_class_args (** or in class arguments [class c (...) = ...] *)
+  | In_class_def (** or in [class c = let ... in ...] *)
+  | In_self_pattern (** or in self pattern *)
+
+val type_binding:
+        Env.t -> rec_flag ->
+          Parsetree.value_binding list ->
+          Annot.ident option ->
+          Typedtree.value_binding list * Env.t
+val type_let:
+        existential_restriction -> Env.t -> rec_flag ->
+          Parsetree.value_binding list ->
+          Annot.ident option ->
+          Typedtree.value_binding list * Env.t
+val type_expression:
+        Env.t -> Parsetree.expression -> Typedtree.expression
+val type_class_arg_pattern:
+        string -> Env.t -> Env.t -> arg_label -> Parsetree.pattern ->
+        Typedtree.pattern * (Ident.t * Ident.t * type_expr) list *
+        Env.t * Env.t
+val type_self_pattern:
+        string -> type_expr -> Env.t -> Env.t -> Env.t -> Parsetree.pattern ->
+        Typedtree.pattern *
+        (Ident.t * type_expr) Meths.t ref *
+        (Ident.t * Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr)
+            Vars.t ref *
+        Env.t * Env.t * Env.t
+val check_partial:
+        ?lev:int -> Env.t -> type_expr ->
+        Location.t -> Typedtree.case list -> Typedtree.partial
+val type_expect:
+        ?in_function:(Location.t * type_expr) ->
+        Env.t -> Parsetree.expression -> type_expected -> Typedtree.expression
+val type_exp:
+        Env.t -> Parsetree.expression -> Typedtree.expression
+val type_approx:
+        Env.t -> Parsetree.expression -> type_expr
+val type_argument:
+        Env.t -> Parsetree.expression ->
+        type_expr -> type_expr -> Typedtree.expression
+
+val option_some: Env.t -> Typedtree.expression -> Typedtree.expression
+val option_none: Env.t -> type_expr -> Location.t -> Typedtree.expression
+val extract_option_type: Env.t -> type_expr -> type_expr
+val generalizable: int -> type_expr -> bool
+type delayed_check
+val delayed_checks: delayed_check list ref
+val reset_delayed_checks: unit -> unit
+val force_delayed_checks: unit -> unit
+
+val name_pattern : string -> Typedtree.pattern list -> Ident.t
+
+val name_cases : string -> Typedtree.case list -> Ident.t
+
+val self_coercion : (Path.t * Location.t list ref) list ref
+
+type error =
+  | Constructor_arity_mismatch of Longident.t * int * int
+  | Label_mismatch of Longident.t * Ctype.Unification_trace.t
+  | Pattern_type_clash of
+      Ctype.Unification_trace.t * Typedtree.pattern_desc option
+  | Or_pattern_type_clash of Ident.t * Ctype.Unification_trace.t
+  | Multiply_bound_variable of string
+  | Orpat_vars of Ident.t * Ident.t list
+  | Expr_type_clash of
+      Ctype.Unification_trace.t * type_forcing_context option
+      * Typedtree.expression_desc option
+  | Apply_non_function of type_expr
+  | Apply_wrong_label of arg_label * type_expr
+  | Label_multiply_defined of string
+  | Label_missing of Ident.t list
+  | Label_not_mutable of Longident.t
+  | Wrong_name of
+      string * type_expected * string * Path.t * string * string list
+  | Name_type_mismatch of
+      string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
+  | Invalid_format of string
+  | Undefined_method of type_expr * string * string list option
+  | Undefined_inherited_method of string * string list
+  | Virtual_class of Longident.t
+  | Private_type of type_expr
+  | Private_label of Longident.t * type_expr
+  | Private_constructor of constructor_description * type_expr
+  | Unbound_instance_variable of string * string list
+  | Instance_variable_not_mutable of string
+  | Not_subtype of Ctype.Unification_trace.t * Ctype.Unification_trace.t
+  | Outside_class
+  | Value_multiply_overridden of string
+  | Coercion_failure of
+      type_expr * type_expr * Ctype.Unification_trace.t * bool
+  | Too_many_arguments of bool * type_expr * type_forcing_context option
+  | Abstract_wrong_label of arg_label * type_expr * type_forcing_context option
+  | Scoping_let_module of string * type_expr
+  | Not_a_variant_type of Longident.t
+  | Incoherent_label_order
+  | Less_general of string * Ctype.Unification_trace.t
+  | Modules_not_allowed
+  | Cannot_infer_signature
+  | Not_a_packed_module of type_expr
+  | Unexpected_existential of existential_restriction * string * string list
+  | Invalid_interval
+  | Invalid_for_loop_index
+  | No_value_clauses
+  | Exception_pattern_disallowed
+  | Mixed_value_and_exception_patterns_under_guard
+  | Inlined_record_escape
+  | Inlined_record_expected
+  | Unrefuted_pattern of Typedtree.pattern
+  | Invalid_extension_constructor_payload
+  | Not_an_extension_constructor
+  | Literal_overflow of string
+  | Unknown_literal of string * char
+  | Illegal_letrec_pat
+  | Illegal_letrec_expr
+  | Illegal_class_expr
+  | Empty_pattern
+  | Letop_type_clash of string * Ctype.Unification_trace.t
+  | Andop_type_clash of string * Ctype.Unification_trace.t
+  | Bindings_type_clash of Ctype.Unification_trace.t
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+val report_error: loc:Location.t -> Env.t -> error -> Location.error
+ (** @deprecated.  Use {!Location.error_of_exn}, {!Location.print_report}. *)
+
+(* Forward declaration, to be filled in by Typemod.type_module *)
+val type_module: (Env.t -> Parsetree.module_expr -> Typedtree.module_expr) ref
+(* Forward declaration, to be filled in by Typemod.type_open *)
+val type_open:
+  (?used_slot:bool ref -> override_flag -> Env.t -> Location.t ->
+   Longident.t loc -> Path.t * Env.t)
+    ref
+(* Forward declaration, to be filled in by Typemod.type_open_decl *)
+val type_open_decl:
+  (?used_slot:bool ref -> Env.t -> Parsetree.open_declaration ->
+   Typedtree.open_declaration * Types.signature * Env.t)
+    ref
+(* Forward declaration, to be filled in by Typeclass.class_structure *)
+val type_object:
+  (Env.t -> Location.t -> Parsetree.class_structure ->
+   Typedtree.class_structure * Types.class_signature * string list) ref
+val type_package:
+  (Env.t -> Parsetree.module_expr -> Path.t -> Longident.t list ->
+  Typedtree.module_expr * type_expr list) ref
+
+val create_package_type : Location.t -> Env.t ->
+  Longident.t * (Longident.t * Parsetree.core_type) list ->
+  Path.t * (Longident.t * Typedtree.core_type) list * Types.type_expr
+
+val constant: Parsetree.constant -> (Asttypes.constant, error) result
+
+val check_recursive_bindings : Env.t -> Typedtree.value_binding list -> unit
+val check_recursive_class_bindings :
+  Env.t -> Ident.t list -> Typedtree.class_expr list -> unit
+
+(* Merlin specific *)
+val partial_pred :
+  lev:int ->
+  ?explode:int ->
+  Env.t ->
+  type_expr ->
+  (label, constructor_description) Hashtbl.t ->
+  (label, label_description) Hashtbl.t ->
+  Parsetree.pattern ->
+  Typedtree.pattern option
diff --git a/src/ocaml/typing/410+multicore/typedecl.ml b/src/ocaml/typing/410+multicore/typedecl.ml
new file mode 100644
index 00000000..d9c8c2ec
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl.ml
@@ -0,0 +1,1839 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*  Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt  *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(**** Typing of type definitions ****)
+
+open Misc
+open Asttypes
+open Parsetree
+open Primitive
+open Types
+open Typetexp
+
+module String = Std.String
+
+type native_repr_kind = Unboxed | Untagged
+
+type error =
+    Repeated_parameter
+  | Duplicate_constructor of string
+  | Too_many_constructors
+  | Duplicate_label of string
+  | Recursive_abbrev of string
+  | Cycle_in_def of string * type_expr
+  | Definition_mismatch of type_expr * Includecore.type_mismatch option
+  | Constraint_failed of type_expr * type_expr
+  | Inconsistent_constraint of Env.t * Ctype.Unification_trace.t
+  | Type_clash of Env.t * Ctype.Unification_trace.t
+  | Parameters_differ of Path.t * type_expr * type_expr
+  | Null_arity_external
+  | Missing_native_external
+  | Unbound_type_var of type_expr * type_declaration
+  | Cannot_extend_private_type of Path.t
+  | Not_extensible_type of Path.t
+  | Extension_mismatch of Path.t * Includecore.type_mismatch
+  | Rebind_wrong_type of Longident.t * Env.t * Ctype.Unification_trace.t
+  | Rebind_mismatch of Longident.t * Path.t * Path.t
+  | Rebind_private of Longident.t
+  | Variance of Typedecl_variance.error
+  | Unavailable_type_constructor of Path.t
+  | Bad_fixed_type of string
+  | Unbound_type_var_ext of type_expr * extension_constructor
+  | Val_in_structure
+  | Multiple_native_repr_attributes
+  | Cannot_unbox_or_untag_type of native_repr_kind
+  | Deep_unbox_or_untag_attribute of native_repr_kind
+  | Immediacy of Typedecl_immediacy.error
+  | Bad_unboxed_attribute of string
+  | Wrong_unboxed_type_float
+  | Boxed_and_unboxed
+  | Nonrec_gadt
+
+open Typedtree
+
+exception Error of Location.t * error
+
+(* Note: do not factor the branches in the following pattern-matching:
+   the records must be constants for the compiler to do sharing on them.
+*)
+let get_unboxed_from_attributes sdecl =
+  let unboxed = Builtin_attributes.has_unboxed sdecl.ptype_attributes in
+  let boxed = Builtin_attributes.has_boxed sdecl.ptype_attributes in
+  match boxed, unboxed, !Clflags.unboxed_types with
+  | true, true, _ -> raise (Error(sdecl.ptype_loc, Boxed_and_unboxed))
+  | true, false, _ -> unboxed_false_default_false
+  | false, true, _ -> unboxed_true_default_false
+  | false, false, false -> unboxed_false_default_true
+  | false, false, true -> unboxed_true_default_true
+
+(* Enter all declared types in the environment as abstract types *)
+
+let add_type ~check id decl env =
+  Builtin_attributes.warning_scope ~ppwarning:false decl.type_attributes
+    (fun () -> Env.add_type ~check id decl env)
+
+let enter_type rec_flag env sdecl id =
+  let needed =
+    match rec_flag with
+    | Asttypes.Nonrecursive ->
+        begin match sdecl.ptype_kind with
+        | Ptype_variant scds ->
+            List.iter (fun cd ->
+              if cd.pcd_res <> None then raise (Error(cd.pcd_loc, Nonrec_gadt)))
+              scds
+        | _ -> ()
+        end;
+        Btype.is_row_name (Ident.name id)
+    | Asttypes.Recursive -> true
+  in
+  if not needed then env else
+  let decl =
+    { type_params =
+        List.map (fun _ -> Btype.newgenvar ()) sdecl.ptype_params;
+      type_arity = List.length sdecl.ptype_params;
+      type_kind = Type_abstract;
+      type_private = sdecl.ptype_private;
+      type_manifest =
+        begin match sdecl.ptype_manifest with None -> None
+        | Some _ -> Some(Ctype.newvar ()) end;
+      type_variance = List.map (fun _ -> Variance.full) sdecl.ptype_params;
+      type_is_newtype = false;
+      type_expansion_scope = Btype.lowest_level;
+      type_loc = sdecl.ptype_loc;
+      type_attributes = sdecl.ptype_attributes;
+      type_immediate = Unknown;
+      type_unboxed = unboxed_false_default_false;
+    }
+  in
+  add_type ~check:true id decl env
+
+let update_type temp_env env id loc =
+  let path = Path.Pident id in
+  let decl = Env.find_type path temp_env in
+  match decl.type_manifest with None -> ()
+  | Some ty ->
+      let params = List.map (fun _ -> Ctype.newvar ()) decl.type_params in
+      try Ctype.unify env (Ctype.newconstr path params) ty
+      with Ctype.Unify trace ->
+        raise (Error(loc, Type_clash (env, trace)))
+
+let get_unboxed_type_representation env ty =
+  match Typedecl_unboxed.get_unboxed_type_representation env ty with
+  | Typedecl_unboxed.This x -> Some x
+  | _ -> None
+
+(* Determine if a type's values are represented by floats at run-time. *)
+let is_float env ty =
+  match get_unboxed_type_representation env ty with
+    Some {desc = Tconstr(p, _, _); _} -> Path.same p Predef.path_float
+  | _ -> false
+
+(* Determine if a type definition defines a fixed type. (PW) *)
+let is_fixed_type sd =
+  let rec has_row_var sty =
+    match sty.ptyp_desc with
+      Ptyp_alias (sty, _) -> has_row_var sty
+    | Ptyp_class _
+    | Ptyp_object (_, Open)
+    | Ptyp_variant (_, Open, _)
+    | Ptyp_variant (_, Closed, Some _) -> true
+    | _ -> false
+  in
+  match sd.ptype_manifest with
+    None -> false
+  | Some sty ->
+      sd.ptype_kind = Ptype_abstract &&
+      sd.ptype_private = Private &&
+      has_row_var sty
+
+(* Set the row variable in a fixed type *)
+let set_fixed_row env loc p decl =
+  let tm =
+    match decl.type_manifest with
+      None -> assert false
+    | Some t -> Ctype.expand_head env t
+  in
+  let rv =
+    match tm.desc with
+      Tvariant row ->
+        let row = Btype.row_repr row in
+        tm.desc <- Tvariant {row with row_fixed = Some Fixed_private};
+        if Btype.static_row row then Btype.newgenty Tnil
+        else row.row_more
+    | Tobject (ty, _) ->
+        snd (Ctype.flatten_fields ty)
+    | _ ->
+        raise (Error (loc, Bad_fixed_type "is not an object or variant"))
+  in
+  if not (Btype.is_Tvar rv) then
+    raise (Error (loc, Bad_fixed_type "has no row variable"));
+  rv.desc <- Tconstr (p, decl.type_params, ref Mnil)
+
+(* Translate one type declaration *)
+
+let make_params env params =
+  let make_param (sty, v) =
+    try
+      (transl_type_param env sty, v)
+    with Already_bound ->
+      raise(Error(sty.ptyp_loc, Repeated_parameter))
+  in
+    List.map make_param params
+
+let transl_labels env closed lbls =
+  assert (lbls <> []);
+  let all_labels = ref String.Set.empty in
+  List.iter
+    (fun {pld_name = {txt=name; loc}} ->
+       if String.Set.mem name !all_labels then
+         raise(Error(loc, Duplicate_label name));
+       all_labels := String.Set.add name !all_labels)
+    lbls;
+  let mk {pld_name=name;pld_mutable=mut;pld_type=arg;pld_loc=loc;
+          pld_attributes=attrs} =
+    Builtin_attributes.warning_scope attrs
+      (fun () ->
+         let arg = Ast_helper.Typ.force_poly arg in
+         let cty = transl_simple_type env closed arg in
+         {ld_id = Ident.create_local name.txt;
+          ld_name = name; ld_mutable = mut;
+          ld_type = cty; ld_loc = loc; ld_attributes = attrs}
+      )
+  in
+  let lbls = List.map mk lbls in
+  let lbls' =
+    List.map
+      (fun ld ->
+         let ty = ld.ld_type.ctyp_type in
+         let ty = match ty.desc with Tpoly(t,[]) -> t | _ -> ty in
+         {Types.ld_id = ld.ld_id;
+          ld_mutable = ld.ld_mutable;
+          ld_type = ty;
+          ld_loc = ld.ld_loc;
+          ld_attributes = ld.ld_attributes
+         }
+      )
+      lbls in
+  lbls, lbls'
+
+let transl_constructor_arguments env closed = function
+  | Pcstr_tuple l ->
+      let l = List.map (transl_simple_type env closed) l in
+      Types.Cstr_tuple (List.map (fun t -> t.ctyp_type) l),
+      Cstr_tuple l
+  | Pcstr_record l ->
+      let lbls, lbls' = transl_labels env closed l in
+      Types.Cstr_record lbls',
+      Cstr_record lbls
+
+let make_constructor env type_path type_params sargs sret_type =
+  match sret_type with
+  | None ->
+      let args, targs =
+        transl_constructor_arguments env true sargs
+      in
+        targs, None, args, None, type_params
+  | Some sret_type ->
+      (* if it's a generalized constructor we must first narrow and
+         then widen so as to not introduce any new constraints *)
+      let z = narrow () in
+      reset_type_variables ();
+      let args, targs =
+        transl_constructor_arguments env false sargs
+      in
+      let tret_type = transl_simple_type env false sret_type in
+      let ret_type = tret_type.ctyp_type in
+      let params =
+        match (Ctype.repr ret_type).desc with
+        | Tconstr (p', params, _) when Path.same type_path p' ->
+            params
+        | _ ->
+            raise (Error (sret_type.ptyp_loc, Constraint_failed
+                            (ret_type, Ctype.newconstr type_path type_params)))
+      in
+      widen z;
+      targs, Some tret_type, args, Some ret_type, params
+
+(* Check that the variable [id] is present in the [univ] list. *)
+let check_type_var loc univ id =
+  let f t = (Btype.repr t).id = id in
+  if not (List.exists f univ) then raise (Error (loc, Wrong_unboxed_type_float))
+
+(* Check that all the variables found in [ty] are in [univ].
+   Because [ty] is the argument to an abstract type, the representation
+   of that abstract type could be any subexpression of [ty], in particular
+   any type variable present in [ty].
+*)
+let rec check_unboxed_abstract_arg loc univ ty =
+  match ty.desc with
+  | Tvar _ -> check_type_var loc univ ty.id
+  | Tarrow (_, t1, t2, _)
+  | Tfield (_, _, t1, t2) ->
+    check_unboxed_abstract_arg loc univ t1;
+    check_unboxed_abstract_arg loc univ t2
+  | Ttuple args
+  | Tconstr (_, args, _)
+  | Tpackage (_, _, args) ->
+    List.iter (check_unboxed_abstract_arg loc univ) args
+  | Tobject (fields, r) ->
+    check_unboxed_abstract_arg loc univ fields;
+    begin match !r with
+    | None -> ()
+    | Some (_, args) -> List.iter (check_unboxed_abstract_arg loc univ) args
+    end
+  | Tnil
+  | Tunivar _ -> ()
+  | Tlink e -> check_unboxed_abstract_arg loc univ e
+  | Tsubst _ -> assert false
+  | Tvariant { row_fields; row_more; row_name } ->
+    List.iter (check_unboxed_abstract_row_field loc univ) row_fields;
+    check_unboxed_abstract_arg loc univ row_more;
+    begin match row_name with
+    | None -> ()
+    | Some (_, args) -> List.iter (check_unboxed_abstract_arg loc univ) args
+    end
+  | Tpoly (t, _) -> check_unboxed_abstract_arg loc univ t
+
+and check_unboxed_abstract_row_field loc univ (_, field) =
+  match field with
+  | Rpresent (Some ty) -> check_unboxed_abstract_arg loc univ ty
+  | Reither (_, args, _, r) ->
+    List.iter (check_unboxed_abstract_arg loc univ) args;
+    begin match !r with
+    | None -> ()
+    | Some f -> check_unboxed_abstract_row_field loc univ ("", f)
+    end
+  | Rabsent
+  | Rpresent None -> ()
+
+(* Check that the argument to a GADT constructor is compatible with unboxing
+   the type, given the universal parameters of the type. *)
+let rec check_unboxed_gadt_arg loc univ env ty =
+  match get_unboxed_type_representation env ty with
+  | Some {desc = Tvar _; id} -> check_type_var loc univ id
+  | Some {desc = Tarrow _ | Ttuple _ | Tpackage _ | Tobject _ | Tnil
+                 | Tvariant _; _} ->
+    ()
+    (* A comment in [Translcore.transl_exp0] claims the above cannot be
+       represented by floats. *)
+  | Some {desc = Tconstr (p, args, _); _} ->
+    let tydecl = Env.find_type p env in
+    assert (not tydecl.type_unboxed.unboxed);
+    if tydecl.type_kind = Type_abstract then
+      List.iter (check_unboxed_abstract_arg loc univ) args
+  | Some {desc = Tfield _ | Tlink _ | Tsubst _; _} -> assert false
+  | Some {desc = Tunivar _; _} -> ()
+  | Some {desc = Tpoly (t2, _); _} -> check_unboxed_gadt_arg loc univ env t2
+  | None -> ()
+      (* This case is tricky: the argument is another (or the same) type
+         in the same recursive definition. In this case we don't have to
+         check because we will also check that other type for correctness. *)
+
+let transl_declaration env sdecl id =
+  (* Bind type parameters *)
+  reset_type_variables();
+  Ctype.begin_def ();
+  let tparams = make_params env sdecl.ptype_params in
+  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
+  let cstrs = List.map
+    (fun (sty, sty', loc) ->
+      transl_simple_type env false sty,
+      transl_simple_type env false sty', loc)
+    sdecl.ptype_cstrs
+  in
+  let raw_status = get_unboxed_from_attributes sdecl in
+  if raw_status.unboxed && not raw_status.default then begin
+    match sdecl.ptype_kind with
+    | Ptype_abstract ->
+        raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                      "it is abstract"))
+    | Ptype_variant [{pcd_args = Pcstr_tuple []; _}] ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "its constructor has no argument"))
+    | Ptype_variant [{pcd_args = Pcstr_tuple [_]; _}] -> ()
+    | Ptype_variant [{pcd_args = Pcstr_tuple _; _}] ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "its constructor has more than one argument"))
+    | Ptype_variant [{pcd_args = Pcstr_record
+                        [{pld_mutable=Immutable; _}]; _}] -> ()
+    | Ptype_variant [{pcd_args = Pcstr_record [{pld_mutable=Mutable; _}]; _}] ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute "it is mutable"))
+    | Ptype_variant [{pcd_args = Pcstr_record _; _}] ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "its constructor has more than one argument"))
+    | Ptype_variant _ ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "it has more than one constructor"))
+    | Ptype_record [{pld_mutable=Immutable; _}] -> ()
+    | Ptype_record [{pld_mutable=Mutable; _}] ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "it is mutable"))
+    | Ptype_record _ ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "it has more than one field"))
+    | Ptype_open ->
+      raise(Error(sdecl.ptype_loc, Bad_unboxed_attribute
+                    "extensible variant types cannot be unboxed"))
+  end;
+  let unboxed_status =
+    match sdecl.ptype_kind with
+    | Ptype_variant [{pcd_args = Pcstr_tuple [_]; _}]
+      | Ptype_variant [{pcd_args = Pcstr_record
+                          [{pld_mutable = Immutable; _}]; _}]
+      | Ptype_record [{pld_mutable = Immutable; _}] ->
+    raw_status
+    | _ -> (* The type is not unboxable, mark it as boxed *)
+      unboxed_false_default_false
+  in
+  let unbox = unboxed_status.unboxed in
+  let (tkind, kind) =
+    match sdecl.ptype_kind with
+      | Ptype_abstract -> Ttype_abstract, Type_abstract
+      | Ptype_variant scstrs ->
+        if List.exists (fun cstr -> cstr.pcd_res <> None) scstrs then begin
+          match cstrs with
+            [] -> ()
+          | (_,_,loc)::_ ->
+              Location.prerr_warning loc Warnings.Constraint_on_gadt
+        end;
+        let all_constrs = ref String.Set.empty in
+        List.iter
+          (fun {pcd_name = {txt = name}} ->
+            if String.Set.mem name !all_constrs then
+              raise(Error(sdecl.ptype_loc, Duplicate_constructor name));
+            all_constrs := String.Set.add name !all_constrs)
+          scstrs;
+        if List.length
+            (List.filter (fun cd -> cd.pcd_args <> Pcstr_tuple []) scstrs)
+           > (Config.max_tag + 1) then
+          raise(Error(sdecl.ptype_loc, Too_many_constructors));
+        let make_cstr scstr =
+          let name = Ident.create_local scstr.pcd_name.txt in
+          let targs, tret_type, args, ret_type, cstr_params =
+            make_constructor env (Path.Pident id) params
+                             scstr.pcd_args scstr.pcd_res
+          in
+          if Config.flat_float_array && unbox then begin
+            (* Cannot unbox a type when the argument can be both float and
+               non-float because it interferes with the dynamic float array
+               optimization. This can only happen when the type is a GADT
+               and the argument is an existential type variable or an
+               unboxed (or abstract) type constructor applied to some
+               existential type variable. Of course we also have to rule
+               out any abstract type constructor applied to anything that
+               might be an existential type variable.
+               There is a difficulty with existential variables created
+               out of thin air (rather than bound by the declaration).
+               See PR#7511 and GPR#1133 for details. *)
+            match Datarepr.constructor_existentials args ret_type with
+            | _, [] -> ()
+            | [argty], _ex ->
+                check_unboxed_gadt_arg sdecl.ptype_loc cstr_params env argty
+            | _ -> assert false
+          end;
+          let tcstr =
+            { cd_id = name;
+              cd_name = scstr.pcd_name;
+              cd_args = targs;
+              cd_res = tret_type;
+              cd_loc = scstr.pcd_loc;
+              cd_attributes = scstr.pcd_attributes }
+          in
+          let cstr =
+            { Types.cd_id = name;
+              cd_args = args;
+              cd_res = ret_type;
+              cd_loc = scstr.pcd_loc;
+              cd_attributes = scstr.pcd_attributes }
+          in
+            tcstr, cstr
+        in
+        let make_cstr scstr =
+          Builtin_attributes.warning_scope scstr.pcd_attributes
+            (fun () -> make_cstr scstr)
+        in
+        let tcstrs, cstrs = List.split (List.map make_cstr scstrs) in
+          Ttype_variant tcstrs, Type_variant cstrs
+      | Ptype_record lbls ->
+          let lbls, lbls' = transl_labels env true lbls in
+          let rep =
+            if unbox then Record_unboxed false
+            else if List.for_all (fun l -> is_float env l.Types.ld_type) lbls'
+            then Record_float
+            else Record_regular
+          in
+          Ttype_record lbls, Type_record(lbls', rep)
+      | Ptype_open -> Ttype_open, Type_open
+      in
+    let (tman, man) = match sdecl.ptype_manifest with
+        None -> None, None
+      | Some sty ->
+        let no_row = not (is_fixed_type sdecl) in
+        let cty = transl_simple_type env no_row sty in
+        Some cty, Some cty.ctyp_type
+    in
+    let decl =
+      { type_params = params;
+        type_arity = List.length params;
+        type_kind = kind;
+        type_private = sdecl.ptype_private;
+        type_manifest = man;
+        type_variance = List.map (fun _ -> Variance.full) params;
+        type_is_newtype = false;
+        type_expansion_scope = Btype.lowest_level;
+        type_loc = sdecl.ptype_loc;
+        type_attributes = sdecl.ptype_attributes;
+        type_immediate = Unknown;
+        type_unboxed = unboxed_status;
+      } in
+
+  (* Check constraints *)
+    List.iter
+      (fun (cty, cty', loc) ->
+        let ty = cty.ctyp_type in
+        let ty' = cty'.ctyp_type in
+        try Ctype.unify env ty ty' with Ctype.Unify tr ->
+          raise(Error(loc, Inconsistent_constraint (env, tr))))
+      cstrs;
+    Ctype.end_def ();
+  (* Add abstract row *)
+    if is_fixed_type sdecl then begin
+      let p, _ =
+        try Env.find_type_by_name
+              (Longident.Lident(Ident.name id ^ "#row")) env
+        with Not_found -> assert false
+      in
+      set_fixed_row env sdecl.ptype_loc p decl
+    end;
+  (* Check for cyclic abbreviations *)
+    begin match decl.type_manifest with None -> ()
+      | Some ty ->
+        if Ctype.cyclic_abbrev env id ty then
+          raise(Error(sdecl.ptype_loc, Recursive_abbrev sdecl.ptype_name.txt));
+    end;
+    {
+      typ_id = id;
+      typ_name = sdecl.ptype_name;
+      typ_params = tparams;
+      typ_type = decl;
+      typ_cstrs = cstrs;
+      typ_loc = sdecl.ptype_loc;
+      typ_manifest = tman;
+      typ_kind = tkind;
+      typ_private = sdecl.ptype_private;
+      typ_attributes = sdecl.ptype_attributes;
+    }
+
+(* Generalize a type declaration *)
+
+let generalize_decl decl =
+  List.iter Ctype.generalize decl.type_params;
+  Btype.iter_type_expr_kind Ctype.generalize decl.type_kind;
+  begin match decl.type_manifest with
+  | None    -> ()
+  | Some ty -> Ctype.generalize ty
+  end
+
+(* Check that all constraints are enforced *)
+
+module TypeSet = Btype.TypeSet
+module TypeMap = Btype.TypeMap
+
+let rec check_constraints_rec env loc visited ty =
+  let ty = Ctype.repr ty in
+  if TypeSet.mem ty !visited then () else begin
+  visited := TypeSet.add ty !visited;
+  match ty.desc with
+  | Tconstr (path, args, _) ->
+      let args' = List.map (fun _ -> Ctype.newvar ()) args in
+      let ty' = Ctype.newconstr path args' in
+      begin try Ctype.enforce_constraints env ty'
+      with Ctype.Unify _ -> assert false
+      | Not_found -> raise (Error(loc, Unavailable_type_constructor path))
+      end;
+      if not (Ctype.matches env ty ty') then
+        raise (Error(loc, Constraint_failed (ty, ty')));
+      List.iter (check_constraints_rec env loc visited) args
+  | Tpoly (ty, tl) ->
+      let _, ty = Ctype.instance_poly false tl ty in
+      check_constraints_rec env loc visited ty
+  | _ ->
+      Btype.iter_type_expr (check_constraints_rec env loc visited) ty
+  end
+
+let check_constraints_labels env visited l pl =
+  let rec get_loc name = function
+      [] -> assert false
+    | pld :: tl ->
+        if name = pld.pld_name.txt then pld.pld_type.ptyp_loc
+        else get_loc name tl
+  in
+  List.iter
+    (fun {Types.ld_id=name; ld_type=ty} ->
+       check_constraints_rec env (get_loc (Ident.name name) pl) visited ty)
+    l
+
+let check_constraints env sdecl (_, decl) =
+  let visited = ref TypeSet.empty in
+  begin match decl.type_kind with
+  | Type_abstract -> ()
+  | Type_variant l ->
+      let find_pl = function
+          Ptype_variant pl -> pl
+        | Ptype_record _ | Ptype_abstract | Ptype_open -> assert false
+      in
+      let pl = find_pl sdecl.ptype_kind in
+      let pl_index =
+        let foldf acc x =
+          String.Map.add ~key:x.pcd_name.txt ~data:x acc
+        in
+        List.fold_left foldf String.Map.empty pl
+      in
+      List.iter
+        (fun {Types.cd_id=name; cd_args; cd_res} ->
+          let {pcd_args; pcd_res; _} =
+            try String.Map.find (Ident.name name) pl_index
+            with Not_found -> assert false in
+          begin match cd_args, pcd_args with
+          | Cstr_tuple tyl, Pcstr_tuple styl ->
+              List.iter2
+                (fun sty ty ->
+                   check_constraints_rec env sty.ptyp_loc visited ty)
+                styl tyl
+          | Cstr_record tyl, Pcstr_record styl ->
+              check_constraints_labels env visited tyl styl
+          | _ -> assert false
+          end;
+          match pcd_res, cd_res with
+          | Some sr, Some r ->
+              check_constraints_rec env sr.ptyp_loc visited r
+          | _ ->
+              () )
+        l
+  | Type_record (l, _) ->
+      let find_pl = function
+          Ptype_record pl -> pl
+        | Ptype_variant _ | Ptype_abstract | Ptype_open -> assert false
+      in
+      let pl = find_pl sdecl.ptype_kind in
+      check_constraints_labels env visited l pl
+  | Type_open -> ()
+  end;
+  begin match decl.type_manifest with
+  | None -> ()
+  | Some ty ->
+      let sty =
+        match sdecl.ptype_manifest with Some sty -> sty | _ -> assert false
+      in
+      check_constraints_rec env sty.ptyp_loc visited ty
+  end
+
+(*
+   If both a variant/record definition and a type equation are given,
+   need to check that the equation refers to a type of the same kind
+   with the same constructors and labels.
+*)
+let check_coherence env loc dpath decl =
+  match decl with
+    { type_kind = (Type_variant _ | Type_record _| Type_open);
+      type_manifest = Some ty } ->
+      begin match (Ctype.repr ty).desc with
+        Tconstr(path, args, _) ->
+          begin try
+            let decl' = Env.find_type path env in
+            let err =
+              if List.length args <> List.length decl.type_params
+              then Some Includecore.Arity
+              else if not (Ctype.equal env false args decl.type_params)
+              then Some Includecore.Constraint
+              else
+                Includecore.type_declarations ~loc ~equality:true env
+                  ~mark:true
+                  (Path.last path)
+                  decl'
+                  dpath
+                  (Subst.type_declaration
+                     (Subst.add_type_path dpath path Subst.identity) decl)
+            in
+            if err <> None then
+              raise(Error(loc, Definition_mismatch (ty, err)))
+          with Not_found ->
+            raise(Error(loc, Unavailable_type_constructor path))
+          end
+      | _ -> raise(Error(loc, Definition_mismatch (ty, None)))
+      end
+  | _ -> ()
+
+let check_abbrev env sdecl (id, decl) =
+  check_coherence env sdecl.ptype_loc (Path.Pident id) decl
+
+(* Check that recursion is well-founded *)
+
+let check_well_founded env loc path to_check ty =
+  let visited = ref TypeMap.empty in
+  let rec check ty0 parents ty =
+    let ty = Btype.repr ty in
+    if TypeSet.mem ty parents then begin
+      (*Format.eprintf "@[%a@]@." Printtyp.raw_type_expr ty;*)
+      if match ty0.desc with
+      | Tconstr (p, _, _) -> Path.same p path
+      | _ -> false
+      then raise (Error (loc, Recursive_abbrev (Path.name path)))
+      else raise (Error (loc, Cycle_in_def (Path.name path, ty0)))
+    end;
+    let (fini, parents) =
+      try
+        let prev = TypeMap.find ty !visited in
+        if TypeSet.subset parents prev then (true, parents) else
+        (false, TypeSet.union parents prev)
+      with Not_found ->
+        (false, parents)
+    in
+    if fini then () else
+    let rec_ok =
+      match ty.desc with
+        Tconstr(p,_,_) ->
+          !Clflags.recursive_types && Ctype.is_contractive env p
+      | Tobject _ | Tvariant _ -> true
+      | _ -> !Clflags.recursive_types
+    in
+    let visited' = TypeMap.add ty parents !visited in
+    let arg_exn =
+      try
+        visited := visited';
+        let parents =
+          if rec_ok then TypeSet.empty else TypeSet.add ty parents in
+        Btype.iter_type_expr (check ty0 parents) ty;
+        None
+      with e ->
+        visited := visited'; Some e
+    in
+    match ty.desc with
+    | Tconstr(p, _, _) when arg_exn <> None || to_check p ->
+        if to_check p then Option.iter raise arg_exn
+        else Btype.iter_type_expr (check ty0 TypeSet.empty) ty;
+        begin try
+          let ty' = Ctype.try_expand_once_opt env ty in
+          let ty0 = if TypeSet.is_empty parents then ty else ty0 in
+          check ty0 (TypeSet.add ty parents) ty'
+        with
+          Ctype.Cannot_expand -> Option.iter raise arg_exn
+        end
+    | _ -> Option.iter raise arg_exn
+  in
+  let snap = Btype.snapshot () in
+  try Ctype.wrap_trace_gadt_instances env (check ty TypeSet.empty) ty
+  with Ctype.Unify _ ->
+    (* Will be detected by check_recursion *)
+    Btype.backtrack snap
+
+let check_well_founded_manifest env loc path decl =
+  if decl.type_manifest = None then () else
+  let args = List.map (fun _ -> Ctype.newvar()) decl.type_params in
+  check_well_founded env loc path (Path.same path) (Ctype.newconstr path args)
+
+let check_well_founded_decl env loc path decl to_check =
+  let open Btype in
+  let it =
+    {type_iterators with
+     it_type_expr = (fun _ -> check_well_founded env loc path to_check)} in
+  it.it_type_declaration it (Ctype.generic_instance_declaration decl)
+
+(* Check for ill-defined abbrevs *)
+
+let check_recursion env loc path decl to_check =
+  (* to_check is true for potentially mutually recursive paths.
+     (path, decl) is the type declaration to be checked. *)
+
+  if decl.type_params = [] then () else
+
+  let visited = ref [] in
+
+  let rec check_regular cpath args prev_exp ty =
+    let ty = Ctype.repr ty in
+    if not (List.memq ty !visited) then begin
+      visited := ty :: !visited;
+      match ty.desc with
+      | Tconstr(path', args', _) ->
+          if Path.same path path' then begin
+            if not (Ctype.equal env false args args') then
+              raise (Error(loc,
+                     Parameters_differ(cpath, ty, Ctype.newconstr path args)))
+          end
+          (* Attempt to expand a type abbreviation if:
+              1- [to_check path'] holds
+                 (otherwise the expansion cannot involve [path]);
+              2- we haven't expanded this type constructor before
+                 (otherwise we could loop if [path'] is itself
+                 a non-regular abbreviation). *)
+          else if to_check path' && not (List.mem path' prev_exp) then begin
+            try
+              (* Attempt expansion *)
+              let (params0, body0, _) = Env.find_type_expansion path' env in
+              let (params, body) =
+                Ctype.instance_parameterized_type params0 body0 in
+              begin
+                try List.iter2 (Ctype.unify env) params args'
+                with Ctype.Unify _ ->
+                  raise (Error(loc, Constraint_failed
+                                 (ty, Ctype.newconstr path' params0)));
+              end;
+              check_regular path' args (path' :: prev_exp) body
+            with Not_found -> ()
+          end;
+          List.iter (check_regular cpath args prev_exp) args'
+      | Tpoly (ty, tl) ->
+          let (_, ty) = Ctype.instance_poly ~keep_names:true false tl ty in
+          check_regular cpath args prev_exp ty
+      | _ ->
+          Btype.iter_type_expr (check_regular cpath args prev_exp) ty
+    end in
+
+  Option.iter
+    (fun body ->
+      let (args, body) =
+        Ctype.instance_parameterized_type
+          ~keep_names:true decl.type_params body in
+      check_regular path args [] body)
+    decl.type_manifest
+
+let check_abbrev_recursion env id_loc_list to_check tdecl =
+  let decl = tdecl.typ_type in
+  let id = tdecl.typ_id in
+  check_recursion env (List.assoc id id_loc_list) (Path.Pident id) decl to_check
+
+(* Check multiple declarations of labels/constructors *)
+
+let check_duplicates sdecl_list =
+  let labels = Hashtbl.create 7 and constrs = Hashtbl.create 7 in
+  List.iter
+    (fun sdecl -> match sdecl.ptype_kind with
+      Ptype_variant cl ->
+        List.iter
+          (fun pcd ->
+            try
+              let name' = Hashtbl.find constrs pcd.pcd_name.txt in
+              Location.prerr_warning pcd.pcd_loc
+                (Warnings.Duplicate_definitions
+                   ("constructor", pcd.pcd_name.txt, name',
+                    sdecl.ptype_name.txt))
+            with Not_found ->
+              Hashtbl.add constrs pcd.pcd_name.txt sdecl.ptype_name.txt)
+          cl
+    | Ptype_record fl ->
+        List.iter
+          (fun {pld_name=cname;pld_loc=loc} ->
+            try
+              let name' = Hashtbl.find labels cname.txt in
+              Location.prerr_warning loc
+                (Warnings.Duplicate_definitions
+                   ("label", cname.txt, name', sdecl.ptype_name.txt))
+            with Not_found -> Hashtbl.add labels cname.txt sdecl.ptype_name.txt)
+          fl
+    | Ptype_abstract -> ()
+    | Ptype_open -> ())
+    sdecl_list
+
+(* Force recursion to go through id for private types*)
+let name_recursion sdecl id decl =
+  match decl with
+  | { type_kind = Type_abstract;
+      type_manifest = Some ty;
+      type_private = Private; } when is_fixed_type sdecl ->
+    let ty = Ctype.repr ty in
+    let ty' = Btype.newty2 ty.level ty.desc in
+    if Ctype.deep_occur ty ty' then
+      let td = Tconstr(Path.Pident id, decl.type_params, ref Mnil) in
+      Btype.link_type ty (Btype.newty2 ty.level td);
+      {decl with type_manifest = Some ty'}
+    else decl
+  | _ -> decl
+
+let name_recursion_decls sdecls decls =
+  List.map2 (fun sdecl (id, decl) -> (id, name_recursion sdecl id decl))
+    sdecls decls
+
+(* Warn on definitions of type "type foo = ()" which redefine a different unit
+   type and are likely a mistake. *)
+let check_redefined_unit (td: Parsetree.type_declaration) =
+  let open Parsetree in
+  let is_unit_constructor cd = cd.pcd_name.txt = "()" in
+  match td with
+  | { ptype_name = { txt = name };
+      ptype_manifest = None;
+      ptype_kind = Ptype_variant [ cd ] }
+    when is_unit_constructor cd ->
+      Location.prerr_warning td.ptype_loc (Warnings.Redefining_unit name)
+  | _ ->
+      ()
+
+let add_types_to_env decls env =
+  List.fold_right
+    (fun (id, decl) env -> add_type ~check:true id decl env)
+    decls env
+
+(* Translate a set of type declarations, mutually recursive or not *)
+let transl_type_decl env rec_flag sdecl_list =
+  List.iter check_redefined_unit sdecl_list;
+  (* Add dummy types for fixed rows *)
+  let fixed_types = List.filter is_fixed_type sdecl_list in
+  let sdecl_list =
+    List.map
+      (fun sdecl ->
+         let ptype_name =
+           let loc = { sdecl.ptype_name.loc with Location.loc_ghost = true } in
+           mkloc (sdecl.ptype_name.txt ^"#row") loc
+         in
+         let ptype_kind = Ptype_abstract in
+         let ptype_manifest = None in
+         let ptype_loc = { sdecl.ptype_loc with Location.loc_ghost = true } in
+        {sdecl with
+           ptype_name; ptype_kind; ptype_manifest; ptype_loc })
+      fixed_types
+    @ sdecl_list
+  in
+
+  (* Create identifiers. *)
+  let scope = Ctype.create_scope () in
+  let id_list =
+    List.map (fun sdecl -> Ident.create_scoped ~scope sdecl.ptype_name.txt)
+      sdecl_list
+  in
+  Ctype.begin_def();
+  (* Enter types. *)
+  let temp_env =
+    List.fold_left2 (enter_type rec_flag) env sdecl_list id_list in
+  (* Translate each declaration. *)
+  let current_slot = ref None in
+  let warn_unused = Warnings.is_active (Warnings.Unused_type_declaration "") in
+  let id_slots id =
+    match rec_flag with
+    | Asttypes.Recursive when warn_unused ->
+        (* See typecore.ml for a description of the algorithm used
+             to detect unused declarations in a set of recursive definitions. *)
+        let slot = ref [] in
+        let td = Env.find_type (Path.Pident id) temp_env in
+        let name = Ident.name id in
+        Env.set_type_used_callback
+          name td
+          (fun old_callback ->
+             match !current_slot with
+             | Some slot -> slot := (name, td) :: !slot
+             | None ->
+                 List.iter (fun (name, d) -> Env.mark_type_used name d)
+                   (get_ref slot);
+                 old_callback ()
+          );
+        id, Some slot
+    | Asttypes.Recursive | Asttypes.Nonrecursive ->
+        id, None
+  in
+  let transl_declaration name_sdecl (id, slot) =
+    current_slot := slot;
+    Builtin_attributes.warning_scope
+      name_sdecl.ptype_attributes
+      (fun () -> transl_declaration temp_env name_sdecl id)
+  in
+  let tdecls =
+    List.map2 transl_declaration sdecl_list (List.map id_slots id_list) in
+  let decls =
+    List.map (fun tdecl -> (tdecl.typ_id, tdecl.typ_type)) tdecls in
+  current_slot := None;
+  (* Check for duplicates *)
+  check_duplicates sdecl_list;
+  (* Build the final env. *)
+  let new_env = add_types_to_env decls env in
+  (* Update stubs *)
+  begin match rec_flag with
+    | Asttypes.Nonrecursive -> ()
+    | Asttypes.Recursive ->
+      List.iter2
+        (fun id sdecl -> update_type temp_env new_env id sdecl.ptype_loc)
+        id_list sdecl_list
+  end;
+  (* Generalize type declarations. *)
+  Ctype.end_def();
+  List.iter (fun (_, decl) -> generalize_decl decl) decls;
+  (* Check for ill-formed abbrevs *)
+  let id_loc_list =
+    List.map2 (fun id sdecl -> (id, sdecl.ptype_loc))
+      id_list sdecl_list
+  in
+  List.iter (fun (id, decl) ->
+    check_well_founded_manifest new_env (List.assoc id id_loc_list)
+      (Path.Pident id) decl)
+    decls;
+  let to_check =
+    function Path.Pident id -> List.mem_assoc id id_loc_list | _ -> false in
+  List.iter (fun (id, decl) ->
+    check_well_founded_decl new_env (List.assoc id id_loc_list) (Path.Pident id)
+      decl to_check)
+    decls;
+  List.iter (check_abbrev_recursion new_env id_loc_list to_check) tdecls;
+  (* Check that all type variables are closed *)
+  List.iter2
+    (fun sdecl tdecl ->
+      let decl = tdecl.typ_type in
+       match Ctype.closed_type_decl decl with
+         Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
+       | None   -> ())
+    sdecl_list tdecls;
+  (* Check that constraints are enforced *)
+  List.iter2 (check_constraints new_env) sdecl_list decls;
+  (* Add type properties to declarations *)
+  let decls =
+    try
+      decls
+      |> name_recursion_decls sdecl_list
+      |> Typedecl_variance.update_decls env sdecl_list
+      |> Typedecl_immediacy.update_decls env
+    with
+    | Typedecl_variance.Error (loc, err) -> raise (Error (loc, Variance err))
+    | Typedecl_immediacy.Error (loc, err) -> raise (Error (loc, Immediacy err))
+  in
+  (* Compute the final environment with variance and immediacy *)
+  let final_env = add_types_to_env decls env in
+  (* Check re-exportation *)
+  List.iter2 (check_abbrev final_env) sdecl_list decls;
+  (* Keep original declaration *)
+  let final_decls =
+    List.map2
+      (fun tdecl (_id2, decl) ->
+        { tdecl with typ_type = decl }
+      ) tdecls decls
+  in
+  (* Done *)
+  (final_decls, final_env)
+
+(* Translating type extensions *)
+
+let transl_extension_constructor env type_path type_params
+                                 typext_params priv sext =
+  let scope = Ctype.create_scope () in
+  let id = Ident.create_scoped ~scope sext.pext_name.txt in
+  let args, ret_type, kind =
+    match sext.pext_kind with
+      Pext_decl(sargs, sret_type) ->
+        let targs, tret_type, args, ret_type, _ =
+          make_constructor env type_path typext_params
+            sargs sret_type
+        in
+          args, ret_type, Text_decl(targs, tret_type)
+    | Pext_rebind lid ->
+        let usage = if priv = Public then Env.Positive else Env.Privatize in
+        let cdescr = Env.lookup_constructor ~loc:lid.loc usage lid.txt env in
+        let (args, cstr_res) = Ctype.instance_constructor cdescr in
+        let res, ret_type =
+          if cdescr.cstr_generalized then
+            let params = Ctype.instance_list type_params in
+            let res = Ctype.newconstr type_path params in
+            let ret_type = Some (Ctype.newconstr type_path params) in
+              res, ret_type
+          else (Ctype.newconstr type_path typext_params), None
+        in
+        begin
+          try
+            Ctype.unify env cstr_res res
+          with Ctype.Unify trace ->
+            raise (Error(lid.loc,
+                     Rebind_wrong_type(lid.txt, env, trace)))
+        end;
+        (* Remove "_" names from parameters used in the constructor *)
+        if not cdescr.cstr_generalized then begin
+          let vars =
+            Ctype.free_variables (Btype.newgenty (Ttuple args))
+          in
+            List.iter
+              (function {desc = Tvar (Some "_")} as ty ->
+                          if List.memq ty vars then ty.desc <- Tvar None
+                        | _ -> ())
+              typext_params
+        end;
+        (* Ensure that constructor's type matches the type being extended *)
+        let cstr_type_path, cstr_type_params =
+          match cdescr.cstr_res.desc with
+            Tconstr (p, _, _) ->
+              let decl = Env.find_type p env in
+                p, decl.type_params
+          | _ -> assert false
+        in
+        let cstr_types =
+          (Btype.newgenty
+             (Tconstr(cstr_type_path, cstr_type_params, ref Mnil)))
+          :: cstr_type_params
+        in
+        let ext_types =
+          (Btype.newgenty
+             (Tconstr(type_path, type_params, ref Mnil)))
+          :: type_params
+        in
+        if not (Ctype.equal env true cstr_types ext_types) then
+          raise (Error(lid.loc,
+                       Rebind_mismatch(lid.txt, cstr_type_path, type_path)));
+        (* Disallow rebinding private constructors to non-private *)
+        begin
+          match cdescr.cstr_private, priv with
+            Private, Public ->
+              raise (Error(lid.loc, Rebind_private lid.txt))
+          | _ -> ()
+        end;
+        let path =
+          match cdescr.cstr_tag with
+            Cstr_extension(path, _) -> path
+          | _ -> assert false
+        in
+        let args =
+          match cdescr.cstr_inlined with
+          | None ->
+              Types.Cstr_tuple args
+          | Some decl ->
+              let tl =
+                match args with
+                | [ {desc=Tconstr(_, tl, _)} ] -> tl
+                | _ -> assert false
+              in
+              let decl = Ctype.instance_declaration decl in
+              assert (List.length decl.type_params = List.length tl);
+              List.iter2 (Ctype.unify env) decl.type_params tl;
+              let lbls =
+                match decl.type_kind with
+                | Type_record (lbls, Record_extension _) -> lbls
+                | _ -> assert false
+              in
+              Types.Cstr_record lbls
+        in
+        args, ret_type, Text_rebind(path, lid)
+  in
+  let ext =
+    { ext_type_path = type_path;
+      ext_type_params = typext_params;
+      ext_args = args;
+      ext_ret_type = ret_type;
+      ext_private = priv;
+      Types.ext_loc = sext.pext_loc;
+      Types.ext_attributes = sext.pext_attributes; }
+  in
+    { ext_id = id;
+      ext_name = sext.pext_name;
+      ext_type = ext;
+      ext_kind = kind;
+      Typedtree.ext_loc = sext.pext_loc;
+      Typedtree.ext_attributes = sext.pext_attributes; }
+
+let transl_extension_constructor env type_path type_params
+    typext_params priv sext =
+  Builtin_attributes.warning_scope sext.pext_attributes
+    (fun () -> transl_extension_constructor env type_path type_params
+        typext_params priv sext)
+
+let transl_type_extension extend env loc styext =
+  reset_type_variables();
+  Ctype.begin_def();
+  let type_path, type_decl =
+    let lid = styext.ptyext_path in
+    Env.lookup_type ~loc:lid.loc lid.txt env
+  in
+  begin
+    match type_decl.type_kind with
+    | Type_open -> begin
+        match type_decl.type_private with
+        | Private when extend -> begin
+            match
+              List.find
+                (function {pext_kind = Pext_decl _} -> true
+                        | {pext_kind = Pext_rebind _} -> false)
+                styext.ptyext_constructors
+            with
+            | {pext_loc} ->
+                raise (Error(pext_loc, Cannot_extend_private_type type_path))
+            | exception Not_found -> ()
+          end
+        | _ -> ()
+      end
+    | _ ->
+        raise (Error(loc, Not_extensible_type type_path))
+  end;
+  let type_variance =
+    List.map (fun v ->
+                let (co, cn) = Variance.get_upper v in
+                  (not cn, not co, false))
+             type_decl.type_variance
+  in
+  let err =
+    if type_decl.type_arity <> List.length styext.ptyext_params then
+      Some Includecore.Arity
+    else
+      if List.for_all2
+           (fun (c1, n1, _) (c2, n2, _) -> (not c2 || c1) && (not n2 || n1))
+           type_variance
+           (Typedecl_variance.variance_of_params styext.ptyext_params)
+      then None else Some Includecore.Variance
+  in
+  begin match err with
+  | None -> ()
+  | Some err -> raise (Error(loc, Extension_mismatch (type_path, err)))
+  end;
+  let ttype_params = make_params env styext.ptyext_params in
+  let type_params = List.map (fun (cty, _) -> cty.ctyp_type) ttype_params in
+  List.iter2 (Ctype.unify_var env)
+    (Ctype.instance_list type_decl.type_params)
+    type_params;
+  let constructors =
+    List.map (transl_extension_constructor env type_path
+               type_decl.type_params type_params styext.ptyext_private)
+      styext.ptyext_constructors
+  in
+  Ctype.end_def();
+  (* Generalize types *)
+  List.iter Ctype.generalize type_params;
+  List.iter
+    (fun ext ->
+       Btype.iter_type_expr_cstr_args Ctype.generalize ext.ext_type.ext_args;
+       Option.iter Ctype.generalize ext.ext_type.ext_ret_type)
+    constructors;
+  (* Check that all type variables are closed *)
+  List.iter
+    (fun ext ->
+       match Ctype.closed_extension_constructor ext.ext_type with
+         Some ty ->
+           raise(Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
+       | None -> ())
+    constructors;
+  (* Check variances are correct *)
+  List.iter
+    (fun ext->
+       (* Note that [loc] here is distinct from [type_decl.type_loc], which
+          makes the [loc] parameter to this function useful. [loc] is the
+          location of the extension, while [type_decl] points to the original
+          type declaration being extended. *)
+       try Typedecl_variance.check_variance_extension
+             env type_decl ext (type_variance, loc)
+       with Typedecl_variance.Error (loc, err) ->
+         raise (Error (loc, Variance err)))
+    constructors;
+  (* Add extension constructors to the environment *)
+  let newenv =
+    List.fold_left
+      (fun env ext ->
+         Env.add_extension ~check:true ext.ext_id ext.ext_type env)
+      env constructors
+  in
+  let tyext =
+    { tyext_path = type_path;
+      tyext_txt = styext.ptyext_path;
+      tyext_params = ttype_params;
+      tyext_constructors = constructors;
+      tyext_private = styext.ptyext_private;
+      tyext_loc = styext.ptyext_loc;
+      tyext_attributes = styext.ptyext_attributes; }
+  in
+    (tyext, newenv)
+
+let transl_type_extension extend env loc styext =
+  Builtin_attributes.warning_scope styext.ptyext_attributes
+    (fun () -> transl_type_extension extend env loc styext)
+
+let transl_exception env sext =
+  reset_type_variables();
+  Ctype.begin_def();
+  let ext =
+    transl_extension_constructor env
+      Predef.path_exn [] [] Asttypes.Public sext
+  in
+  Ctype.end_def();
+  (* Generalize types *)
+  Btype.iter_type_expr_cstr_args Ctype.generalize ext.ext_type.ext_args;
+  Option.iter Ctype.generalize ext.ext_type.ext_ret_type;
+  (* Check that all type variables are closed *)
+  begin match Ctype.closed_extension_constructor ext.ext_type with
+    Some ty ->
+      raise (Error(ext.ext_loc, Unbound_type_var_ext(ty, ext.ext_type)))
+  | None -> ()
+  end;
+  let newenv = Env.add_extension ~check:true ext.ext_id ext.ext_type env in
+  ext, newenv
+
+let transl_type_exception env t =
+  Builtin_attributes.check_no_alert t.ptyexn_attributes;
+  let contructor, newenv =
+    Builtin_attributes.warning_scope t.ptyexn_attributes
+      (fun () ->
+         transl_exception env t.ptyexn_constructor
+      )
+  in
+  {tyexn_constructor = contructor;
+   tyexn_loc = t.ptyexn_loc;
+   tyexn_attributes = t.ptyexn_attributes}, newenv
+
+
+type native_repr_attribute =
+  | Native_repr_attr_absent
+  | Native_repr_attr_present of native_repr_kind
+
+let get_native_repr_attribute attrs ~global_repr =
+  match
+    Attr_helper.get_no_payload_attribute ["unboxed"; "ocaml.unboxed"]  attrs,
+    Attr_helper.get_no_payload_attribute ["untagged"; "ocaml.untagged"] attrs,
+    global_repr
+  with
+  | None, None, None -> Native_repr_attr_absent
+  | None, None, Some repr -> Native_repr_attr_present repr
+  | Some _, None, None -> Native_repr_attr_present Unboxed
+  | None, Some _, None -> Native_repr_attr_present Untagged
+  | Some { Location.loc }, _, _
+  | _, Some { Location.loc }, _ ->
+    raise (Error (loc, Multiple_native_repr_attributes))
+
+let native_repr_of_type env kind ty =
+  match kind, (Ctype.expand_head_opt env ty).desc with
+  | Untagged, Tconstr (path, _, _) when Path.same path Predef.path_int ->
+    Some Untagged_int
+  | Unboxed, Tconstr (path, _, _) when Path.same path Predef.path_float ->
+    Some Unboxed_float
+  | Unboxed, Tconstr (path, _, _) when Path.same path Predef.path_int32 ->
+    Some (Unboxed_integer Pint32)
+  | Unboxed, Tconstr (path, _, _) when Path.same path Predef.path_int64 ->
+    Some (Unboxed_integer Pint64)
+  | Unboxed, Tconstr (path, _, _) when Path.same path Predef.path_nativeint ->
+    Some (Unboxed_integer Pnativeint)
+  | _ ->
+    None
+
+(* Raises an error when [core_type] contains an [@unboxed] or [@untagged]
+   attribute in a strict sub-term. *)
+let error_if_has_deep_native_repr_attributes core_type =
+  let open Ast_iterator in
+  let this_iterator =
+    { default_iterator with typ = fun iterator core_type ->
+      begin
+        match
+          get_native_repr_attribute core_type.ptyp_attributes ~global_repr:None
+        with
+        | Native_repr_attr_present kind ->
+           raise (Error (core_type.ptyp_loc,
+                         Deep_unbox_or_untag_attribute kind))
+        | Native_repr_attr_absent -> ()
+      end;
+      default_iterator.typ iterator core_type }
+  in
+  default_iterator.typ this_iterator core_type
+
+let make_native_repr env core_type ty ~global_repr =
+  error_if_has_deep_native_repr_attributes core_type;
+  match get_native_repr_attribute core_type.ptyp_attributes ~global_repr with
+  | Native_repr_attr_absent ->
+    Same_as_ocaml_repr
+  | Native_repr_attr_present kind ->
+    begin match native_repr_of_type env kind ty with
+    | None ->
+      raise (Error (core_type.ptyp_loc, Cannot_unbox_or_untag_type kind))
+    | Some repr -> repr
+    end
+
+let rec parse_native_repr_attributes env core_type ty ~global_repr =
+  match core_type.ptyp_desc, (Ctype.repr ty).desc,
+    get_native_repr_attribute core_type.ptyp_attributes ~global_repr:None
+  with
+  | Ptyp_arrow _, Tarrow _, Native_repr_attr_present kind  ->
+    raise (Error (core_type.ptyp_loc, Cannot_unbox_or_untag_type kind))
+  | Ptyp_arrow (_, ct1, ct2), Tarrow (_, t1, t2, _), _ ->
+    let repr_arg = make_native_repr env ct1 t1 ~global_repr in
+    let repr_args, repr_res =
+      parse_native_repr_attributes env ct2 t2 ~global_repr
+    in
+    (repr_arg :: repr_args, repr_res)
+  | Ptyp_arrow _, _, _ | _, Tarrow _, _ -> assert false
+  | _ -> ([], make_native_repr env core_type ty ~global_repr)
+
+
+let check_unboxable env loc ty =
+  let check_type acc ty : Path.Set.t =
+    let ty = Ctype.repr (Ctype.expand_head_opt env ty) in
+    try match ty.desc with
+      | Tconstr (p, _, _) ->
+        let tydecl = Env.find_type p env in
+        if tydecl.type_unboxed.default then
+          Path.Set.add p acc
+        else acc
+      | _ -> acc
+    with Not_found -> acc
+  in
+  let all_unboxable_types = Btype.fold_type_expr check_type Path.Set.empty ty in
+  Path.Set.fold
+    (fun p () ->
+       let p = Printtyp.shorten_type_path env p in
+       Location.prerr_warning loc
+         (Warnings.Unboxable_type_in_prim_decl (Path.name p))
+    )
+    all_unboxable_types
+    ()
+
+(* Translate a value declaration *)
+let transl_value_decl env loc valdecl =
+  let cty = Typetexp.transl_type_scheme env valdecl.pval_type in
+  let ty = cty.ctyp_type in
+  let v =
+  match valdecl.pval_prim with
+    [] when Env.is_in_signature env ->
+      { val_type = ty; val_kind = Val_reg; Types.val_loc = loc;
+        val_attributes = valdecl.pval_attributes }
+  | [] ->
+      raise (Error(valdecl.pval_loc, Val_in_structure))
+  | _ ->
+      let global_repr =
+        match
+          get_native_repr_attribute valdecl.pval_attributes ~global_repr:None
+        with
+        | Native_repr_attr_present repr -> Some repr
+        | Native_repr_attr_absent -> None
+      in
+      let native_repr_args, native_repr_res =
+        parse_native_repr_attributes env valdecl.pval_type ty ~global_repr
+      in
+      let prim =
+        Primitive.parse_declaration valdecl
+          ~native_repr_args
+          ~native_repr_res
+      in
+      (*
+      if prim.prim_arity = 0 &&
+         (prim.prim_name = "" || prim.prim_name.[0] <> '%') then
+        raise(Error(valdecl.pval_type.ptyp_loc, Null_arity_external));
+      *)
+      if !Clflags.native_code
+      && prim.prim_arity > 5
+      && prim.prim_native_name = ""
+      then raise(Error(valdecl.pval_type.ptyp_loc, Missing_native_external));
+      check_unboxable env loc ty;
+      { val_type = ty; val_kind = Val_prim prim; Types.val_loc = loc;
+        val_attributes = valdecl.pval_attributes }
+  in
+  let (id, newenv) =
+    Env.enter_value valdecl.pval_name.txt v env
+      ~check:(fun s -> Warnings.Unused_value_declaration s)
+  in
+  let desc =
+    {
+     val_id = id;
+     val_name = valdecl.pval_name;
+     val_desc = cty; val_val = v;
+     val_prim = valdecl.pval_prim;
+     val_loc = valdecl.pval_loc;
+     val_attributes = valdecl.pval_attributes;
+    }
+  in
+  desc, newenv
+
+let transl_value_decl env loc valdecl =
+  Builtin_attributes.warning_scope valdecl.pval_attributes
+    (fun () -> transl_value_decl env loc valdecl)
+
+(* Translate a "with" constraint -- much simplified version of
+    transl_type_decl. *)
+let transl_with_constraint env id row_path orig_decl sdecl =
+  Env.mark_type_used (Ident.name id) orig_decl;
+  reset_type_variables();
+  Ctype.begin_def();
+  let tparams = make_params env sdecl.ptype_params in
+  let params = List.map (fun (cty, _) -> cty.ctyp_type) tparams in
+  let orig_decl = Ctype.instance_declaration orig_decl in
+  let arity_ok = List.length params = orig_decl.type_arity in
+  if arity_ok then
+    List.iter2 (Ctype.unify_var env) params orig_decl.type_params;
+  let constraints = List.map
+    (function (ty, ty', loc) ->
+       try
+         let cty = transl_simple_type env false ty in
+         let cty' = transl_simple_type env false ty' in
+         let ty = cty.ctyp_type in
+         let ty' = cty'.ctyp_type in
+         Ctype.unify env ty ty';
+         (cty, cty', loc)
+       with Ctype.Unify tr ->
+         raise(Error(loc, Inconsistent_constraint (env, tr))))
+    sdecl.ptype_cstrs
+  in
+  let no_row = not (is_fixed_type sdecl) in
+  let (tman, man) =  match sdecl.ptype_manifest with
+      None -> None, None
+    | Some sty ->
+        let cty = transl_simple_type env no_row sty in
+        Some cty, Some cty.ctyp_type
+  in
+  let priv =
+    if sdecl.ptype_private = Private then Private else
+    if arity_ok && orig_decl.type_kind <> Type_abstract
+    then orig_decl.type_private else sdecl.ptype_private
+  in
+  if arity_ok && orig_decl.type_kind <> Type_abstract
+  && sdecl.ptype_private = Private then
+    Location.deprecated sdecl.ptype_loc "spurious use of private";
+  let type_kind, type_unboxed =
+    if arity_ok && man <> None then
+      orig_decl.type_kind, orig_decl.type_unboxed
+    else
+      Type_abstract, unboxed_false_default_false
+  in
+  let decl =
+    { type_params = params;
+      type_arity = List.length params;
+      type_kind;
+      type_private = priv;
+      type_manifest = man;
+      type_variance = [];
+      type_is_newtype = false;
+      type_expansion_scope = Btype.lowest_level;
+      type_loc = sdecl.ptype_loc;
+      type_attributes = sdecl.ptype_attributes;
+      type_immediate = Unknown;
+      type_unboxed;
+    }
+  in
+  begin match row_path with None -> ()
+  | Some p -> set_fixed_row env sdecl.ptype_loc p decl
+  end;
+  begin match Ctype.closed_type_decl decl with None -> ()
+  | Some ty -> raise(Error(sdecl.ptype_loc, Unbound_type_var(ty,decl)))
+  end;
+  let decl = name_recursion sdecl id decl in
+  let type_variance =
+    try Typedecl_variance.compute_decl
+          env ~check:true decl (Typedecl_variance.variance_of_sdecl sdecl)
+    with Typedecl_variance.Error (loc, err) ->
+      raise (Error (loc, Variance err)) in
+  let type_immediate =
+    (* Typedecl_immediacy.compute_decl never raises *)
+    Typedecl_immediacy.compute_decl env decl in
+  let decl = {decl with type_variance; type_immediate} in
+  Ctype.end_def();
+  generalize_decl decl;
+  {
+    typ_id = id;
+    typ_name = sdecl.ptype_name;
+    typ_params = tparams;
+    typ_type = decl;
+    typ_cstrs = constraints;
+    typ_loc = sdecl.ptype_loc;
+    typ_manifest = tman;
+    typ_kind = Ttype_abstract;
+    typ_private = sdecl.ptype_private;
+    typ_attributes = sdecl.ptype_attributes;
+  }
+
+(* Approximate a type declaration: just make all types abstract *)
+
+let abstract_type_decl arity =
+  let rec make_params n =
+    if n <= 0 then [] else Ctype.newvar() :: make_params (n-1) in
+  Ctype.begin_def();
+  let decl =
+    { type_params = make_params arity;
+      type_arity = arity;
+      type_kind = Type_abstract;
+      type_private = Public;
+      type_manifest = None;
+      type_variance = replicate_list Variance.full arity;
+      type_is_newtype = false;
+      type_expansion_scope = Btype.lowest_level;
+      type_loc = Location.none;
+      type_attributes = [];
+      type_immediate = Unknown;
+      type_unboxed = unboxed_false_default_false;
+     } in
+  Ctype.end_def();
+  generalize_decl decl;
+  decl
+
+let approx_type_decl sdecl_list =
+  let scope = Ctype.create_scope () in
+  List.map
+    (fun sdecl ->
+      (Ident.create_scoped ~scope sdecl.ptype_name.txt,
+       abstract_type_decl (List.length sdecl.ptype_params)))
+    sdecl_list
+
+(* Variant of check_abbrev_recursion to check the well-formedness
+   conditions on type abbreviations defined within recursive modules. *)
+
+let check_recmod_typedecl env loc recmod_ids path decl =
+  (* recmod_ids is the list of recursively-defined module idents.
+     (path, decl) is the type declaration to be checked. *)
+  let to_check path = Path.exists_free recmod_ids path in
+  check_well_founded_decl env loc path decl to_check;
+  check_recursion env loc path decl to_check;
+  (* additionally check coherece, as one might build an incoherent signature,
+     and use it to build an incoherent module, cf. #7851 *)
+  check_coherence env loc path decl
+
+
+(**** Error report ****)
+
+open Format
+
+let explain_unbound_gen ppf tv tl typ kwd pr =
+  try
+    let ti = List.find (fun ti -> Ctype.deep_occur tv (typ ti)) tl in
+    let ty0 = (* Hack to force aliasing when needed *)
+      Btype.newgenty (Tobject(tv, ref None)) in
+    Printtyp.reset_and_mark_loops_list [typ ti; ty0];
+    fprintf ppf
+      ".@.@[<hov2>In %s@ %a@;<1 -2>the variable %a is unbound@]"
+      kwd pr ti Printtyp.marked_type_expr tv
+  with Not_found -> ()
+
+let explain_unbound ppf tv tl typ kwd lab =
+  explain_unbound_gen ppf tv tl typ kwd
+    (fun ppf ti ->
+       fprintf ppf "%s%a" (lab ti) Printtyp.marked_type_expr (typ ti)
+    )
+
+let explain_unbound_single ppf tv ty =
+  let trivial ty =
+    explain_unbound ppf tv [ty] (fun t -> t) "type" (fun _ -> "") in
+  match (Ctype.repr ty).desc with
+    Tobject(fi,_) ->
+      let (tl, rv) = Ctype.flatten_fields fi in
+      if rv == tv then trivial ty else
+      explain_unbound ppf tv tl (fun (_,_,t) -> t)
+        "method" (fun (lab,_,_) -> lab ^ ": ")
+  | Tvariant row ->
+      let row = Btype.row_repr row in
+      if row.row_more == tv then trivial ty else
+      explain_unbound ppf tv row.row_fields
+        (fun (_l,f) -> match Btype.row_field_repr f with
+          Rpresent (Some t) -> t
+        | Reither (_,[t],_,_) -> t
+        | Reither (_,tl,_,_) -> Btype.newgenty (Ttuple tl)
+        | _ -> Btype.newgenty (Ttuple[]))
+        "case" (fun (lab,_) -> "`" ^ lab ^ " of ")
+  | _ -> trivial ty
+
+
+let tys_of_constr_args = function
+  | Types.Cstr_tuple tl -> tl
+  | Types.Cstr_record lbls -> List.map (fun l -> l.Types.ld_type) lbls
+
+let report_error ppf = function
+  | Repeated_parameter ->
+      fprintf ppf "A type parameter occurs several times"
+  | Duplicate_constructor s ->
+      fprintf ppf "Two constructors are named %s" s
+  | Too_many_constructors ->
+      fprintf ppf
+        "@[Too many non-constant constructors@ -- maximum is %i %s@]"
+        (Config.max_tag + 1) "non-constant constructors"
+  | Duplicate_label s ->
+      fprintf ppf "Two labels are named %s" s
+  | Recursive_abbrev s ->
+      fprintf ppf "The type abbreviation %s is cyclic" s
+  | Cycle_in_def (s, ty) ->
+      fprintf ppf "@[<v>The definition of %s contains a cycle:@ %a@]"
+        s Printtyp.type_expr ty
+  | Definition_mismatch (ty, None) ->
+      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%a@]@]"
+        "This variant or record definition" "does not match that of type"
+        Printtyp.type_expr ty
+  | Definition_mismatch (ty, Some err) ->
+      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%a@]%a@]"
+        "This variant or record definition" "does not match that of type"
+        Printtyp.type_expr ty
+        (Includecore.report_type_mismatch "the original" "this" "definition")
+        err
+  | Constraint_failed (ty, ty') ->
+      Printtyp.reset_and_mark_loops ty;
+      Printtyp.mark_loops ty';
+      Printtyp.Naming_context.reset ();
+      fprintf ppf "@[%s@ @[<hv>Type@ %a@ should be an instance of@ %a@]@]"
+        "Constraints are not satisfied in this type."
+        !Oprint.out_type (Printtyp.tree_of_typexp false ty)
+        !Oprint.out_type (Printtyp.tree_of_typexp false ty')
+  | Parameters_differ (path, ty, ty') ->
+      Printtyp.reset_and_mark_loops ty;
+      Printtyp.mark_loops ty';
+      Printtyp.Naming_context.reset ();
+      fprintf ppf
+        "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
+        (Path.name path)
+        !Oprint.out_type (Printtyp.tree_of_typexp false ty)
+        !Oprint.out_type (Printtyp.tree_of_typexp false ty')
+  | Inconsistent_constraint (env, trace) ->
+      fprintf ppf "The type constraints are not consistent.@.";
+      Printtyp.report_unification_error ppf env trace
+        (fun ppf -> fprintf ppf "Type")
+        (fun ppf -> fprintf ppf "is not compatible with type")
+  | Type_clash (env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "This type constructor expands to type")
+        (function ppf ->
+           fprintf ppf "but is used here with type")
+  | Null_arity_external ->
+      fprintf ppf "External identifiers must be functions"
+  | Missing_native_external ->
+      fprintf ppf "@[<hv>An external function with more than 5 arguments \
+                   requires a second stub function@ \
+                   for native-code compilation@]"
+  | Unbound_type_var (ty, decl) ->
+      fprintf ppf "A type variable is unbound in this type declaration";
+      let ty = Ctype.repr ty in
+      begin match decl.type_kind, decl.type_manifest with
+      | Type_variant tl, _ ->
+          explain_unbound_gen ppf ty tl (fun c ->
+              let tl = tys_of_constr_args c.Types.cd_args in
+              Btype.newgenty (Ttuple tl)
+            )
+            "case" (fun ppf c ->
+                fprintf ppf
+                  "%a of %a" Printtyp.ident c.Types.cd_id
+                  Printtyp.constructor_arguments c.Types.cd_args)
+      | Type_record (tl, _), _ ->
+          explain_unbound ppf ty tl (fun l -> l.Types.ld_type)
+            "field" (fun l -> Ident.name l.Types.ld_id ^ ": ")
+      | Type_abstract, Some ty' ->
+          explain_unbound_single ppf ty ty'
+      | _ -> ()
+      end
+  | Unbound_type_var_ext (ty, ext) ->
+      fprintf ppf "A type variable is unbound in this extension constructor";
+      let args = tys_of_constr_args ext.ext_args in
+      explain_unbound ppf ty args (fun c -> c) "type" (fun _ -> "")
+  | Cannot_extend_private_type path ->
+      fprintf ppf "@[%s@ %a@]"
+        "Cannot extend private type definition"
+        Printtyp.path path
+  | Not_extensible_type path ->
+      fprintf ppf "@[%s@ %a@ %s@]"
+        "Type definition"
+        Printtyp.path path
+        "is not extensible"
+  | Extension_mismatch (path, err) ->
+      fprintf ppf "@[<v>@[<hov>%s@ %s@;<1 2>%s@]%a@]"
+        "This extension" "does not match the definition of type"
+        (Path.name path)
+        (Includecore.report_type_mismatch
+           "the type" "this extension" "definition")
+        err
+  | Rebind_wrong_type (lid, env, trace) ->
+      Printtyp.report_unification_error ppf env trace
+        (function ppf ->
+           fprintf ppf "The constructor %a@ has type"
+             Printtyp.longident lid)
+        (function ppf ->
+           fprintf ppf "but was expected to be of type")
+  | Rebind_mismatch (lid, p, p') ->
+      fprintf ppf
+        "@[%s@ %a@ %s@ %s@ %s@ %s@ %s@]"
+        "The constructor" Printtyp.longident lid
+        "extends type" (Path.name p)
+        "whose declaration does not match"
+        "the declaration of type" (Path.name p')
+  | Rebind_private lid ->
+      fprintf ppf "@[%s@ %a@ %s@]"
+        "The constructor"
+        Printtyp.longident lid
+        "is private"
+  | Variance (Typedecl_variance.Bad_variance (n, v1, v2)) ->
+      let variance (p,n,i) =
+        let inj = if i then "injective " else "" in
+        match p, n with
+          true,  true  -> inj ^ "invariant"
+        | true,  false -> inj ^ "covariant"
+        | false, true  -> inj ^ "contravariant"
+        | false, false -> if inj = "" then "unrestricted" else inj
+      in
+      let suffix n =
+        let teen = (n mod 100)/10 = 1 in
+        match n mod 10 with
+        | 1 when not teen -> "st"
+        | 2 when not teen -> "nd"
+        | 3 when not teen -> "rd"
+        | _ -> "th"
+      in
+      (match n with
+       | Variance_not_reflected ->
+           fprintf ppf "@[%s@ %s@ It"
+             "In this definition, a type variable has a variance that"
+             "is not reflected by its occurrence in type parameters."
+       | No_variable ->
+           fprintf ppf "@[%s@ %s@]"
+             "In this definition, a type variable cannot be deduced"
+             "from the type parameters."
+       | Variance_not_deducible ->
+           fprintf ppf "@[%s@ %s@ It"
+             "In this definition, a type variable has a variance that"
+             "cannot be deduced from the type parameters."
+       | Variance_not_satisfied n ->
+           fprintf ppf "@[%s@ %s@ The %d%s type parameter"
+             "In this definition, expected parameter"
+             "variances are not satisfied."
+             n (suffix n));
+      (match n with
+       | No_variable -> ()
+       | _ ->
+           fprintf ppf " was expected to be %s,@ but it is %s.@]"
+             (variance v2) (variance v1))
+  | Unavailable_type_constructor p ->
+      fprintf ppf "The definition of type %a@ is unavailable" Printtyp.path p
+  | Bad_fixed_type r ->
+      fprintf ppf "This fixed type %s" r
+  | Variance Typedecl_variance.Varying_anonymous ->
+      fprintf ppf "@[%s@ %s@ %s@]"
+        "In this GADT definition," "the variance of some parameter"
+        "cannot be checked"
+  | Val_in_structure ->
+      fprintf ppf "Value declarations are only allowed in signatures"
+  | Multiple_native_repr_attributes ->
+      fprintf ppf "Too many [@@unboxed]/[@@untagged] attributes"
+  | Cannot_unbox_or_untag_type Unboxed ->
+      fprintf ppf "@[Don't know how to unbox this type.@ \
+                   Only float, int32, int64 and nativeint can be unboxed.@]"
+  | Cannot_unbox_or_untag_type Untagged ->
+      fprintf ppf "@[Don't know how to untag this type.@ \
+                   Only int can be untagged.@]"
+  | Deep_unbox_or_untag_attribute kind ->
+      fprintf ppf
+        "@[The attribute '%s' should be attached to@ \
+         a direct argument or result of the primitive,@ \
+         it should not occur deeply into its type.@]"
+        (match kind with Unboxed -> "@unboxed" | Untagged -> "@untagged")
+  | Immediacy (Typedecl_immediacy.Bad_immediacy_attribute violation) ->
+      fprintf ppf "@[%a@]" Format.pp_print_text
+        (match violation with
+         | Type_immediacy.Violation.Not_always_immediate ->
+             "Types marked with the immediate attribute must be \
+              non-pointer types like int or bool."
+         | Type_immediacy.Violation.Not_always_immediate_on_64bits ->
+             "Types marked with the immediate64 attribute must be \
+              produced using the Stdlib.Sys.Immediate64.Make functor.")
+  | Bad_unboxed_attribute msg ->
+      fprintf ppf "@[This type cannot be unboxed because@ %s.@]" msg
+  | Wrong_unboxed_type_float ->
+      fprintf ppf "@[This type cannot be unboxed because@ \
+                   it might contain both float and non-float values.@ \
+                   You should annotate it with [%@%@ocaml.boxed].@]"
+  | Boxed_and_unboxed ->
+      fprintf ppf "@[A type cannot be boxed and unboxed at the same time.@]"
+  | Nonrec_gadt ->
+      fprintf ppf
+        "@[GADT case syntax cannot be used in a 'nonrec' block.@]"
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, err) ->
+        Some (Location.error_of_printer ~loc report_error err)
+      | _ ->
+        None
+    )
diff --git a/src/ocaml/typing/410+multicore/typedecl.mli b/src/ocaml/typing/410+multicore/typedecl.mli
new file mode 100644
index 00000000..93b83471
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl.mli
@@ -0,0 +1,99 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Typing of type definitions and primitive definitions *)
+
+open Types
+open Format
+
+val transl_type_decl:
+    Env.t -> Asttypes.rec_flag -> Parsetree.type_declaration list ->
+    Typedtree.type_declaration list * Env.t
+
+val transl_exception:
+    Env.t -> Parsetree.extension_constructor ->
+    Typedtree.extension_constructor * Env.t
+
+val transl_type_exception:
+    Env.t ->
+    Parsetree.type_exception -> Typedtree.type_exception * Env.t
+
+val transl_type_extension:
+    bool -> Env.t -> Location.t -> Parsetree.type_extension ->
+    Typedtree.type_extension * Env.t
+
+val transl_value_decl:
+    Env.t -> Location.t ->
+    Parsetree.value_description -> Typedtree.value_description * Env.t
+
+val transl_with_constraint:
+    Env.t -> Ident.t -> Path.t option -> Types.type_declaration ->
+    Parsetree.type_declaration -> Typedtree.type_declaration
+
+val abstract_type_decl: int -> type_declaration
+val approx_type_decl:
+    Parsetree.type_declaration list ->
+                                  (Ident.t * type_declaration) list
+val check_recmod_typedecl:
+    Env.t -> Location.t -> Ident.t list -> Path.t -> type_declaration -> unit
+val check_coherence:
+    Env.t -> Location.t -> Path.t -> type_declaration -> unit
+
+(* for fixed types *)
+val is_fixed_type : Parsetree.type_declaration -> bool
+
+(* for typeopt.ml *)
+val get_unboxed_type_representation: Env.t -> type_expr -> type_expr option
+
+type native_repr_kind = Unboxed | Untagged
+
+type error =
+    Repeated_parameter
+  | Duplicate_constructor of string
+  | Too_many_constructors
+  | Duplicate_label of string
+  | Recursive_abbrev of string
+  | Cycle_in_def of string * type_expr
+  | Definition_mismatch of type_expr * Includecore.type_mismatch option
+  | Constraint_failed of type_expr * type_expr
+  | Inconsistent_constraint of Env.t * Ctype.Unification_trace.t
+  | Type_clash of Env.t * Ctype.Unification_trace.t
+  | Parameters_differ of Path.t * type_expr * type_expr
+  | Null_arity_external
+  | Missing_native_external
+  | Unbound_type_var of type_expr * type_declaration
+  | Cannot_extend_private_type of Path.t
+  | Not_extensible_type of Path.t
+  | Extension_mismatch of Path.t * Includecore.type_mismatch
+  | Rebind_wrong_type of Longident.t * Env.t * Ctype.Unification_trace.t
+  | Rebind_mismatch of Longident.t * Path.t * Path.t
+  | Rebind_private of Longident.t
+  | Variance of Typedecl_variance.error
+  | Unavailable_type_constructor of Path.t
+  | Bad_fixed_type of string
+  | Unbound_type_var_ext of type_expr * extension_constructor
+  | Val_in_structure
+  | Multiple_native_repr_attributes
+  | Cannot_unbox_or_untag_type of native_repr_kind
+  | Deep_unbox_or_untag_attribute of native_repr_kind
+  | Immediacy of Typedecl_immediacy.error
+  | Bad_unboxed_attribute of string
+  | Wrong_unboxed_type_float
+  | Boxed_and_unboxed
+  | Nonrec_gadt
+
+exception Error of Location.t * error
+
+val report_error: formatter -> error -> unit
diff --git a/src/ocaml/typing/410+multicore/typedecl_immediacy.ml b/src/ocaml/typing/410+multicore/typedecl_immediacy.ml
new file mode 100644
index 00000000..ccd09e81
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_immediacy.ml
@@ -0,0 +1,71 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Types
+
+type error = Bad_immediacy_attribute of Type_immediacy.Violation.t
+exception Error of Location.t * error
+
+let compute_decl env tdecl =
+  match (tdecl.type_kind, tdecl.type_manifest) with
+  | (Type_variant [{cd_args = Cstr_tuple [arg]; _}], _)
+    | (Type_variant [{cd_args = Cstr_record [{ld_type = arg; _}]; _}], _)
+    | (Type_record ([{ld_type = arg; _}], _), _)
+  when tdecl.type_unboxed.unboxed ->
+    begin match Typedecl_unboxed.get_unboxed_type_representation env arg with
+    | Typedecl_unboxed.Unavailable -> Type_immediacy.Unknown
+    | Typedecl_unboxed.This argrepr -> Ctype.immediacy env argrepr
+    | Typedecl_unboxed.Only_on_64_bits argrepr ->
+        match Ctype.immediacy env argrepr with
+        | Type_immediacy.Always -> Type_immediacy.Always_on_64bits
+        | Type_immediacy.Always_on_64bits | Type_immediacy.Unknown as x -> x
+    end
+  | (Type_variant (_ :: _ as cstrs), _) ->
+    if not (List.exists (fun c -> c.Types.cd_args <> Types.Cstr_tuple []) cstrs)
+    then
+      Type_immediacy.Always
+    else
+      Type_immediacy.Unknown
+  | (Type_abstract, Some(typ)) -> Ctype.immediacy env typ
+  | (Type_abstract, None) -> Type_immediacy.of_attributes tdecl.type_attributes
+  | _ -> Type_immediacy.Unknown
+
+let property : (Type_immediacy.t, unit) Typedecl_properties.property =
+  let open Typedecl_properties in
+  let eq = (=) in
+  let merge ~prop:_ ~new_prop = new_prop in
+  let default _decl = Type_immediacy.Unknown in
+  let compute env decl () = compute_decl env decl in
+  let update_decl decl immediacy = { decl with type_immediate = immediacy } in
+  let check _env _id decl () =
+    let written_by_user = Type_immediacy.of_attributes decl.type_attributes in
+    match Type_immediacy.coerce decl.type_immediate ~as_:written_by_user with
+    | Ok () -> ()
+    | Error violation ->
+        raise (Error (decl.type_loc,
+                      Bad_immediacy_attribute violation))
+  in
+  {
+    eq;
+    merge;
+    default;
+    compute;
+    update_decl;
+    check;
+  }
+
+let update_decls env decls =
+  Typedecl_properties.compute_property_noreq property env decls
diff --git a/src/ocaml/typing/410+multicore/typedecl_immediacy.mli b/src/ocaml/typing/410+multicore/typedecl_immediacy.mli
new file mode 100644
index 00000000..17fb985c
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_immediacy.mli
@@ -0,0 +1,27 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type error = Bad_immediacy_attribute of Type_immediacy.Violation.t
+exception Error of Location.t * error
+
+val compute_decl : Env.t -> Types.type_declaration -> Type_immediacy.t
+
+val property : (Type_immediacy.t, unit) Typedecl_properties.property
+
+val update_decls :
+  Env.t ->
+  (Ident.t * Typedecl_properties.decl) list ->
+  (Ident.t * Typedecl_properties.decl) list
diff --git a/src/ocaml/typing/410+multicore/typedecl_properties.ml b/src/ocaml/typing/410+multicore/typedecl_properties.ml
new file mode 100644
index 00000000..28a1bb66
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_properties.ml
@@ -0,0 +1,73 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type decl = Types.type_declaration
+
+type ('prop, 'req) property = {
+  eq : 'prop -> 'prop -> bool;
+  merge : prop:'prop -> new_prop:'prop -> 'prop;
+
+  default : decl -> 'prop;
+  compute : Env.t -> decl -> 'req -> 'prop;
+  update_decl : decl -> 'prop -> decl;
+
+  check : Env.t -> Ident.t -> decl -> 'req -> unit;
+}
+
+let add_type ~check id decl env =
+  let open Types in
+  Builtin_attributes.warning_scope ~ppwarning:false decl.type_attributes
+    (fun () -> Env.add_type ~check id decl env)
+
+let add_types_to_env decls env =
+  List.fold_right
+    (fun (id, decl) env -> add_type ~check:true id decl env)
+    decls env
+
+let compute_property
+: ('prop, 'req) property -> Env.t ->
+  (Ident.t * decl) list -> 'req list -> (Ident.t * decl) list
+= fun property env decls required ->
+  (* [decls] and [required] must be lists of the same size,
+     with [required] containing the requirement for the corresponding
+     declaration in [decls]. *)
+  let props = List.map (fun (_id, decl) -> property.default decl) decls in
+  let rec compute_fixpoint props =
+    let new_decls =
+      List.map2 (fun (id, decl) prop ->
+          (id, property.update_decl decl prop))
+        decls props in
+    let new_env = add_types_to_env new_decls env in
+    let new_props =
+      List.map2
+        (fun (_id, decl) (prop, req) ->
+           let new_prop = property.compute new_env decl req in
+           property.merge ~prop ~new_prop)
+        new_decls (List.combine props required) in
+    if not (List.for_all2 property.eq props new_props)
+    then compute_fixpoint new_props
+    else begin
+      List.iter2
+        (fun (id, decl) req -> property.check new_env id decl req)
+        new_decls required;
+      new_decls
+    end
+  in
+  compute_fixpoint props
+
+let compute_property_noreq property env decls =
+  let req = List.map (fun _ -> ()) decls in
+  compute_property property env decls req
diff --git a/src/ocaml/typing/410+multicore/typedecl_properties.mli b/src/ocaml/typing/410+multicore/typedecl_properties.mli
new file mode 100644
index 00000000..153c3f71
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_properties.mli
@@ -0,0 +1,55 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type decl = Types.type_declaration
+
+(** An abstract interface for properties of type definitions, such as
+   variance and immediacy, that are computed by a fixpoint on
+   mutually-recursive type declarations. This interface contains all
+   the operations needed to initialize and run the fixpoint
+   computation, and then (optionally) check that the result is
+   consistent with the declaration or user expectations. *)
+
+type ('prop, 'req) property = {
+  eq : 'prop -> 'prop -> bool;
+  merge : prop:'prop -> new_prop:'prop -> 'prop;
+
+  default : decl -> 'prop;
+  compute : Env.t -> decl -> 'req -> 'prop;
+  update_decl : decl -> 'prop -> decl;
+
+  check : Env.t -> Ident.t -> decl -> 'req -> unit;
+}
+(** ['prop] represents the type of property values
+    ({!Types.Variance.t}, just 'bool' for immediacy, etc).
+
+    ['req] represents the property value required by the author of the
+    declaration, if they gave an expectation: [type +'a t = ...].
+
+    Some properties have no natural notion of user requirement, or
+    their requirement is global, or already stored in
+    [type_declaration]; they can just use [unit] as ['req] parameter. *)
+
+
+(** [compute_property prop env decls req] performs a fixpoint computation
+    to determine the final values of a property on a set of mutually-recursive
+    type declarations. The [req] argument must be a list of the same size as
+    [decls], providing the user requirement for each declaration. *)
+val compute_property : ('prop, 'req) property -> Env.t ->
+  (Ident.t * decl) list -> 'req list -> (Ident.t * decl) list
+
+val compute_property_noreq : ('prop, unit) property -> Env.t ->
+  (Ident.t * decl) list -> (Ident.t * decl) list
diff --git a/src/ocaml/typing/410+multicore/typedecl_unboxed.ml b/src/ocaml/typing/410+multicore/typedecl_unboxed.ml
new file mode 100644
index 00000000..e2d29a86
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_unboxed.ml
@@ -0,0 +1,57 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Types
+
+type t =
+  | Unavailable
+  | This of type_expr
+  | Only_on_64_bits of type_expr
+
+(* We use the Ctype.expand_head_opt version of expand_head to get access
+   to the manifest type of private abbreviations. *)
+let rec get_unboxed_type_representation env ty fuel =
+  if fuel < 0 then Unavailable else
+  let ty = Ctype.repr (Ctype.expand_head_opt env ty) in
+  match ty.desc with
+  | Tconstr (p, args, _) ->
+    begin match Env.find_type p env with
+    | exception Not_found -> This ty
+    | {type_immediate = Always; _} ->
+        This Predef.type_int
+    | {type_immediate = Always_on_64bits; _} ->
+        Only_on_64_bits Predef.type_int
+    | {type_unboxed = {unboxed = false}} -> This ty
+    | {type_params; type_kind =
+         Type_record ([{ld_type = ty2; _}], _)
+       | Type_variant [{cd_args = Cstr_tuple [ty2]; _}]
+       | Type_variant [{cd_args = Cstr_record [{ld_type = ty2; _}]; _}]}
+
+      ->
+        let ty2 = match ty2.desc with Tpoly (t, _) -> t | _ -> ty2 in
+        get_unboxed_type_representation env
+          (Ctype.apply env type_params ty2 args) (fuel - 1)
+    | {type_kind=Type_abstract} -> Unavailable
+          (* This case can occur when checking a recursive unboxed type
+             declaration. *)
+    | _ -> assert false (* only the above can be unboxed *)
+    end
+  | _ -> This ty
+
+let get_unboxed_type_representation env ty =
+  (* Do not give too much fuel: PR#7424 *)
+  get_unboxed_type_representation env ty 100
+;;
diff --git a/src/ocaml/typing/410+multicore/typedecl_unboxed.mli b/src/ocaml/typing/410+multicore/typedecl_unboxed.mli
new file mode 100644
index 00000000..9afd38e8
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_unboxed.mli
@@ -0,0 +1,25 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Types
+
+type t =
+  | Unavailable
+  | This of type_expr
+  | Only_on_64_bits of type_expr
+
+(* for typeopt.ml *)
+val get_unboxed_type_representation: Env.t -> type_expr -> t
diff --git a/src/ocaml/typing/410+multicore/typedecl_variance.ml b/src/ocaml/typing/410+multicore/typedecl_variance.ml
new file mode 100644
index 00000000..6b3bd288
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_variance.ml
@@ -0,0 +1,384 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Asttypes
+open Types
+
+module TypeSet = Btype.TypeSet
+module TypeMap = Btype.TypeMap
+
+type surface_variance = bool * bool * bool
+
+type variance_error =
+| Variance_not_satisfied of int
+| No_variable
+| Variance_not_reflected
+| Variance_not_deducible
+
+type error =
+| Bad_variance of variance_error * surface_variance * surface_variance
+| Varying_anonymous
+
+
+exception Error of Location.t * error
+
+(* Compute variance *)
+
+let get_variance ty visited =
+  try TypeMap.find ty !visited with Not_found -> Variance.null
+
+let compute_variance env visited vari ty =
+  let rec compute_variance_rec vari ty =
+    (* Format.eprintf "%a: %x@." Printtyp.type_expr ty (Obj.magic vari); *)
+    let ty = Ctype.repr ty in
+    let vari' = get_variance ty visited in
+    if Variance.subset vari vari' then () else
+    let vari = Variance.union vari vari' in
+    visited := TypeMap.add ty vari !visited;
+    let compute_same = compute_variance_rec vari in
+    match ty.desc with
+      Tarrow (_, ty1, ty2, _) ->
+        let open Variance in
+        let v = conjugate vari in
+        let v1 =
+          if mem May_pos v || mem May_neg v
+          then set May_weak true v else v
+        in
+        compute_variance_rec v1 ty1;
+        compute_same ty2
+    | Ttuple tl ->
+        List.iter compute_same tl
+    | Tconstr (path, tl, _) ->
+        let open Variance in
+        if tl = [] then () else begin
+          try
+            let decl = Env.find_type path env in
+            let cvari f = mem f vari in
+            List.iter2
+              (fun ty v ->
+                let cv f = mem f v in
+                let strict =
+                  cvari Inv && cv Inj || (cvari Pos || cvari Neg) && cv Inv
+                in
+                if strict then compute_variance_rec full ty else
+                let p1 = inter v vari
+                and n1 = inter v (conjugate vari) in
+                let v1 =
+                  union (inter covariant (union p1 (conjugate p1)))
+                    (inter (conjugate covariant) (union n1 (conjugate n1)))
+                and weak =
+                  cvari May_weak && (cv May_pos || cv May_neg) ||
+                  (cvari May_pos || cvari May_neg) && cv May_weak
+                in
+                let v2 = set May_weak weak v1 in
+                compute_variance_rec v2 ty)
+              tl decl.type_variance
+          with Not_found ->
+            List.iter (compute_variance_rec may_inv) tl
+        end
+    | Tobject (ty, _) ->
+        compute_same ty
+    | Tfield (_, _, ty1, ty2) ->
+        compute_same ty1;
+        compute_same ty2
+    | Tsubst ty ->
+        compute_same ty
+    | Tvariant row ->
+        let row = Btype.row_repr row in
+        List.iter
+          (fun (_,f) ->
+            match Btype.row_field_repr f with
+              Rpresent (Some ty) ->
+                compute_same ty
+            | Reither (_, tyl, _, _) ->
+                let open Variance in
+                let upper =
+                  List.fold_left (fun s f -> set f true s)
+                    null [May_pos; May_neg; May_weak]
+                in
+                let v = inter vari upper in
+                (* cf PR#7269:
+                   if List.length tyl > 1 then upper else inter vari upper *)
+                List.iter (compute_variance_rec v) tyl
+            | _ -> ())
+          row.row_fields;
+        compute_same row.row_more
+    | Tpoly (ty, _) ->
+        compute_same ty
+    | Tvar _ | Tnil | Tlink _ | Tunivar _ -> ()
+    | Tpackage (_, _, tyl) ->
+        let v =
+          Variance.(if mem Pos vari || mem Neg vari then full else may_inv)
+        in
+        List.iter (compute_variance_rec v) tyl
+  in
+  compute_variance_rec vari ty
+
+let make p n i =
+  let open Variance in
+  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))
+
+let compute_variance_type env ~check (required, loc) decl tyl =
+  (* Requirements *)
+  let required =
+    List.map (fun (c,n,i) -> if c || n then (c,n,i) else (true,true,i))
+      required
+  in
+  (* Prepare *)
+  let params = List.map Btype.repr decl.type_params in
+  let tvl = ref TypeMap.empty in
+  (* Compute occurrences in the body *)
+  let open Variance in
+  List.iter
+    (fun (cn,ty) ->
+      compute_variance env tvl (if cn then full else covariant) ty)
+    tyl;
+  if check then begin
+    (* Check variance of parameters *)
+    let pos = ref 0 in
+    List.iter2
+      (fun ty (c, n, i) ->
+        incr pos;
+        let var = get_variance ty tvl in
+        let (co,cn) = get_upper var and ij = mem Inj var in
+        if Btype.is_Tvar ty && (co && not c || cn && not n || not ij && i)
+        then raise (Error(loc, Bad_variance
+                                (Variance_not_satisfied !pos,
+                                                        (co,cn,ij),
+                                                        (c,n,i)))))
+      params required;
+    (* Check propagation from constrained parameters *)
+    let args = Btype.newgenty (Ttuple params) in
+    let fvl = Ctype.free_variables args in
+    let fvl = List.filter (fun v -> not (List.memq v params)) fvl in
+    (* If there are no extra variables there is nothing to do *)
+    if fvl = [] then () else
+    let tvl2 = ref TypeMap.empty in
+    List.iter2
+      (fun ty (p,n,_) ->
+        if Btype.is_Tvar ty then () else
+        let v =
+          if p then if n then full else covariant else conjugate covariant in
+        compute_variance env tvl2 v ty)
+      params required;
+    let visited = ref TypeSet.empty in
+    let rec check ty =
+      let ty = Ctype.repr ty in
+      if TypeSet.mem ty !visited then () else
+      let visited' = TypeSet.add ty !visited in
+      visited := visited';
+      let v1 = get_variance ty tvl in
+      let snap = Btype.snapshot () in
+      let v2 =
+        TypeMap.fold
+          (fun t vt v ->
+            if Ctype.equal env false [ty] [t] then union vt v else v)
+          !tvl2 null in
+      Btype.backtrack snap;
+      let (c1,n1) = get_upper v1 and (c2,n2,_,i2) = get_lower v2 in
+      if c1 && not c2 || n1 && not n2 then
+        if List.memq ty fvl then
+          let code = if not i2 then No_variable
+                     else if c2 || n2 then Variance_not_reflected
+                     else Variance_not_deducible in
+          raise (Error (loc, Bad_variance (code, (c1,n1,false), (c2,n2,false))))
+        else
+          Btype.iter_type_expr check ty
+    in
+    List.iter (fun (_,ty) -> check ty) tyl;
+  end;
+  List.map2
+    (fun ty (p, n, i) ->
+      let v = get_variance ty tvl in
+      let tr = decl.type_private in
+      (* Use required variance where relevant *)
+      let concr = decl.type_kind <> Type_abstract (*|| tr = Type_new*) in
+      let (p, n) =
+        if tr = Private || not (Btype.is_Tvar ty) then (p, n) (* set *)
+        else (false, false) (* only check *)
+      and i = concr  || i && tr = Private in
+      let v = union v (make p n i) in
+      let v =
+        if not concr then v else
+        if mem Pos v && mem Neg v then full else
+        if Btype.is_Tvar ty then v else
+        union v
+          (if p then if n then full else covariant else conjugate covariant)
+      in
+      if decl.type_kind = Type_abstract && tr = Public then v else
+      set May_weak (mem May_neg v) v)
+    params required
+
+let add_false = List.map (fun ty -> false, ty)
+
+(* A parameter is constrained if it is either instantiated,
+   or it is a variable appearing in another parameter *)
+let constrained vars ty =
+  match ty.desc with
+  | Tvar _ -> List.exists (fun tl -> List.memq ty tl) vars
+  | _ -> true
+
+let for_constr = function
+  | Types.Cstr_tuple l -> add_false l
+  | Types.Cstr_record l ->
+      List.map
+        (fun {Types.ld_mutable; ld_type} -> (ld_mutable = Mutable, ld_type))
+        l
+
+let compute_variance_gadt env ~check (required, loc as rloc) decl
+    (tl, ret_type_opt) =
+  match ret_type_opt with
+  | None ->
+      compute_variance_type env ~check rloc {decl with type_private = Private}
+        (for_constr tl)
+  | Some ret_type ->
+      match Ctype.repr ret_type with
+      | {desc=Tconstr (_, tyl, _)} ->
+          (* let tyl = List.map (Ctype.expand_head env) tyl in *)
+          let tyl = List.map Ctype.repr tyl in
+          let fvl = List.map (Ctype.free_variables ?env:None) tyl in
+          let _ =
+            List.fold_left2
+              (fun (fv1,fv2) ty (c,n,_) ->
+                match fv2 with [] -> assert false
+                | fv :: fv2 ->
+                    (* fv1 @ fv2 = free_variables of other parameters *)
+                    if (c||n) && constrained (fv1 @ fv2) ty then
+                      raise (Error(loc, Varying_anonymous));
+                    (fv :: fv1, fv2))
+              ([], fvl) tyl required
+          in
+          compute_variance_type env ~check rloc
+            {decl with type_params = tyl; type_private = Private}
+            (for_constr tl)
+      | _ -> assert false
+
+let compute_variance_extension env ~check decl ext rloc =
+  compute_variance_gadt env ~check rloc
+    {decl with type_params = ext.ext_type_params}
+    (ext.ext_args, ext.ext_ret_type)
+
+let compute_variance_decl env ~check decl (required, _ as rloc) =
+  if (decl.type_kind = Type_abstract || decl.type_kind = Type_open)
+       && decl.type_manifest = None then
+    List.map
+      (fun (c, n, i) ->
+        make (not n) (not c) (decl.type_kind <> Type_abstract || i))
+      required
+  else
+  let mn =
+    match decl.type_manifest with
+      None -> []
+    | Some ty -> [false, ty]
+  in
+  match decl.type_kind with
+    Type_abstract | Type_open ->
+      compute_variance_type env ~check rloc decl mn
+  | Type_variant tll ->
+      if List.for_all (fun c -> c.Types.cd_res = None) tll then
+        compute_variance_type env ~check rloc decl
+          (mn @ List.flatten (List.map (fun c -> for_constr c.Types.cd_args)
+                                tll))
+      else begin
+        let mn =
+          List.map (fun (_,ty) -> (Types.Cstr_tuple [ty],None)) mn in
+        let tll =
+          mn @ List.map (fun c -> c.Types.cd_args, c.Types.cd_res) tll in
+        match List.map (compute_variance_gadt env ~check rloc decl) tll with
+        | vari :: rem ->
+            let varl = List.fold_left (List.map2 Variance.union) vari rem in
+            List.map
+              Variance.(fun v -> if mem Pos v && mem Neg v then full else v)
+              varl
+        | _ -> assert false
+      end
+  | Type_record (ftl, _) ->
+      compute_variance_type env ~check rloc decl
+        (mn @ List.map (fun {Types.ld_mutable; ld_type} ->
+             (ld_mutable = Mutable, ld_type)) ftl)
+
+let is_hash id =
+  let s = Ident.name id in
+  String.length s > 0 && s.[0] = '#'
+
+let check_variance_extension env decl ext rloc =
+  (* TODO: refactorize compute_variance_extension *)
+  ignore (compute_variance_extension env ~check:true decl
+    ext.Typedtree.ext_type rloc)
+
+let compute_decl env ~check decl req =
+  compute_variance_decl env ~check decl (req, decl.type_loc)
+
+let check_decl env decl req =
+  ignore (compute_variance_decl env ~check:true decl (req, decl.type_loc))
+
+type prop = Variance.t list
+type req = surface_variance list
+let property : (prop, req) Typedecl_properties.property =
+  let open Typedecl_properties in
+  let eq li1 li2 =
+    try List.for_all2 Variance.eq li1 li2 with _ -> false in
+  let merge ~prop ~new_prop =
+    List.map2 Variance.union prop new_prop in
+  let default decl =
+    List.map (fun _ -> Variance.null) decl.type_params in
+  let compute env decl req =
+    compute_decl env ~check:false decl req in
+  let update_decl decl variance =
+    { decl with type_variance = variance } in
+  let check env id decl req =
+    if is_hash id then () else check_decl env decl req in
+  {
+    eq;
+    merge;
+    default;
+    compute;
+    update_decl;
+    check;
+  }
+
+let transl_variance : Asttypes.variance -> _ = function
+  | Covariant -> (true, false, false)
+  | Contravariant -> (false, true, false)
+  | Invariant -> (false, false, false)
+
+let variance_of_params ptype_params =
+  List.map transl_variance (List.map snd ptype_params)
+
+let variance_of_sdecl sdecl =
+  variance_of_params sdecl.Parsetree.ptype_params
+
+let update_decls env sdecls decls =
+  let required = List.map variance_of_sdecl sdecls in
+  Typedecl_properties.compute_property property env decls required
+
+let update_class_decls env cldecls =
+  let decls, required =
+    List.fold_right
+      (fun (obj_id, obj_abbr, _cl_abbr, _clty, _cltydef, ci) (decls, req) ->
+        (obj_id, obj_abbr) :: decls,
+        variance_of_params ci.Typedtree.ci_params :: req)
+      cldecls ([],[])
+  in
+  let decls =
+    Typedecl_properties.compute_property property env decls required in
+  List.map2
+    (fun (_,decl) (_, _, cl_abbr, clty, cltydef, _) ->
+      let variance = decl.type_variance in
+      (decl, {cl_abbr with type_variance = variance},
+       {clty with cty_variance = variance},
+       {cltydef with clty_variance = variance}))
+    decls cldecls
diff --git a/src/ocaml/typing/410+multicore/typedecl_variance.mli b/src/ocaml/typing/410+multicore/typedecl_variance.mli
new file mode 100644
index 00000000..99ce18d6
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedecl_variance.mli
@@ -0,0 +1,62 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*   Gabriel Scherer, projet Parsifal, INRIA Saclay                       *)
+(*   Rodolphe Lepigre, projet Deducteam, INRIA Saclay                     *)
+(*                                                                        *)
+(*   Copyright 2018 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Types
+open Typedecl_properties
+
+type surface_variance = bool * bool * bool
+
+val variance_of_params :
+  (Parsetree.core_type * Asttypes.variance) list -> surface_variance list
+val variance_of_sdecl :
+  Parsetree.type_declaration -> surface_variance list
+
+type prop = Variance.t list
+type req = surface_variance list
+val property : (Variance.t list, req) property
+
+type variance_error =
+| Variance_not_satisfied of int
+| No_variable
+| Variance_not_reflected
+| Variance_not_deducible
+
+type error =
+| Bad_variance of variance_error * surface_variance * surface_variance
+| Varying_anonymous
+
+exception Error of Location.t * error
+
+val check_variance_extension :
+  Env.t -> type_declaration ->
+  Typedtree.extension_constructor -> req * Location.t -> unit
+
+val compute_decl :
+  Env.t -> check:bool -> type_declaration -> req -> prop
+
+val update_decls :
+  Env.t -> Parsetree.type_declaration list ->
+  (Ident.t * type_declaration) list ->
+  (Ident.t * type_declaration) list
+
+val update_class_decls :
+  Env.t ->
+  (Ident.t * Typedecl_properties.decl * Types.type_declaration *
+   Types.class_declaration * Types.class_type_declaration *
+   'a Typedtree.class_infos) list ->
+  (Typedecl_properties.decl * Types.type_declaration *
+   Types.class_declaration * Types.class_type_declaration) list
+(* FIXME: improve this horrible interface *)
diff --git a/src/ocaml/typing/410+multicore/typedtree.ml b/src/ocaml/typing/410+multicore/typedtree.ml
new file mode 100644
index 00000000..2d6053a4
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedtree.ml
@@ -0,0 +1,745 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Abstract syntax tree after typing *)
+
+open Asttypes
+open Types
+
+(* Value expressions for the core language *)
+
+type partial = Partial | Total
+
+type attribute = Parsetree.attribute
+type attributes = attribute list
+
+type pattern =
+  { pat_desc: pattern_desc;
+    pat_loc: Location.t;
+    pat_extra : (pat_extra * Location.t * attribute list) list;
+    pat_type: type_expr;
+    mutable pat_env: Env.t;
+    pat_attributes: attribute list;
+   }
+
+and pat_extra =
+  | Tpat_constraint of core_type
+  | Tpat_type of Path.t * Longident.t loc
+  | Tpat_open of Path.t * Longident.t loc * Env.t
+  | Tpat_unpack
+
+and pattern_desc =
+    Tpat_any
+  | Tpat_var of Ident.t * string loc
+  | Tpat_alias of pattern * Ident.t * string loc
+  | Tpat_constant of constant
+  | Tpat_tuple of pattern list
+  | Tpat_construct of
+      Longident.t loc * constructor_description * pattern list
+  | Tpat_variant of label * pattern option * row_desc ref
+  | Tpat_record of
+      (Longident.t loc * label_description * pattern) list *
+        closed_flag
+  | Tpat_array of pattern list
+  | Tpat_or of pattern * pattern * row_desc option
+  | Tpat_lazy of pattern
+  | Tpat_exception of pattern
+
+and expression =
+  { exp_desc: expression_desc;
+    exp_loc: Location.t;
+    exp_extra: (exp_extra * Location.t * attribute list) list;
+    exp_type: type_expr;
+    exp_env: Env.t;
+    exp_attributes: attribute list;
+   }
+
+and exp_extra =
+  | Texp_constraint of core_type
+  | Texp_coerce of core_type option * core_type
+  | Texp_poly of core_type option
+  | Texp_newtype of string
+
+and expression_desc =
+    Texp_ident of Path.t * Longident.t loc * Types.value_description
+  | Texp_constant of constant
+  | Texp_let of rec_flag * value_binding list * expression
+  | Texp_function of { arg_label : arg_label; param : Ident.t;
+      cases : case list; partial : partial; }
+  | Texp_apply of expression * (arg_label * expression option) list
+  | Texp_match of expression * case list * partial
+  | Texp_try of expression * case list
+  | Texp_tuple of expression list
+  | Texp_construct of
+      Longident.t loc * constructor_description * expression list
+  | Texp_variant of label * expression option
+  | Texp_record of {
+      fields : ( Types.label_description * record_label_definition ) array;
+      representation : Types.record_representation;
+      extended_expression : expression option;
+    }
+  | Texp_field of expression * Longident.t loc * label_description
+  | Texp_setfield of
+      expression * Longident.t loc * label_description * expression
+  | Texp_array of expression list
+  | Texp_ifthenelse of expression * expression * expression option
+  | Texp_sequence of expression * expression
+  | Texp_while of expression * expression
+  | Texp_for of
+      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
+        expression
+  | Texp_send of expression * meth * expression option
+  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
+  | Texp_instvar of Path.t * Path.t * string loc
+  | Texp_setinstvar of Path.t * Path.t * string loc * expression
+  | Texp_override of Path.t * (Path.t * string loc * expression) list
+  | Texp_letmodule of
+      Ident.t option * string option loc * Types.module_presence * module_expr *
+        expression
+  | Texp_letexception of extension_constructor * expression
+  | Texp_assert of expression
+  | Texp_lazy of expression
+  | Texp_object of class_structure * string list
+  | Texp_pack of module_expr
+  | Texp_letop of {
+      let_ : binding_op;
+      ands : binding_op list;
+      param : Ident.t;
+      body : case;
+      partial : partial;
+    }
+  | Texp_unreachable
+  | Texp_extension_constructor of Longident.t loc * Path.t
+  | Texp_open of open_declaration * expression
+
+and meth =
+    Tmeth_name of string
+  | Tmeth_val of Ident.t
+
+and case =
+    {
+     c_lhs: pattern;
+     c_guard: expression option;
+     c_rhs: expression;
+    }
+
+and record_label_definition =
+  | Kept of Types.type_expr
+  | Overridden of Longident.t loc * expression
+
+and binding_op =
+  {
+    bop_op_path : Path.t;
+    bop_op_name : string loc;
+    bop_op_val : Types.value_description;
+    bop_op_type : Types.type_expr;
+    bop_exp : expression;
+    bop_loc : Location.t;
+  }
+
+(* Value expressions for the class language *)
+
+and class_expr =
+    {
+     cl_desc: class_expr_desc;
+     cl_loc: Location.t;
+     cl_type: Types.class_type;
+     cl_env: Env.t;
+     cl_attributes: attribute list;
+    }
+
+and class_expr_desc =
+    Tcl_ident of Path.t * Longident.t loc * core_type list
+  | Tcl_structure of class_structure
+  | Tcl_fun of
+      arg_label * pattern * (Ident.t * expression) list
+      * class_expr * partial
+  | Tcl_apply of class_expr * (arg_label * expression option) list
+  | Tcl_let of rec_flag * value_binding list *
+                  (Ident.t * expression) list * class_expr
+  | Tcl_constraint of
+      class_expr * class_type option * string list * string list * Concr.t
+    (* Visible instance variables, methods and concrete methods *)
+  | Tcl_open of open_description * class_expr
+
+and class_structure =
+  {
+   cstr_self: pattern;
+   cstr_fields: class_field list;
+   cstr_type: Types.class_signature;
+   cstr_meths: Ident.t Meths.t;
+  }
+
+and class_field =
+   {
+    cf_desc: class_field_desc;
+    cf_loc: Location.t;
+    cf_attributes: attribute list;
+  }
+
+and class_field_kind =
+  | Tcfk_virtual of core_type
+  | Tcfk_concrete of override_flag * expression
+
+and class_field_desc =
+    Tcf_inherit of
+      override_flag * class_expr * string option * (string * Ident.t) list *
+        (string * Ident.t) list
+    (* Inherited instance variables and concrete methods *)
+  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
+  | Tcf_method of string loc * private_flag * class_field_kind
+  | Tcf_constraint of core_type * core_type
+  | Tcf_initializer of expression
+  | Tcf_attribute of attribute
+
+(* Value expressions for the module language *)
+
+and module_expr =
+  { mod_desc: module_expr_desc;
+    mod_loc: Location.t;
+    mod_type: Types.module_type;
+    mod_env: Env.t;
+    mod_attributes: attribute list;
+   }
+
+and module_type_constraint =
+  Tmodtype_implicit
+| Tmodtype_explicit of module_type
+
+and functor_parameter =
+  | Unit
+  | Named of Ident.t option * string option loc * module_type
+
+and module_expr_desc =
+    Tmod_ident of Path.t * Longident.t loc
+  | Tmod_structure of structure
+  | Tmod_functor of functor_parameter * module_expr
+  | Tmod_apply of module_expr * module_expr * module_coercion
+  | Tmod_constraint of
+      module_expr * Types.module_type * module_type_constraint * module_coercion
+  | Tmod_unpack of expression * Types.module_type
+
+and structure = {
+  str_items : structure_item list;
+  str_type : Types.signature;
+  str_final_env : Env.t;
+}
+
+and structure_item =
+  { str_desc : structure_item_desc;
+    str_loc : Location.t;
+    str_env : Env.t
+  }
+
+and structure_item_desc =
+    Tstr_eval of expression * attributes
+  | Tstr_value of rec_flag * value_binding list
+  | Tstr_primitive of value_description
+  | Tstr_type of rec_flag * type_declaration list
+  | Tstr_typext of type_extension
+  | Tstr_exception of type_exception
+  | Tstr_module of module_binding
+  | Tstr_recmodule of module_binding list
+  | Tstr_modtype of module_type_declaration
+  | Tstr_open of open_declaration
+  | Tstr_class of (class_declaration * string list) list
+  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
+  | Tstr_include of include_declaration
+  | Tstr_attribute of attribute
+
+and module_binding =
+    {
+     mb_id: Ident.t option;
+     mb_name: string option loc;
+     mb_presence: module_presence;
+     mb_expr: module_expr;
+     mb_attributes: attribute list;
+     mb_loc: Location.t;
+    }
+
+and value_binding =
+  {
+    vb_pat: pattern;
+    vb_expr: expression;
+    vb_attributes: attributes;
+    vb_loc: Location.t;
+  }
+
+and module_coercion =
+    Tcoerce_none
+  | Tcoerce_structure of (int * module_coercion) list *
+                         (Ident.t * int * module_coercion) list
+  | Tcoerce_functor of module_coercion * module_coercion
+  | Tcoerce_primitive of primitive_coercion
+  | Tcoerce_alias of Env.t * Path.t * module_coercion
+
+and module_type =
+  { mty_desc: module_type_desc;
+    mty_type : Types.module_type;
+    mty_env : Env.t;
+    mty_loc: Location.t;
+    mty_attributes: attribute list;
+   }
+
+and module_type_desc =
+    Tmty_ident of Path.t * Longident.t loc
+  | Tmty_signature of signature
+  | Tmty_functor of functor_parameter * module_type
+  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
+  | Tmty_typeof of module_expr
+  | Tmty_alias of Path.t * Longident.t loc
+
+(* Keep primitive type information for type-based lambda-code specialization *)
+and primitive_coercion =
+  {
+    pc_desc: Primitive.description;
+    pc_type: type_expr;
+    pc_env: Env.t;
+    pc_loc : Location.t;
+  }
+
+and signature = {
+  sig_items : signature_item list;
+  sig_type : Types.signature;
+  sig_final_env : Env.t;
+}
+
+and signature_item =
+  { sig_desc: signature_item_desc;
+    sig_env : Env.t; (* BINANNOT ADDED *)
+    sig_loc: Location.t }
+
+and signature_item_desc =
+    Tsig_value of value_description
+  | Tsig_type of rec_flag * type_declaration list
+  | Tsig_typesubst of type_declaration list
+  | Tsig_typext of type_extension
+  | Tsig_exception of type_exception
+  | Tsig_module of module_declaration
+  | Tsig_modsubst of module_substitution
+  | Tsig_recmodule of module_declaration list
+  | Tsig_modtype of module_type_declaration
+  | Tsig_open of open_description
+  | Tsig_include of include_description
+  | Tsig_class of class_description list
+  | Tsig_class_type of class_type_declaration list
+  | Tsig_attribute of attribute
+
+and module_declaration =
+    {
+     md_id: Ident.t option;
+     md_name: string option loc;
+     md_presence: module_presence;
+     md_type: module_type;
+     md_attributes: attribute list;
+     md_loc: Location.t;
+    }
+
+and module_substitution =
+    {
+     ms_id: Ident.t;
+     ms_name: string loc;
+     ms_manifest: Path.t;
+     ms_txt: Longident.t loc;
+     ms_attributes: attributes;
+     ms_loc: Location.t;
+    }
+
+and module_type_declaration =
+    {
+     mtd_id: Ident.t;
+     mtd_name: string loc;
+     mtd_type: module_type option;
+     mtd_attributes: attribute list;
+     mtd_loc: Location.t;
+    }
+
+and 'a open_infos =
+    {
+     open_expr: 'a;
+     open_bound_items: Types.signature;
+     open_override: override_flag;
+     open_env: Env.t;
+     open_loc: Location.t;
+     open_attributes: attribute list;
+    }
+
+and open_description = (Path.t * Longident.t loc) open_infos
+
+and open_declaration = module_expr open_infos
+
+and 'a include_infos =
+    {
+     incl_mod: 'a;
+     incl_type: Types.signature;
+     incl_loc: Location.t;
+     incl_attributes: attribute list;
+    }
+
+and include_description = module_type include_infos
+
+and include_declaration = module_expr include_infos
+
+and with_constraint =
+    Twith_type of type_declaration
+  | Twith_module of Path.t * Longident.t loc
+  | Twith_typesubst of type_declaration
+  | Twith_modsubst of Path.t * Longident.t loc
+
+and core_type =
+(* mutable because of [Typeclass.declare_method] *)
+  { mutable ctyp_desc : core_type_desc;
+    mutable ctyp_type : type_expr;
+    ctyp_env : Env.t; (* BINANNOT ADDED *)
+    ctyp_loc : Location.t;
+    ctyp_attributes: attribute list;
+   }
+
+and core_type_desc =
+    Ttyp_any
+  | Ttyp_var of string
+  | Ttyp_arrow of arg_label * core_type * core_type
+  | Ttyp_tuple of core_type list
+  | Ttyp_constr of Path.t * Longident.t loc * core_type list
+  | Ttyp_object of object_field list * closed_flag
+  | Ttyp_class of Path.t * Longident.t loc * core_type list
+  | Ttyp_alias of core_type * string
+  | Ttyp_variant of row_field list * closed_flag * label list option
+  | Ttyp_poly of string list * core_type
+  | Ttyp_package of package_type
+
+and package_type = {
+  pack_path : Path.t;
+  pack_fields : (Longident.t loc * core_type) list;
+  pack_type : Types.module_type;
+  pack_txt : Longident.t loc;
+}
+
+and row_field = {
+  rf_desc : row_field_desc;
+  rf_loc : Location.t;
+  rf_attributes : attributes;
+}
+
+and row_field_desc =
+    Ttag of string loc * bool * core_type list
+  | Tinherit of core_type
+
+and object_field = {
+  of_desc : object_field_desc;
+  of_loc : Location.t;
+  of_attributes : attributes;
+}
+
+and object_field_desc =
+  | OTtag of string loc * core_type
+  | OTinherit of core_type
+
+and value_description =
+  { val_id: Ident.t;
+    val_name: string loc;
+    val_desc: core_type;
+    val_val: Types.value_description;
+    val_prim: string list;
+    val_loc: Location.t;
+    val_attributes: attribute list;
+    }
+
+and type_declaration =
+  { typ_id: Ident.t;
+    typ_name: string loc;
+    typ_params: (core_type * variance) list;
+    typ_type: Types.type_declaration;
+    typ_cstrs: (core_type * core_type * Location.t) list;
+    typ_kind: type_kind;
+    typ_private: private_flag;
+    typ_manifest: core_type option;
+    typ_loc: Location.t;
+    typ_attributes: attribute list;
+   }
+
+and type_kind =
+    Ttype_abstract
+  | Ttype_variant of constructor_declaration list
+  | Ttype_record of label_declaration list
+  | Ttype_open
+
+and label_declaration =
+    {
+     ld_id: Ident.t;
+     ld_name: string loc;
+     ld_mutable: mutable_flag;
+     ld_type: core_type;
+     ld_loc: Location.t;
+     ld_attributes: attribute list;
+    }
+
+and constructor_declaration =
+    {
+     cd_id: Ident.t;
+     cd_name: string loc;
+     cd_args: constructor_arguments;
+     cd_res: core_type option;
+     cd_loc: Location.t;
+     cd_attributes: attribute list;
+    }
+
+and constructor_arguments =
+  | Cstr_tuple of core_type list
+  | Cstr_record of label_declaration list
+
+and type_extension =
+  {
+    tyext_path: Path.t;
+    tyext_txt: Longident.t loc;
+    tyext_params: (core_type * variance) list;
+    tyext_constructors: extension_constructor list;
+    tyext_private: private_flag;
+    tyext_loc: Location.t;
+    tyext_attributes: attribute list;
+  }
+
+and type_exception =
+  {
+    tyexn_constructor: extension_constructor;
+    tyexn_loc: Location.t;
+    tyexn_attributes: attribute list;
+  }
+
+and extension_constructor =
+  {
+    ext_id: Ident.t;
+    ext_name: string loc;
+    ext_type: Types.extension_constructor;
+    ext_kind: extension_constructor_kind;
+    ext_loc: Location.t;
+    ext_attributes: attribute list;
+  }
+
+and extension_constructor_kind =
+    Text_decl of constructor_arguments * core_type option
+  | Text_rebind of Path.t * Longident.t loc
+
+and class_type =
+    {
+     cltyp_desc: class_type_desc;
+     cltyp_type: Types.class_type;
+     cltyp_env: Env.t;
+     cltyp_loc: Location.t;
+     cltyp_attributes: attribute list;
+    }
+
+and class_type_desc =
+    Tcty_constr of Path.t * Longident.t loc * core_type list
+  | Tcty_signature of class_signature
+  | Tcty_arrow of arg_label * core_type * class_type
+  | Tcty_open of open_description * class_type
+
+and class_signature = {
+    csig_self: core_type;
+    csig_fields: class_type_field list;
+    csig_type: Types.class_signature;
+  }
+
+and class_type_field = {
+    ctf_desc: class_type_field_desc;
+    ctf_loc: Location.t;
+    ctf_attributes: attribute list;
+  }
+
+and class_type_field_desc =
+  | Tctf_inherit of class_type
+  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
+  | Tctf_method of (string * private_flag * virtual_flag * core_type)
+  | Tctf_constraint of (core_type * core_type)
+  | Tctf_attribute of attribute
+
+and class_declaration =
+  class_expr class_infos
+
+and class_description =
+  class_type class_infos
+
+and class_type_declaration =
+  class_type class_infos
+
+and 'a class_infos =
+  { ci_virt: virtual_flag;
+    ci_params: (core_type * variance) list;
+    ci_id_name: string loc;
+    ci_id_class: Ident.t;
+    ci_id_class_type: Ident.t;
+    ci_id_object: Ident.t;
+    ci_id_typehash: Ident.t;
+    ci_expr: 'a;
+    ci_decl: Types.class_declaration;
+    ci_type_decl: Types.class_type_declaration;
+    ci_loc: Location.t;
+    ci_attributes: attribute list;
+   }
+
+(* Auxiliary functions over the a.s.t. *)
+
+let shallow_iter_pattern_desc f = function
+  | Tpat_alias(p, _, _) -> f p
+  | Tpat_tuple patl -> List.iter f patl
+  | Tpat_construct(_, _, patl) -> List.iter f patl
+  | Tpat_variant(_, pat, _) -> Option.iter f pat
+  | Tpat_record (lbl_pat_list, _) ->
+      List.iter (fun (_, _, pat) -> f pat) lbl_pat_list
+  | Tpat_array patl -> List.iter f patl
+  | Tpat_or(p1, p2, _) -> f p1; f p2
+  | Tpat_lazy p -> f p
+  | Tpat_exception p -> f p
+  | Tpat_any
+  | Tpat_var _
+  | Tpat_constant _ -> ()
+
+let shallow_map_pattern_desc f d =
+  match d with
+  | Tpat_alias (p1, id, s) ->
+      Tpat_alias (f p1, id, s)
+  | Tpat_tuple pats ->
+      Tpat_tuple (List.map f pats)
+  | Tpat_record (lpats, closed) ->
+      Tpat_record (List.map (fun (lid, l,p) -> lid, l, f p) lpats, closed)
+  | Tpat_construct (lid, c,pats) ->
+      Tpat_construct (lid, c, List.map f pats)
+  | Tpat_array pats ->
+      Tpat_array (List.map f pats)
+  | Tpat_lazy p1 -> Tpat_lazy (f p1)
+  | Tpat_exception p1 -> Tpat_exception (f p1)
+  | Tpat_variant (x1, Some p1, x2) ->
+      Tpat_variant (x1, Some (f p1), x2)
+  | Tpat_or (p1,p2,path) ->
+      Tpat_or (f p1, f p2, path)
+  | Tpat_var _
+  | Tpat_constant _
+  | Tpat_any
+  | Tpat_variant (_,None,_) -> d
+
+let rec iter_pattern f p =
+  f p;
+  shallow_iter_pattern_desc (iter_pattern f) p.pat_desc
+
+let exists_pattern f p =
+  let exception Found in
+  let raiser f x = if (f x) then raise Found else () in
+  match iter_pattern (raiser f) p with
+  | exception Found -> true
+  | () -> false
+
+(* List the identifiers bound by a pattern or a let *)
+
+let rec iter_bound_idents f pat =
+  match pat.pat_desc with
+  | Tpat_var (id,s) ->
+     f (id,s,pat.pat_type)
+  | Tpat_alias(p, id, s) ->
+      iter_bound_idents f p;
+      f (id,s,pat.pat_type)
+  | Tpat_or(p1, _, _) ->
+      (* Invariant : both arguments bind the same variables *)
+      iter_bound_idents f p1
+  | d ->
+     shallow_iter_pattern_desc (iter_bound_idents f) d
+
+let rev_pat_bound_idents_full pat =
+  let idents_full = ref [] in
+  let add id_full = idents_full := id_full :: !idents_full in
+  iter_bound_idents add pat;
+  !idents_full
+
+let rev_only_idents idents_full =
+  List.rev_map (fun (id,_,_) -> id) idents_full
+
+let pat_bound_idents_full pat =
+  List.rev (rev_pat_bound_idents_full pat)
+let pat_bound_idents pat =
+  rev_only_idents (rev_pat_bound_idents_full pat)
+
+let pat_bound_idents_with_loc p =
+  List.map (fun (id,loc,_ty) -> id, loc) (pat_bound_idents_full p)
+
+let rev_let_bound_idents_full bindings =
+  let idents_full = ref [] in
+  let add id_full = idents_full := id_full :: !idents_full in
+  List.iter (fun vb -> iter_bound_idents add vb.vb_pat) bindings;
+  !idents_full
+
+let let_bound_idents_full bindings =
+  List.rev (rev_let_bound_idents_full bindings)
+let let_bound_idents pat =
+  rev_only_idents (rev_let_bound_idents_full pat)
+
+let alpha_var env id = List.assoc id env
+
+let rec alpha_pat env p = match p.pat_desc with
+| Tpat_var (id, s) -> (* note the ``Not_found'' case *)
+    {p with pat_desc =
+     try Tpat_var (alpha_var env id, s) with
+     | Not_found -> Tpat_any}
+| Tpat_alias (p1, id, s) ->
+    let new_p =  alpha_pat env p1 in
+    begin try
+      {p with pat_desc = Tpat_alias (new_p, alpha_var env id, s)}
+    with
+    | Not_found -> new_p
+    end
+| d ->
+    {p with pat_desc = shallow_map_pattern_desc (alpha_pat env) d}
+
+let mkloc = Location.mkloc
+let mknoloc = Location.mknoloc
+
+let split_pattern pat =
+  let combine_pattern_desc_opts ~into p1 p2 =
+    match p1, p2 with
+    | None, None -> None
+    | Some p, None
+    | None, Some p ->
+        Some p
+    | Some p1, Some p2 ->
+        (* The third parameter of [Tpat_or] is [Some _] only for "#typ"
+           patterns, which we do *not* expand. Hence we can put [None] here. *)
+        Some { into with pat_desc = Tpat_or (p1, p2, None) }
+  in
+  let rec split_pattern pat =
+    match pat.pat_desc with
+    | Tpat_or (p1, p2, None) ->
+        let vals1, exns1 = split_pattern p1 in
+        let vals2, exns2 = split_pattern p2 in
+        combine_pattern_desc_opts ~into:pat vals1 vals2,
+        (* We could change the pattern type for exception patterns to
+           [Predef.exn], but it doesn't really matter. *)
+        combine_pattern_desc_opts ~into:pat exns1 exns2
+    | Tpat_exception p ->
+        None, Some p
+    | _ ->
+        Some pat, None
+  in
+  split_pattern pat
+
+(* Merlin specific *)
+
+let unpack_functor_me me =
+  match me.mod_desc with
+  | Tmod_functor (fp, mty) -> fp, mty
+  | _ -> invalid_arg "Typedtree.unpack_functor_me (merlin)"
+
+let unpack_functor_mty mty =
+  match mty.mty_desc with
+  | Tmty_functor (fp, mty) -> fp, mty
+  | _ -> invalid_arg "Typedtree.unpack_functor_mty (merlin)"
diff --git a/src/ocaml/typing/410+multicore/typedtree.mli b/src/ocaml/typing/410+multicore/typedtree.mli
new file mode 100644
index 00000000..42da1ea5
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typedtree.mli
@@ -0,0 +1,750 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Abstract syntax tree after typing *)
+
+
+(** By comparison with {!Parsetree}:
+    - Every {!Longindent.t} is accompanied by a resolved {!Path.t}.
+
+*)
+
+open Asttypes
+open Types
+
+(* Value expressions for the core language *)
+
+type partial = Partial | Total
+
+(** {1 Extension points} *)
+
+type attribute = Parsetree.attribute
+type attributes = attribute list
+
+(** {1 Core language} *)
+
+type pattern =
+  { pat_desc: pattern_desc;
+    pat_loc: Location.t;
+    pat_extra : (pat_extra * Location.t * attributes) list;
+    pat_type: type_expr;
+    mutable pat_env: Env.t;
+    pat_attributes: attributes;
+   }
+
+and pat_extra =
+  | Tpat_constraint of core_type
+        (** P : T          { pat_desc = P
+                           ; pat_extra = (Tpat_constraint T, _, _) :: ... }
+         *)
+  | Tpat_type of Path.t * Longident.t loc
+        (** #tconst        { pat_desc = disjunction
+                           ; pat_extra = (Tpat_type (P, "tconst"), _, _) :: ...}
+
+                           where [disjunction] is a [Tpat_or _] representing the
+                           branches of [tconst].
+         *)
+  | Tpat_open of Path.t * Longident.t loc * Env.t
+  | Tpat_unpack
+        (** (module P)     { pat_desc  = Tpat_var "P"
+                           ; pat_extra = (Tpat_unpack, _, _) :: ... }
+         *)
+
+and pattern_desc =
+    Tpat_any
+        (** _ *)
+  | Tpat_var of Ident.t * string loc
+        (** x *)
+  | Tpat_alias of pattern * Ident.t * string loc
+        (** P as a *)
+  | Tpat_constant of constant
+        (** 1, 'a', "true", 1.0, 1l, 1L, 1n *)
+  | Tpat_tuple of pattern list
+        (** (P1, ..., Pn)
+
+            Invariant: n >= 2
+         *)
+  | Tpat_construct of
+      Longident.t loc * constructor_description * pattern list
+        (** C                []
+            C P              [P]
+            C (P1, ..., Pn)  [P1; ...; Pn]
+          *)
+  | Tpat_variant of label * pattern option * row_desc ref
+        (** `A             (None)
+            `A P           (Some P)
+
+            See {!Types.row_desc} for an explanation of the last parameter.
+         *)
+  | Tpat_record of
+      (Longident.t loc * label_description * pattern) list *
+        closed_flag
+        (** { l1=P1; ...; ln=Pn }     (flag = Closed)
+            { l1=P1; ...; ln=Pn; _}   (flag = Open)
+
+            Invariant: n > 0
+         *)
+  | Tpat_array of pattern list
+        (** [| P1; ...; Pn |] *)
+  | Tpat_or of pattern * pattern * row_desc option
+        (** P1 | P2
+
+            [row_desc] = [Some _] when translating [Ppat_type _],
+                         [None] otherwise.
+         *)
+  | Tpat_lazy of pattern
+        (** lazy P *)
+  | Tpat_exception of pattern
+        (** exception P *)
+
+and expression =
+  { exp_desc: expression_desc;
+    exp_loc: Location.t;
+    exp_extra: (exp_extra * Location.t * attributes) list;
+    exp_type: type_expr;
+    exp_env: Env.t;
+    exp_attributes: attributes;
+   }
+
+and exp_extra =
+  | Texp_constraint of core_type
+        (** E : T *)
+  | Texp_coerce of core_type option * core_type
+        (** E :> T           [Texp_coerce (None, T)]
+            E : T0 :> T      [Texp_coerce (Some T0, T)]
+         *)
+  | Texp_poly of core_type option
+        (** Used for method bodies. *)
+  | Texp_newtype of string
+        (** fun (type t) ->  *)
+
+and expression_desc =
+    Texp_ident of Path.t * Longident.t loc * Types.value_description
+        (** x
+            M.x
+         *)
+  | Texp_constant of constant
+        (** 1, 'a', "true", 1.0, 1l, 1L, 1n *)
+  | Texp_let of rec_flag * value_binding list * expression
+        (** let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
+            let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
+         *)
+  | Texp_function of { arg_label : arg_label; param : Ident.t;
+      cases : case list; partial : partial; }
+        (** [Pexp_fun] and [Pexp_function] both translate to [Texp_function].
+            See {!Parsetree} for more details.
+
+            [param] is the identifier that is to be used to name the
+            parameter of the function.
+
+            partial =
+              [Partial] if the pattern match is partial
+              [Total] otherwise.
+         *)
+  | Texp_apply of expression * (arg_label * expression option) list
+        (** E0 ~l1:E1 ... ~ln:En
+
+            The expression can be None if the expression is abstracted over
+            this argument. It currently appears when a label is applied.
+
+            For example:
+            let f x ~y = x + y in
+            f ~y:3
+
+            The resulting typedtree for the application is:
+            Texp_apply (Texp_ident "f/1037",
+                        [(Nolabel, None);
+                         (Labelled "y", Some (Texp_constant Const_int 3))
+                        ])
+         *)
+  | Texp_match of expression * case list * partial
+        (** match E0 with
+            | P1 -> E1
+            | P2 | exception P3 -> E2
+            | exception P4 -> E3
+
+            [Texp_match (E0, [(P1, E1); (P2 | exception P3, E2);
+                              (exception P4, E3)], _)]
+         *)
+  | Texp_try of expression * case list
+        (** try E with P1 -> E1 | ... | PN -> EN *)
+  | Texp_tuple of expression list
+        (** (E1, ..., EN) *)
+  | Texp_construct of
+      Longident.t loc * constructor_description * expression list
+        (** C                []
+            C E              [E]
+            C (E1, ..., En)  [E1;...;En]
+         *)
+  | Texp_variant of label * expression option
+  | Texp_record of {
+      fields : ( Types.label_description * record_label_definition ) array;
+      representation : Types.record_representation;
+      extended_expression : expression option;
+    }
+        (** { l1=P1; ...; ln=Pn }           (extended_expression = None)
+            { E0 with l1=P1; ...; ln=Pn }   (extended_expression = Some E0)
+
+            Invariant: n > 0
+
+            If the type is { l1: t1; l2: t2 }, the expression
+            { E0 with t2=P2 } is represented as
+            Texp_record
+              { fields = [| l1, Kept t1; l2 Override P2 |]; representation;
+                extended_expression = Some E0 }
+        *)
+  | Texp_field of expression * Longident.t loc * label_description
+  | Texp_setfield of
+      expression * Longident.t loc * label_description * expression
+  | Texp_array of expression list
+  | Texp_ifthenelse of expression * expression * expression option
+  | Texp_sequence of expression * expression
+  | Texp_while of expression * expression
+  | Texp_for of
+      Ident.t * Parsetree.pattern * expression * expression * direction_flag *
+        expression
+  | Texp_send of expression * meth * expression option
+  | Texp_new of Path.t * Longident.t loc * Types.class_declaration
+  | Texp_instvar of Path.t * Path.t * string loc
+  | Texp_setinstvar of Path.t * Path.t * string loc * expression
+  | Texp_override of Path.t * (Path.t * string loc * expression) list
+  | Texp_letmodule of
+      Ident.t option * string option loc * Types.module_presence * module_expr *
+        expression
+  | Texp_letexception of extension_constructor * expression
+  | Texp_assert of expression
+  | Texp_lazy of expression
+  | Texp_object of class_structure * string list
+  | Texp_pack of module_expr
+  | Texp_letop of {
+      let_ : binding_op;
+      ands : binding_op list;
+      param : Ident.t;
+      body : case;
+      partial : partial;
+    }
+  | Texp_unreachable
+  | Texp_extension_constructor of Longident.t loc * Path.t
+  | Texp_open of open_declaration * expression
+        (** let open[!] M in e *)
+
+and meth =
+    Tmeth_name of string
+  | Tmeth_val of Ident.t
+
+and case =
+    {
+     c_lhs: pattern;
+     c_guard: expression option;
+     c_rhs: expression;
+    }
+
+and record_label_definition =
+  | Kept of Types.type_expr
+  | Overridden of Longident.t loc * expression
+
+and binding_op =
+  {
+    bop_op_path : Path.t;
+    bop_op_name : string loc;
+    bop_op_val : Types.value_description;
+    bop_op_type : Types.type_expr;
+    (* This is the type at which the operator was used.
+       It is always an instance of [bop_op_val.val_type] *)
+    bop_exp : expression;
+    bop_loc : Location.t;
+  }
+
+(* Value expressions for the class language *)
+
+and class_expr =
+    {
+     cl_desc: class_expr_desc;
+     cl_loc: Location.t;
+     cl_type: Types.class_type;
+     cl_env: Env.t;
+     cl_attributes: attributes;
+    }
+
+and class_expr_desc =
+    Tcl_ident of Path.t * Longident.t loc * core_type list
+  | Tcl_structure of class_structure
+  | Tcl_fun of
+      arg_label * pattern * (Ident.t * expression) list
+      * class_expr * partial
+  | Tcl_apply of class_expr * (arg_label * expression option) list
+  | Tcl_let of rec_flag * value_binding list *
+                  (Ident.t * expression) list * class_expr
+  | Tcl_constraint of
+      class_expr * class_type option * string list * string list * Concr.t
+  (* Visible instance variables, methods and concrete methods *)
+  | Tcl_open of open_description * class_expr
+
+and class_structure =
+  {
+   cstr_self: pattern;
+   cstr_fields: class_field list;
+   cstr_type: Types.class_signature;
+   cstr_meths: Ident.t Meths.t;
+  }
+
+and class_field =
+   {
+    cf_desc: class_field_desc;
+    cf_loc: Location.t;
+    cf_attributes: attributes;
+  }
+
+and class_field_kind =
+  | Tcfk_virtual of core_type
+  | Tcfk_concrete of override_flag * expression
+
+and class_field_desc =
+    Tcf_inherit of
+      override_flag * class_expr * string option * (string * Ident.t) list *
+        (string * Ident.t) list
+    (* Inherited instance variables and concrete methods *)
+  | Tcf_val of string loc * mutable_flag * Ident.t * class_field_kind * bool
+  | Tcf_method of string loc * private_flag * class_field_kind
+  | Tcf_constraint of core_type * core_type
+  | Tcf_initializer of expression
+  | Tcf_attribute of attribute
+
+(* Value expressions for the module language *)
+
+and module_expr =
+  { mod_desc: module_expr_desc;
+    mod_loc: Location.t;
+    mod_type: Types.module_type;
+    mod_env: Env.t;
+    mod_attributes: attributes;
+   }
+
+(** Annotations for [Tmod_constraint]. *)
+and module_type_constraint =
+  | Tmodtype_implicit
+  (** The module type constraint has been synthesized during typechecking. *)
+  | Tmodtype_explicit of module_type
+  (** The module type was in the source file. *)
+
+and functor_parameter =
+  | Unit
+  | Named of Ident.t option * string option loc * module_type
+
+and module_expr_desc =
+    Tmod_ident of Path.t * Longident.t loc
+  | Tmod_structure of structure
+  | Tmod_functor of functor_parameter * module_expr
+  | Tmod_apply of module_expr * module_expr * module_coercion
+  | Tmod_constraint of
+      module_expr * Types.module_type * module_type_constraint * module_coercion
+    (** ME          (constraint = Tmodtype_implicit)
+        (ME : MT)   (constraint = Tmodtype_explicit MT)
+     *)
+  | Tmod_unpack of expression * Types.module_type
+
+and structure = {
+  str_items : structure_item list;
+  str_type : Types.signature;
+  str_final_env : Env.t;
+}
+
+and structure_item =
+  { str_desc : structure_item_desc;
+    str_loc : Location.t;
+    str_env : Env.t
+  }
+
+and structure_item_desc =
+    Tstr_eval of expression * attributes
+  | Tstr_value of rec_flag * value_binding list
+  | Tstr_primitive of value_description
+  | Tstr_type of rec_flag * type_declaration list
+  | Tstr_typext of type_extension
+  | Tstr_exception of type_exception
+  | Tstr_module of module_binding
+  | Tstr_recmodule of module_binding list
+  | Tstr_modtype of module_type_declaration
+  | Tstr_open of open_declaration
+  | Tstr_class of (class_declaration * string list) list
+  | Tstr_class_type of (Ident.t * string loc * class_type_declaration) list
+  | Tstr_include of include_declaration
+  | Tstr_attribute of attribute
+
+and module_binding =
+    {
+     mb_id: Ident.t option;
+     mb_name: string option loc;
+     mb_presence: module_presence;
+     mb_expr: module_expr;
+     mb_attributes: attributes;
+     mb_loc: Location.t;
+    }
+
+and value_binding =
+  {
+    vb_pat: pattern;
+    vb_expr: expression;
+    vb_attributes: attributes;
+    vb_loc: Location.t;
+  }
+
+and module_coercion =
+    Tcoerce_none
+  | Tcoerce_structure of (int * module_coercion) list *
+                         (Ident.t * int * module_coercion) list
+  | Tcoerce_functor of module_coercion * module_coercion
+  | Tcoerce_primitive of primitive_coercion
+  | Tcoerce_alias of Env.t * Path.t * module_coercion
+
+and module_type =
+  { mty_desc: module_type_desc;
+    mty_type : Types.module_type;
+    mty_env : Env.t;
+    mty_loc: Location.t;
+    mty_attributes: attributes;
+   }
+
+and module_type_desc =
+    Tmty_ident of Path.t * Longident.t loc
+  | Tmty_signature of signature
+  | Tmty_functor of functor_parameter * module_type
+  | Tmty_with of module_type * (Path.t * Longident.t loc * with_constraint) list
+  | Tmty_typeof of module_expr
+  | Tmty_alias of Path.t * Longident.t loc
+
+and primitive_coercion =
+  {
+    pc_desc: Primitive.description;
+    pc_type: type_expr;
+    pc_env: Env.t;
+    pc_loc : Location.t;
+  }
+
+and signature = {
+  sig_items : signature_item list;
+  sig_type : Types.signature;
+  sig_final_env : Env.t;
+}
+
+and signature_item =
+  { sig_desc: signature_item_desc;
+    sig_env : Env.t; (* BINANNOT ADDED *)
+    sig_loc: Location.t }
+
+and signature_item_desc =
+    Tsig_value of value_description
+  | Tsig_type of rec_flag * type_declaration list
+  | Tsig_typesubst of type_declaration list
+  | Tsig_typext of type_extension
+  | Tsig_exception of type_exception
+  | Tsig_module of module_declaration
+  | Tsig_modsubst of module_substitution
+  | Tsig_recmodule of module_declaration list
+  | Tsig_modtype of module_type_declaration
+  | Tsig_open of open_description
+  | Tsig_include of include_description
+  | Tsig_class of class_description list
+  | Tsig_class_type of class_type_declaration list
+  | Tsig_attribute of attribute
+
+and module_declaration =
+    {
+     md_id: Ident.t option;
+     md_name: string option loc;
+     md_presence: module_presence;
+     md_type: module_type;
+     md_attributes: attributes;
+     md_loc: Location.t;
+    }
+
+and module_substitution =
+    {
+     ms_id: Ident.t;
+     ms_name: string loc;
+     ms_manifest: Path.t;
+     ms_txt: Longident.t loc;
+     ms_attributes: attributes;
+     ms_loc: Location.t;
+    }
+
+and module_type_declaration =
+    {
+     mtd_id: Ident.t;
+     mtd_name: string loc;
+     mtd_type: module_type option;
+     mtd_attributes: attributes;
+     mtd_loc: Location.t;
+    }
+
+and 'a open_infos =
+    {
+     open_expr: 'a;
+     open_bound_items: Types.signature;
+     open_override: override_flag;
+     open_env: Env.t;
+     open_loc: Location.t;
+     open_attributes: attribute list;
+    }
+
+and open_description = (Path.t * Longident.t loc) open_infos
+
+and open_declaration = module_expr open_infos
+
+
+and 'a include_infos =
+    {
+     incl_mod: 'a;
+     incl_type: Types.signature;
+     incl_loc: Location.t;
+     incl_attributes: attribute list;
+    }
+
+and include_description = module_type include_infos
+
+and include_declaration = module_expr include_infos
+
+and with_constraint =
+    Twith_type of type_declaration
+  | Twith_module of Path.t * Longident.t loc
+  | Twith_typesubst of type_declaration
+  | Twith_modsubst of Path.t * Longident.t loc
+
+and core_type =
+  { mutable ctyp_desc : core_type_desc;
+      (** mutable because of [Typeclass.declare_method] *)
+    mutable ctyp_type : type_expr;
+      (** mutable because of [Typeclass.declare_method] *)
+    ctyp_env : Env.t; (* BINANNOT ADDED *)
+    ctyp_loc : Location.t;
+    ctyp_attributes: attributes;
+   }
+
+and core_type_desc =
+    Ttyp_any
+  | Ttyp_var of string
+  | Ttyp_arrow of arg_label * core_type * core_type
+  | Ttyp_tuple of core_type list
+  | Ttyp_constr of Path.t * Longident.t loc * core_type list
+  | Ttyp_object of object_field list * closed_flag
+  | Ttyp_class of Path.t * Longident.t loc * core_type list
+  | Ttyp_alias of core_type * string
+  | Ttyp_variant of row_field list * closed_flag * label list option
+  | Ttyp_poly of string list * core_type
+  | Ttyp_package of package_type
+
+and package_type = {
+  pack_path : Path.t;
+  pack_fields : (Longident.t loc * core_type) list;
+  pack_type : Types.module_type;
+  pack_txt : Longident.t loc;
+}
+
+and row_field = {
+  rf_desc : row_field_desc;
+  rf_loc : Location.t;
+  rf_attributes : attributes;
+}
+
+and row_field_desc =
+    Ttag of string loc * bool * core_type list
+  | Tinherit of core_type
+
+and object_field = {
+  of_desc : object_field_desc;
+  of_loc : Location.t;
+  of_attributes : attributes;
+}
+
+and object_field_desc =
+  | OTtag of string loc * core_type
+  | OTinherit of core_type
+
+and value_description =
+  { val_id: Ident.t;
+    val_name: string loc;
+    val_desc: core_type;
+    val_val: Types.value_description;
+    val_prim: string list;
+    val_loc: Location.t;
+    val_attributes: attributes;
+    }
+
+and type_declaration =
+  {
+    typ_id: Ident.t;
+    typ_name: string loc;
+    typ_params: (core_type * variance) list;
+    typ_type: Types.type_declaration;
+    typ_cstrs: (core_type * core_type * Location.t) list;
+    typ_kind: type_kind;
+    typ_private: private_flag;
+    typ_manifest: core_type option;
+    typ_loc: Location.t;
+    typ_attributes: attributes;
+   }
+
+and type_kind =
+    Ttype_abstract
+  | Ttype_variant of constructor_declaration list
+  | Ttype_record of label_declaration list
+  | Ttype_open
+
+and label_declaration =
+    {
+     ld_id: Ident.t;
+     ld_name: string loc;
+     ld_mutable: mutable_flag;
+     ld_type: core_type;
+     ld_loc: Location.t;
+     ld_attributes: attributes;
+    }
+
+and constructor_declaration =
+    {
+     cd_id: Ident.t;
+     cd_name: string loc;
+     cd_args: constructor_arguments;
+     cd_res: core_type option;
+     cd_loc: Location.t;
+     cd_attributes: attributes;
+    }
+
+and constructor_arguments =
+  | Cstr_tuple of core_type list
+  | Cstr_record of label_declaration list
+
+and type_extension =
+  {
+    tyext_path: Path.t;
+    tyext_txt: Longident.t loc;
+    tyext_params: (core_type * variance) list;
+    tyext_constructors: extension_constructor list;
+    tyext_private: private_flag;
+    tyext_loc: Location.t;
+    tyext_attributes: attributes;
+  }
+
+and type_exception =
+  {
+    tyexn_constructor: extension_constructor;
+    tyexn_loc: Location.t;
+    tyexn_attributes: attribute list;
+  }
+
+and extension_constructor =
+  {
+    ext_id: Ident.t;
+    ext_name: string loc;
+    ext_type : Types.extension_constructor;
+    ext_kind : extension_constructor_kind;
+    ext_loc : Location.t;
+    ext_attributes: attributes;
+  }
+
+and extension_constructor_kind =
+    Text_decl of constructor_arguments * core_type option
+  | Text_rebind of Path.t * Longident.t loc
+
+and class_type =
+    {
+     cltyp_desc: class_type_desc;
+     cltyp_type: Types.class_type;
+     cltyp_env: Env.t;
+     cltyp_loc: Location.t;
+     cltyp_attributes: attributes;
+    }
+
+and class_type_desc =
+    Tcty_constr of Path.t * Longident.t loc * core_type list
+  | Tcty_signature of class_signature
+  | Tcty_arrow of arg_label * core_type * class_type
+  | Tcty_open of open_description * class_type
+
+and class_signature = {
+    csig_self : core_type;
+    csig_fields : class_type_field list;
+    csig_type : Types.class_signature;
+  }
+
+and class_type_field = {
+    ctf_desc: class_type_field_desc;
+    ctf_loc: Location.t;
+    ctf_attributes: attributes;
+  }
+
+and class_type_field_desc =
+  | Tctf_inherit of class_type
+  | Tctf_val of (string * mutable_flag * virtual_flag * core_type)
+  | Tctf_method of (string * private_flag * virtual_flag * core_type)
+  | Tctf_constraint of (core_type * core_type)
+  | Tctf_attribute of attribute
+
+and class_declaration =
+  class_expr class_infos
+
+and class_description =
+  class_type class_infos
+
+and class_type_declaration =
+  class_type class_infos
+
+and 'a class_infos =
+  { ci_virt: virtual_flag;
+    ci_params: (core_type * variance) list;
+    ci_id_name : string loc;
+    ci_id_class: Ident.t;
+    ci_id_class_type : Ident.t;
+    ci_id_object : Ident.t;
+    ci_id_typehash : Ident.t;
+    ci_expr: 'a;
+    ci_decl: Types.class_declaration;
+    ci_type_decl : Types.class_type_declaration;
+    ci_loc: Location.t;
+    ci_attributes: attributes;
+   }
+
+(* Auxiliary functions over the a.s.t. *)
+
+val shallow_iter_pattern_desc:
+  (pattern -> unit) -> pattern_desc -> unit
+val shallow_map_pattern_desc:
+  (pattern -> pattern) -> pattern_desc -> pattern_desc
+
+val iter_pattern: (pattern -> unit) -> pattern -> unit
+val exists_pattern: (pattern -> bool) -> pattern -> bool
+
+val let_bound_idents: value_binding list -> Ident.t list
+val let_bound_idents_full:
+    value_binding list -> (Ident.t * string loc * type_expr) list
+
+(** Alpha conversion of patterns *)
+val alpha_pat: (Ident.t * Ident.t) list -> pattern -> pattern
+
+val mknoloc: 'a -> 'a Asttypes.loc
+val mkloc: 'a -> Location.t -> 'a Asttypes.loc
+
+val pat_bound_idents: pattern -> Ident.t list
+val pat_bound_idents_full:
+  pattern -> (Ident.t * string loc * type_expr) list
+val pat_bound_idents_with_loc: pattern -> (Ident.t * string loc) list
+
+(** Splits an or pattern into its value (left) and exception (right) parts. *)
+val split_pattern : pattern -> pattern option * pattern option
+
+(* Merlin specific *)
+
+val unpack_functor_me : module_expr -> functor_parameter * module_expr
+val unpack_functor_mty : module_type -> functor_parameter * module_type
diff --git a/src/ocaml/typing/410+multicore/typemod.ml b/src/ocaml/typing/410+multicore/typemod.ml
new file mode 100644
index 00000000..a4093555
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typemod.ml
@@ -0,0 +1,3042 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Misc
+open Longident
+open Path
+open Asttypes
+open Parsetree
+open Types
+open Format
+
+module Sig_component_kind = struct
+  type t =
+    | Value
+    | Type
+    | Module
+    | Module_type
+    | Extension_constructor
+    | Class
+    | Class_type
+
+  let to_string = function
+    | Value -> "value"
+    | Type -> "type"
+    | Module -> "module"
+    | Module_type -> "module type"
+    | Extension_constructor -> "extension constructor"
+    | Class -> "class"
+    | Class_type -> "class type"
+
+  (** Whether the name of a component of that kind can appear in a type. *)
+  let can_appear_in_types = function
+    | Value
+    | Extension_constructor ->
+        false
+    | Type
+    | Module
+    | Module_type
+    | Class
+    | Class_type ->
+        true
+end
+
+type hiding_error =
+  | Illegal_shadowing of {
+      shadowed_item_id: Ident.t;
+      shadowed_item_kind: Sig_component_kind.t;
+      shadowed_item_loc: Location.t;
+      shadower_id: Ident.t;
+      user_id: Ident.t;
+      user_kind: Sig_component_kind.t;
+      user_loc: Location.t;
+    }
+  | Appears_in_signature of {
+      opened_item_id: Ident.t;
+      opened_item_kind: Sig_component_kind.t;
+      user_id: Ident.t;
+      user_kind: Sig_component_kind.t;
+      user_loc: Location.t;
+    }
+
+type error =
+    Cannot_apply of module_type
+  | Not_included of Includemod.error list
+  | Cannot_eliminate_dependency of module_type
+  | Signature_expected
+  | Structure_expected of module_type
+  | With_no_component of Longident.t
+  | With_mismatch of Longident.t * Includemod.error list
+  | With_makes_applicative_functor_ill_typed of
+      Longident.t * Path.t * Includemod.error list
+  | With_changes_module_alias of Longident.t * Ident.t * Path.t
+  | With_cannot_remove_constrained_type
+  | Repeated_name of Sig_component_kind.t * string
+  | Non_generalizable of type_expr
+  | Non_generalizable_class of Ident.t * class_declaration
+  | Non_generalizable_module of module_type
+  | Implementation_is_required of string
+  | Interface_not_compiled of string
+  | Not_allowed_in_functor_body
+  | Not_a_packed_module of type_expr
+  | Incomplete_packed_module of type_expr
+  | Scoping_pack of Longident.t * type_expr
+  | Recursive_module_require_explicit_type
+  | Apply_generative
+  | Cannot_scrape_alias of Path.t
+  | Badly_formed_signature of string * Typedecl.error
+  | Cannot_hide_id of hiding_error
+  | Invalid_type_subst_rhs
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+open Typedtree
+
+let rec path_concat head p =
+  match p with
+    Pident tail -> Pdot (Pident head, Ident.name tail)
+  | Pdot (pre, s) -> Pdot (path_concat head pre, s)
+  | Papply _ -> assert false
+
+(* Extract a signature from a module type *)
+
+let extract_sig env loc mty =
+  match Env.scrape_alias env mty with
+    Mty_signature sg -> sg
+  | Mty_alias path ->
+      raise(Error(loc, env, Cannot_scrape_alias path))
+  | _ -> raise(Error(loc, env, Signature_expected))
+
+let extract_sig_open env loc mty =
+  match Env.scrape_alias env mty with
+    Mty_signature sg -> sg
+  | Mty_alias path ->
+      raise(Error(loc, env, Cannot_scrape_alias path))
+  | mty -> raise(Error(loc, env, Structure_expected mty))
+
+(* Compute the environment after opening a module *)
+
+let type_open_ ?used_slot ?toplevel ovf env loc lid =
+  let path = Env.lookup_module_path ~load:true ~loc:lid.loc lid.txt env in
+  match Env.open_signature ~loc ?used_slot ?toplevel ovf path env with
+  | Some env -> path, env
+  | None ->
+      let md = Env.find_module path env in
+      ignore (extract_sig_open env lid.loc md.md_type);
+      assert false
+
+let initial_env ~loc ~safe_string ~initially_opened_module
+    ~open_implicit_modules =
+  let env =
+    if safe_string then
+      Env.initial_safe_string
+    else
+      Env.initial_unsafe_string
+  in
+  let open_module env m =
+    let open Asttypes in
+    let lid = {loc; txt = Longident.parse m } in
+    try
+      snd (type_open_ Override env lid.loc lid)
+    with
+    | (Typetexp.Error _ | Env.Error _ | Magic_numbers.Cmi.Error _) as exn ->
+      Msupport.raise_error exn;
+      env
+    | exn ->
+      Printf.ksprintf failwith
+        "Uncaught exception %s in initial_env.open_module: %s"
+        Obj.Extension_constructor.(name (of_val exn))
+        (Printexc.to_string exn)
+  in
+  let add_units env units =
+    String.Set.fold
+      (fun name env ->
+         Env.add_persistent_structure (Ident.create_persistent name) env)
+      units
+      env
+  in
+  let units =
+    List.rev_map Env.persistent_structures_of_dir (Load_path.get ())
+  in
+  let env, units =
+    match initially_opened_module with
+    | None -> (env, units)
+    | Some m ->
+        (* Locate the directory that contains [m], adds the units it
+           contains to the environment and open [m] in the resulting
+           environment. *)
+        let rec loop before after =
+          match after with
+          | [] -> None
+          | units :: after ->
+              if String.Set.mem m units then
+                Some (units, List.rev_append before after)
+              else
+                loop (units :: before) after
+        in
+        let env, units =
+          match loop [] units with
+          | None ->
+              (env, units)
+          | Some (units_containing_m, other_units) ->
+              (add_units env units_containing_m, other_units)
+        in
+        (open_module env m, units)
+  in
+  let env = List.fold_left add_units env units in
+  List.fold_left open_module env open_implicit_modules
+
+let type_open_descr ?used_slot ?toplevel env sod =
+  let (path, newenv) =
+    Builtin_attributes.warning_scope sod.popen_attributes
+      (fun () ->
+         type_open_ ?used_slot ?toplevel sod.popen_override env sod.popen_loc
+           sod.popen_expr
+      )
+  in
+  let od =
+    {
+      open_expr = (path, sod.popen_expr);
+      open_bound_items = [];
+      open_override = sod.popen_override;
+      open_env = newenv;
+      open_attributes = sod.popen_attributes;
+      open_loc = sod.popen_loc;
+    }
+  in
+  (od, newenv)
+
+(* Record a module type *)
+let rm node =
+  Stypes.record (Stypes.Ti_mod node);
+  node
+
+(* Forward declaration, to be filled in by type_module_type_of *)
+let type_module_type_of_fwd :
+    (Env.t -> Parsetree.module_expr ->
+      Typedtree.module_expr * Types.module_type) ref
+  = ref (fun _env _m -> assert false)
+
+(* Additional validity checks on type definitions arising from
+   recursive modules *)
+
+let check_recmod_typedecls env decls =
+  let recmod_ids = List.map fst decls in
+  List.iter
+    (fun (id, md) ->
+      List.iter
+        (fun path ->
+          Typedecl.check_recmod_typedecl env md.Types.md_loc recmod_ids
+                                         path (Env.find_type path env))
+        (Mtype.type_paths env (Pident id) md.Types.md_type))
+    decls
+
+(* Merge one "with" constraint in a signature *)
+
+let rec add_rec_types env = function
+    Sig_type(id, decl, Trec_next, _) :: rem ->
+      add_rec_types (Env.add_type ~check:true id decl env) rem
+  | _ -> env
+
+let check_type_decl env loc id row_id newdecl decl rs rem =
+  let env = Env.add_type ~check:true id newdecl env in
+  let env =
+    match row_id with
+    | None -> env
+    | Some id -> Env.add_type ~check:false id newdecl env
+  in
+  let env = if rs = Trec_not then env else add_rec_types env rem in
+  Includemod.type_declarations ~loc env id newdecl decl;
+  Typedecl.check_coherence env loc (Path.Pident id) newdecl
+
+let update_rec_next rs rem =
+  match rs with
+    Trec_next -> rem
+  | Trec_first | Trec_not ->
+      match rem with
+        Sig_type (id, decl, Trec_next, priv) :: rem ->
+          Sig_type (id, decl, rs, priv) :: rem
+      | Sig_module (id, pres, mty, Trec_next, priv) :: rem ->
+          Sig_module (id, pres, mty, rs, priv) :: rem
+      | _ -> rem
+
+let make_variance p n i =
+  let open Variance in
+  set May_pos p (set May_neg n (set May_weak n (set Inj i null)))
+
+let rec iter_path_apply p ~f =
+  match p with
+  | Pident _ -> ()
+  | Pdot (p, _) -> iter_path_apply p ~f
+  | Papply (p1, p2) ->
+     iter_path_apply p1 ~f;
+     iter_path_apply p2 ~f;
+     f p1 p2 (* after recursing, so we know both paths are well typed *)
+
+let path_is_strict_prefix =
+  let rec list_is_strict_prefix l ~prefix =
+    match l, prefix with
+    | [], [] -> false
+    | _ :: _, [] -> true
+    | [], _ :: _ -> false
+    | s1 :: t1, s2 :: t2 ->
+       String.equal s1 s2 && list_is_strict_prefix t1 ~prefix:t2
+  in
+  fun path ~prefix ->
+    match Path.flatten path, Path.flatten prefix with
+    | `Contains_apply, _ | _, `Contains_apply -> false
+    | `Ok (ident1, l1), `Ok (ident2, l2) ->
+       Ident.same ident1 ident2
+       && list_is_strict_prefix l1 ~prefix:l2
+
+let iterator_with_env env =
+  let env = ref (lazy env) in
+  let super = Btype.type_iterators in
+  env, { super with
+    Btype.it_signature = (fun self sg ->
+      (* add all items to the env before recursing down, to handle recursive
+         definitions *)
+      let env_before = !env in
+      env := lazy (Env.add_signature sg (Lazy.force env_before));
+      super.Btype.it_signature self sg;
+      env := env_before
+    );
+    Btype.it_module_type = (fun self -> function
+    | Mty_functor (param, mty_body) ->
+      let env_before = !env in
+      begin match param with
+      | Unit -> ()
+      | Named (param, mty_arg) ->
+        self.Btype.it_module_type self mty_arg;
+        match param with
+        | None -> ()
+        | Some id ->
+          env := lazy (Env.add_module ~arg:true id Mp_present
+                       mty_arg (Lazy.force env_before))
+      end;
+      self.Btype.it_module_type self mty_body;
+      env := env_before;
+    | mty ->
+      super.Btype.it_module_type self mty
+    )
+  }
+
+let retype_applicative_functor_type ~loc env funct arg =
+  let mty_functor = (Env.find_module funct env).md_type in
+  let mty_arg = (Env.find_module arg env).md_type in
+  let mty_param =
+    match Env.scrape_alias env mty_functor with
+    | Mty_functor (Named (_, mty_param), _) -> mty_param
+    | _ -> assert false (* could trigger due to MPR#7611 *)
+  in
+  Includemod.check_modtype_inclusion ~loc env mty_arg arg mty_param
+
+(* When doing a deep destructive substitution with type M.N.t := .., we change M
+   and M.N and so we have to check that uses of the modules other than just
+   extracting components from them still make sense. There are only two such
+   kinds of uses:
+   - applicative functor types: F(M).t might not be well typed anymore
+   - aliases: module A = M still makes sense but it doesn't mean the same thing
+     anymore, so it's forbidden until it's clear what we should do with it.
+   This function would be called with M.N.t and N.t to check for these uses. *)
+let check_usage_of_path_of_substituted_item paths env signature ~loc ~lid =
+  let iterator =
+    let env, super = iterator_with_env env in
+    { super with
+      Btype.it_signature_item = (fun self -> function
+      | Sig_module (id, _, { md_type = Mty_alias aliased_path; _ }, _, _)
+        when List.exists
+               (fun path -> path_is_strict_prefix path ~prefix:aliased_path)
+               paths
+        ->
+         let e = With_changes_module_alias (lid.txt, id, aliased_path) in
+         raise(Error(loc, Lazy.force !env, e))
+      | sig_item ->
+         super.Btype.it_signature_item self sig_item
+      );
+      Btype.it_path = (fun referenced_path ->
+        iter_path_apply referenced_path ~f:(fun funct arg ->
+          if List.exists
+               (fun path -> path_is_strict_prefix path ~prefix:arg)
+               paths
+          then
+            let env = Lazy.force !env in
+            try retype_applicative_functor_type ~loc env funct arg
+            with Includemod.Error explanation ->
+              raise(Error(loc, env,
+                          With_makes_applicative_functor_ill_typed
+                            (lid.txt, referenced_path, explanation)))
+        )
+      );
+    }
+  in
+  iterator.Btype.it_signature iterator signature;
+  Btype.unmark_iterators.Btype.it_signature Btype.unmark_iterators signature
+
+(* After substitution one also needs to re-check the well-foundedness
+   of type declarations in recursive modules *)
+let rec extract_next_modules = function
+  | Sig_module (id, _, mty, Trec_next, _) :: rem ->
+      let (id_mty_l, rem) = extract_next_modules rem in
+      ((id, mty) :: id_mty_l, rem)
+  | sg -> ([], sg)
+
+let check_well_formed_module env loc context mty =
+  (* Format.eprintf "@[check_well_formed_module@ %a@]@."
+     Printtyp.modtype mty; *)
+  let open Btype in
+  let iterator =
+    let rec check_signature env = function
+      | [] -> ()
+      | Sig_module (id, _, mty, Trec_first, _) :: rem ->
+          let (id_mty_l, rem) = extract_next_modules rem in
+          begin try
+            check_recmod_typedecls (Lazy.force env) ((id, mty) :: id_mty_l)
+          with Typedecl.Error (_, err) ->
+            raise (Error (loc, Lazy.force env,
+                          Badly_formed_signature(context, err)))
+          end;
+          check_signature env rem
+      | _ :: rem ->
+          check_signature env rem
+    in
+    let env, super = iterator_with_env env in
+    { super with
+      it_type_expr = (fun _self _ty -> ());
+      it_signature = (fun self sg ->
+        let env_before = !env in
+        let env = lazy (Env.add_signature sg (Lazy.force env_before)) in
+        check_signature env sg;
+        super.it_signature self sg);
+    }
+  in
+  iterator.it_module_type iterator mty
+
+let () = Env.check_well_formed_module := check_well_formed_module
+
+let type_decl_is_alias sdecl = (* assuming no explicit constraint *)
+  match sdecl.ptype_manifest with
+  | Some {ptyp_desc = Ptyp_constr (lid, stl)}
+       when List.length stl = List.length sdecl.ptype_params ->
+     begin
+       match
+         List.iter2 (fun x (y, _) ->
+             match x, y with
+               {ptyp_desc=Ptyp_var sx}, {ptyp_desc=Ptyp_var sy}
+                  when sx = sy -> ()
+             | _, _ -> raise Exit)
+           stl sdecl.ptype_params;
+       with
+       | exception Exit -> None
+       | () -> Some lid
+     end
+  | _ -> None
+;;
+
+let params_are_constrained =
+  let rec loop = function
+    | [] -> false
+    | hd :: tl ->
+       match (Btype.repr hd).desc with
+       | Tvar _ -> List.memq hd tl || loop tl
+       | _ -> true
+  in
+  loop
+;;
+
+let merge_constraint initial_env remove_aliases loc sg constr =
+  let lid =
+    match constr with
+    | Pwith_type (lid, _) | Pwith_module (lid, _)
+    | Pwith_typesubst (lid, _) | Pwith_modsubst (lid, _) -> lid
+  in
+  let destructive_substitution =
+    match constr with
+    | Pwith_type _ | Pwith_module _ -> false
+    | Pwith_typesubst _ | Pwith_modsubst _ -> true
+  in
+  let real_ids = ref [] in
+  let rec merge env sg namelist row_id =
+    match (sg, namelist, constr) with
+      ([], _, _) ->
+        raise(Error(loc, env, With_no_component lid.txt))
+    | (Sig_type(id, decl, rs, priv) :: rem, [s],
+       Pwith_type (_, ({ptype_kind = Ptype_abstract} as sdecl)))
+      when Ident.name id = s && Typedecl.is_fixed_type sdecl ->
+        let decl_row =
+          { type_params =
+              List.map (fun _ -> Btype.newgenvar()) sdecl.ptype_params;
+            type_arity = List.length sdecl.ptype_params;
+            type_kind = Type_abstract;
+            type_private = Private;
+            type_manifest = None;
+            type_variance =
+              List.map
+                (fun (_, v) ->
+                   let (c, n) =
+                     match v with
+                     | Covariant -> true, false
+                     | Contravariant -> false, true
+                     | Invariant -> false, false
+                   in
+                   make_variance (not n) (not c) false
+                )
+                sdecl.ptype_params;
+            type_loc = sdecl.ptype_loc;
+            type_is_newtype = false;
+            type_expansion_scope = Btype.lowest_level;
+            type_attributes = [];
+            type_immediate = Unknown;
+            type_unboxed = unboxed_false_default_false;
+          }
+        and id_row = Ident.create_local (s^"#row") in
+        let initial_env =
+          Env.add_type ~check:false id_row decl_row initial_env
+        in
+        let tdecl = Typedecl.transl_with_constraint
+                        initial_env id (Some(Pident id_row)) decl sdecl in
+        let newdecl = tdecl.typ_type in
+        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
+        let decl_row = {decl_row with type_params = newdecl.type_params} in
+        let rs' = if rs = Trec_first then Trec_not else rs in
+        (Pident id, lid, Twith_type tdecl),
+        Sig_type(id_row, decl_row, rs', priv)
+        :: Sig_type(id, newdecl, rs, priv)
+        :: rem
+    | (Sig_type(id, decl, rs, priv) :: rem , [s], Pwith_type (_, sdecl))
+      when Ident.name id = s ->
+        let tdecl =
+          Typedecl.transl_with_constraint initial_env id None decl sdecl in
+        let newdecl = tdecl.typ_type in
+        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
+        (Pident id, lid, Twith_type tdecl),
+        Sig_type(id, newdecl, rs, priv) :: rem
+    | (Sig_type(id, _, _, _) :: rem, [s], (Pwith_type _ | Pwith_typesubst _))
+      when Ident.name id = s ^ "#row" ->
+        merge env rem namelist (Some id)
+    | (Sig_type(id, decl, rs, _priv) :: rem, [s], Pwith_typesubst (_, sdecl))
+      when Ident.name id = s ->
+        (* Check as for a normal with constraint, but discard definition *)
+        let tdecl =
+          Typedecl.transl_with_constraint initial_env id None decl sdecl in
+        let newdecl = tdecl.typ_type in
+        check_type_decl env sdecl.ptype_loc id row_id newdecl decl rs rem;
+        real_ids := [Pident id];
+        (Pident id, lid, Twith_typesubst tdecl),
+        update_rec_next rs rem
+    | (Sig_module(id, pres, md, rs, priv) :: rem, [s], Pwith_module (_, lid'))
+      when Ident.name id = s ->
+        let path, md' = Env.lookup_module ~loc lid'.txt initial_env in
+        let mty = md'.md_type in
+        let mty = Mtype.scrape_for_type_of ~remove_aliases env mty in
+        let md'' = { md' with md_type = mty } in
+        let newmd = Mtype.strengthen_decl ~aliasable:false env md'' path in
+        ignore(Includemod.modtypes ~loc env newmd.md_type md.md_type);
+        (Pident id, lid, Twith_module (path, lid')),
+        Sig_module(id, pres, newmd, rs, priv) :: rem
+    | (Sig_module(id, _, md, rs, _) :: rem, [s], Pwith_modsubst (_, lid'))
+      when Ident.name id = s ->
+        let path, md' = Env.lookup_module ~loc lid'.txt initial_env in
+        let aliasable = not (Env.is_functor_arg path env) in
+        let newmd = Mtype.strengthen_decl ~aliasable env md' path in
+        ignore(Includemod.modtypes ~loc env newmd.md_type md.md_type);
+        real_ids := [Pident id];
+        (Pident id, lid, Twith_modsubst (path, lid')),
+        update_rec_next rs rem
+    | (Sig_module(id, _, ({md_type = Mty_alias _} as md), _, _) as item :: rem,
+       s :: namelist, (Pwith_module _ | Pwith_type _))
+      when Ident.name id = s ->
+        let ((path, _, tcstr), _) =
+          merge env (extract_sig env loc md.md_type) namelist None
+        in
+        let path = path_concat id path in
+        real_ids := path :: !real_ids;
+        (path, lid, tcstr), item :: rem
+    | (Sig_module(id, _, md, rs, priv) :: rem, s :: namelist, _)
+      when Ident.name id = s ->
+        let ((path, _path_loc, tcstr), newsg) =
+          merge env (extract_sig env loc md.md_type) namelist None
+        in
+        let path = path_concat id path in
+        real_ids := path :: !real_ids;
+        let newmd = {md with md_type=Mty_signature newsg} in
+        let item = Sig_module(id, Mp_present, newmd, rs, priv) in
+        (path, lid, tcstr),
+        item :: rem
+    | (item :: rem, _, _) ->
+        let (cstr, items) = merge (Env.add_item item env) rem namelist row_id
+        in
+        cstr, item :: items
+  in
+  try
+    let names = Longident.flatten lid.txt in
+    let (tcstr, sg) = merge initial_env sg names None in
+    if destructive_substitution then (
+      match List.rev !real_ids with
+      | [] -> assert false
+      | last :: rest ->
+        (* The last item is the one that's removed. We don't need to check how
+           it's used since it's replaced by a more specific type/module. *)
+        assert (match last with Pident _ -> true | _ -> false);
+        match rest with
+        | [] -> ()
+        | _ :: _ ->
+          check_usage_of_path_of_substituted_item
+            rest initial_env sg ~loc ~lid;
+    );
+    let sg =
+    match tcstr with
+    | (_, _, Twith_typesubst tdecl) ->
+       let how_to_extend_subst =
+         let sdecl =
+           match constr with
+           | Pwith_typesubst (_, sdecl) -> sdecl
+           | _ -> assert false
+         in
+         match type_decl_is_alias sdecl with
+         | Some lid ->
+            let replacement, _ =
+              try Env.find_type_by_name lid.txt initial_env
+              with Not_found -> assert false
+            in
+            fun s path -> Subst.add_type_path path replacement s
+         | None ->
+            let body = Option.get tdecl.typ_type.type_manifest in
+            let params = tdecl.typ_type.type_params in
+            if params_are_constrained params
+            then raise(Error(loc, initial_env,
+                             With_cannot_remove_constrained_type));
+            fun s path -> Subst.add_type_function path ~params ~body s
+       in
+       let sub = List.fold_left how_to_extend_subst Subst.identity !real_ids in
+       (* This signature will not be used directly, it will always be freshened
+          by the caller. So what we do with the scope doesn't really matter. But
+          making it local makes it unlikely that we will ever use the result of
+          this function unfreshened without issue. *)
+       Subst.signature Make_local sub sg
+    | (_, _, Twith_modsubst (real_path, _)) ->
+       let sub =
+         List.fold_left
+           (fun s path -> Subst.add_module_path path real_path s)
+           Subst.identity
+           !real_ids
+       in
+       (* See explanation in the [Twith_typesubst] case above. *)
+       Subst.signature Make_local sub sg
+    | _ ->
+       sg
+    in
+    check_well_formed_module initial_env loc "this instantiated signature"
+      (Mty_signature sg);
+    (tcstr, sg)
+  with Includemod.Error explanation ->
+    raise(Error(loc, initial_env, With_mismatch(lid.txt, explanation)))
+
+(* Add recursion flags on declarations arising from a mutually recursive
+   block. *)
+
+let map_rec fn decls rem =
+  match decls with
+  | [] -> rem
+  | d1 :: dl -> fn Trec_first d1 :: map_end (fn Trec_next) dl rem
+
+let map_rec_type ~rec_flag fn decls rem =
+  match decls with
+  | [] -> rem
+  | d1 :: dl ->
+      let first =
+        match rec_flag with
+        | Recursive -> Trec_first
+        | Nonrecursive -> Trec_not
+      in
+      fn first d1 :: map_end (fn Trec_next) dl rem
+
+let rec map_rec_type_with_row_types ~rec_flag fn decls rem =
+  match decls with
+  | [] -> rem
+  | d1 :: dl ->
+      if Btype.is_row_name (Ident.name d1.typ_id) then
+        fn Trec_not d1 :: map_rec_type_with_row_types ~rec_flag fn dl rem
+      else
+        map_rec_type ~rec_flag fn decls rem
+
+(* Add type extension flags to extension constructors *)
+let map_ext fn exts rem =
+  match exts with
+  | [] -> rem
+  | d1 :: dl -> fn Text_first d1 :: map_end (fn Text_next) dl rem
+
+(* Auxiliary for translating recursively-defined module types.
+   Return a module type that approximates the shape of the given module
+   type AST.  Retain only module, type, and module type
+   components of signatures.  For types, retain only their arity,
+   making them abstract otherwise. *)
+
+let rec approx_modtype env smty =
+  match smty.pmty_desc with
+    Pmty_ident lid ->
+      let (path, _info) =
+        Env.lookup_modtype ~use:false ~loc:smty.pmty_loc lid.txt env
+      in
+      Mty_ident path
+  | Pmty_alias lid ->
+      let path =
+        Env.lookup_module_path ~use:false ~load:false
+          ~loc:smty.pmty_loc lid.txt env
+      in
+      Mty_alias(path)
+  | Pmty_signature ssg ->
+      Mty_signature(approx_sig env ssg)
+  | Pmty_functor(param, sres) ->
+      let (param, newenv) =
+        match param with
+        | Unit -> Types.Unit, env
+        | Named (param, sarg) ->
+          let arg = approx_modtype env sarg in
+          match param.txt with
+          | None -> Types.Named (None, arg), env
+          | Some name ->
+            let rarg = Mtype.scrape_for_functor_arg env arg in
+            let scope = Ctype.create_scope () in
+            let (id, newenv) =
+              Env.enter_module ~scope ~arg:true name Mp_present rarg env
+            in
+            Types.Named (Some id, arg), newenv
+      in
+      let res = approx_modtype newenv sres in
+      Mty_functor(param, res)
+  | Pmty_with(sbody, constraints) ->
+      let body = approx_modtype env sbody in
+      List.iter
+        (fun sdecl ->
+          match sdecl with
+          | Pwith_type _ -> ()
+          | Pwith_typesubst _ -> ()
+          | Pwith_module (_, lid') ->
+              (* Lookup the module to make sure that it is not recursive.
+                 (GPR#1626) *)
+              ignore (Env.lookup_module ~use:false ~loc:lid'.loc lid'.txt env)
+          | Pwith_modsubst (_, lid') ->
+              ignore (Env.lookup_module ~use:false ~loc:lid'.loc lid'.txt env))
+        constraints;
+      body
+  | Pmty_typeof smod ->
+      let (_, mty) = !type_module_type_of_fwd env smod in
+      mty
+  | Pmty_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+and approx_module_declaration env pmd =
+  {
+    Types.md_type = approx_modtype env pmd.pmd_type;
+    md_attributes = pmd.pmd_attributes;
+    md_loc = pmd.pmd_loc;
+  }
+
+and approx_sig env ssg =
+  match ssg with
+    [] -> []
+  | item :: srem ->
+      match item.psig_desc with
+      | Psig_type (rec_flag, sdecls) ->
+          let decls = Typedecl.approx_type_decl sdecls in
+          let rem = approx_sig env srem in
+          map_rec_type ~rec_flag
+            (fun rs (id, info) -> Sig_type(id, info, rs, Exported)) decls rem
+      | Psig_typesubst _ -> approx_sig env srem
+      | Psig_module { pmd_name = { txt = None; _ }; _ } ->
+          approx_sig env srem
+      | Psig_module pmd ->
+          let scope = Ctype.create_scope () in
+          let md = approx_module_declaration env pmd in
+          let pres =
+            match md.Types.md_type with
+            | Mty_alias _ -> Mp_absent
+            | _ -> Mp_present
+          in
+          let id, newenv =
+            Env.enter_module_declaration ~scope (Option.get pmd.pmd_name.txt)
+              pres md env
+          in
+          Sig_module(id, pres, md, Trec_not, Exported) :: approx_sig newenv srem
+      | Psig_modsubst pms ->
+          let scope = Ctype.create_scope () in
+          let _, md =
+            Env.lookup_module ~use:false ~loc:pms.pms_manifest.loc
+               pms.pms_manifest.txt env
+          in
+          let pres =
+            match md.Types.md_type with
+            | Mty_alias _ -> Mp_absent
+            | _ -> Mp_present
+          in
+          let _, newenv =
+            Env.enter_module_declaration ~scope pms.pms_name.txt pres md env
+          in
+          approx_sig newenv srem
+      | Psig_recmodule sdecls ->
+          let scope = Ctype.create_scope () in
+          let decls =
+            List.filter_map
+              (fun pmd ->
+                 Option.map (fun name ->
+                   Ident.create_scoped ~scope name,
+                   approx_module_declaration env pmd
+                 ) pmd.pmd_name.txt
+              )
+              sdecls
+          in
+          let newenv =
+            List.fold_left
+              (fun env (id, md) -> Env.add_module_declaration ~check:false
+                  id Mp_present md env)
+              env decls
+          in
+          map_rec
+            (fun rs (id, md) -> Sig_module(id, Mp_present, md, rs, Exported))
+            decls
+            (approx_sig newenv srem)
+      | Psig_modtype d ->
+          let info = approx_modtype_info env d in
+          let scope = Ctype.create_scope () in
+          let (id, newenv) =
+            Env.enter_modtype ~scope d.pmtd_name.txt info env
+          in
+          Sig_modtype(id, info, Exported) :: approx_sig newenv srem
+      | Psig_open sod ->
+          let _, env = type_open_descr env sod in
+          approx_sig env srem
+      | Psig_include sincl ->
+          let smty = sincl.pincl_mod in
+          let mty = approx_modtype env smty in
+          let scope = Ctype.create_scope () in
+          let sg, newenv = Env.enter_signature ~scope
+              (extract_sig env smty.pmty_loc mty) env in
+          sg @ approx_sig newenv srem
+      | Psig_class sdecls | Psig_class_type sdecls ->
+          let decls = Typeclass.approx_class_declarations env sdecls in
+          let rem = approx_sig env srem in
+          map_rec (fun rs decl ->
+            let open Typeclass in [
+              Sig_class_type(decl.clsty_ty_id, decl.clsty_ty_decl, rs,
+                             Exported);
+              Sig_type(decl.clsty_obj_id, decl.clsty_obj_abbr, rs, Exported);
+              Sig_type(decl.clsty_typesharp_id, decl.clsty_abbr, rs, Exported);
+            ]
+          ) decls [rem]
+          |> List.flatten
+      | _ ->
+          approx_sig env srem
+
+and approx_modtype_info env sinfo =
+  {
+   mtd_type = Option.map (approx_modtype env) sinfo.pmtd_type;
+   mtd_attributes = sinfo.pmtd_attributes;
+   mtd_loc = sinfo.pmtd_loc;
+  }
+
+let approx_modtype env smty =
+  Warnings.without_warnings
+    (fun () -> approx_modtype env smty)
+
+(* Auxiliaries for checking the validity of name shadowing in signatures and
+   structures.
+   If a shadowing is valid, we also record some information (its ident,
+   location where it first appears, etc) about the item that gets shadowed. *)
+module Signature_names : sig
+  type t
+
+  type info = [
+    | `Exported
+    | `From_open
+    | `Shadowable of Ident.t * Location.t
+    | `Substituted_away of Subst.t
+  ]
+
+  val create : unit -> t
+
+  val check_value     : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_type      : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_typext    : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_module    : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_modtype   : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_class     : ?info:info -> t -> Location.t -> Ident.t -> unit
+  val check_class_type: ?info:info -> t -> Location.t -> Ident.t -> unit
+
+  val check_sig_item:
+    ?info:info -> t -> Location.t -> Types.signature_item -> unit
+
+  val simplify: Env.t -> t -> Types.signature -> Types.signature
+end = struct
+
+  type bound_info = [
+    | `Exported
+    | `Shadowable of Ident.t * Location.t
+  ]
+
+  type info = [
+    | `From_open
+    | `Substituted_away of Subst.t
+    | bound_info
+  ]
+
+  type hide_reason =
+    | From_open
+    | Shadowed_by of Ident.t * Location.t
+
+  type to_be_removed = {
+    mutable subst: Subst.t;
+    mutable hide: (Sig_component_kind.t * Location.t * hide_reason) Ident.Map.t;
+  }
+
+  type names_infos = (string, bound_info) Hashtbl.t
+
+  type names = {
+    values: names_infos;
+    types: names_infos;
+    modules: names_infos;
+    modtypes: names_infos;
+    typexts: names_infos;
+    classes: names_infos;
+    class_types: names_infos;
+  }
+
+  let new_names () = {
+    values = Hashtbl.create 16;
+    types = Hashtbl.create 16;
+    modules = Hashtbl.create 16;
+    modtypes = Hashtbl.create 16;
+    typexts = Hashtbl.create 16;
+    classes = Hashtbl.create 16;
+    class_types = Hashtbl.create 16;
+  }
+
+  type t = {
+    bound: names;
+    to_be_removed: to_be_removed;
+  }
+
+  let create () = {
+    bound = new_names ();
+    to_be_removed = {
+      subst = Subst.identity;
+      hide = Ident.Map.empty;
+    };
+  }
+
+  let check cl loc (tbl : names_infos) id (info : info) to_be_removed =
+    match info with
+    | `Substituted_away s ->
+        to_be_removed.subst <- Subst.compose s to_be_removed.subst
+    | `From_open ->
+        to_be_removed.hide <-
+          Ident.Map.add id (cl, loc, From_open) to_be_removed.hide
+    | #bound_info as bound_info ->
+        let name = Ident.name id in
+        match Hashtbl.find_opt tbl name with
+        | None -> Hashtbl.add tbl name bound_info
+        | Some (`Shadowable (shadowed_id, shadowed_loc)) ->
+            Hashtbl.replace tbl name bound_info;
+            let reason = Shadowed_by (id, loc) in
+            to_be_removed.hide <-
+              Ident.Map.add shadowed_id (cl, shadowed_loc, reason)
+                to_be_removed.hide
+        | Some `Exported ->
+            raise(Error(loc, Env.empty, Repeated_name(cl, name)))
+
+  let check_value ?info t loc id =
+    let info =
+      match info with
+      | Some i -> i
+      | None -> `Shadowable (id, loc)
+    in
+    check Sig_component_kind.Value loc t.bound.values id info t.to_be_removed
+  let check_type ?(info=`Exported) t loc id =
+    check Sig_component_kind.Type loc t.bound.types id info t.to_be_removed
+  let check_module ?(info=`Exported) t loc id =
+    check Sig_component_kind.Module loc t.bound.modules id info t.to_be_removed
+  let check_modtype ?(info=`Exported) t loc id =
+    check Sig_component_kind.Module_type loc t.bound.modtypes id info
+      t.to_be_removed
+  let check_typext ?(info=`Exported) t loc id =
+    check Sig_component_kind.Extension_constructor loc t.bound.typexts id info
+      t.to_be_removed
+  let check_class ?(info=`Exported) t loc id =
+    check Sig_component_kind.Class loc t.bound.classes id info t.to_be_removed
+  let check_class_type ?(info=`Exported) t loc id =
+    check Sig_component_kind.Class_type loc t.bound.class_types id info
+      t.to_be_removed
+
+  let check_sig_item ?info names loc component =
+    let info id loc =
+      match info with
+      | None -> `Shadowable (id, loc)
+      | Some i -> i
+    in
+    match component with
+    | Sig_type(id, _, _, _) ->
+        check_type names loc id ~info:(info id loc)
+    | Sig_module(id, _, _, _, _) ->
+        check_module names loc id ~info:(info id loc)
+    | Sig_modtype(id, _, _) ->
+        check_modtype names loc id ~info:(info id loc)
+    | Sig_typext(id, _, _, _) ->
+        check_typext names loc id ~info:(info id loc)
+    | Sig_value (id, _, _) ->
+        check_value names loc id ~info:(info id loc)
+    | Sig_class (id, _, _, _) ->
+        check_class names loc id ~info:(info id loc)
+    | Sig_class_type (id, _, _, _) ->
+        check_class_type names loc id ~info:(info id loc)
+
+  (* We usually require name uniqueness of signature components (e.g. types,
+     modules, etc), however in some situation reusing the name is allowed: if
+     the component is a value or an extension, or if the name is introduced by
+     an include.
+     When there are multiple specifications of a component with the same name,
+     we try to keep only the last (rightmost) one, removing all references to
+     the previous ones from the signature.
+     If some reference cannot be removed, then we error out with
+     [Cannot_hide_id].
+  *)
+
+  let simplify env t sg =
+    let to_remove = t.to_be_removed in
+    let ids_to_remove =
+      Ident.Map.fold (fun id (kind,  _, _) lst ->
+        if Sig_component_kind.can_appear_in_types kind then
+          id :: lst
+        else
+          lst
+      ) to_remove.hide []
+    in
+    let aux component sg =
+      let user_kind, user_id, user_loc =
+        let open Sig_component_kind in
+        match component with
+        | Sig_value(id, v, _) -> Value, id, v.val_loc
+        | Sig_type (id, td, _, _) -> Type, id, td.type_loc
+        | Sig_typext (id, te, _, _) -> Extension_constructor, id, te.ext_loc
+        | Sig_module (id, _, md, _, _) -> Module, id, md.md_loc
+        | Sig_modtype (id, mtd, _) -> Module_type, id, mtd.mtd_loc
+        | Sig_class (id, c, _, _) -> Class, id, c.cty_loc
+        | Sig_class_type (id, ct, _, _) -> Class_type, id, ct.clty_loc
+      in
+      if Ident.Map.mem user_id to_remove.hide then
+        sg
+      else begin
+        let component =
+          if to_remove.subst == Subst.identity then
+            component
+          else
+            Subst.signature_item Keep to_remove.subst component
+        in
+        let component =
+          match ids_to_remove with
+          | [] -> component
+          | ids ->
+            try Mtype.nondep_sig_item env ids component with
+            | Ctype.Nondep_cannot_erase removed_item_id ->
+              let (removed_item_kind, removed_item_loc, reason) =
+                Ident.Map.find removed_item_id to_remove.hide
+              in
+              let err_loc, hiding_error =
+                match reason with
+                | From_open ->
+                  removed_item_loc,
+                  Appears_in_signature {
+                    opened_item_kind = removed_item_kind;
+                    opened_item_id = removed_item_id;
+                    user_id;
+                    user_kind;
+                    user_loc;
+                  }
+                | Shadowed_by (shadower_id, shadower_loc) ->
+                  shadower_loc,
+                  Illegal_shadowing {
+                    shadowed_item_kind = removed_item_kind;
+                    shadowed_item_id = removed_item_id;
+                    shadowed_item_loc = removed_item_loc;
+                    shadower_id;
+                    user_id;
+                    user_kind;
+                    user_loc;
+                  }
+              in
+              raise (Error(err_loc, env, Cannot_hide_id hiding_error))
+        in
+        component :: sg
+      end
+    in
+    List.fold_right aux sg []
+end
+
+let has_remove_aliases_attribute attr =
+  let remove_aliases =
+    Attr_helper.get_no_payload_attribute
+      ["remove_aliases"; "ocaml.remove_aliases"] attr
+  in
+  match remove_aliases with
+  | None -> false
+  | Some _ -> true
+
+(* Check and translate a module type expression *)
+
+let transl_modtype_longident loc env lid =
+  let (path, _info) = Env.lookup_modtype ~loc lid env in
+  path
+
+let transl_module_alias loc env lid =
+  Env.lookup_module_path ~load:false ~loc lid env
+
+let mkmty desc typ env loc attrs =
+  let mty = {
+    mty_desc = desc;
+    mty_type = typ;
+    mty_loc = loc;
+    mty_env = env;
+    mty_attributes = attrs;
+    } in
+  Cmt_format.add_saved_type (Cmt_format.Partial_module_type mty);
+  mty
+
+let mksig desc env loc =
+  let sg = { sig_desc = desc; sig_loc = loc; sig_env = env } in
+  Cmt_format.add_saved_type (Cmt_format.Partial_signature_item sg);
+  sg
+
+(* let signature sg = List.map (fun item -> item.sig_type) sg *)
+
+let rec transl_modtype env smty =
+  Builtin_attributes.warning_scope smty.pmty_attributes
+    (fun () -> transl_modtype_aux env smty)
+
+and transl_modtype_functor_arg env sarg =
+  let mty = transl_modtype env sarg in
+  {mty with mty_type = Mtype.scrape_for_functor_arg env mty.mty_type}
+
+and transl_modtype_aux env smty =
+  let loc = smty.pmty_loc in
+  match smty.pmty_desc with
+    Pmty_ident lid ->
+      let path = transl_modtype_longident loc env lid.txt in
+      mkmty (Tmty_ident (path, lid)) (Mty_ident path) env loc
+        smty.pmty_attributes
+  | Pmty_alias lid ->
+      let path = transl_module_alias loc env lid.txt in
+      mkmty (Tmty_alias (path, lid)) (Mty_alias path) env loc
+        smty.pmty_attributes
+  | Pmty_signature ssg ->
+      let sg = transl_signature env ssg in
+      mkmty (Tmty_signature sg) (Mty_signature sg.sig_type) env loc
+        smty.pmty_attributes
+  | Pmty_functor(sarg_opt, sres) ->
+      let t_arg, ty_arg, newenv =
+        match sarg_opt with
+        | Unit -> Unit, Types.Unit, env
+        | Named (param, sarg) ->
+          let arg = transl_modtype_functor_arg env sarg in
+          let (id, newenv) =
+            match param.txt with
+            | None -> None, env
+            | Some name ->
+              let scope = Ctype.create_scope () in
+              let id, newenv =
+                let arg_md =
+                  { md_type = arg.mty_type;
+                    md_attributes = [];
+                    md_loc = param.loc;
+                  }
+                in
+                Env.enter_module_declaration ~scope ~arg:true name Mp_present
+                  arg_md env
+              in
+              Some id, newenv
+          in
+          Named (id, param, arg), Types.Named (id, arg.mty_type), newenv
+      in
+      let res = transl_modtype newenv sres in
+      mkmty (Tmty_functor (t_arg, res))
+        (Mty_functor(ty_arg, res.mty_type)) env loc
+        smty.pmty_attributes
+  | Pmty_with(sbody, constraints) ->
+      let body = transl_modtype env sbody in
+      let init_sg = extract_sig env sbody.pmty_loc body.mty_type in
+      let remove_aliases = has_remove_aliases_attribute smty.pmty_attributes in
+      let (rev_tcstrs, final_sg) =
+        List.fold_left
+          (fun (rev_tcstrs,sg) sdecl ->
+            let (tcstr, sg) =
+              merge_constraint env remove_aliases smty.pmty_loc sg sdecl
+            in
+            (tcstr :: rev_tcstrs, sg)
+        )
+        ([],init_sg) constraints in
+      let scope = Ctype.create_scope () in
+      mkmty (Tmty_with ( body, List.rev rev_tcstrs))
+        (Mtype.freshen ~scope (Mty_signature final_sg)) env loc
+        smty.pmty_attributes
+  | Pmty_typeof smod ->
+      let env = Env.in_signature false env in
+      let tmty, mty = !type_module_type_of_fwd env smod in
+      mkmty (Tmty_typeof tmty) mty env loc smty.pmty_attributes
+  | Pmty_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+and transl_signature ?(keep_warnings = false) env sg =
+  let names = Signature_names.create () in
+  let rec transl_sig env sg =
+    match sg with
+      [] -> [], [], env
+    | item :: srem ->
+        let loc = item.psig_loc in
+        match item.psig_desc with
+        | Psig_value sdesc ->
+          begin match
+            let (tdesc, _) as res =
+              Typedecl.transl_value_decl env item.psig_loc sdesc
+            in
+            Signature_names.check_value names tdesc.val_loc tdesc.val_id;
+            res
+          with
+          | (tdesc, newenv) ->
+            let (trem,rem, final_env) = transl_sig newenv srem in
+            mksig (Tsig_value tdesc) env loc :: trem,
+            Sig_value(tdesc.val_id, tdesc.val_val, Exported) :: rem,
+              final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_type (rec_flag, sdecls) ->
+          begin match
+            let (decls, _) as res =
+              Typedecl.transl_type_decl env rec_flag sdecls
+            in
+            List.iter (fun td ->
+              Signature_names.check_type names td.typ_loc td.typ_id
+            ) decls;
+            res
+          with
+          | (decls, newenv) ->
+            let newenv = Env.update_short_paths newenv in
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            let sg =
+              map_rec_type_with_row_types ~rec_flag
+                (fun rs td -> Sig_type(td.typ_id, td.typ_type, rs, Exported))
+                decls rem
+            in
+            mksig (Tsig_type (rec_flag, decls)) env loc :: trem,
+            sg,
+            final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_typesubst sdecls ->
+            begin match
+              List.iter (fun td ->
+                if td.ptype_kind <> Ptype_abstract || td.ptype_manifest = None ||
+                  td.ptype_private = Private
+                then
+                  (* This error should be a parsing error,
+                    once we have nice error messages there. *)
+                  raise (Error (td.ptype_loc, env, Invalid_type_subst_rhs))
+              ) sdecls;
+              let (decls, _) as res =
+                Typedecl.transl_type_decl env Nonrecursive sdecls
+              in
+              List.iter (fun td ->
+                let info =
+                    let subst =
+                      Subst.add_type_function (Pident td.typ_id)
+                        ~params:td.typ_type.type_params
+                        ~body:(Option.get td.typ_type.type_manifest)
+                        Subst.identity
+                    in
+                    Some (`Substituted_away subst)
+                in
+                Signature_names.check_type ?info names td.typ_loc td.typ_id
+              ) decls;
+              res
+            with
+            | (decls, newenv) ->
+              let (trem, rem, final_env) = transl_sig newenv srem in
+              let sg = rem in
+              mksig (Tsig_typesubst decls) env loc :: trem,
+              sg,
+              final_env
+            | exception exn ->
+              Msupport.raise_error exn;
+              transl_sig env srem
+            end
+        | Psig_typext styext ->
+          begin match
+            let (tyext, _) as res =
+              Typedecl.transl_type_extension false env item.psig_loc styext
+            in
+            let constructors = tyext.tyext_constructors in
+            List.iter (fun ext ->
+              Signature_names.check_typext names ext.ext_loc ext.ext_id
+            ) constructors;
+            res, constructors
+          with
+          | (tyext, newenv), constructors ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+              mksig (Tsig_typext tyext) env loc :: trem,
+              map_ext (fun es ext ->
+                Sig_typext(ext.ext_id, ext.ext_type, es, Exported)
+              ) constructors rem,
+              final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_exception sext ->
+          begin match
+            let (ext, _) as res = Typedecl.transl_type_exception env sext in
+            let constructor = ext.tyexn_constructor in
+            Signature_names.check_typext names constructor.ext_loc
+              constructor.ext_id;
+            res, constructor
+          with
+          | (ext, newenv), constructor ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            mksig (Tsig_exception ext) env loc :: trem,
+            Sig_typext(constructor.ext_id,
+                       constructor.ext_type,
+                       Text_exception,
+                       Exported) :: rem,
+            final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_module pmd ->
+          let scope = Ctype.create_scope () in
+          begin match
+            let tmty =
+              Builtin_attributes.warning_scope pmd.pmd_attributes
+                (fun () -> transl_modtype env pmd.pmd_type)
+            in
+            let pres =
+              match tmty.mty_type with
+              | Mty_alias _ -> Mp_absent
+              | _ -> Mp_present
+            in
+            match pmd.pmd_name.txt with
+            | None -> None, pres, env, None, tmty
+            | Some name ->
+              let md = {
+                md_type=tmty.mty_type;
+                md_attributes=pmd.pmd_attributes;
+                md_loc=pmd.pmd_loc;
+              } in
+              let id, newenv =
+                Env.enter_module_declaration ~scope name pres md env
+              in
+              let newenv = Env.update_short_paths newenv in
+              Signature_names.check_module names pmd.pmd_name.loc id;
+              let sig_item = Sig_module(id, pres, md, Trec_not, Exported) in
+              Some id, pres, newenv, Some sig_item, tmty
+          with
+          | id, pres, newenv, sig_item, tmty ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            mksig (Tsig_module {md_id=id; md_name=pmd.pmd_name;
+                                md_presence=pres; md_type=tmty;
+                                md_loc=pmd.pmd_loc;
+                                md_attributes=pmd.pmd_attributes})
+              env loc :: trem,
+            (match sig_item with | None -> rem | Some i -> i :: rem),
+            final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_modsubst pms ->
+          let scope = Ctype.create_scope () in
+          begin match
+              let path, md =
+                Env.lookup_module ~loc:pms.pms_manifest.loc
+                  pms.pms_manifest.txt env
+              in
+              let aliasable = not (Env.is_functor_arg path env) in
+              let md =
+                if not aliasable then
+                  md
+                else
+                  { md_type = Mty_alias path;
+                    md_attributes = pms.pms_attributes;
+                    md_loc = pms.pms_loc }
+              in
+              let pres =
+                match md.md_type with
+                | Mty_alias _ -> Mp_absent
+                | _ -> Mp_present
+              in
+              let id, newenv =
+                Env.enter_module_declaration ~scope pms.pms_name.txt pres md env
+              in
+              let info =
+                `Substituted_away (Subst.add_module id path Subst.identity)
+              in
+              Signature_names.check_module ~info names pms.pms_name.loc id;
+              (newenv, Tsig_modsubst {ms_id=id; ms_name=pms.pms_name;
+                                      ms_manifest=path; ms_txt=pms.pms_manifest;
+                                      ms_loc=pms.pms_loc;
+                                      ms_attributes=pms.pms_attributes})
+            with
+            | newenv, sig_item ->
+              let (trem, rem, final_env) = transl_sig newenv srem in
+              (mksig sig_item env loc :: trem, rem, final_env)
+            | exception exn ->
+              Msupport.raise_error exn;
+              transl_sig env srem
+          end
+        | Psig_recmodule sdecls ->
+          begin match
+              let tdecls, newenv =
+                transl_recmodule_modtypes env sdecls in
+              let decls =
+                List.filter_map (fun md ->
+                    match md.md_id with
+                    | None -> None
+                    | Some id -> Some (id, md)
+                  ) tdecls
+              in
+              List.iter
+                (fun (id, md) -> Signature_names.check_module names md.md_loc id)
+                decls;
+              (tdecls, decls, newenv)
+            with
+            | (tdecls, decls, newenv) ->
+              let (trem, rem, final_env) = transl_sig newenv srem in
+              mksig (Tsig_recmodule tdecls) env loc :: trem,
+              map_rec (fun rs (id, md) ->
+                  let d = {Types.md_type = md.md_type.mty_type;
+                           md_attributes = md.md_attributes;
+                           md_loc = md.md_loc;
+                          } in
+                  Sig_module(id, Mp_present, d, rs, Exported))
+                decls rem,
+              final_env
+            | exception exn ->
+              Msupport.raise_error exn;
+              transl_sig env srem
+          end
+        | Psig_modtype pmtd ->
+          begin match transl_modtype_decl names env pmtd with
+          | newenv, mtd, sg ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            mksig (Tsig_modtype mtd) env loc :: trem,
+            sg :: rem,
+            final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_open sod ->
+          begin match type_open_descr env sod with
+          | (od, newenv) ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            mksig (Tsig_open od) env loc :: trem,
+            rem, final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_include sincl ->
+          begin match
+            let smty = sincl.pincl_mod in
+            let tmty =
+              Builtin_attributes.warning_scope sincl.pincl_attributes
+                (fun () -> transl_modtype env smty)
+            in
+            let mty = tmty.mty_type in
+            let scope = Ctype.create_scope () in
+            let sg, newenv = Env.enter_signature ~scope
+                       (extract_sig env smty.pmty_loc mty) env in
+            List.iter (Signature_names.check_sig_item names item.psig_loc) sg;
+            let incl =
+              { incl_mod = tmty;
+                incl_type = sg;
+                incl_attributes = sincl.pincl_attributes;
+                incl_loc = sincl.pincl_loc;
+              }
+            in
+            incl, sg, newenv
+          with
+          | incl, sg, newenv ->
+            let (trem, rem, final_env) = transl_sig newenv srem  in
+            mksig (Tsig_include incl) env loc :: trem,
+            sg @ rem,
+            final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_class cl ->
+          begin match
+            let (classes, _) as res = Typeclass.class_descriptions env cl in
+            List.iter (fun cls ->
+              let open Typeclass in
+              let loc = cls.cls_id_loc.Location.loc in
+              Signature_names.check_type names loc cls.cls_obj_id;
+              Signature_names.check_class names loc cls.cls_id;
+              Signature_names.check_class_type names loc cls.cls_ty_id;
+              Signature_names.check_type names loc cls.cls_typesharp_id;
+            ) classes;
+            res
+          with
+          | (classes, newenv) ->
+            let (trem, rem, final_env) = transl_sig newenv srem in
+            let sg =
+              map_rec (fun rs cls ->
+                let open Typeclass in
+                [Sig_class(cls.cls_id, cls.cls_decl, rs, Exported);
+                 Sig_class_type(cls.cls_ty_id, cls.cls_ty_decl, rs, Exported);
+                 Sig_type(cls.cls_obj_id, cls.cls_obj_abbr, rs, Exported);
+                 Sig_type(cls.cls_typesharp_id, cls.cls_abbr, rs, Exported)]
+              ) classes [rem]
+              |> List.flatten
+            in
+            let typedtree =
+              mksig (Tsig_class
+                       (List.map (fun decr ->
+                          decr.Typeclass.cls_info) classes)) env loc
+              :: trem
+            in
+            typedtree, sg, final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_class_type cl ->
+          begin match
+            let (classes, _) as res = Typeclass.class_type_declarations env cl in
+            List.iter (fun decl ->
+              let open Typeclass in
+              let loc = decl.clsty_id_loc.Location.loc in
+              Signature_names.check_class_type names loc decl.clsty_ty_id;
+              Signature_names.check_type names loc decl.clsty_obj_id;
+              Signature_names.check_type names loc decl.clsty_typesharp_id;
+            ) classes;
+            res
+          with
+          | (classes, newenv) ->
+            let (trem,rem, final_env) = transl_sig newenv srem in
+            let sg =
+              map_rec (fun rs decl ->
+                let open Typeclass in
+                [Sig_class_type(decl.clsty_ty_id, decl.clsty_ty_decl, rs,
+                                Exported);
+                 Sig_type(decl.clsty_obj_id, decl.clsty_obj_abbr, rs, Exported);
+                 Sig_type(decl.clsty_typesharp_id, decl.clsty_abbr, rs,
+                          Exported)
+                ]
+              ) classes [rem]
+              |> List.flatten
+            in
+            let typedtree =
+              mksig
+                (Tsig_class_type
+                   (List.map (fun decl -> decl.Typeclass.clsty_info) classes))
+                env loc
+              :: trem
+            in
+            typedtree, sg, final_env
+          | exception exn ->
+            Msupport.raise_error exn;
+            transl_sig env srem
+          end
+        | Psig_attribute x ->
+            Builtin_attributes.warning_attribute x;
+            let (trem,rem, final_env) = transl_sig env srem in
+            mksig (Tsig_attribute x) env loc :: trem, rem, final_env
+        | Psig_extension (ext, _attrs) ->
+            Msupport.raise_error
+              (Error_forward (Builtin_attributes.error_of_extension ext));
+            transl_sig env srem
+  in
+  Msupport.with_saved_types
+    ?warning_attribute:(if keep_warnings then None else Some [])
+    ~save_part:(fun sg -> Cmt_format.Partial_signature sg)
+    (fun () ->
+       let (trem, rem, final_env) = transl_sig (Env.in_signature true env) sg in
+       let rem = Signature_names.simplify final_env names rem in
+       { sig_items = trem; sig_type = rem; sig_final_env = final_env }
+    )
+
+and transl_modtype_decl names env pmtd =
+  Builtin_attributes.warning_scope pmtd.pmtd_attributes
+    (fun () -> transl_modtype_decl_aux names env pmtd)
+
+and transl_modtype_decl_aux names env
+    {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} =
+  let tmty =
+    Option.map (transl_modtype (Env.in_signature true env)) pmtd_type
+  in
+  let decl =
+    {
+     Types.mtd_type=Option.map (fun t -> t.mty_type) tmty;
+     mtd_attributes=pmtd_attributes;
+     mtd_loc=pmtd_loc;
+    }
+  in
+  let scope = Ctype.create_scope () in
+  let (id, newenv) = Env.enter_modtype ~scope pmtd_name.txt decl env in
+  Signature_names.check_modtype names pmtd_loc id;
+  let mtd =
+    {
+     mtd_id=id;
+     mtd_name=pmtd_name;
+     mtd_type=tmty;
+     mtd_attributes=pmtd_attributes;
+     mtd_loc=pmtd_loc;
+    }
+  in
+  newenv, mtd, Sig_modtype(id, decl, Exported)
+
+and transl_recmodule_modtypes env sdecls =
+  let make_env curr =
+    List.fold_left
+      (fun env (id, _, mty) ->
+         Option.fold ~none:env
+           ~some:(fun id -> Env.add_module ~arg:true id Mp_present mty env) id)
+      env curr in
+  let make_env2 curr =
+    List.fold_left
+      (fun env (id, _, mty) ->
+         Option.fold ~none:env
+           ~some:(fun id ->
+             Env.add_module ~arg:true id Mp_present mty.mty_type env
+           ) id)
+      env curr in
+  let transition env_c curr =
+    List.map2
+      (fun pmd (id, id_loc, _mty) ->
+        let tmty =
+          Builtin_attributes.warning_scope pmd.pmd_attributes
+            (fun () -> transl_modtype env_c pmd.pmd_type)
+        in
+        (id, id_loc, tmty))
+      sdecls curr in
+  let map_mtys =
+    List.filter_map
+      (fun (id, _, mty) ->
+        Option.map (fun id ->
+           (id, Types.{md_type = mty.mty_type;
+                       md_loc = mty.mty_loc;
+                       md_attributes = mty.mty_attributes})
+         ) id)
+  in
+  let scope = Ctype.create_scope () in
+  let ids =
+    List.map (fun x -> Option.map (Ident.create_scoped ~scope) x.pmd_name.txt)
+      sdecls
+  in
+  let approx_env =
+    List.fold_left
+      (fun env ->
+         Option.fold ~none:env ~some:(fun id -> (* cf #5965 *)
+           Env.enter_unbound_module (Ident.name id)
+             Mod_unbound_illegal_recursion env
+         ))
+      env ids
+  in
+  let init =
+    List.map2
+      (fun id pmd ->
+        (id, pmd.pmd_name, approx_modtype approx_env pmd.pmd_type))
+      ids sdecls
+  in
+  let env0 = make_env init in
+  let dcl1 =
+    Warnings.without_warnings
+      (fun () -> transition env0 init)
+  in
+  let env1 = make_env2 dcl1 in
+  check_recmod_typedecls env1 (map_mtys dcl1);
+  let dcl2 = transition env1 dcl1 in
+(*
+  List.iter
+    (fun (id, mty) ->
+      Format.printf "%a: %a@." Printtyp.ident id Printtyp.modtype mty)
+    dcl2;
+*)
+  let env2 = make_env2 dcl2 in
+  check_recmod_typedecls env2 (map_mtys dcl2);
+  let dcl2 =
+    List.map2
+      (fun pmd (id, id_loc, mty) ->
+        {md_id=id; md_name=id_loc; md_type=mty;
+         md_presence=Mp_present;
+         md_loc=pmd.pmd_loc;
+         md_attributes=pmd.pmd_attributes})
+      sdecls dcl2
+  in
+  (dcl2, env2)
+
+(* Try to convert a module expression to a module path. *)
+
+exception Not_a_path
+
+let rec path_of_module mexp =
+  match mexp.mod_desc with
+  | Tmod_ident (p,_) -> p
+  | Tmod_apply(funct, arg, _coercion) when !Clflags.applicative_functors ->
+      Papply(path_of_module funct, path_of_module arg)
+  | Tmod_constraint (mexp, _, _, _) ->
+      path_of_module mexp
+  | _ -> raise Not_a_path
+
+let path_of_module mexp =
+ try Some (path_of_module mexp) with Not_a_path -> None
+
+(* Check that all core type schemes in a structure are closed *)
+
+let rec closed_modtype env = function
+    Mty_ident _ -> true
+  | Mty_alias _ -> true
+  | Mty_signature sg ->
+      let env = Env.add_signature sg env in
+      List.for_all (closed_signature_item env) sg
+  | Mty_functor(arg_opt, body) ->
+      let env =
+        match arg_opt with
+        | Unit
+        | Named (None, _) -> env
+        | Named (Some id, param) ->
+            Env.add_module ~arg:true id Mp_present param env
+      in
+      closed_modtype env body
+
+and closed_signature_item env = function
+    Sig_value(_id, desc, _) -> Ctype.closed_schema env desc.val_type
+  | Sig_module(_id, _, md, _, _) -> closed_modtype env md.md_type
+  | _ -> true
+
+let check_nongen_scheme env sig_item =
+  match sig_item with
+    Sig_value(_id, vd, _) ->
+      if not (Ctype.closed_schema env vd.val_type) then
+        raise (Error (vd.val_loc, env, Non_generalizable vd.val_type))
+  | Sig_module (_id, _, md, _, _) ->
+      if not (closed_modtype env md.md_type) then
+        raise(Error(md.md_loc, env, Non_generalizable_module md.md_type))
+  | _ -> ()
+
+let check_nongen_schemes env sg =
+  List.iter (check_nongen_scheme env) sg
+
+(* Helpers for typing recursive modules *)
+
+let anchor_submodule name anchor =
+  match anchor, name with
+  | None, _
+  | _, None ->
+      None
+  | Some p, Some name ->
+      Some(Pdot(p, name))
+
+let anchor_recmodule = Option.map (fun id -> Pident id)
+
+let enrich_type_decls anchor decls oldenv newenv =
+  match anchor with
+    None -> newenv
+  | Some p ->
+      List.fold_left
+        (fun e info ->
+          let id = info.typ_id in
+          let info' =
+            Mtype.enrich_typedecl oldenv (Pdot(p, Ident.name id))
+              id info.typ_type
+          in
+            Env.add_type ~check:true id info' e)
+        oldenv decls
+
+let enrich_module_type anchor name mty env =
+  match anchor, name with
+  | None, _
+  | _, None ->
+      mty
+  | Some p, Some name ->
+      Mtype.enrich_modtype env (Pdot(p, name)) mty
+
+let check_recmodule_inclusion env bindings =
+  (* PR#4450, PR#4470: consider
+        module rec X : DECL = MOD  where MOD has inferred type ACTUAL
+     The "natural" typing condition
+        E, X: ACTUAL |- ACTUAL <: DECL
+     leads to circularities through manifest types.
+     Instead, we "unroll away" the potential circularities a finite number
+     of times.  The (weaker) condition we implement is:
+        E, X: DECL,
+           X1: ACTUAL,
+           X2: ACTUAL{X <- X1}/X1
+           ...
+           Xn: ACTUAL{X <- X(n-1)}/X(n-1)
+        |- ACTUAL{X <- Xn}/Xn <: DECL{X <- Xn}
+     so that manifest types rooted at X(n+1) are expanded in terms of X(n),
+     avoiding circularities.  The strengthenings ensure that
+     Xn.t = X(n-1).t = ... = X2.t = X1.t.
+     N can be chosen arbitrarily; larger values of N result in more
+     recursive definitions being accepted.  A good choice appears to be
+     the number of mutually recursive declarations. *)
+
+  let subst_and_strengthen env scope s id mty =
+    let mty = Subst.modtype (Rescope scope) s mty in
+    match id with
+    | None -> mty
+    | Some id ->
+        Mtype.strengthen ~aliasable:false env mty
+          (Subst.module_path s (Pident id))
+  in
+
+  let rec check_incl first_time n env s =
+    let scope = Ctype.create_scope () in
+    if n > 0 then begin
+      (* Generate fresh names Y_i for the rec. bound module idents X_i *)
+      let bindings1 =
+        List.map
+          (fun (id, _name, _mty_decl, _modl, mty_actual, _attrs, _loc) ->
+             let ids =
+               Option.map
+                 (fun id -> (id, Ident.create_scoped ~scope (Ident.name id))) id
+             in
+             (ids, mty_actual))
+          bindings in
+      (* Enter the Y_i in the environment with their actual types substituted
+         by the input substitution s *)
+      let env' =
+        List.fold_left
+          (fun env (ids, mty_actual) ->
+             match ids with
+             | None -> env
+             | Some (id, id') ->
+               let mty_actual' =
+                 if first_time
+                 then mty_actual
+                 else subst_and_strengthen env scope s (Some id) mty_actual
+               in
+               Env.add_module ~arg:false id' Mp_present mty_actual' env)
+          env bindings1 in
+      (* Build the output substitution Y_i <- X_i *)
+      let s' =
+        List.fold_left
+          (fun s (ids, _mty_actual) ->
+             match ids with
+             | None -> s
+             | Some (id, id') -> Subst.add_module id (Pident id') s)
+          Subst.identity bindings1 in
+      (* Recurse with env' and s' *)
+      check_incl false (n-1) env' s'
+    end else begin
+      (* Base case: check inclusion of s(mty_actual) in s(mty_decl)
+         and insert coercion if needed *)
+      let check_inclusion (id, name, mty_decl, modl, mty_actual, attrs, loc) =
+        let mty_decl' = Subst.modtype (Rescope scope) s mty_decl.mty_type
+        and mty_actual' = subst_and_strengthen env scope s id mty_actual in
+        let coercion =
+          try
+            Includemod.modtypes ~loc:modl.mod_loc env mty_actual' mty_decl'
+          with Includemod.Error msg ->
+            Msupport.raise_error(Error(modl.mod_loc, env, Not_included msg));
+            Tcoerce_none
+        in
+        let modl' =
+            { mod_desc = Tmod_constraint(modl, mty_decl.mty_type,
+                Tmodtype_explicit mty_decl, coercion);
+              mod_type = mty_decl.mty_type;
+              mod_env = env;
+              mod_loc = modl.mod_loc;
+              mod_attributes = [];
+             } in
+        {
+         mb_id = id;
+         mb_name = name;
+         mb_presence = Mp_present;
+         mb_expr = modl';
+         mb_attributes = attrs;
+         mb_loc = loc;
+        }
+      in
+      List.map check_inclusion bindings
+    end
+  in check_incl true (List.length bindings) env Subst.identity
+
+(* Helper for unpack *)
+
+let rec package_constraints env loc mty constrs =
+  if constrs = [] then mty
+  else let sg = extract_sig env loc mty in
+  let sg' =
+    List.map
+      (function
+        | Sig_type (id, ({type_params=[]} as td), rs, priv)
+          when List.mem_assoc [Ident.name id] constrs ->
+            let ty = List.assoc [Ident.name id] constrs in
+            Sig_type (id, {td with type_manifest = Some ty}, rs, priv)
+        | Sig_module (id, _, md, rs, priv) ->
+            let rec aux = function
+              | (m :: ((_ :: _) as l), t) :: rest when m = Ident.name id ->
+                  (l, t) :: aux rest
+              | _ :: rest -> aux rest
+              | [] -> []
+            in
+            let md =
+              {md with
+               md_type = package_constraints env loc md.md_type (aux constrs)
+              }
+            in
+            Sig_module (id, Mp_present, md, rs, priv)
+        | item -> item
+      )
+      sg
+  in
+  Mty_signature sg'
+
+let modtype_of_package env loc p nl tl =
+  match (Env.find_modtype p env).mtd_type with
+  | Some mty when nl <> [] ->
+      package_constraints env loc mty
+        (List.combine (List.map Longident.flatten nl) tl)
+  | _ ->
+      if nl = [] then Mty_ident p
+      else raise(Error(loc, env, Signature_expected))
+  | exception Not_found -> assert false
+
+let package_subtype env p1 nl1 tl1 p2 nl2 tl2 =
+  let mkmty p nl tl =
+    let ntl =
+      List.filter (fun (_n,t) -> Ctype.free_variables t = [])
+        (List.combine nl tl) in
+    let (nl, tl) = List.split ntl in
+    modtype_of_package env Location.none p nl tl
+  in
+  let mty1 = mkmty p1 nl1 tl1 and mty2 = mkmty p2 nl2 tl2 in
+  try Includemod.modtypes ~loc:Location.none env mty1 mty2 = Tcoerce_none
+  with Includemod.Error _msg -> false
+    (* raise(Error(Location.none, env, Not_included msg)) *)
+
+let () = Ctype.package_subtype := package_subtype
+
+let wrap_constraint env mark arg mty explicit =
+  let mark = if mark then Includemod.Mark_both else Includemod.Mark_neither in
+  let coercion =
+    try
+      Includemod.modtypes ~loc:arg.mod_loc env ~mark arg.mod_type mty
+    with Includemod.Error msg ->
+      Msupport.raise_error(Error(arg.mod_loc, env, Not_included msg));
+      Tcoerce_none
+  in
+  { mod_desc = Tmod_constraint(arg, mty, explicit, coercion);
+    mod_type = mty;
+    mod_env = env;
+    mod_attributes = [];
+    mod_loc = arg.mod_loc }
+
+(* Type a module value expression *)
+
+let rec type_module ?(alias=false) sttn funct_body anchor env smod =
+  try
+    Builtin_attributes.warning_scope smod.pmod_attributes
+      (fun () -> type_module_aux ~alias sttn funct_body anchor env smod)
+  with exn ->
+    Msupport.raise_error exn;
+    { mod_desc = Tmod_structure {
+        str_items = [];
+        str_type = [];
+        str_final_env = env;
+      };
+      mod_type = Mty_signature [];
+      mod_env = env;
+      mod_attributes = Msupport.flush_saved_types () @ smod.pmod_attributes;
+      mod_loc = smod.pmod_loc }
+
+
+and type_module_aux ~alias sttn funct_body anchor env smod =
+  match smod.pmod_desc with
+    Pmod_ident lid ->
+      let path =
+        Env.lookup_module_path ~load:(not alias) ~loc:smod.pmod_loc lid.txt env
+      in
+      let md = { mod_desc = Tmod_ident (path, lid);
+                 mod_type = Mty_alias path;
+                 mod_env = env;
+                 mod_attributes = smod.pmod_attributes;
+                 mod_loc = smod.pmod_loc } in
+      let aliasable = not (Env.is_functor_arg path env) in
+      let md =
+        if alias && aliasable then
+          (Env.add_required_global (Path.head path); md)
+        else match (Env.find_module path env).md_type with
+        | Mty_alias p1 when not alias ->
+            let p1 = Env.normalize_module_path (Some smod.pmod_loc) env p1 in
+            let mty = Includemod.expand_module_alias env [] p1 in
+            { md with
+              mod_desc =
+                Tmod_constraint (md, mty, Tmodtype_implicit,
+                                 Tcoerce_alias (env, path, Tcoerce_none));
+              mod_type =
+                if sttn then Mtype.strengthen ~aliasable:true env mty p1
+                else mty }
+        | mty ->
+            let mty =
+              if sttn then Mtype.strengthen ~aliasable env mty path
+              else mty
+            in
+            { md with mod_type = mty }
+      in rm md
+  | Pmod_structure sstr ->
+      let (str, sg, names, _finalenv) =
+        type_structure funct_body anchor env sstr smod.pmod_loc in
+      let md =
+        rm { mod_desc = Tmod_structure str;
+             mod_type = Mty_signature sg;
+             mod_env = env;
+             mod_attributes = smod.pmod_attributes;
+             mod_loc = smod.pmod_loc }
+      in
+      let sg' = Signature_names.simplify _finalenv names sg in
+      if List.length sg' = List.length sg then md else
+      wrap_constraint env false md (Mty_signature sg')
+        Tmodtype_implicit
+  | Pmod_functor(arg_opt, sbody) ->
+      let t_arg, ty_arg, newenv, funct_body =
+        match arg_opt with
+        | Unit -> Unit, Types.Unit, env, false
+        | Named (param, smty) ->
+          let mty = transl_modtype_functor_arg env smty in
+          let scope = Ctype.create_scope () in
+          let (id, newenv) =
+            match param.txt with
+            | None -> None, env
+            | Some name ->
+              let arg_md =
+                { md_type = mty.mty_type;
+                  md_attributes = [];
+                  md_loc = param.loc;
+                }
+              in
+              let id, newenv =
+                Env.enter_module_declaration ~scope ~arg:true name Mp_present
+                  arg_md env
+              in
+              Some id, newenv
+          in
+          Named (id, param, mty), Types.Named (id, mty.mty_type), newenv, true
+      in
+      let body = type_module sttn funct_body None newenv sbody in
+      rm { mod_desc = Tmod_functor(t_arg, body);
+           mod_type = Mty_functor(ty_arg, body.mod_type);
+           mod_env = env;
+           mod_attributes = smod.pmod_attributes;
+           mod_loc = smod.pmod_loc }
+  | Pmod_apply(sfunct, sarg) ->
+      let arg = type_module true funct_body None env sarg in
+      let path = path_of_module arg in
+      let funct =
+        type_module (sttn && path <> None) funct_body None env sfunct in
+      begin match Env.scrape_alias env funct.mod_type with
+      | Mty_functor (Unit, mty_res) ->
+          if sarg.pmod_desc <> Pmod_structure [] then
+            raise (Error (sfunct.pmod_loc, env, Apply_generative));
+          if funct_body && Mtype.contains_type env funct.mod_type then
+            raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
+          rm { mod_desc = Tmod_apply(funct, arg, Tcoerce_none);
+               mod_type = mty_res;
+               mod_env = env;
+               mod_attributes = smod.pmod_attributes;
+               mod_loc = smod.pmod_loc }
+      | Mty_functor (Named (param, mty_param), mty_res) as mty_functor ->
+          let coercion =
+            try
+              Includemod.modtypes ~loc:sarg.pmod_loc env arg.mod_type mty_param
+            with Includemod.Error msg ->
+              Msupport.raise_error(Error(sarg.pmod_loc, env, Not_included msg));
+              Tcoerce_none
+          in
+          let mty_appl =
+            match path with
+            | Some path ->
+                let scope = Ctype.create_scope () in
+                let subst =
+                  match param with
+                  | None -> Subst.identity
+                  | Some p -> Subst.add_module p path Subst.identity
+                in
+                Subst.modtype (Rescope scope) subst mty_res
+            | None ->
+                let nondep_mty =
+                  match param with
+                  | None -> mty_res
+                  | Some param ->
+                      let parent_env = env in
+                      let env =
+                        Env.add_module ~arg:true param Mp_present arg.mod_type
+                          env
+                      in
+                      check_well_formed_module env smod.pmod_loc
+                        "the signature of this functor application" mty_res;
+                      try Mtype.nondep_supertype env [param] mty_res
+                      with Ctype.Nondep_cannot_erase _ ->
+                        raise(Error(smod.pmod_loc, parent_env,
+                                    Cannot_eliminate_dependency mty_functor))
+                in
+                (* TODO(merlin): we could perhaps log the "fatal error" cases...
+                   not sure it's worth the effort. *)
+                (*
+                begin match
+                  Includemod.modtypes ~loc:smod.pmod_loc env mty_res nondep_mty
+                with
+                | Tcoerce_none -> ()
+                | _ ->
+                  fatal_error
+                    "unexpected coercion from original module type to \
+                     nondep_supertype one"
+                | exception Includemod.Error _ ->
+                  fatal_error
+                    "nondep_supertype not included in original module type"
+                end;
+                *)
+                nondep_mty
+          in
+          check_well_formed_module env smod.pmod_loc
+            "the signature of this functor application" mty_appl;
+          rm { mod_desc = Tmod_apply(funct, arg, coercion);
+               mod_type = mty_appl;
+               mod_env = env;
+               mod_attributes = smod.pmod_attributes;
+               mod_loc = smod.pmod_loc }
+      | Mty_alias path ->
+          raise(Error(sfunct.pmod_loc, env, Cannot_scrape_alias path))
+      | _ ->
+          raise(Error(sfunct.pmod_loc, env, Cannot_apply funct.mod_type))
+      end
+  | Pmod_constraint(sarg, smty) ->
+      let arg = type_module ~alias true funct_body anchor env sarg in
+      let mty = transl_modtype env smty in
+      let md =
+        wrap_constraint env true arg mty.mty_type (Tmodtype_explicit mty)
+      in
+      rm { md with
+          mod_loc = smod.pmod_loc;
+          mod_attributes = smod.pmod_attributes;
+         }
+
+  | Pmod_unpack sexp ->
+      if !Clflags.principal then Ctype.begin_def ();
+      let exp = Typecore.type_exp env sexp in
+      if !Clflags.principal then begin
+        Ctype.end_def ();
+        Ctype.generalize_structure exp.exp_type
+      end;
+      let mty =
+        match Ctype.expand_head env exp.exp_type with
+          {desc = Tpackage (p, nl, tl)} ->
+            if List.exists (fun t -> Ctype.free_variables t <> []) tl then
+              raise (Error (smod.pmod_loc, env,
+                            Incomplete_packed_module exp.exp_type));
+            if !Clflags.principal &&
+              not (Typecore.generalizable (Btype.generic_level-1) exp.exp_type)
+            then
+              Location.prerr_warning smod.pmod_loc
+                (Warnings.Not_principal "this module unpacking");
+            modtype_of_package env smod.pmod_loc p nl tl
+        | {desc = Tvar _} ->
+            raise (Typecore.Error
+                     (smod.pmod_loc, env, Typecore.Cannot_infer_signature))
+        | _ ->
+            raise (Error(smod.pmod_loc, env, Not_a_packed_module exp.exp_type))
+      in
+      if funct_body && Mtype.contains_type env mty then
+        raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
+      rm { mod_desc = Tmod_unpack(exp, mty);
+           mod_type = mty;
+           mod_env = env;
+           mod_attributes = smod.pmod_attributes;
+           mod_loc = smod.pmod_loc }
+  | Pmod_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+and type_open_decl ?used_slot ?toplevel funct_body names env sod =
+  Builtin_attributes.warning_scope sod.popen_attributes
+    (fun () ->
+       type_open_decl_aux ?used_slot ?toplevel funct_body names env sod
+    )
+
+and type_open_decl_aux ?used_slot ?toplevel funct_body names env od =
+  let loc = od.popen_loc in
+  match od.popen_expr.pmod_desc with
+  | Pmod_ident lid ->
+    let path, newenv =
+      type_open_ ?used_slot ?toplevel od.popen_override env loc lid
+    in
+    let md = { mod_desc = Tmod_ident (path, lid);
+               mod_type = Mty_alias path;
+               mod_env = env;
+               mod_attributes = od.popen_expr.pmod_attributes;
+               mod_loc = od.popen_expr.pmod_loc }
+    in
+    let open_descr = {
+      open_expr = md;
+      open_bound_items = [];
+      open_override = od.popen_override;
+      open_env = newenv;
+      open_loc = loc;
+      open_attributes = od.popen_attributes
+    } in
+    open_descr, [], newenv
+  | _ ->
+    let md = type_module true funct_body None env od.popen_expr in
+    let scope = Ctype.create_scope () in
+    let sg, newenv =
+      Env.enter_signature ~scope (extract_sig_open env md.mod_loc md.mod_type)
+        env
+    in
+    List.iter (Signature_names.check_sig_item ~info:`From_open names loc) sg;
+    let sg =
+      List.map (function
+        | Sig_value(id, vd, _) -> Sig_value(id, vd, Hidden)
+        | Sig_type(id, td, rs, _) -> Sig_type(id, td, rs, Hidden)
+        | Sig_typext(id, ec, et, _) -> Sig_typext(id, ec, et, Hidden)
+        | Sig_module(id, mp, md, rs, _) -> Sig_module(id, mp, md, rs, Hidden)
+        | Sig_modtype(id, mtd, _) -> Sig_modtype(id, mtd, Hidden)
+        | Sig_class(id, cd, rs, _) -> Sig_class(id, cd, rs, Hidden)
+        | Sig_class_type(id, ctd, rs, _) -> Sig_class_type(id, ctd, rs, Hidden)
+      ) sg
+    in
+    let open_descr = {
+      open_expr = md;
+      open_bound_items = sg;
+      open_override = od.popen_override;
+      open_env = newenv;
+      open_loc = loc;
+      open_attributes = od.popen_attributes
+    } in
+    open_descr, sg, newenv
+
+and type_structure ?(toplevel = false) ?(keep_warnings = false) funct_body anchor env sstr scope =
+  let names = Signature_names.create () in
+
+  let type_str_item env srem {pstr_loc = loc; pstr_desc = desc} =
+    match desc with
+    | Pstr_eval (sexpr, attrs) ->
+        let expr =
+          Builtin_attributes.warning_scope attrs
+            (fun () -> Typecore.type_expression env sexpr)
+        in
+        Tstr_eval (expr, attrs), [], env
+    | Pstr_value(rec_flag, sdefs) ->
+        let scope =
+          match rec_flag with
+          | Recursive ->
+              Some (Annot.Idef {scope with
+                                Location.loc_start = loc.Location.loc_start})
+          | Nonrecursive ->
+              let start =
+                match srem with
+                | [] -> loc.Location.loc_end
+                | {pstr_loc = loc2} :: _ -> loc2.Location.loc_start
+              in
+              Some (Annot.Idef {scope with Location.loc_start = start})
+        in
+        let (defs, newenv) =
+          Typecore.type_binding env rec_flag sdefs scope in
+        let () = if rec_flag = Recursive then
+          Typecore.check_recursive_bindings env defs
+        in
+        (* Note: Env.find_value does not trigger the value_used event. Values
+           will be marked as being used during the signature inclusion test. *)
+        Tstr_value(rec_flag, defs),
+        List.map (fun (id, { Asttypes.loc; _ }, _typ)->
+          Signature_names.check_value names loc id;
+          Sig_value(id, Env.find_value (Pident id) newenv, Exported)
+        ) (let_bound_idents_full defs),
+        newenv
+    | Pstr_primitive sdesc ->
+        let (desc, newenv) = Typedecl.transl_value_decl env loc sdesc in
+        Signature_names.check_value names desc.val_loc desc.val_id;
+        Tstr_primitive desc,
+        [Sig_value(desc.val_id, desc.val_val, Exported)],
+        newenv
+    | Pstr_type (rec_flag, sdecls) ->
+        let (decls, newenv) = Typedecl.transl_type_decl env rec_flag sdecls in
+        let newenv = Env.update_short_paths newenv in
+        List.iter
+          Signature_names.(fun td -> check_type names td.typ_loc td.typ_id)
+          decls;
+        Tstr_type (rec_flag, decls),
+        map_rec_type_with_row_types ~rec_flag
+          (fun rs info -> Sig_type(info.typ_id, info.typ_type, rs, Exported))
+          decls [],
+        enrich_type_decls anchor decls env newenv
+    | Pstr_typext styext ->
+        let (tyext, newenv) =
+          Typedecl.transl_type_extension true env loc styext
+        in
+        let constructors = tyext.tyext_constructors in
+        List.iter
+          Signature_names.(fun ext -> check_typext names ext.ext_loc ext.ext_id)
+          constructors;
+        (Tstr_typext tyext,
+         map_ext
+           (fun es ext -> Sig_typext(ext.ext_id, ext.ext_type, es, Exported))
+           constructors [],
+         newenv)
+    | Pstr_exception sext ->
+        let (ext, newenv) = Typedecl.transl_type_exception env sext in
+        let constructor = ext.tyexn_constructor in
+        Signature_names.check_typext names constructor.ext_loc
+          constructor.ext_id;
+        Tstr_exception ext,
+        [Sig_typext(constructor.ext_id,
+                    constructor.ext_type,
+                    Text_exception,
+                    Exported)],
+        newenv
+    | Pstr_module {pmb_name = name; pmb_expr = smodl; pmb_attributes = attrs;
+                   pmb_loc;
+                  } ->
+        let outer_scope = Ctype.get_current_level () in
+        let scope = Ctype.create_scope () in
+        let modl =
+          Builtin_attributes.warning_scope attrs
+            (fun () ->
+               type_module ~alias:true true funct_body
+                 (anchor_submodule name.txt anchor) env smodl
+            )
+        in
+        let pres =
+          match modl.mod_type with
+          | Mty_alias _ -> Mp_absent
+          | _ -> Mp_present
+        in
+        let md =
+          { md_type = enrich_module_type anchor name.txt modl.mod_type env;
+            md_attributes = attrs;
+            md_loc = pmb_loc;
+          }
+        in
+        (*prerr_endline (Ident.unique_toplevel_name id);*)
+        Mtype.lower_nongen outer_scope md.md_type;
+        let id, newenv, sg =
+          match name.txt with
+          | None -> None, env, []
+          | Some name ->
+            let id, e = Env.enter_module_declaration ~scope name pres md env in
+            let e = Env.update_short_paths e in
+            Signature_names.check_module names pmb_loc id;
+            Some id, e,
+            [Sig_module(id, pres,
+                        {md_type = modl.mod_type;
+                         md_attributes = attrs;
+                         md_loc = pmb_loc;
+                        }, Trec_not, Exported)]
+        in
+        Tstr_module {mb_id=id; mb_name=name; mb_expr=modl;
+                     mb_presence=pres; mb_attributes=attrs;  mb_loc=pmb_loc; },
+        sg,
+        newenv
+    | Pstr_recmodule sbind ->
+        let sbind =
+          List.map
+            (function
+              | {pmb_name = name;
+                 pmb_expr = {pmod_desc=Pmod_constraint(expr, typ)};
+                 pmb_attributes = attrs;
+                 pmb_loc = loc;
+                } ->
+                  name, typ, expr, attrs, loc
+              | mb ->
+                  raise (Error (mb.pmb_expr.pmod_loc, env,
+                                Recursive_module_require_explicit_type))
+            )
+            sbind
+        in
+        let (decls, newenv) =
+          transl_recmodule_modtypes env
+            (List.map (fun (name, smty, _smodl, attrs, loc) ->
+                 {pmd_name=name; pmd_type=smty;
+                  pmd_attributes=attrs; pmd_loc=loc}) sbind
+            ) in
+        List.iter
+          (fun md ->
+            Option.iter Signature_names.(check_module names md.md_loc) md.md_id)
+          decls;
+        let newenv = Env.update_short_paths newenv in
+        let bindings1 =
+          List.map2
+            (fun {md_id=id; md_type=mty} (name, _, smodl, attrs, loc) ->
+               let modl =
+                 Builtin_attributes.warning_scope attrs
+                   (fun () ->
+                      type_module true funct_body (anchor_recmodule id)
+                        newenv smodl
+                   )
+               in
+               let mty' =
+                 enrich_module_type anchor name.txt modl.mod_type newenv
+               in
+               (id, name, mty, modl, mty', attrs, loc))
+            decls sbind in
+        let newenv = (* allow aliasing recursive modules from outside *)
+          List.fold_left
+            (fun env md ->
+               match md.md_id with
+               | None -> env
+               | Some id ->
+                   let mdecl =
+                     {
+                       md_type = md.md_type.mty_type;
+                       md_attributes = md.md_attributes;
+                       md_loc = md.md_loc;
+                     }
+                   in
+                   Env.add_module_declaration ~check:true
+                     id Mp_present mdecl env
+            )
+            env decls
+        in
+        let newenv = Env.update_short_paths newenv in
+        let bindings2 =
+          check_recmodule_inclusion newenv bindings1 in
+        let mbs =
+          List.filter_map (fun mb -> Option.map (fun id -> id, mb)  mb.mb_id)
+            bindings2
+        in
+        Tstr_recmodule bindings2,
+        map_rec (fun rs (id, mb) ->
+            Sig_module(id, Mp_present, {
+                md_type=mb.mb_expr.mod_type;
+                md_attributes=mb.mb_attributes;
+                md_loc=mb.mb_loc;
+              }, rs, Exported))
+           mbs [],
+        newenv
+    | Pstr_modtype pmtd ->
+        (* check that it is non-abstract *)
+        let newenv, mtd, sg = transl_modtype_decl names env pmtd in
+        let newenv = Env.update_short_paths newenv in
+        Tstr_modtype mtd, [sg], newenv
+    | Pstr_open sod ->
+        let (od, sg, newenv) =
+          type_open_decl ~toplevel funct_body names env sod
+        in
+        let newenv = Env.update_short_paths newenv in
+        Tstr_open od, sg, newenv
+    | Pstr_class cl ->
+        let (classes, new_env) = Typeclass.class_declarations env cl in
+        let new_env = Env.update_short_paths new_env in
+        List.iter (fun cls ->
+          let open Typeclass in
+          let loc = cls.cls_id_loc.Location.loc in
+          Signature_names.check_class names loc cls.cls_id;
+          Signature_names.check_class_type names loc cls.cls_ty_id;
+          Signature_names.check_type names loc cls.cls_obj_id;
+          Signature_names.check_type names loc cls.cls_typesharp_id;
+        ) classes;
+        Tstr_class
+          (List.map (fun cls ->
+               (cls.Typeclass.cls_info,
+                cls.Typeclass.cls_pub_methods)) classes),
+(* TODO: check with Jacques why this is here
+      Tstr_class_type
+          (List.map (fun (_,_, i, d, _,_,_,_,_,_,c) -> (i, c)) classes) ::
+      Tstr_type
+          (List.map (fun (_,_,_,_, i, d, _,_,_,_,_) -> (i, d)) classes) ::
+      Tstr_type
+          (List.map (fun (_,_,_,_,_,_, i, d, _,_,_) -> (i, d)) classes) ::
+*)
+        List.flatten
+          (map_rec
+            (fun rs cls ->
+              let open Typeclass in
+              [Sig_class(cls.cls_id, cls.cls_decl, rs, Exported);
+               Sig_class_type(cls.cls_ty_id, cls.cls_ty_decl, rs, Exported);
+               Sig_type(cls.cls_obj_id, cls.cls_obj_abbr, rs, Exported);
+               Sig_type(cls.cls_typesharp_id, cls.cls_abbr, rs, Exported)])
+             classes []),
+        new_env
+    | Pstr_class_type cl ->
+        let (classes, new_env) = Typeclass.class_type_declarations env cl in
+        let new_env = Env.update_short_paths new_env in
+        List.iter (fun decl ->
+          let open Typeclass in
+          let loc = decl.clsty_id_loc.Location.loc in
+          Signature_names.check_class_type names loc decl.clsty_ty_id;
+          Signature_names.check_type names loc decl.clsty_obj_id;
+          Signature_names.check_type names loc decl.clsty_typesharp_id;
+        ) classes;
+        Tstr_class_type
+          (List.map (fun cl ->
+               (cl.Typeclass.clsty_ty_id,
+                cl.Typeclass.clsty_id_loc,
+                cl.Typeclass.clsty_info)) classes),
+(*  TODO: check with Jacques why this is here
+           Tstr_type
+             (List.map (fun (_, _, i, d, _, _) -> (i, d)) classes) ::
+           Tstr_type
+             (List.map (fun (_, _, _, _, i, d) -> (i, d)) classes) :: *)
+        List.flatten
+          (map_rec
+             (fun rs decl ->
+                let open Typeclass in
+                [Sig_class_type(decl.clsty_ty_id, decl.clsty_ty_decl, rs,
+                                Exported);
+                 Sig_type(decl.clsty_obj_id, decl.clsty_obj_abbr, rs, Exported);
+                 Sig_type(decl.clsty_typesharp_id, decl.clsty_abbr, rs,
+                          Exported)
+                ])
+             classes []),
+        new_env
+    | Pstr_include sincl ->
+        let smodl = sincl.pincl_mod in
+        let modl =
+          Builtin_attributes.warning_scope sincl.pincl_attributes
+            (fun () -> type_module true funct_body None env smodl)
+        in
+        let scope = Ctype.create_scope () in
+        (* Rename all identifiers bound by this signature to avoid clashes *)
+        let sg, new_env = Env.enter_signature ~scope
+            (extract_sig_open env smodl.pmod_loc modl.mod_type) env in
+        let new_env = Env.update_short_paths new_env in
+        List.iter (Signature_names.check_sig_item names loc) sg;
+        let incl =
+          { incl_mod = modl;
+            incl_type = sg;
+            incl_attributes = sincl.pincl_attributes;
+            incl_loc = sincl.pincl_loc;
+          }
+        in
+        Tstr_include incl, sg, new_env
+    | Pstr_extension (ext, _attrs) ->
+        raise (Error_forward (Builtin_attributes.error_of_extension ext))
+    | Pstr_attribute x ->
+        Builtin_attributes.warning_attribute x;
+        Tstr_attribute x, [], env
+  in
+  let rec type_struct env sstr =
+    match sstr with
+    | [] -> ([], [], env)
+    | pstr :: srem ->
+        let previous_saved_types = Cmt_format.get_saved_types () in
+        match type_str_item env srem pstr with
+        | desc, sg, new_env ->
+          let str = { str_desc = desc; str_loc = pstr.pstr_loc; str_env = env } in
+          Cmt_format.set_saved_types (Cmt_format.Partial_structure_item str
+                                      :: previous_saved_types);
+          let (str_rem, sig_rem, final_env) = type_struct new_env srem in
+          (str :: str_rem, sg @ sig_rem, final_env)
+        | exception exn ->
+          Msupport.raise_error exn;
+          type_struct env srem
+  in
+  if !Clflags.annotations then
+    (* moved to genannot *)
+    List.iter (function {pstr_loc = l} -> Stypes.record_phrase l) sstr;
+  Msupport.with_saved_types
+    ?warning_attribute:(if toplevel || keep_warnings then None else Some [])
+    ~save_part:(fun (str,_,_,_) -> Cmt_format.Partial_structure str)
+    (fun () ->
+       let (items, sg, final_env) = type_struct env sstr in
+       let str = { str_items = items; str_type = sg; str_final_env = final_env } in
+       str, sg, names, final_env)
+
+let type_toplevel_phrase env s =
+  Env.reset_required_globals ();
+  let (str, sg, _to_remove_from_sg, env) =
+    type_structure ~toplevel:true false None env s Location.none in
+  (str, sg, (* to_remove_from_sg,*) env)
+
+let type_module_alias = type_module ~alias:true true false None
+let type_module = type_module true false None
+
+let merlin_type_structure env str loc =
+  let (str, sg, _sg_names, env) =
+    type_structure ~keep_warnings:true false None env str loc
+  in
+  str, sg, env
+let type_structure = type_structure false None
+let merlin_transl_signature env sg = transl_signature ~keep_warnings:true env sg
+let transl_signature env sg = transl_signature env sg
+
+(* Normalize types in a signature *)
+
+let rec normalize_modtype env = function
+    Mty_ident _
+  | Mty_alias _ -> ()
+  | Mty_signature sg -> normalize_signature env sg
+  | Mty_functor(_param, body) -> normalize_modtype env body
+
+and normalize_signature env = List.iter (normalize_signature_item env)
+
+and normalize_signature_item env = function
+    Sig_value(_id, desc, _) -> Ctype.normalize_type env desc.val_type
+  | Sig_module(_id, _, md, _, _) -> normalize_modtype env md.md_type
+  | _ -> ()
+
+(* Extract the module type of a module expression *)
+
+let type_module_type_of env smod =
+  let remove_aliases = has_remove_aliases_attribute smod.pmod_attributes in
+  let tmty =
+    match smod.pmod_desc with
+    | Pmod_ident lid -> (* turn off strengthening in this case *)
+        let path, md = Env.lookup_module ~loc:smod.pmod_loc lid.txt env in
+          rm { mod_desc = Tmod_ident (path, lid);
+               mod_type = md.md_type;
+               mod_env = env;
+               mod_attributes = smod.pmod_attributes;
+               mod_loc = smod.pmod_loc }
+    | _ -> type_module env smod
+  in
+  let mty = Mtype.scrape_for_type_of ~remove_aliases env tmty.mod_type in
+  (* PR#5036: must not contain non-generalized type variables *)
+  if not (closed_modtype env mty) then
+    raise(Error(smod.pmod_loc, env, Non_generalizable_module mty));
+  tmty, mty
+
+(* For Typecore *)
+
+(* Graft a longident onto a path *)
+let rec extend_path path =
+  fun lid ->
+    match lid with
+    | Lident name -> Pdot(path, name)
+    | Ldot(m, name) -> Pdot(extend_path path m, name)
+    | Lapply _ -> assert false
+
+(* Lookup a type's longident within a signature *)
+let lookup_type_in_sig sg =
+  let types, modules =
+    List.fold_left
+      (fun acc item ->
+         match item with
+         | Sig_type(id, _, _, _) ->
+             let types, modules = acc in
+             let types = String.Map.add (Ident.name id) id types in
+             types, modules
+         | Sig_module(id, _, _, _, _) ->
+             let types, modules = acc in
+             let modules = String.Map.add (Ident.name id) id modules in
+             types, modules
+         | _ -> acc)
+      (String.Map.empty, String.Map.empty) sg
+  in
+  let rec module_path = function
+    | Lident name -> Pident (String.Map.find name modules)
+    | Ldot(m, name) -> Pdot(module_path m, name)
+    | Lapply _ -> assert false
+  in
+  fun lid ->
+    match lid with
+    | Lident name -> Pident (String.Map.find name types)
+    | Ldot(m, name) -> Pdot(module_path m, name)
+    | Lapply _ -> assert false
+
+let type_package env m p nl =
+  (* Same as Pexp_letmodule *)
+  (* remember original level *)
+  Ctype.begin_def ();
+  let context = Typetexp.narrow () in
+  let modl = type_module env m in
+  let scope = Ctype.create_scope () in
+  Typetexp.widen context;
+  let nl', tl', env =
+    match nl with
+    | [] -> [], [], env
+    | nl ->
+      let type_path, env =
+        match modl.mod_desc with
+        | Tmod_ident (mp,_)
+        | Tmod_constraint
+            ({mod_desc=Tmod_ident (mp,_)}, _, Tmodtype_implicit, _) ->
+          (* We special case these because interactions between
+             strengthening of module types and packages can cause
+             spurious escape errors. See examples from PR#6982 in the
+             testsuite. This can be removed when such issues are
+             fixed. *)
+          extend_path mp, env
+        | _ ->
+          let sg = extract_sig_open env modl.mod_loc modl.mod_type in
+          let sg, env = Env.enter_signature ~scope sg env in
+          lookup_type_in_sig sg, env
+      in
+      let nl', tl' =
+        List.fold_right
+          (fun lid (nl, tl) ->
+             match type_path lid with
+             | exception Not_found -> (nl, tl)
+             | path -> begin
+                 match Env.find_type path env with
+                 | exception Not_found -> (nl, tl)
+                 | decl ->
+                     if decl.type_arity > 0 then begin
+                       (nl, tl)
+                     end else begin
+                       let t = Btype.newgenty (Tconstr (path,[],ref Mnil)) in
+                       (lid :: nl, t :: tl)
+                     end
+               end)
+          nl ([], [])
+      in
+      nl', tl', env
+  in
+  (* go back to original level *)
+  Ctype.end_def ();
+  let mty =
+    if nl = [] then (Mty_ident p)
+    else modtype_of_package env modl.mod_loc p nl' tl'
+  in
+  List.iter2
+    (fun n ty ->
+      try Ctype.unify env ty (Ctype.newvar ())
+      with Ctype.Unify _ ->
+        raise (Error(modl.mod_loc, env, Scoping_pack (n,ty))))
+    nl' tl';
+  let modl = wrap_constraint env true modl mty Tmodtype_implicit in
+  (* Dropped exports should have produced an error above *)
+  assert (List.length nl = List.length tl');
+  modl, tl'
+
+(* Fill in the forward declarations *)
+
+let type_open_decl ?used_slot env od =
+  type_open_decl ?used_slot ?toplevel:None false (Signature_names.create ()) env
+    od
+
+let type_open_descr ?used_slot env od =
+  type_open_descr ?used_slot ?toplevel:None env od
+
+let () =
+  Typecore.type_module := type_module_alias;
+  Typetexp.transl_modtype_longident := transl_modtype_longident;
+  Typetexp.transl_modtype := transl_modtype;
+  Typecore.type_open := type_open_ ?toplevel:None;
+  Typecore.type_open_decl := type_open_decl;
+  Typecore.type_package := type_package;
+  Typeclass.type_open_descr := type_open_descr;
+  type_module_type_of_fwd := type_module_type_of
+
+
+(* Typecheck an implementation file *)
+
+let type_implementation sourcefile outputprefix modulename initial_env ast =
+  Cmt_format.clear ();
+  Misc.try_finally (fun () ->
+      Typecore.reset_delayed_checks ();
+      Env.reset_required_globals ();
+      if !Clflags.print_types then (* #7656 *)
+        Warnings.parse_options false "-32-34-37-38-60";
+      let (str, sg, names, finalenv) =
+        type_structure initial_env ast (Location.in_file sourcefile) in
+      let simple_sg = Signature_names.simplify finalenv names sg in
+      if !Clflags.print_types then begin
+        Typecore.force_delayed_checks ();
+        Printtyp.wrap_printing_env ~error:false initial_env
+          (fun () -> fprintf std_formatter "%a@."
+              (Printtyp.printed_signature sourcefile) simple_sg
+          );
+        (str, Tcoerce_none)   (* result is ignored by Compile.implementation *)
+      end else begin
+        let sourceintf =
+          Filename.remove_extension sourcefile ^ !Config.interface_suffix in
+        if Sys.file_exists sourceintf then begin
+          let intf_file =
+            try
+              Load_path.find_uncap (modulename ^ ".cmi")
+            with Not_found ->
+              raise(Error(Location.in_file sourcefile, Env.empty,
+                          Interface_not_compiled sourceintf)) in
+          let dclsig = Env.read_signature modulename intf_file in
+          let coercion =
+            Includemod.compunit initial_env ~mark:Includemod.Mark_positive
+              sourcefile sg intf_file dclsig
+          in
+          Typecore.force_delayed_checks ();
+          (* It is important to run these checks after the inclusion test above,
+             so that value declarations which are not used internally but
+             exported are not reported as being unused. *)
+          Cmt_format.save_cmt (outputprefix ^ ".cmt") modulename
+            (Cmt_format.Implementation str) (Some sourcefile) initial_env None;
+          (str, coercion)
+        end else begin
+          let coercion =
+            Includemod.compunit initial_env ~mark:Includemod.Mark_positive
+              sourcefile sg "(inferred signature)" simple_sg
+          in
+          check_nongen_schemes finalenv simple_sg;
+          normalize_signature finalenv simple_sg;
+          Typecore.force_delayed_checks ();
+          (* See comment above. Here the target signature contains all
+             the value being exported. We can still capture unused
+             declarations like "let x = true;; let x = 1;;", because in this
+             case, the inferred signature contains only the last declaration. *)
+          if not !Clflags.dont_write_files then begin
+            let alerts = Builtin_attributes.alerts_of_str ast in
+            let cmi =
+              Env.save_signature ~alerts
+                simple_sg modulename (outputprefix ^ ".cmi")
+            in
+            Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
+              (Cmt_format.Implementation str)
+              (Some sourcefile) initial_env (Some cmi);
+          end;
+          (str, coercion)
+        end
+      end
+    )
+    ~exceptionally:(fun () ->
+        Cmt_format.save_cmt  (outputprefix ^ ".cmt") modulename
+          (Cmt_format.Partial_implementation
+             (Array.of_list (Cmt_format.get_saved_types ())))
+          (Some sourcefile) initial_env None)
+
+let save_signature modname tsg outputprefix source_file initial_env cmi =
+  Cmt_format.save_cmt  (outputprefix ^ ".cmti") modname
+    (Cmt_format.Interface tsg) (Some source_file) initial_env (Some cmi)
+
+let type_interface env ast =
+  transl_signature env ast
+
+(* "Packaging" of several compilation units into one unit
+   having them as sub-modules.  *)
+
+let package_signatures units =
+  let units_with_ids =
+    List.map
+      (fun (name, sg) ->
+        let oldid = Ident.create_persistent name in
+        let newid = Ident.create_local name in
+        (oldid, newid, sg))
+      units
+  in
+  let subst =
+    List.fold_left
+      (fun acc (oldid, newid, _) ->
+        Subst.add_module oldid (Pident newid) acc)
+      Subst.identity units_with_ids
+  in
+  List.map
+    (fun (_, newid, sg) ->
+      (* This signature won't be used for anything, it'll just be saved in a cmi
+         and cmt. *)
+      let sg = Subst.signature Make_local subst sg in
+      let md =
+        { md_type=Mty_signature sg;
+          md_attributes=[];
+          md_loc=Location.none; }
+      in
+      Sig_module(newid, Mp_present, md, Trec_not, Exported))
+    units_with_ids
+
+let package_units initial_env objfiles cmifile modulename =
+  (* Read the signatures of the units *)
+  let units =
+    List.map
+      (fun f ->
+         let pref = chop_extensions f in
+         let modname = String.capitalize_ascii(Filename.basename pref) in
+         let sg = Env.read_signature modname (pref ^ ".cmi") in
+         if Filename.check_suffix f ".cmi" &&
+            not(Mtype.no_code_needed_sig Env.initial_safe_string sg)
+         then raise(Error(Location.none, Env.empty,
+                          Implementation_is_required f));
+         (modname, Env.read_signature modname (pref ^ ".cmi")))
+      objfiles in
+  (* Compute signature of packaged unit *)
+  Ident.reinit();
+  let sg = package_signatures units in
+  (* See if explicit interface is provided *)
+  let prefix = Filename.remove_extension cmifile in
+  let mlifile = prefix ^ !Config.interface_suffix in
+  if Sys.file_exists mlifile then begin
+    if not (Sys.file_exists cmifile) then begin
+      raise(Error(Location.in_file mlifile, Env.empty,
+                  Interface_not_compiled mlifile))
+    end;
+    let dclsig = Env.read_signature modulename cmifile in
+    Cmt_format.save_cmt  (prefix ^ ".cmt") modulename
+      (Cmt_format.Packed (sg, objfiles)) None initial_env  None ;
+    Includemod.compunit initial_env "(obtained by packing)" sg mlifile dclsig
+  end else begin
+    (* Determine imports *)
+    let unit_names = List.map fst units in
+    let imports =
+      List.filter
+        (fun (name, _crc) -> not (List.mem name unit_names))
+        (Env.imports()) in
+    (* Write packaged signature *)
+    if not !Clflags.dont_write_files then begin
+      let cmi =
+        Env.save_signature_with_imports ~alerts:String.Map.empty
+          sg modulename
+          (prefix ^ ".cmi") imports
+      in
+      Cmt_format.save_cmt (prefix ^ ".cmt")  modulename
+        (Cmt_format.Packed (cmi.Cmi_format.cmi_sign, objfiles)) None initial_env
+        (Some cmi)
+    end;
+    Tcoerce_none
+  end
+
+(* Error report *)
+
+open Printtyp
+
+let report_error ppf = function
+    Cannot_apply mty ->
+      fprintf ppf
+        "@[This module is not a functor; it has type@ %a@]" modtype mty
+  | Not_included errs ->
+      fprintf ppf
+        "@[<v>Signature mismatch:@ %a@]" Includemod.report_error errs
+  | Cannot_eliminate_dependency mty ->
+      fprintf ppf
+        "@[This functor has type@ %a@ \
+           The parameter cannot be eliminated in the result type.@ \
+           Please bind the argument to a module identifier.@]" modtype mty
+  | Signature_expected -> fprintf ppf "This module type is not a signature"
+  | Structure_expected mty ->
+      fprintf ppf
+        "@[This module is not a structure; it has type@ %a" modtype mty
+  | With_no_component lid ->
+      fprintf ppf
+        "@[The signature constrained by `with' has no component named %a@]"
+        longident lid
+  | With_mismatch(lid, explanation) ->
+      fprintf ppf
+        "@[<v>\
+           @[In this `with' constraint, the new definition of %a@ \
+             does not match its original definition@ \
+             in the constrained signature:@]@ \
+           %a@]"
+        longident lid Includemod.report_error explanation
+  | With_makes_applicative_functor_ill_typed(lid, path, explanation) ->
+      fprintf ppf
+        "@[<v>\
+           @[This `with' constraint on %a makes the applicative functor @ \
+             type %s ill-typed in the constrained signature:@]@ \
+           %a@]"
+        longident lid (Path.name path) Includemod.report_error explanation
+  | With_changes_module_alias(lid, id, path) ->
+      fprintf ppf
+        "@[<v>\
+           @[This `with' constraint on %a changes %s, which is aliased @ \
+             in the constrained signature (as %s)@].@]"
+        longident lid (Path.name path) (Ident.name id)
+  | With_cannot_remove_constrained_type ->
+      fprintf ppf
+        "@[<v>Destructive substitutions are not supported for constrained @ \
+              types (other than when replacing a type constructor with @ \
+              a type constructor with the same arguments).@]"
+  | Repeated_name(kind, name) ->
+      fprintf ppf
+        "@[Multiple definition of the %s name %s.@ \
+         Names must be unique in a given structure or signature.@]"
+        (Sig_component_kind.to_string kind) name
+  | Non_generalizable typ ->
+      fprintf ppf
+        "@[The type of this expression,@ %a,@ \
+           contains type variables that cannot be generalized@]" type_scheme typ
+  | Non_generalizable_class (id, desc) ->
+      fprintf ppf
+        "@[The type of this class,@ %a,@ \
+           contains type variables that cannot be generalized@]"
+        (class_declaration id) desc
+  | Non_generalizable_module mty ->
+      fprintf ppf
+        "@[The type of this module,@ %a,@ \
+           contains type variables that cannot be generalized@]" modtype mty
+  | Implementation_is_required intf_name ->
+      fprintf ppf
+        "@[The interface %a@ declares values, not just types.@ \
+           An implementation must be provided.@]"
+        Location.print_filename intf_name
+  | Interface_not_compiled intf_name ->
+      fprintf ppf
+        "@[Could not find the .cmi file for interface@ %a.@]"
+        Location.print_filename intf_name
+  | Not_allowed_in_functor_body ->
+      fprintf ppf
+        "@[This expression creates fresh types.@ %s@]"
+        "It is not allowed inside applicative functors."
+  | Not_a_packed_module ty ->
+      fprintf ppf
+        "This expression is not a packed module. It has type@ %a"
+        type_expr ty
+  | Incomplete_packed_module ty ->
+      fprintf ppf
+        "The type of this packed module contains variables:@ %a"
+        type_expr ty
+  | Scoping_pack (lid, ty) ->
+      fprintf ppf
+        "The type %a in this module cannot be exported.@ " longident lid;
+      fprintf ppf
+        "Its type contains local dependencies:@ %a" type_expr ty
+  | Recursive_module_require_explicit_type ->
+      fprintf ppf "Recursive modules require an explicit module type."
+  | Apply_generative ->
+      fprintf ppf "This is a generative functor. It can only be applied to ()"
+  | Cannot_scrape_alias p ->
+      fprintf ppf
+        "This is an alias for module %a, which is missing"
+        path p
+  | Badly_formed_signature (context, err) ->
+      fprintf ppf "@[In %s:@ %a@]" context Typedecl.report_error err
+  | Cannot_hide_id Illegal_shadowing
+      { shadowed_item_kind; shadowed_item_id; shadowed_item_loc;
+        shadower_id; user_id; user_kind; user_loc } ->
+      let shadowed_item_kind= Sig_component_kind.to_string shadowed_item_kind in
+      fprintf ppf
+        "@[<v>Illegal shadowing of included %s %a by %a@ \
+         %a:@;<1 2>%s %a came from this include@ \
+         %a:@;<1 2>The %s %s has no valid type if %a is shadowed@]"
+        shadowed_item_kind Ident.print shadowed_item_id Ident.print shadower_id
+        Location.print_loc shadowed_item_loc
+        (String.capitalize_ascii shadowed_item_kind)
+        Ident.print shadowed_item_id
+        Location.print_loc user_loc
+        (Sig_component_kind.to_string user_kind) (Ident.name user_id)
+        Ident.print shadowed_item_id
+  | Cannot_hide_id Appears_in_signature
+      { opened_item_kind; opened_item_id; user_id; user_kind; user_loc } ->
+      let opened_item_kind= Sig_component_kind.to_string opened_item_kind in
+      fprintf ppf
+        "@[<v>The %s %a introduced by this open appears in the signature@ \
+         %a:@;<1 2>The %s %s has no valid type if %a is hidden@]"
+        opened_item_kind Ident.print opened_item_id
+        Location.print_loc user_loc
+        (Sig_component_kind.to_string user_kind) (Ident.name user_id)
+        Ident.print opened_item_id
+  | Invalid_type_subst_rhs ->
+      fprintf ppf "Only type synonyms are allowed on the right of :="
+
+let report_error env ppf err =
+  Printtyp.wrap_printing_env ~error:true env (fun () -> report_error ppf err)
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, env, err) ->
+        Some (Location.error_of_printer ~loc (report_error env) err)
+      | Error_forward err ->
+        Some err
+      | _ ->
+        None
+    )
diff --git a/src/ocaml/typing/410+multicore/typemod.mli b/src/ocaml/typing/410+multicore/typemod.mli
new file mode 100644
index 00000000..55896a13
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typemod.mli
@@ -0,0 +1,146 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Type-checking of the module language and typed ast hooks
+
+  {b Warning:} this module is unstable and part of
+  {{!Compiler_libs}compiler-libs}.
+
+*)
+
+open Types
+open Format
+
+module Signature_names : sig
+  type t
+
+  val simplify: Env.t -> t -> signature -> signature
+end
+
+val type_module:
+        Env.t -> Parsetree.module_expr -> Typedtree.module_expr
+val type_structure:
+  Env.t -> Parsetree.structure -> Location.t ->
+  Typedtree.structure * Types.signature * Signature_names.t * Env.t
+val type_toplevel_phrase:
+  Env.t -> Parsetree.structure ->
+  Typedtree.structure * Types.signature * (* Signature_names.t * *) Env.t
+val type_implementation:
+  string -> string -> string -> Env.t -> Parsetree.structure ->
+  Typedtree.structure * Typedtree.module_coercion
+val type_interface:
+        Env.t -> Parsetree.signature -> Typedtree.signature
+val transl_signature:
+        Env.t -> Parsetree.signature -> Typedtree.signature
+val check_nongen_schemes:
+        Env.t -> Types.signature -> unit
+val type_open_:
+        ?used_slot:bool ref -> ?toplevel:bool ->
+        Asttypes.override_flag ->
+        Env.t -> Location.t -> Longident.t Asttypes.loc -> Path.t * Env.t
+val modtype_of_package:
+        Env.t -> Location.t ->
+        Path.t -> Longident.t list -> type_expr list -> module_type
+
+val path_of_module : Typedtree.module_expr -> Path.t option
+
+val save_signature:
+  string -> Typedtree.signature -> string -> string ->
+  Env.t -> Cmi_format.cmi_infos -> unit
+
+val package_units:
+  Env.t -> string list -> string -> string -> Typedtree.module_coercion
+
+(* Should be in Envaux, but it breaks the build of the debugger *)
+val initial_env:
+  loc:Location.t -> safe_string:bool ->
+  initially_opened_module:string option ->
+  open_implicit_modules:string list -> Env.t
+
+module Sig_component_kind : sig
+  type t =
+    | Value
+    | Type
+    | Module
+    | Module_type
+    | Extension_constructor
+    | Class
+    | Class_type
+
+  val to_string : t -> string
+end
+
+type hiding_error =
+  | Illegal_shadowing of {
+      shadowed_item_id: Ident.t;
+      shadowed_item_kind: Sig_component_kind.t;
+      shadowed_item_loc: Location.t;
+      shadower_id: Ident.t;
+      user_id: Ident.t;
+      user_kind: Sig_component_kind.t;
+      user_loc: Location.t;
+    }
+  | Appears_in_signature of {
+      opened_item_id: Ident.t;
+      opened_item_kind: Sig_component_kind.t;
+      user_id: Ident.t;
+      user_kind: Sig_component_kind.t;
+      user_loc: Location.t;
+    }
+
+type error =
+    Cannot_apply of module_type
+  | Not_included of Includemod.error list
+  | Cannot_eliminate_dependency of module_type
+  | Signature_expected
+  | Structure_expected of module_type
+  | With_no_component of Longident.t
+  | With_mismatch of Longident.t * Includemod.error list
+  | With_makes_applicative_functor_ill_typed of
+      Longident.t * Path.t * Includemod.error list
+  | With_changes_module_alias of Longident.t * Ident.t * Path.t
+  | With_cannot_remove_constrained_type
+  | Repeated_name of Sig_component_kind.t * string
+  | Non_generalizable of type_expr
+  | Non_generalizable_class of Ident.t * class_declaration
+  | Non_generalizable_module of module_type
+  | Implementation_is_required of string
+  | Interface_not_compiled of string
+  | Not_allowed_in_functor_body
+  | Not_a_packed_module of type_expr
+  | Incomplete_packed_module of type_expr
+  | Scoping_pack of Longident.t * type_expr
+  | Recursive_module_require_explicit_type
+  | Apply_generative
+  | Cannot_scrape_alias of Path.t
+  | Badly_formed_signature of string * Typedecl.error
+  | Cannot_hide_id of hiding_error
+  | Invalid_type_subst_rhs
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+val report_error: Env.t -> formatter -> error -> unit
+
+(* merlin *)
+
+val normalize_signature : Env.t -> Types.signature -> unit
+
+val merlin_type_structure:
+  Env.t -> Parsetree.structure -> Location.t ->
+  Typedtree.structure * Types.signature * (* Signature_names.t * *) Env.t
+
+val merlin_transl_signature:
+  Env.t -> Parsetree.signature -> Typedtree.signature
diff --git a/src/ocaml/typing/410+multicore/typeopt.ml b/src/ocaml/typing/410+multicore/typeopt.ml
new file mode 100644
index 00000000..8cd3210a
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typeopt.ml
@@ -0,0 +1,140 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1998 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Auxiliaries for type-based optimizations, e.g. array kinds *)
+
+open Types
+open Asttypes
+open Typedtree
+
+let scrape_ty env ty =
+  let ty = Ctype.expand_head_opt env (Ctype.correct_levels ty) in
+  match ty.desc with
+  | Tconstr (p, _, _) ->
+      begin match Env.find_type p env with
+      | {type_unboxed = {unboxed = true; _}; _} ->
+        begin match Typedecl.get_unboxed_type_representation env ty with
+        | None -> ty
+        | Some ty2 -> ty2
+        end
+      | _ -> ty
+      | exception Not_found -> ty
+      end
+  | _ -> ty
+
+let scrape env ty =
+  (scrape_ty env ty).desc
+
+let is_function_type env ty =
+  match scrape env ty with
+  | Tarrow (_, lhs, rhs, _) -> Some (lhs, rhs)
+  | _ -> None
+
+let is_base_type env ty base_ty_path =
+  match scrape env ty with
+  | Tconstr(p, _, _) -> Path.same p base_ty_path
+  | _ -> false
+
+(*
+let maybe_pointer_type env ty =
+  let ty = scrape_ty env ty in
+  if Ctype.maybe_pointer_type env ty then
+    Pointer
+  else
+    Immediate
+*)
+
+(* let maybe_pointer exp = maybe_pointer_type exp.exp_env exp.exp_type *)
+
+type classification =
+  | Int
+  | Float
+  | Lazy
+  | Addr  (* anything except a float or a lazy *)
+  | Any
+
+let classify env ty =
+  let ty = scrape_ty env ty in
+  if not (Ctype.maybe_pointer_type env ty) then Int
+  else match ty.desc with
+  | Tvar _ | Tunivar _ ->
+      Any
+  | Tconstr (p, _args, _abbrev) ->
+      if Path.same p Predef.path_float then Float
+      else if Path.same p Predef.path_lazy_t then Lazy
+      else if Path.same p Predef.path_string
+           || Path.same p Predef.path_bytes
+           || Path.same p Predef.path_array
+           || Path.same p Predef.path_nativeint
+           || Path.same p Predef.path_int32
+           || Path.same p Predef.path_int64 then Addr
+      else begin
+        try
+          match (Env.find_type p env).type_kind with
+          | Type_abstract ->
+              Any
+          | Type_record _ | Type_variant _ | Type_open ->
+              Addr
+        with Not_found ->
+          (* This can happen due to e.g. missing -I options,
+             causing some .cmi files to be unavailable.
+             Maybe we should emit a warning. *)
+          Any
+      end
+  | Tarrow _ | Ttuple _ | Tpackage _ | Tobject _ | Tnil | Tvariant _ ->
+      Addr
+  | Tlink _ | Tsubst _ | Tpoly _ | Tfield _ ->
+      assert false
+
+(*
+let function_return_value_kind env ty =
+  match is_function_type env ty with
+  | Some (_lhs, rhs) -> value_kind env rhs
+  | None -> Pgenval
+*)
+
+(** Whether a forward block is needed for a lazy thunk on a value, i.e.
+    if the value can be represented as a float/forward/lazy *)
+let lazy_val_requires_forward env ty =
+  match classify env ty with
+  | Any | Lazy -> true
+  | Float -> false (* TODO: Config.flat_float_array *)
+  | Addr | Int -> false
+
+(** The compilation of the expression [lazy e] depends on the form of e:
+    constants, floats and identifiers are optimized.  The optimization must be
+    taken into account when determining whether a recursive binding is safe. *)
+let classify_lazy_argument : Typedtree.expression ->
+                             [`Constant_or_function
+                             |`Float_that_cannot_be_shortcut
+                             |`Identifier of [`Forward_value|`Other]
+                             |`Other] =
+  fun e -> match e.exp_desc with
+    | Texp_constant
+        ( Const_int _ | Const_char _ | Const_string _
+        | Const_int32 _ | Const_int64 _ | Const_nativeint _ )
+    | Texp_function _
+    | Texp_construct (_, {cstr_arity = 0}, _) ->
+       `Constant_or_function
+    | Texp_constant(Const_float _) ->
+      (* TODO: handle flat float array, either at configure time or from the
+         .merlin. *)
+       `Constant_or_function
+    | Texp_ident _ when lazy_val_requires_forward e.exp_env e.exp_type ->
+       `Identifier `Forward_value
+    | Texp_ident _ ->
+       `Identifier `Other
+    | _ ->
+       `Other
diff --git a/src/ocaml/typing/410+multicore/typeopt.mli b/src/ocaml/typing/410+multicore/typeopt.mli
new file mode 100644
index 00000000..e3d4c791
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typeopt.mli
@@ -0,0 +1,26 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1998 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Auxiliaries for type-based optimizations, e.g. array kinds *)
+
+val is_function_type :
+      Env.t -> Types.type_expr -> (Types.type_expr * Types.type_expr) option
+val is_base_type : Env.t -> Types.type_expr -> Path.t -> bool
+
+val classify_lazy_argument : Typedtree.expression ->
+                             [ `Constant_or_function
+                             | `Float_that_cannot_be_shortcut
+                             | `Identifier of [`Forward_value | `Other]
+                             | `Other]
diff --git a/src/ocaml/typing/410+multicore/types.ml b/src/ocaml/typing/410+multicore/types.ml
new file mode 100644
index 00000000..d941c901
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/types.ml
@@ -0,0 +1,385 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Representation of types and declarations *)
+
+open Asttypes
+
+(* Type expressions for the core language *)
+
+type type_expr =
+  { mutable desc: type_desc;
+    mutable level: int;
+    mutable scope: int;
+    id: int }
+
+and type_desc =
+    Tvar of string option
+  | Tarrow of arg_label * type_expr * type_expr * commutable
+  | Ttuple of type_expr list
+  | Tconstr of Path.t * type_expr list * abbrev_memo ref
+  | Tobject of type_expr * (Path.t * type_expr list) option ref
+  | Tfield of string * field_kind * type_expr * type_expr
+  | Tnil
+  | Tlink of type_expr
+  | Tsubst of type_expr         (* for copying *)
+  | Tvariant of row_desc
+  | Tunivar of string option
+  | Tpoly of type_expr * type_expr list
+  | Tpackage of Path.t * Longident.t list * type_expr list
+
+and row_desc =
+    { row_fields: (label * row_field) list;
+      row_more: type_expr;
+      row_bound: unit;
+      row_closed: bool;
+      row_fixed: fixed_explanation option;
+      row_name: (Path.t * type_expr list) option }
+and fixed_explanation =
+  | Univar of type_expr | Fixed_private | Reified of Path.t | Rigid
+and row_field =
+    Rpresent of type_expr option
+  | Reither of bool * type_expr list * bool * row_field option ref
+        (* 1st true denotes a constant constructor *)
+        (* 2nd true denotes a tag in a pattern matching, and
+           is erased later *)
+  | Rabsent
+
+and abbrev_memo =
+    Mnil
+  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
+  | Mlink of abbrev_memo ref
+
+and field_kind =
+    Fvar of field_kind option ref
+  | Fpresent
+  | Fabsent
+
+and commutable =
+    Cok
+  | Cunknown
+  | Clink of commutable ref
+
+module TypeOps = struct
+  type t = type_expr
+  let compare t1 t2 = t1.id - t2.id
+  let hash t = t.id
+  let equal t1 t2 = t1 == t2
+end
+
+(* Maps of methods and instance variables *)
+
+module Meths = Misc.String.Map
+module Vars = Meths
+
+(* Value descriptions *)
+
+type value_description =
+  { val_type: type_expr;                (* Type of the value *)
+    val_kind: value_kind;
+    val_loc: Location.t;
+    val_attributes: Parsetree.attributes;
+ }
+
+and value_kind =
+    Val_reg                             (* Regular value *)
+  | Val_prim of Primitive.description   (* Primitive *)
+  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
+  | Val_self of (Ident.t * type_expr) Meths.t ref *
+                (Ident.t * Asttypes.mutable_flag *
+                 Asttypes.virtual_flag * type_expr) Vars.t ref *
+                string * type_expr
+                                        (* Self *)
+  | Val_anc of (string * Ident.t) list * string
+                                        (* Ancestor *)
+
+(* Variance *)
+
+module Variance = struct
+  type t = int
+  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
+  let single = function
+    | May_pos -> 1
+    | May_neg -> 2
+    | May_weak -> 4
+    | Inj -> 8
+    | Pos -> 16
+    | Neg -> 32
+    | Inv -> 64
+  let union v1 v2 = v1 lor v2
+  let inter v1 v2 = v1 land v2
+  let subset v1 v2 = (v1 land v2 = v1)
+  let eq (v1 : t) v2 = (v1 = v2)
+  let set x b v =
+    if b then v lor single x else  v land (lnot (single x))
+  let mem x = subset (single x)
+  let null = 0
+  let may_inv = 7
+  let full = 127
+  let covariant = single May_pos lor single Pos lor single Inj
+  let swap f1 f2 v =
+    let v' = set f1 (mem f2 v) v in set f2 (mem f1 v) v'
+  let conjugate v = swap May_pos May_neg (swap Pos Neg v)
+  let get_upper v = (mem May_pos v, mem May_neg v)
+  let get_lower v = (mem Pos v, mem Neg v, mem Inv v, mem Inj v)
+end
+
+(* Type definitions *)
+
+type type_declaration =
+  { type_params: type_expr list;
+    type_arity: int;
+    type_kind: type_kind;
+    type_private: private_flag;
+    type_manifest: type_expr option;
+    type_variance: Variance.t list;
+    type_is_newtype: bool;
+    type_expansion_scope: int;
+    type_loc: Location.t;
+    type_attributes: Parsetree.attributes;
+    type_immediate: Type_immediacy.t;
+    type_unboxed: unboxed_status;
+ }
+
+and type_kind =
+    Type_abstract
+  | Type_record of label_declaration list  * record_representation
+  | Type_variant of constructor_declaration list
+  | Type_open
+
+and record_representation =
+    Record_regular                      (* All fields are boxed / tagged *)
+  | Record_float                        (* All fields are floats *)
+  | Record_unboxed of bool    (* Unboxed single-field record, inlined or not *)
+  | Record_inlined of int               (* Inlined record *)
+  | Record_extension of Path.t          (* Inlined record under extension *)
+
+and label_declaration =
+  {
+    ld_id: Ident.t;
+    ld_mutable: mutable_flag;
+    ld_type: type_expr;
+    ld_loc: Location.t;
+    ld_attributes: Parsetree.attributes;
+  }
+
+and constructor_declaration =
+  {
+    cd_id: Ident.t;
+    cd_args: constructor_arguments;
+    cd_res: type_expr option;
+    cd_loc: Location.t;
+    cd_attributes: Parsetree.attributes;
+  }
+
+and constructor_arguments =
+  | Cstr_tuple of type_expr list
+  | Cstr_record of label_declaration list
+
+and unboxed_status =
+  {
+    unboxed: bool;
+    default: bool; (* False if the unboxed field was set from an attribute. *)
+  }
+
+let unboxed_false_default_false = {unboxed = false; default = false}
+let unboxed_false_default_true = {unboxed = false; default = true}
+let unboxed_true_default_false = {unboxed = true; default = false}
+let unboxed_true_default_true = {unboxed = true; default = true}
+
+type extension_constructor =
+    { ext_type_path: Path.t;
+      ext_type_params: type_expr list;
+      ext_args: constructor_arguments;
+      ext_ret_type: type_expr option;
+      ext_private: private_flag;
+      ext_loc: Location.t;
+      ext_attributes: Parsetree.attributes; }
+
+and type_transparence =
+    Type_public      (* unrestricted expansion *)
+  | Type_new         (* "new" type *)
+  | Type_private     (* private type *)
+
+(* Type expressions for the class language *)
+
+module Concr = Misc.String.Set
+
+type class_type =
+    Cty_constr of Path.t * type_expr list * class_type
+  | Cty_signature of class_signature
+  | Cty_arrow of arg_label * type_expr * class_type
+
+and class_signature =
+  { csig_self: type_expr;
+    csig_vars:
+      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
+    csig_concr: Concr.t;
+    csig_inher: (Path.t * type_expr list) list }
+
+type class_declaration =
+  { cty_params: type_expr list;
+    mutable cty_type: class_type;
+    cty_path: Path.t;
+    cty_new: type_expr option;
+    cty_variance: Variance.t list;
+    cty_loc: Location.t;
+    cty_attributes: Parsetree.attributes;
+ }
+
+type class_type_declaration =
+  { clty_params: type_expr list;
+    clty_type: class_type;
+    clty_path: Path.t;
+    clty_variance: Variance.t list;
+    clty_loc: Location.t;
+    clty_attributes: Parsetree.attributes;
+  }
+
+(* Type expressions for the module language *)
+
+type visibility =
+  | Exported
+  | Hidden
+
+type module_type =
+    Mty_ident of Path.t
+  | Mty_signature of signature
+  | Mty_functor of functor_parameter * module_type
+  | Mty_alias of Path.t
+
+and functor_parameter =
+  | Unit
+  | Named of Ident.t option * module_type
+
+and module_presence =
+  | Mp_present
+  | Mp_absent
+
+and signature = signature_item list
+
+and signature_item =
+    Sig_value of Ident.t * value_description * visibility
+  | Sig_type of Ident.t * type_declaration * rec_status * visibility
+  | Sig_typext of Ident.t * extension_constructor * ext_status * visibility
+  | Sig_module of
+      Ident.t * module_presence * module_declaration * rec_status * visibility
+  | Sig_modtype of Ident.t * modtype_declaration * visibility
+  | Sig_class of Ident.t * class_declaration * rec_status * visibility
+  | Sig_class_type of Ident.t * class_type_declaration * rec_status * visibility
+
+and module_declaration =
+  {
+    md_type: module_type;
+    md_attributes: Parsetree.attributes;
+    md_loc: Location.t;
+  }
+
+and modtype_declaration =
+  {
+    mtd_type: module_type option;  (* Note: abstract *)
+    mtd_attributes: Parsetree.attributes;
+    mtd_loc: Location.t;
+  }
+
+and rec_status =
+    Trec_not                   (* first in a nonrecursive group *)
+  | Trec_first                 (* first in a recursive group *)
+  | Trec_next                  (* not first in a recursive/nonrecursive group *)
+
+and ext_status =
+    Text_first                     (* first constructor of an extension *)
+  | Text_next                      (* not first constructor of an extension *)
+  | Text_exception                 (* an exception *)
+
+
+(* Constructor and record label descriptions inserted held in typing
+   environments *)
+
+type constructor_description =
+  { cstr_name: string;                  (* Constructor name *)
+    cstr_res: type_expr;                (* Type of the result *)
+    cstr_existentials: type_expr list;  (* list of existentials *)
+    cstr_args: type_expr list;          (* Type of the arguments *)
+    cstr_arity: int;                    (* Number of arguments *)
+    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
+    cstr_consts: int;                   (* Number of constant constructors *)
+    cstr_nonconsts: int;                (* Number of non-const constructors *)
+    cstr_normal: int;                   (* Number of non generalized constrs *)
+    cstr_generalized: bool;             (* Constrained return type? *)
+    cstr_private: private_flag;         (* Read-only constructor? *)
+    cstr_loc: Location.t;
+    cstr_attributes: Parsetree.attributes;
+    cstr_inlined: type_declaration option;
+   }
+
+and constructor_tag =
+    Cstr_constant of int                (* Constant constructor (an int) *)
+  | Cstr_block of int                   (* Regular constructor (a block) *)
+  | Cstr_unboxed                        (* Constructor of an unboxed type *)
+  | Cstr_extension of Path.t * bool     (* Extension constructor
+                                           true if a constant false if a block*)
+
+let equal_tag t1 t2 =
+  match (t1, t2) with
+  | Cstr_constant i1, Cstr_constant i2 -> i2 = i1
+  | Cstr_block i1, Cstr_block i2 -> i2 = i1
+  | Cstr_unboxed, Cstr_unboxed -> true
+  | Cstr_extension (path1, b1), Cstr_extension (path2, b2) ->
+      Path.same path1 path2 && b1 = b2
+  | (Cstr_constant _|Cstr_block _|Cstr_unboxed|Cstr_extension _), _ -> false
+
+let may_equal_constr c1 c2 = match c1.cstr_tag,c2.cstr_tag with
+| Cstr_extension _,Cstr_extension _ -> c1.cstr_arity = c2.cstr_arity
+| tag1,tag2 -> equal_tag tag1 tag2
+
+type label_description =
+  { lbl_name: string;                   (* Short name *)
+    lbl_res: type_expr;                 (* Type of the result *)
+    lbl_arg: type_expr;                 (* Type of the argument *)
+    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
+    lbl_pos: int;                       (* Position in block *)
+    lbl_all: label_description array;   (* All the labels in this type *)
+    lbl_repres: record_representation;  (* Representation for this record *)
+    lbl_private: private_flag;          (* Read-only field? *)
+    lbl_loc: Location.t;
+    lbl_attributes: Parsetree.attributes;
+   }
+
+let rec bound_value_identifiers = function
+    [] -> []
+  | Sig_value(id, {val_kind = Val_reg}, _) :: rem ->
+      id :: bound_value_identifiers rem
+  | Sig_typext(id, _, _, _) :: rem -> id :: bound_value_identifiers rem
+  | Sig_module(id, Mp_present, _, _, _) :: rem ->
+      id :: bound_value_identifiers rem
+  | Sig_class(id, _, _, _) :: rem -> id :: bound_value_identifiers rem
+  | _ :: rem -> bound_value_identifiers rem
+
+let signature_item_id = function
+  | Sig_value (id, _, _)
+  | Sig_type (id, _, _, _)
+  | Sig_typext (id, _, _, _)
+  | Sig_module (id, _, _, _, _)
+  | Sig_modtype (id, _, _)
+  | Sig_class (id, _, _, _)
+  | Sig_class_type (id, _, _, _)
+    -> id
+
+(* Merlin specific *)
+
+let unpack_functor = function
+  | Mty_functor (fp, mty) -> fp, mty
+  | _ -> invalid_arg "Types.unpack_functor (merlin)"
diff --git a/src/ocaml/typing/410+multicore/types.mli b/src/ocaml/typing/410+multicore/types.mli
new file mode 100644
index 00000000..47ced5e4
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/types.mli
@@ -0,0 +1,520 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** {0 Representation of types and declarations} *)
+
+(** [Types] defines the representation of types and declarations (that is, the
+    content of module signatures).
+
+    CMI files are made of marshalled types.
+*)
+
+(** Asttypes exposes basic definitions shared both by Parsetree and Types. *)
+open Asttypes
+
+(** Type expressions for the core language.
+
+    The [type_desc] variant defines all the possible type expressions one can
+    find in OCaml. [type_expr] wraps this with some annotations.
+
+    The [level] field tracks the level of polymorphism associated to a type,
+    guiding the generalization algorithm.
+    Put shortly, when referring to a type in a given environment, both the type
+    and the environment have a level. If the type has an higher level, then it
+    can be considered fully polymorphic (type variables will be printed as
+    ['a]), otherwise it'll be weakly polymorphic, or non generalized (type
+    variables printed as ['_a]).
+    See [http://okmij.org/ftp/ML/generalization.html] for more information.
+
+    Note about [type_declaration]: one should not make the confusion between
+    [type_expr] and [type_declaration].
+
+    [type_declaration] refers specifically to the [type] construct in OCaml
+    language, where you create and name a new type or type alias.
+
+    [type_expr] is used when you refer to existing types, e.g. when annotating
+    the expected type of a value.
+
+    Also, as the type system of OCaml is generative, a [type_declaration] can
+    have the side-effect of introducing a new type constructor, different from
+    all other known types.
+    Whereas [type_expr] is a pure construct which allows referring to existing
+    types.
+
+    Note on mutability: TBD.
+ *)
+type type_expr =
+  { mutable desc: type_desc;
+    mutable level: int;
+    mutable scope: int;
+    id: int }
+
+and type_desc =
+  | Tvar of string option
+  (** [Tvar (Some "a")] ==> ['a] or ['_a]
+      [Tvar None]       ==> [_] *)
+
+  | Tarrow of arg_label * type_expr * type_expr * commutable
+  (** [Tarrow (Nolabel,      e1, e2, c)] ==> [e1    -> e2]
+      [Tarrow (Labelled "l", e1, e2, c)] ==> [l:e1  -> e2]
+      [Tarrow (Optional "l", e1, e2, c)] ==> [?l:e1 -> e2]
+
+      See [commutable] for the last argument. *)
+
+  | Ttuple of type_expr list
+  (** [Ttuple [t1;...;tn]] ==> [(t1 * ... * tn)] *)
+
+  | Tconstr of Path.t * type_expr list * abbrev_memo ref
+  (** [Tconstr (`A.B.t', [t1;...;tn], _)] ==> [(t1,...,tn) A.B.t]
+      The last parameter keep tracks of known expansions, see [abbrev_memo]. *)
+
+  | Tobject of type_expr * (Path.t * type_expr list) option ref
+  (** [Tobject (`f1:t1;...;fn: tn', `None')] ==> [< f1: t1; ...; fn: tn >]
+      f1, fn are represented as a linked list of types using Tfield and Tnil
+      constructors.
+
+      [Tobject (_, `Some (`A.ct', [t1;...;tn]')] ==> [(t1, ..., tn) A.ct].
+      where A.ct is the type of some class.
+
+      There are also special cases for so-called "class-types", cf. [Typeclass]
+      and [Ctype.set_object_name]:
+
+        [Tobject (Tfield(_,_,...(Tfield(_,_,rv)...),
+                         Some(`A.#ct`, [rv;t1;...;tn])]
+             ==> [(t1, ..., tn) #A.ct]
+        [Tobject (_, Some(`A.#ct`, [Tnil;t1;...;tn])] ==> [(t1, ..., tn) A.ct]
+
+      where [rv] is the hidden row variable.
+  *)
+
+  | Tfield of string * field_kind * type_expr * type_expr
+  (** [Tfield ("foo", Fpresent, t, ts)] ==> [<...; foo : t; ts>] *)
+
+  | Tnil
+  (** [Tnil] ==> [<...; >] *)
+
+  | Tlink of type_expr
+  (** Indirection used by unification engine. *)
+
+  | Tsubst of type_expr         (* for copying *)
+  (** [Tsubst] is used temporarily to store information in low-level
+      functions manipulating representation of types, such as
+      instantiation or copy.
+      This constructor should not appear outside of these cases. *)
+
+  | Tvariant of row_desc
+  (** Representation of polymorphic variants, see [row_desc]. *)
+
+  | Tunivar of string option
+  (** Occurrence of a type variable introduced by a
+      forall quantifier / [Tpoly]. *)
+
+  | Tpoly of type_expr * type_expr list
+  (** [Tpoly (ty,tyl)] ==> ['a1... 'an. ty],
+      where 'a1 ... 'an are names given to types in tyl
+      and occurrences of those types in ty. *)
+
+  | Tpackage of Path.t * Longident.t list * type_expr list
+  (** Type of a first-class module (a.k.a package). *)
+
+(** [  `X | `Y ]       (row_closed = true)
+    [< `X | `Y ]       (row_closed = true)
+    [> `X | `Y ]       (row_closed = false)
+    [< `X | `Y > `X ]  (row_closed = true)
+
+    type t = [> `X ] as 'a      (row_more = Tvar a)
+    type t = private [> `X ]    (row_more = Tconstr (t#row, [], ref Mnil))
+
+    And for:
+
+        let f = function `X -> `X -> | `Y -> `X
+
+    the type of "f" will be a [Tarrow] whose lhs will (basically) be:
+
+        Tvariant { row_fields = [("X", _)];
+                   row_more   =
+                     Tvariant { row_fields = [("Y", _)];
+                                row_more   =
+                                  Tvariant { row_fields = [];
+                                             row_more   = _;
+                                             _ };
+                                _ };
+                   _
+                 }
+
+*)
+and row_desc =
+    { row_fields: (label * row_field) list;
+      row_more: type_expr;
+      row_bound: unit; (* kept for compatibility *)
+      row_closed: bool;
+      row_fixed: fixed_explanation option;
+      row_name: (Path.t * type_expr list) option }
+and fixed_explanation =
+  | Univar of type_expr (** The row type was bound to an univar *)
+  | Fixed_private (** The row type is private *)
+  | Reified of Path.t (** The row was reified *)
+  | Rigid (** The row type was made rigid during constraint verification *)
+and row_field =
+    Rpresent of type_expr option
+  | Reither of bool * type_expr list * bool * row_field option ref
+        (* 1st true denotes a constant constructor *)
+        (* 2nd true denotes a tag in a pattern matching, and
+           is erased later *)
+  | Rabsent
+
+(** [abbrev_memo] allows one to keep track of different expansions of a type
+    alias. This is done for performance purposes.
+
+    For instance, when defining [type 'a pair = 'a * 'a], when one refers to an
+    ['a pair], it is just a shortcut for the ['a * 'a] type.
+    This expansion will be stored in the [abbrev_memo] of the corresponding
+    [Tconstr] node.
+
+    In practice, [abbrev_memo] behaves like list of expansions with a mutable
+    tail.
+
+    Note on marshalling: [abbrev_memo] must not appear in saved types.
+    [Btype], with [cleanup_abbrev] and [memo], takes care of tracking and
+    removing abbreviations.
+*)
+and abbrev_memo =
+  | Mnil (** No known abbreviation *)
+
+  | Mcons of private_flag * Path.t * type_expr * type_expr * abbrev_memo
+  (** Found one abbreviation.
+      A valid abbreviation should be at least as visible and reachable by the
+      same path.
+      The first expression is the abbreviation and the second the expansion. *)
+
+  | Mlink of abbrev_memo ref
+  (** Abbreviations can be found after this indirection *)
+
+and field_kind =
+    Fvar of field_kind option ref
+  | Fpresent
+  | Fabsent
+
+(** [commutable] is a flag appended to every arrow type.
+
+    When typing an application, if the type of the functional is
+    known, its type is instantiated with [Cok] arrows, otherwise as
+    [Clink (ref Cunknown)].
+
+    When the type is not known, the application will be used to infer
+    the actual type.  This is fragile in presence of labels where
+    there is no principal type.
+
+    Two incompatible applications relying on [Cunknown] arrows will
+    trigger an error.
+
+    let f g =
+      g ~a:() ~b:();
+      g ~b:() ~a:();
+
+    Error: This function is applied to arguments
+    in an order different from other calls.
+    This is only allowed when the real type is known.
+*)
+and commutable =
+    Cok
+  | Cunknown
+  | Clink of commutable ref
+
+module TypeOps : sig
+  type t = type_expr
+  val compare : t -> t -> int
+  val equal : t -> t -> bool
+  val hash : t -> int
+end
+
+(* Maps of methods and instance variables *)
+
+module Meths : Map.S with type key = string
+module Vars  : Map.S with type key = string
+
+(* Value descriptions *)
+
+type value_description =
+  { val_type: type_expr;                (* Type of the value *)
+    val_kind: value_kind;
+    val_loc: Location.t;
+    val_attributes: Parsetree.attributes;
+   }
+
+and value_kind =
+    Val_reg                             (* Regular value *)
+  | Val_prim of Primitive.description   (* Primitive *)
+  | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
+  | Val_self of (Ident.t * type_expr) Meths.t ref *
+                (Ident.t * mutable_flag * virtual_flag * type_expr) Vars.t ref *
+                string * type_expr
+                                        (* Self *)
+  | Val_anc of (string * Ident.t) list * string
+                                        (* Ancestor *)
+
+(* Variance *)
+
+module Variance : sig
+  type t
+  type f = May_pos | May_neg | May_weak | Inj | Pos | Neg | Inv
+  val null : t                          (* no occurrence *)
+  val full : t                          (* strictly invariant *)
+  val covariant : t                     (* strictly covariant *)
+  val may_inv : t                       (* maybe invariant *)
+  val union  : t -> t -> t
+  val inter  : t -> t -> t
+  val subset : t -> t -> bool
+  val eq : t -> t -> bool
+  val set : f -> bool -> t -> t
+  val mem : f -> t -> bool
+  val conjugate : t -> t                (* exchange positive and negative *)
+  val get_upper : t -> bool * bool                  (* may_pos, may_neg   *)
+  val get_lower : t -> bool * bool * bool * bool    (* pos, neg, inv, inj *)
+end
+
+(* Type definitions *)
+
+type type_declaration =
+  { type_params: type_expr list;
+    type_arity: int;
+    type_kind: type_kind;
+    type_private: private_flag;
+    type_manifest: type_expr option;
+    type_variance: Variance.t list;
+    (* covariant, contravariant, weakly contravariant, injective *)
+    type_is_newtype: bool;
+    type_expansion_scope: int;
+    type_loc: Location.t;
+    type_attributes: Parsetree.attributes;
+    type_immediate: Type_immediacy.t;
+    type_unboxed: unboxed_status;
+  }
+
+and type_kind =
+    Type_abstract
+  | Type_record of label_declaration list  * record_representation
+  | Type_variant of constructor_declaration list
+  | Type_open
+
+and record_representation =
+    Record_regular                      (* All fields are boxed / tagged *)
+  | Record_float                        (* All fields are floats *)
+  | Record_unboxed of bool    (* Unboxed single-field record, inlined or not *)
+  | Record_inlined of int               (* Inlined record *)
+  | Record_extension of Path.t          (* Inlined record under extension *)
+
+and label_declaration =
+  {
+    ld_id: Ident.t;
+    ld_mutable: mutable_flag;
+    ld_type: type_expr;
+    ld_loc: Location.t;
+    ld_attributes: Parsetree.attributes;
+  }
+
+and constructor_declaration =
+  {
+    cd_id: Ident.t;
+    cd_args: constructor_arguments;
+    cd_res: type_expr option;
+    cd_loc: Location.t;
+    cd_attributes: Parsetree.attributes;
+  }
+
+and constructor_arguments =
+  | Cstr_tuple of type_expr list
+  | Cstr_record of label_declaration list
+
+and unboxed_status = private
+  (* This type must be private in order to ensure perfect sharing of the
+     four possible values. Otherwise, ocamlc.byte and ocamlc.opt produce
+     different executables. *)
+  {
+    unboxed: bool;
+    default: bool; (* True for unannotated unboxable types. *)
+  }
+
+val unboxed_false_default_false : unboxed_status
+val unboxed_false_default_true : unboxed_status
+val unboxed_true_default_false : unboxed_status
+val unboxed_true_default_true : unboxed_status
+
+type extension_constructor =
+    {
+      ext_type_path: Path.t;
+      ext_type_params: type_expr list;
+      ext_args: constructor_arguments;
+      ext_ret_type: type_expr option;
+      ext_private: private_flag;
+      ext_loc: Location.t;
+      ext_attributes: Parsetree.attributes;
+    }
+
+and type_transparence =
+    Type_public      (* unrestricted expansion *)
+  | Type_new         (* "new" type *)
+  | Type_private     (* private type *)
+
+(* Type expressions for the class language *)
+
+module Concr : Set.S with type elt = string
+
+type class_type =
+    Cty_constr of Path.t * type_expr list * class_type
+  | Cty_signature of class_signature
+  | Cty_arrow of arg_label * type_expr * class_type
+
+and class_signature =
+  { csig_self: type_expr;
+    csig_vars:
+      (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
+    csig_concr: Concr.t;
+    csig_inher: (Path.t * type_expr list) list }
+
+type class_declaration =
+  { cty_params: type_expr list;
+    mutable cty_type: class_type;
+    cty_path: Path.t;
+    cty_new: type_expr option;
+    cty_variance: Variance.t list;
+    cty_loc: Location.t;
+    cty_attributes: Parsetree.attributes;
+  }
+
+type class_type_declaration =
+  { clty_params: type_expr list;
+    clty_type: class_type;
+    clty_path: Path.t;
+    clty_variance: Variance.t list;
+    clty_loc: Location.t;
+    clty_attributes: Parsetree.attributes;
+  }
+
+(* Type expressions for the module language *)
+
+type visibility =
+  | Exported
+  | Hidden
+
+type module_type =
+    Mty_ident of Path.t
+  | Mty_signature of signature
+  | Mty_functor of functor_parameter * module_type
+  | Mty_alias of Path.t
+
+and functor_parameter =
+  | Unit
+  | Named of Ident.t option * module_type
+
+and module_presence =
+  | Mp_present
+  | Mp_absent
+
+and signature = signature_item list
+
+and signature_item =
+    Sig_value of Ident.t * value_description * visibility
+  | Sig_type of Ident.t * type_declaration * rec_status * visibility
+  | Sig_typext of Ident.t * extension_constructor * ext_status * visibility
+  | Sig_module of
+      Ident.t * module_presence * module_declaration * rec_status * visibility
+  | Sig_modtype of Ident.t * modtype_declaration * visibility
+  | Sig_class of Ident.t * class_declaration * rec_status * visibility
+  | Sig_class_type of Ident.t * class_type_declaration * rec_status * visibility
+
+and module_declaration =
+  {
+    md_type: module_type;
+    md_attributes: Parsetree.attributes;
+    md_loc: Location.t;
+  }
+
+and modtype_declaration =
+  {
+    mtd_type: module_type option;  (* None: abstract *)
+    mtd_attributes: Parsetree.attributes;
+    mtd_loc: Location.t;
+  }
+
+and rec_status =
+    Trec_not                   (* first in a nonrecursive group *)
+  | Trec_first                 (* first in a recursive group *)
+  | Trec_next                  (* not first in a recursive/nonrecursive group *)
+
+and ext_status =
+    Text_first                     (* first constructor in an extension *)
+  | Text_next                      (* not first constructor in an extension *)
+  | Text_exception
+
+
+(* Constructor and record label descriptions inserted held in typing
+   environments *)
+
+type constructor_description =
+  { cstr_name: string;                  (* Constructor name *)
+    cstr_res: type_expr;                (* Type of the result *)
+    cstr_existentials: type_expr list;  (* list of existentials *)
+    cstr_args: type_expr list;          (* Type of the arguments *)
+    cstr_arity: int;                    (* Number of arguments *)
+    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
+    cstr_consts: int;                   (* Number of constant constructors *)
+    cstr_nonconsts: int;                (* Number of non-const constructors *)
+    cstr_normal: int;                   (* Number of non generalized constrs *)
+    cstr_generalized: bool;             (* Constrained return type? *)
+    cstr_private: private_flag;         (* Read-only constructor? *)
+    cstr_loc: Location.t;
+    cstr_attributes: Parsetree.attributes;
+    cstr_inlined: type_declaration option;
+   }
+
+and constructor_tag =
+    Cstr_constant of int                (* Constant constructor (an int) *)
+  | Cstr_block of int                   (* Regular constructor (a block) *)
+  | Cstr_unboxed                        (* Constructor of an unboxed type *)
+  | Cstr_extension of Path.t * bool     (* Extension constructor
+                                           true if a constant false if a block*)
+
+(* Constructors are the same *)
+val equal_tag :  constructor_tag -> constructor_tag -> bool
+
+(* Constructors may be the same, given potential rebinding *)
+val may_equal_constr :
+    constructor_description ->  constructor_description -> bool
+
+type label_description =
+  { lbl_name: string;                   (* Short name *)
+    lbl_res: type_expr;                 (* Type of the result *)
+    lbl_arg: type_expr;                 (* Type of the argument *)
+    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
+    lbl_pos: int;                       (* Position in block *)
+    lbl_all: label_description array;   (* All the labels in this type *)
+    lbl_repres: record_representation;  (* Representation for this record *)
+    lbl_private: private_flag;          (* Read-only field? *)
+    lbl_loc: Location.t;
+    lbl_attributes: Parsetree.attributes;
+  }
+
+(** Extracts the list of "value" identifiers bound by a signature.
+    "Value" identifiers are identifiers for signature components that
+    correspond to a run-time value: values, extensions, modules, classes.
+    Note: manifest primitives do not correspond to a run-time value! *)
+val bound_value_identifiers: signature -> Ident.t list
+
+val signature_item_id : signature_item -> Ident.t
+
+(* Merlin specific *)
+
+val unpack_functor : module_type -> functor_parameter * module_type
diff --git a/src/ocaml/typing/410+multicore/typetexp.ml b/src/ocaml/typing/410+multicore/typetexp.ml
new file mode 100644
index 00000000..879f1202
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typetexp.ml
@@ -0,0 +1,813 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* typetexp.ml,v 1.34.4.9 2002/01/07 08:39:16 garrigue Exp *)
+
+(* Typechecking of type expressions for the core language *)
+
+open Asttypes
+open Misc
+open Parsetree
+open Typedtree
+open Types
+open Ctype
+
+exception Already_bound
+
+type error =
+    Unbound_type_variable of string
+  | Undefined_type_constructor of Path.t
+  | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of Ctype.Unification_trace.t
+  | Alias_type_mismatch of Ctype.Unification_trace.t
+  | Present_has_conjunction of string
+  | Present_has_no_type of string
+  | Constructor_mismatch of type_expr * type_expr
+  | Not_a_variant of type_expr
+  | Variant_tags of string * string
+  | Invalid_variable_name of string
+  | Cannot_quantify of string * type_expr
+  | Multiple_constraints_on_type of Longident.t
+  | Method_mismatch of string * type_expr * type_expr
+  | Opened_object of Path.t option
+  | Not_an_object of type_expr
+
+exception Error of Location.t * Env.t * error
+exception Error_forward of Location.error
+
+(** Map indexed by type variable names. *)
+module TyVarMap = String.Map
+
+type variable_context = int * type_expr TyVarMap.t
+
+(* Support for first-class modules. *)
+
+let transl_modtype_longident = ref (fun _ -> assert false)
+let transl_modtype = ref (fun _ -> assert false)
+
+let create_package_mty fake loc env (p, l) =
+  let l =
+    List.sort
+      (fun (s1, _t1) (s2, _t2) ->
+         if s1.txt = s2.txt then
+           raise (Error (loc, env, Multiple_constraints_on_type s1.txt));
+         compare s1.txt s2.txt)
+      l
+  in
+  l,
+  List.fold_left
+    (fun mty (s, t) ->
+      let d = {ptype_name = mkloc (Longident.last s.txt) s.loc;
+               ptype_params = [];
+               ptype_cstrs = [];
+               ptype_kind = Ptype_abstract;
+               ptype_private = Asttypes.Public;
+               ptype_manifest = if fake then None else Some t;
+               ptype_attributes = [];
+               ptype_loc = loc} in
+      Ast_helper.Mty.mk ~loc
+        (Pmty_with (mty, [ Pwith_type ({ txt = s.txt; loc }, d) ]))
+    )
+    (Ast_helper.Mty.mk ~loc (Pmty_ident p))
+    l
+
+(* Translation of type expressions *)
+
+let type_variables = ref (TyVarMap.empty : type_expr TyVarMap.t)
+let univars        = ref ([] : (string * type_expr) list)
+let pre_univars    = ref ([] : type_expr list)
+let used_variables = ref (TyVarMap.empty : (type_expr * Location.t) TyVarMap.t)
+
+let reset_type_variables () =
+  reset_global_level ();
+  Ctype.reset_reified_var_counter ();
+  type_variables := TyVarMap.empty
+
+let narrow () =
+  (increase_global_level (), !type_variables)
+
+let widen (gl, tv) =
+  restore_global_level gl;
+  type_variables := tv
+
+let strict_ident c = (c = '_' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z')
+
+let validate_name = function
+    None -> None
+  | Some name as s ->
+      if name <> "" && strict_ident name.[0] then s else None
+
+let new_global_var ?name () =
+  new_global_var ?name:(validate_name name) ()
+let newvar ?name () =
+  newvar ?name:(validate_name name) ()
+
+let type_variable loc name =
+  try
+    TyVarMap.find name !type_variables
+  with Not_found ->
+    raise(Error(loc, Env.empty, Unbound_type_variable ("'" ^ name)))
+
+let valid_tyvar_name name =
+  name <> "" && name.[0] <> '_'
+
+let transl_type_param env styp =
+  let loc = styp.ptyp_loc in
+  match styp.ptyp_desc with
+    Ptyp_any ->
+      let ty = new_global_var ~name:"_" () in
+        { ctyp_desc = Ttyp_any; ctyp_type = ty; ctyp_env = env;
+          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
+  | Ptyp_var name ->
+      let ty =
+        try
+          if not (valid_tyvar_name name) then
+            raise (Error (loc, Env.empty, Invalid_variable_name ("'" ^ name)));
+          ignore (TyVarMap.find name !type_variables);
+          raise Already_bound
+        with Not_found ->
+          let v = new_global_var ~name () in
+            type_variables := TyVarMap.add name v !type_variables;
+            v
+      in
+        { ctyp_desc = Ttyp_var name; ctyp_type = ty; ctyp_env = env;
+          ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes; }
+  | _ -> assert false
+
+let transl_type_param env styp =
+  (* Currently useless, since type parameters cannot hold attributes
+     (but this could easily be lifted in the future). *)
+  Builtin_attributes.warning_scope styp.ptyp_attributes
+    (fun () -> transl_type_param env styp)
+
+
+let new_pre_univar ?name () =
+  let v = newvar ?name () in pre_univars := v :: !pre_univars; v
+
+type policy = Fixed | Extensible | Univars
+
+let rec transl_type env policy styp =
+  Builtin_attributes.warning_scope styp.ptyp_attributes
+    (fun () -> transl_type_aux env policy styp)
+
+and transl_type_aux env policy styp =
+  let loc = styp.ptyp_loc in
+  let ctyp ctyp_desc ctyp_type =
+    { ctyp_desc; ctyp_type; ctyp_env = env;
+      ctyp_loc = loc; ctyp_attributes = styp.ptyp_attributes }
+  in
+  match styp.ptyp_desc with
+    Ptyp_any ->
+      let ty =
+        if policy = Univars then new_pre_univar () else
+          if policy = Fixed then
+            raise (Error (styp.ptyp_loc, env, Unbound_type_variable "_"))
+          else newvar ()
+      in
+      ctyp Ttyp_any ty
+  | Ptyp_var name ->
+    let ty =
+      if name <> "" && name.[0] = '_' then
+        raise (Error (styp.ptyp_loc, env, Invalid_variable_name ("'" ^ name)));
+      begin try
+        instance (List.assoc name !univars)
+      with Not_found -> try
+        instance (fst (TyVarMap.find name !used_variables))
+      with Not_found ->
+        let v =
+          if policy = Univars then new_pre_univar ~name () else newvar ~name ()
+        in
+        used_variables := TyVarMap.add name (v, styp.ptyp_loc) !used_variables;
+        v
+      end
+    in
+    ctyp (Ttyp_var name) ty
+  | Ptyp_arrow(l, st1, st2) ->
+    let cty1 = transl_type env policy st1 in
+    let cty2 = transl_type env policy st2 in
+    let ty1 = cty1.ctyp_type in
+    let ty1 =
+      if Btype.is_optional l
+      then newty (Tconstr(Predef.path_option,[ty1], ref Mnil))
+      else ty1 in
+    let ty = newty (Tarrow(l, ty1, cty2.ctyp_type, Cok)) in
+    ctyp (Ttyp_arrow (l, cty1, cty2)) ty
+  | Ptyp_tuple stl ->
+    assert (List.length stl >= 2);
+    let ctys = List.map (transl_type env policy) stl in
+    let ty = newty (Ttuple (List.map (fun ctyp -> ctyp.ctyp_type) ctys)) in
+    ctyp (Ttyp_tuple ctys) ty
+  | Ptyp_constr(lid, stl) ->
+      let (path, decl) = Env.lookup_type ~loc:lid.loc lid.txt env in
+      let stl =
+        match stl with
+        | [ {ptyp_desc=Ptyp_any} as t ] when decl.type_arity > 1 ->
+            List.map (fun _ -> t) decl.type_params
+        | _ -> stl
+      in
+      if List.length stl <> decl.type_arity then
+        raise(Error(styp.ptyp_loc, env,
+                    Type_arity_mismatch(lid.txt, decl.type_arity,
+                                        List.length stl)));
+      let args = List.map (transl_type env policy) stl in
+      let params = instance_list decl.type_params in
+      let unify_param =
+        match decl.type_manifest with
+          None -> unify_var
+        | Some ty ->
+            if (repr ty).level = Btype.generic_level then unify_var else unify
+      in
+      List.iter2
+        (fun (sty, cty) ty' ->
+           try unify_param env ty' cty.ctyp_type with Unify trace ->
+             let trace = Unification_trace.swap trace in
+             raise (Error(sty.ptyp_loc, env, Type_mismatch trace))
+        )
+        (List.combine stl args) params;
+      let constr =
+        newconstr path (List.map (fun ctyp -> ctyp.ctyp_type) args) in
+      begin try
+        Ctype.enforce_constraints env constr
+      with Unify trace ->
+        raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
+      end;
+      ctyp (Ttyp_constr (path, lid, args)) constr
+  | Ptyp_object (fields, o) ->
+      let ty, fields = transl_fields env policy o fields in
+      ctyp (Ttyp_object (fields, o)) (newobj ty)
+  | Ptyp_class(lid, stl) ->
+      let (path, decl, _is_variant) =
+        try
+          let path, decl = Env.find_type_by_name lid.txt env in
+          let rec check decl =
+            match decl.type_manifest with
+              None -> raise Not_found
+            | Some ty ->
+                match (repr ty).desc with
+                  Tvariant row when Btype.static_row row -> ()
+                | Tconstr (path, _, _) ->
+                    check (Env.find_type path env)
+                | _ -> raise Not_found
+          in check decl;
+          Location.deprecated styp.ptyp_loc
+            "old syntax for polymorphic variant type";
+          ignore(Env.lookup_type ~loc:lid.loc lid.txt env);
+          (path, decl,true)
+        with Not_found -> try
+          let lid2 =
+            match lid.txt with
+              Longident.Lident s     -> Longident.Lident ("#" ^ s)
+            | Longident.Ldot(r, s)   -> Longident.Ldot (r, "#" ^ s)
+            | Longident.Lapply(_, _) -> fatal_error "Typetexp.transl_type"
+          in
+          let path, decl = Env.find_type_by_name lid2 env in
+          ignore(Env.lookup_cltype ~loc:lid.loc lid.txt env);
+          (path, decl, false)
+        with Not_found ->
+          ignore (Env.lookup_cltype ~loc:lid.loc lid.txt env); assert false
+      in
+      if List.length stl <> decl.type_arity then
+        raise(Error(styp.ptyp_loc, env,
+                    Type_arity_mismatch(lid.txt, decl.type_arity,
+                                        List.length stl)));
+      let args = List.map (transl_type env policy) stl in
+      let params = instance_list decl.type_params in
+      List.iter2
+        (fun (sty, cty) ty' ->
+           try unify_var env ty' cty.ctyp_type with Unify trace ->
+             let trace = Unification_trace.swap trace in
+             raise (Error(sty.ptyp_loc, env, Type_mismatch trace))
+        )
+        (List.combine stl args) params;
+        let ty_args = List.map (fun ctyp -> ctyp.ctyp_type) args in
+      let ty =
+        try Ctype.expand_head env (newconstr path ty_args)
+        with Unify trace ->
+          raise (Error(styp.ptyp_loc, env, Type_mismatch trace))
+      in
+      let ty = match ty.desc with
+        Tvariant row ->
+          let row = Btype.row_repr row in
+          let fields =
+            List.map
+              (fun (l,f) -> l,
+                match Btype.row_field_repr f with
+                | Rpresent (Some ty) ->
+                    Reither(false, [ty], false, ref None)
+                | Rpresent None ->
+                    Reither (true, [], false, ref None)
+                | _ -> f)
+              row.row_fields
+          in
+          let row = { row_closed = true; row_fields = fields;
+                      row_bound = (); row_name = Some (path, ty_args);
+                      row_fixed = None; row_more = newvar () } in
+          let static = Btype.static_row row in
+          let row =
+            if static then { row with row_more = newty Tnil }
+            else if policy <> Univars then row
+            else { row with row_more = new_pre_univar () }
+          in
+          newty (Tvariant row)
+      | Tobject (fi, _) ->
+          let _, tv = flatten_fields fi in
+          if policy = Univars then pre_univars := tv :: !pre_univars;
+          ty
+      | _ ->
+          assert false
+      in
+      ctyp (Ttyp_class (path, lid, args)) ty
+  | Ptyp_alias(st, alias) ->
+      let cty =
+        try
+          let t =
+            try List.assoc alias !univars
+            with Not_found ->
+              instance (fst(TyVarMap.find alias !used_variables))
+          in
+          let ty = transl_type env policy st in
+          begin try unify_var env t ty.ctyp_type with Unify trace ->
+            let trace = Unification_trace.swap trace in
+            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
+          end;
+          ty
+        with Not_found ->
+          if !Clflags.principal then begin_def ();
+          let t = newvar () in
+          used_variables :=
+            TyVarMap.add alias (t, styp.ptyp_loc) !used_variables;
+          let ty = transl_type env policy st in
+          begin try unify_var env t ty.ctyp_type with Unify trace ->
+            let trace = Unification_trace.swap trace in
+            raise(Error(styp.ptyp_loc, env, Alias_type_mismatch trace))
+          end;
+          if !Clflags.principal then begin
+            end_def ();
+            generalize_structure t;
+          end;
+          let t = instance t in
+          let px = Btype.proxy t in
+          begin match px.desc with
+          | Tvar None -> Btype.set_type_desc px (Tvar (Some alias))
+          | Tunivar None -> Btype.set_type_desc px (Tunivar (Some alias))
+          | _ -> ()
+          end;
+          { ty with ctyp_type = t }
+      in
+      ctyp (Ttyp_alias (cty, alias)) cty.ctyp_type
+  | Ptyp_variant(fields, closed, present) ->
+      let name = ref None in
+      let mkfield l f =
+        newty (Tvariant {row_fields=[l,f]; row_more=newvar();
+                         row_bound=(); row_closed=true;
+                         row_fixed=None; row_name=None}) in
+      let hfields = Hashtbl.create 17 in
+      let add_typed_field loc l f =
+        let h = Btype.hash_variant l in
+        try
+          let (l',f') = Hashtbl.find hfields h in
+          (* Check for tag conflicts *)
+          if l <> l' then raise(Error(styp.ptyp_loc, env, Variant_tags(l, l')));
+          let ty = mkfield l f and ty' = mkfield l f' in
+          if equal env false [ty] [ty'] then () else
+          try unify env ty ty'
+          with Unify _trace ->
+            raise(Error(loc, env, Constructor_mismatch (ty,ty')))
+        with Not_found ->
+          Hashtbl.add hfields h (l,f)
+      in
+      let add_field field =
+        let rf_loc = field.prf_loc in
+        let rf_attributes = field.prf_attributes in
+        let rf_desc = match field.prf_desc with
+        | Rtag (l, c, stl) ->
+            name := None;
+            let tl =
+              Builtin_attributes.warning_scope rf_attributes
+                (fun () -> List.map (transl_type env policy) stl)
+            in
+            let f = match present with
+              Some present when not (List.mem l.txt present) ->
+                let ty_tl = List.map (fun cty -> cty.ctyp_type) tl in
+                Reither(c, ty_tl, false, ref None)
+            | _ ->
+                if List.length stl > 1 || c && stl <> [] then
+                  raise(Error(styp.ptyp_loc, env,
+                              Present_has_conjunction l.txt));
+                match tl with [] -> Rpresent None
+                | st :: _ ->
+                      Rpresent (Some st.ctyp_type)
+            in
+            add_typed_field styp.ptyp_loc l.txt f;
+              Ttag (l,c,tl)
+        | Rinherit sty ->
+            let cty = transl_type env policy sty in
+            let ty = cty.ctyp_type in
+            let nm =
+              match repr cty.ctyp_type with
+                {desc=Tconstr(p, tl, _)} -> Some(p, tl)
+              | _                        -> None
+            in
+            begin try
+              (* Set name if there are no fields yet *)
+              Hashtbl.iter (fun _ _ -> raise Exit) hfields;
+              name := nm
+            with Exit ->
+              (* Unset it otherwise *)
+              name := None
+            end;
+            let fl = match expand_head env cty.ctyp_type, nm with
+              {desc=Tvariant row}, _ when Btype.static_row row ->
+                let row = Btype.row_repr row in
+                row.row_fields
+            | {desc=Tvar _}, Some(p, _) ->
+                raise(Error(sty.ptyp_loc, env, Undefined_type_constructor p))
+            | _ ->
+                raise(Error(sty.ptyp_loc, env, Not_a_variant ty))
+            in
+            List.iter
+              (fun (l, f) ->
+                let f = match present with
+                  Some present when not (List.mem l present) ->
+                    begin match f with
+                      Rpresent(Some ty) ->
+                        Reither(false, [ty], false, ref None)
+                    | Rpresent None ->
+                        Reither(true, [], false, ref None)
+                    | _ ->
+                        assert false
+                    end
+                | _ -> f
+                in
+                add_typed_field sty.ptyp_loc l f)
+              fl;
+              Tinherit cty
+        in
+        { rf_desc; rf_loc; rf_attributes; }
+      in
+      let tfields = List.map add_field fields in
+      let fields = Hashtbl.fold (fun _ p l -> p :: l) hfields [] in
+      begin match present with None -> ()
+      | Some present ->
+          List.iter
+            (fun l -> if not (List.mem_assoc l fields) then
+              raise(Error(styp.ptyp_loc, env, Present_has_no_type l)))
+            present
+      end;
+      let row =
+        { row_fields = List.rev fields; row_more = newvar ();
+          row_bound = (); row_closed = (closed = Closed);
+          row_fixed = None; row_name = !name } in
+      let static = Btype.static_row row in
+      let row =
+        if static then { row with row_more = newty Tnil }
+        else if policy <> Univars then row
+        else { row with row_more = new_pre_univar () }
+      in
+      let ty = newty (Tvariant row) in
+      ctyp (Ttyp_variant (tfields, closed, present)) ty
+  | Ptyp_poly(vars, st) ->
+      let vars = List.map (fun v -> v.txt) vars in
+      begin_def();
+      let new_univars = List.map (fun name -> name, newvar ~name ()) vars in
+      let old_univars = !univars in
+      univars := new_univars @ !univars;
+      let cty = transl_type env policy st in
+      let ty = cty.ctyp_type in
+      univars := old_univars;
+      end_def();
+      generalize ty;
+      let ty_list =
+        List.fold_left
+          (fun tyl (name, ty1) ->
+            let v = Btype.proxy ty1 in
+            if deep_occur v ty then begin
+              match v.desc with
+                Tvar name when v.level = Btype.generic_level ->
+                  v.desc <- Tunivar name;
+                  v :: tyl
+              | _ ->
+                raise (Error (styp.ptyp_loc, env, Cannot_quantify (name, v)))
+            end else tyl)
+          [] new_univars
+      in
+      let ty' = Btype.newgenty (Tpoly(ty, List.rev ty_list)) in
+      unify_var env (newvar()) ty';
+      ctyp (Ttyp_poly (vars, cty)) ty'
+  | Ptyp_package (p, l) ->
+      let l, mty = create_package_mty true styp.ptyp_loc env (p, l) in
+      let z = narrow () in
+      let mty = !transl_modtype env mty in
+      widen z;
+      let ptys = List.map (fun (s, pty) ->
+                             s, transl_type env policy pty
+                          ) l in
+      let path = !transl_modtype_longident styp.ptyp_loc env p.txt in
+      let ty = newty (Tpackage (path,
+                       List.map (fun (s, _pty) -> s.txt) l,
+                       List.map (fun (_,cty) -> cty.ctyp_type) ptys))
+      in
+      ctyp (Ttyp_package {
+            pack_path = path;
+            pack_type = mty.mty_type;
+            pack_fields = ptys;
+            pack_txt = p;
+           }) ty
+  | Ptyp_extension ext ->
+      raise (Error_forward (Builtin_attributes.error_of_extension ext))
+
+and transl_poly_type env policy t =
+  transl_type env policy (Ast_helper.Typ.force_poly t)
+
+and transl_fields env policy o fields =
+  let hfields = Hashtbl.create 17 in
+  let add_typed_field loc l ty =
+    try
+      let ty' = Hashtbl.find hfields l in
+      if equal env false [ty] [ty'] then () else
+        try unify env ty ty'
+        with Unify _trace ->
+          raise(Error(loc, env, Method_mismatch (l, ty, ty')))
+    with Not_found ->
+      Hashtbl.add hfields l ty in
+  let add_field {pof_desc; pof_loc; pof_attributes;} =
+    let of_loc = pof_loc in
+    let of_attributes = pof_attributes in
+    let of_desc = match pof_desc with
+    | Otag (s, ty1) -> begin
+        let ty1 =
+          Builtin_attributes.warning_scope of_attributes
+            (fun () -> transl_poly_type env policy ty1)
+        in
+        let field = OTtag (s, ty1) in
+        add_typed_field ty1.ctyp_loc s.txt ty1.ctyp_type;
+        field
+      end
+    | Oinherit sty -> begin
+        let cty = transl_type env policy sty in
+        let nm =
+          match repr cty.ctyp_type with
+            {desc=Tconstr(p, _, _)} -> Some p
+          | _                        -> None in
+        let t = expand_head env cty.ctyp_type in
+        match t, nm with
+          {desc=Tobject ({desc=(Tfield _ | Tnil) as tf}, _)}, _ -> begin
+            if opened_object t then
+              raise (Error (sty.ptyp_loc, env, Opened_object nm));
+            let rec iter_add = function
+              | Tfield (s, _k, ty1, ty2) -> begin
+                  add_typed_field sty.ptyp_loc s ty1;
+                  iter_add ty2.desc
+                end
+              | Tnil -> ()
+              | _ -> assert false in
+            iter_add tf;
+            OTinherit cty
+            end
+        | {desc=Tvar _}, Some p ->
+            raise (Error (sty.ptyp_loc, env, Undefined_type_constructor p))
+        | _ -> raise (Error (sty.ptyp_loc, env, Not_an_object t))
+      end in
+    { of_desc; of_loc; of_attributes; }
+  in
+  let object_fields = List.map add_field fields in
+  let fields = Hashtbl.fold (fun s ty l -> (s, ty) :: l) hfields [] in
+  let ty_init =
+     match o, policy with
+     | Closed, _ -> newty Tnil
+     | Open, Univars -> new_pre_univar ()
+     | Open, _ -> newvar () in
+  let ty = List.fold_left (fun ty (s, ty') ->
+      newty (Tfield (s, Fpresent, ty', ty))) ty_init fields in
+  ty, object_fields
+
+
+(* Make the rows "fixed" in this type, to make universal check easier *)
+let rec make_fixed_univars ty =
+  let ty = repr ty in
+  if ty.level >= Btype.lowest_level then begin
+    Btype.mark_type_node ty;
+    match ty.desc with
+    | Tvariant row ->
+        let row = Btype.row_repr row in
+        let more = Btype.row_more row in
+        if Btype.is_Tunivar more then
+          ty.desc <- Tvariant
+              {row with row_fixed=Some(Univar more);
+               row_fields = List.map
+                 (fun (s,f as p) -> match Btype.row_field_repr f with
+                   Reither (c, tl, _m, r) -> s, Reither (c, tl, true, r)
+                 | _ -> p)
+                 row.row_fields};
+        Btype.iter_row make_fixed_univars row
+    | _ ->
+        Btype.iter_type_expr make_fixed_univars ty
+  end
+
+let make_fixed_univars ty =
+  make_fixed_univars ty;
+  Btype.unmark_type ty
+
+let create_package_mty = create_package_mty false
+
+let globalize_used_variables env fixed =
+  let r = ref [] in
+  TyVarMap.iter
+    (fun name (ty, loc) ->
+      let v = new_global_var () in
+      let snap = Btype.snapshot () in
+      if try unify env v ty; true with _ -> Btype.backtrack snap; false
+      then try
+        r := (loc, v,  TyVarMap.find name !type_variables) :: !r
+      with Not_found ->
+        if fixed && Btype.is_Tvar (repr ty) then
+          raise(Error(loc, env, Unbound_type_variable ("'"^name)));
+        let v2 = new_global_var () in
+        r := (loc, v, v2) :: !r;
+        type_variables := TyVarMap.add name v2 !type_variables)
+    !used_variables;
+  used_variables := TyVarMap.empty;
+  fun () ->
+    List.iter
+      (function (loc, t1, t2) ->
+        try unify env t1 t2 with Unify trace ->
+          raise (Error(loc, env, Type_mismatch trace)))
+      !r
+
+let transl_simple_type env fixed styp =
+  univars := []; used_variables := TyVarMap.empty;
+  let typ = transl_type env (if fixed then Fixed else Extensible) styp in
+  globalize_used_variables env fixed ();
+  make_fixed_univars typ.ctyp_type;
+  typ
+
+let transl_simple_type_univars env styp =
+  univars := []; used_variables := TyVarMap.empty; pre_univars := [];
+  begin_def ();
+  let typ = transl_type env Univars styp in
+  (* Only keep already global variables in used_variables *)
+  let new_variables = !used_variables in
+  used_variables := TyVarMap.empty;
+  TyVarMap.iter
+    (fun name p ->
+      if TyVarMap.mem name !type_variables then
+        used_variables := TyVarMap.add name p !used_variables)
+    new_variables;
+  globalize_used_variables env false ();
+  end_def ();
+  generalize typ.ctyp_type;
+  let univs =
+    List.fold_left
+      (fun acc v ->
+        let v = repr v in
+        match v.desc with
+          Tvar name when v.level = Btype.generic_level ->
+            v.desc <- Tunivar name; v :: acc
+        | _ -> acc)
+      [] !pre_univars
+  in
+  make_fixed_univars typ.ctyp_type;
+    { typ with ctyp_type =
+        instance (Btype.newgenty (Tpoly (typ.ctyp_type, univs))) }
+
+let transl_simple_type_delayed env styp =
+  univars := []; used_variables := TyVarMap.empty;
+  let typ = transl_type env Extensible styp in
+  make_fixed_univars typ.ctyp_type;
+  (typ, globalize_used_variables env false)
+
+let transl_type_scheme env styp =
+  reset_type_variables();
+  begin_def();
+  let typ = transl_simple_type env false styp in
+  end_def();
+  generalize typ.ctyp_type;
+  typ
+
+
+(* Error report *)
+
+open Format
+open Printtyp
+
+let report_error env ppf = function
+  | Unbound_type_variable name ->
+      let add_name name _ l = if name = "_" then l else ("'" ^ name) :: l in
+      let names = TyVarMap.fold add_name !type_variables [] in
+    fprintf ppf "The type variable %s is unbound in this type declaration.@ %a"
+      name
+      did_you_mean (fun () -> Misc.spellcheck names name )
+  | Undefined_type_constructor p ->
+    fprintf ppf "The type constructor@ %a@ is not yet completely defined"
+      path p
+  | Type_arity_mismatch(lid, expected, provided) ->
+    fprintf ppf
+      "@[The type constructor %a@ expects %i argument(s),@ \
+        but is here applied to %i argument(s)@]"
+      longident lid expected provided
+  | Bound_type_variable name ->
+    fprintf ppf "Already bound type parameter %a" Pprintast.tyvar name
+  | Recursive_type ->
+    fprintf ppf "This type is recursive"
+  | Unbound_row_variable lid ->
+      (* we don't use "spellcheck" here: this error is not raised
+         anywhere so it's unclear how it should be handled *)
+      fprintf ppf "Unbound row variable in #%a" longident lid
+  | Type_mismatch trace ->
+      Printtyp.report_unification_error ppf Env.empty trace
+        (function ppf ->
+           fprintf ppf "This type")
+        (function ppf ->
+           fprintf ppf "should be an instance of type")
+  | Alias_type_mismatch trace ->
+      Printtyp.report_unification_error ppf Env.empty trace
+        (function ppf ->
+           fprintf ppf "This alias is bound to type")
+        (function ppf ->
+           fprintf ppf "but is used as an instance of type")
+  | Present_has_conjunction l ->
+      fprintf ppf "The present constructor %s has a conjunctive type" l
+  | Present_has_no_type l ->
+      fprintf ppf
+        "@[<v>@[The constructor %s is missing from the upper bound@ \
+         (between '<'@ and '>')@ of this polymorphic variant@ \
+         but is present in@ its lower bound (after '>').@]@,\
+         @[Hint: Either add `%s in the upper bound,@ \
+         or remove it@ from the lower bound.@]@]"
+         l l
+  | Constructor_mismatch (ty, ty') ->
+      wrap_printing_env ~error:true env (fun ()  ->
+        Printtyp.reset_and_mark_loops_list [ty; ty'];
+        fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
+          "This variant type contains a constructor"
+          !Oprint.out_type (tree_of_typexp false ty)
+          "which should be"
+           !Oprint.out_type (tree_of_typexp false ty'))
+  | Not_a_variant ty ->
+      fprintf ppf
+        "@[The type %a@ does not expand to a polymorphic variant type@]"
+        Printtyp.type_expr ty;
+      begin match ty.desc with
+        | Tvar (Some s) ->
+           (* PR#7012: help the user that wrote 'Foo instead of `Foo *)
+           Misc.did_you_mean ppf (fun () -> ["`" ^ s])
+        | _ -> ()
+      end
+  | Variant_tags (lab1, lab2) ->
+      fprintf ppf
+        "@[Variant tags `%s@ and `%s have the same hash value.@ %s@]"
+        lab1 lab2 "Change one of them."
+  | Invalid_variable_name name ->
+      fprintf ppf "The type variable name %s is not allowed in programs" name
+  | Cannot_quantify (name, v) ->
+      fprintf ppf
+        "@[<hov>The universal type variable %a cannot be generalized:@ "
+        Pprintast.tyvar name;
+      if Btype.is_Tvar v then
+        fprintf ppf "it escapes its scope"
+      else if Btype.is_Tunivar v then
+        fprintf ppf "it is already bound to another variable"
+      else
+        fprintf ppf "it is bound to@ %a" Printtyp.type_expr v;
+      fprintf ppf ".@]";
+  | Multiple_constraints_on_type s ->
+      fprintf ppf "Multiple constraints for type %a" longident s
+  | Method_mismatch (l, ty, ty') ->
+      wrap_printing_env ~error:true env (fun ()  ->
+        fprintf ppf "@[<hov>Method '%s' has type %a,@ which should be %a@]"
+          l Printtyp.type_expr ty Printtyp.type_expr ty')
+  | Opened_object nm ->
+      fprintf ppf
+        "Illegal open object type%a"
+        (fun ppf -> function
+             Some p -> fprintf ppf "@ %a" path p
+           | None -> fprintf ppf "") nm
+  | Not_an_object ty ->
+      fprintf ppf "@[The type %a@ is not an object type@]"
+        Printtyp.type_expr ty
+
+let () =
+  Location.register_error_of_exn
+    (function
+      | Error (loc, env, err) ->
+        Some (Location.error_of_printer ~loc (report_error env) err)
+      | Error_forward err ->
+        Some err
+      | _ ->
+        None
+    )
diff --git a/src/ocaml/typing/410+multicore/typetexp.mli b/src/ocaml/typing/410+multicore/typetexp.mli
new file mode 100644
index 00000000..5475abbc
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/typetexp.mli
@@ -0,0 +1,76 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(* Typechecking of type expressions for the core language *)
+
+open Types
+
+val valid_tyvar_name : string -> bool
+
+val transl_simple_type:
+        Env.t -> bool -> Parsetree.core_type -> Typedtree.core_type
+val transl_simple_type_univars:
+        Env.t -> Parsetree.core_type -> Typedtree.core_type
+val transl_simple_type_delayed:
+        Env.t -> Parsetree.core_type -> Typedtree.core_type * (unit -> unit)
+        (* Translate a type, but leave type variables unbound. Returns
+           the type and a function that binds the type variable. *)
+val transl_type_scheme:
+        Env.t -> Parsetree.core_type -> Typedtree.core_type
+val reset_type_variables: unit -> unit
+val type_variable: Location.t -> string -> type_expr
+val transl_type_param:
+  Env.t -> Parsetree.core_type -> Typedtree.core_type
+
+type variable_context
+val narrow: unit -> variable_context
+val widen: variable_context -> unit
+
+exception Already_bound
+
+type error =
+    Unbound_type_variable of string
+  | Undefined_type_constructor of Path.t
+  | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of Ctype.Unification_trace.t
+  | Alias_type_mismatch of Ctype.Unification_trace.t
+  | Present_has_conjunction of string
+  | Present_has_no_type of string
+  | Constructor_mismatch of type_expr * type_expr
+  | Not_a_variant of type_expr
+  | Variant_tags of string * string
+  | Invalid_variable_name of string
+  | Cannot_quantify of string * type_expr
+  | Multiple_constraints_on_type of Longident.t
+  | Method_mismatch of string * type_expr * type_expr
+  | Opened_object of Path.t option
+  | Not_an_object of type_expr
+
+exception Error of Location.t * Env.t * error
+
+val report_error: Env.t -> Format.formatter -> error -> unit
+
+(* Support for first-class modules. *)
+val transl_modtype_longident:  (* from Typemod *)
+    (Location.t -> Env.t -> Longident.t -> Path.t) ref
+val transl_modtype: (* from Typemod *)
+    (Env.t -> Parsetree.module_type -> Typedtree.module_type) ref
+val create_package_mty:
+    Location.t -> Env.t -> Parsetree.package_type ->
+    (Longident.t Asttypes.loc * Parsetree.core_type) list *
+      Parsetree.module_type
diff --git a/src/ocaml/typing/410+multicore/untypeast.ml b/src/ocaml/typing/410+multicore/untypeast.ml
new file mode 100644
index 00000000..727cdd4f
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/untypeast.ml
@@ -0,0 +1,898 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*    Thomas Gazagnaire (OCamlPro), Fabrice Le Fessant (INRIA Saclay)     *)
+(*                                                                        *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Longident
+open Asttypes
+open Parsetree
+open Ast_helper
+
+module T = Typedtree
+
+type mapper = {
+  attribute: mapper -> T.attribute -> attribute;
+  attributes: mapper -> T.attribute list -> attribute list;
+  binding_op: mapper -> T.binding_op -> T.pattern -> binding_op;
+  case: mapper -> T.case -> case;
+  cases: mapper -> T.case list -> case list;
+  class_declaration: mapper -> T.class_declaration -> class_declaration;
+  class_description: mapper -> T.class_description -> class_description;
+  class_expr: mapper -> T.class_expr -> class_expr;
+  class_field: mapper -> T.class_field -> class_field;
+  class_signature: mapper -> T.class_signature -> class_signature;
+  class_structure: mapper -> T.class_structure -> class_structure;
+  class_type: mapper -> T.class_type -> class_type;
+  class_type_declaration: mapper -> T.class_type_declaration
+                          -> class_type_declaration;
+  class_type_field: mapper -> T.class_type_field -> class_type_field;
+  constructor_declaration: mapper -> T.constructor_declaration
+                           -> constructor_declaration;
+  expr: mapper -> T.expression -> expression;
+  extension_constructor: mapper -> T.extension_constructor
+                         -> extension_constructor;
+  include_declaration: mapper -> T.include_declaration -> include_declaration;
+  include_description: mapper -> T.include_description -> include_description;
+  label_declaration: mapper -> T.label_declaration -> label_declaration;
+  location: mapper -> Location.t -> Location.t;
+  module_binding: mapper -> T.module_binding -> module_binding;
+  module_declaration: mapper -> T.module_declaration -> module_declaration;
+  module_substitution: mapper -> T.module_substitution -> module_substitution;
+  module_expr: mapper -> T.module_expr -> module_expr;
+  module_type: mapper -> T.module_type -> module_type;
+  module_type_declaration:
+    mapper -> T.module_type_declaration -> module_type_declaration;
+  package_type: mapper -> T.package_type -> package_type;
+  open_declaration: mapper -> T.open_declaration -> open_declaration;
+  open_description: mapper -> T.open_description -> open_description;
+  pat: mapper -> T.pattern -> pattern;
+  row_field: mapper -> T.row_field -> row_field;
+  object_field: mapper -> T.object_field -> object_field;
+  signature: mapper -> T.signature -> signature;
+  signature_item: mapper -> T.signature_item -> signature_item;
+  structure: mapper -> T.structure -> structure;
+  structure_item: mapper -> T.structure_item -> structure_item;
+  typ: mapper -> T.core_type -> core_type;
+  type_declaration: mapper -> T.type_declaration -> type_declaration;
+  type_extension: mapper -> T.type_extension -> type_extension;
+  type_exception: mapper -> T.type_exception -> type_exception;
+  type_kind: mapper -> T.type_kind -> type_kind;
+  value_binding: mapper -> T.value_binding -> value_binding;
+  value_description: mapper -> T.value_description -> value_description;
+  with_constraint:
+    mapper -> (Path.t * Longident.t Location.loc * T.with_constraint)
+    -> with_constraint;
+}
+
+open T
+
+(*
+Some notes:
+
+   * For Pexp_function, we cannot go back to the exact original version
+   when there is a default argument, because the default argument is
+   translated in the typer. The code, if printed, will not be parsable because
+   new generated identifiers are not correct.
+
+   * For Pexp_apply, it is unclear whether arguments are reordered, especially
+    when there are optional arguments.
+
+*)
+
+
+(** Utility functions. *)
+
+let string_is_prefix sub str =
+  let sublen = String.length sub in
+  String.length str >= sublen && String.sub str 0 sublen = sub
+
+let rec lident_of_path = function
+  | Path.Pident id -> Longident.Lident (Ident.name id)
+  | Path.Pdot (p, s) -> Longident.Ldot (lident_of_path p, s)
+  | Path.Papply (p1, p2) ->
+      Longident.Lapply (lident_of_path p1, lident_of_path p2)
+
+let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}
+
+(** Try a name [$name$0], check if it's free, if not, increment and repeat. *)
+let fresh_name s env =
+  let rec aux i =
+    let name = s ^ Int.to_string i in
+    if Env.bound_value name env then aux (i+1)
+    else name
+  in
+  aux 0
+
+(** Extract the [n] patterns from the case of a letop *)
+let rec extract_letop_patterns n pat =
+  if n = 0 then pat, []
+  else begin
+    match pat.pat_desc with
+    | Tpat_tuple([first; rest]) ->
+        let next, others = extract_letop_patterns (n-1) rest in
+        first, next :: others
+    | _ ->
+      let rec anys n =
+        if n = 0 then []
+        else { pat with pat_desc = Tpat_any } :: anys (n-1)
+      in
+      { pat with pat_desc = Tpat_any }, anys (n-1)
+  end
+
+(** Mapping functions. *)
+
+let constant = function
+  | Const_char c -> Pconst_char c
+  | Const_string (s,d) -> Pconst_string (s,d)
+  | Const_int i -> Pconst_integer (Int.to_string i, None)
+  | Const_int32 i -> Pconst_integer (Int32.to_string i, Some 'l')
+  | Const_int64 i -> Pconst_integer (Int64.to_string i, Some 'L')
+  | Const_nativeint i -> Pconst_integer (Nativeint.to_string i, Some 'n')
+  | Const_float f -> Pconst_float (f,None)
+
+let attribute sub a = {
+    attr_name = map_loc sub a.attr_name;
+    attr_payload = a.attr_payload;
+    attr_loc = a.attr_loc
+  }
+
+let attributes sub l = List.map (sub.attribute sub) l
+
+let structure sub str =
+  List.map (sub.structure_item sub) str.str_items
+
+let open_description sub od =
+  let loc = sub.location sub od.open_loc in
+  let attrs = sub.attributes sub od.open_attributes in
+  Opn.mk ~loc ~attrs
+    ~override:od.open_override
+    (snd od.open_expr)
+
+let open_declaration sub od =
+  let loc = sub.location sub od.open_loc in
+  let attrs = sub.attributes sub od.open_attributes in
+  Opn.mk ~loc ~attrs
+    ~override:od.open_override
+    (sub.module_expr sub od.open_expr)
+
+let structure_item sub item =
+  let loc = sub.location sub item.str_loc in
+  let desc =
+    match item.str_desc with
+      Tstr_eval (exp, attrs) -> Pstr_eval (sub.expr sub exp, attrs)
+    | Tstr_value (rec_flag, list) ->
+        Pstr_value (rec_flag, List.map (sub.value_binding sub) list)
+    | Tstr_primitive vd ->
+        Pstr_primitive (sub.value_description sub vd)
+    | Tstr_type (rec_flag, list) ->
+        Pstr_type (rec_flag, List.map (sub.type_declaration sub) list)
+    | Tstr_typext tyext ->
+        Pstr_typext (sub.type_extension sub tyext)
+    | Tstr_exception ext ->
+        Pstr_exception (sub.type_exception sub ext)
+    | Tstr_module mb ->
+        Pstr_module (sub.module_binding sub mb)
+    | Tstr_recmodule list ->
+        Pstr_recmodule (List.map (sub.module_binding sub) list)
+    | Tstr_modtype mtd ->
+        Pstr_modtype (sub.module_type_declaration sub mtd)
+    | Tstr_open od ->
+        Pstr_open (sub.open_declaration sub od)
+    | Tstr_class list ->
+        Pstr_class
+          (List.map
+             (fun (ci, _) -> sub.class_declaration sub ci)
+             list)
+    | Tstr_class_type list ->
+        Pstr_class_type
+          (List.map
+             (fun (_id, _name, ct) -> sub.class_type_declaration sub ct)
+             list)
+    | Tstr_include incl ->
+        Pstr_include (sub.include_declaration sub incl)
+    | Tstr_attribute x ->
+        Pstr_attribute x
+  in
+  Str.mk ~loc desc
+
+let value_description sub v =
+  let loc = sub.location sub v.val_loc in
+  let attrs = sub.attributes sub v.val_attributes in
+  Val.mk ~loc ~attrs
+    ~prim:v.val_prim
+    (map_loc sub v.val_name)
+    (sub.typ sub v.val_desc)
+
+let module_binding sub mb =
+  let loc = sub.location sub mb.mb_loc in
+  let attrs = sub.attributes sub mb.mb_attributes in
+  Mb.mk ~loc ~attrs
+    (map_loc sub mb.mb_name)
+    (sub.module_expr sub mb.mb_expr)
+
+let type_parameter sub (ct, v) = (sub.typ sub ct, v)
+
+let type_declaration sub decl =
+  let loc = sub.location sub decl.typ_loc in
+  let attrs = sub.attributes sub decl.typ_attributes in
+  Type.mk ~loc ~attrs
+    ~params:(List.map (type_parameter sub) decl.typ_params)
+    ~cstrs:(
+      List.map
+        (fun (ct1, ct2, loc) ->
+           (sub.typ sub ct1, sub.typ sub ct2, sub.location sub loc))
+        decl.typ_cstrs)
+    ~kind:(sub.type_kind sub decl.typ_kind)
+    ~priv:decl.typ_private
+    ?manifest:(Option.map (sub.typ sub) decl.typ_manifest)
+    (map_loc sub decl.typ_name)
+
+let type_kind sub tk = match tk with
+  | Ttype_abstract -> Ptype_abstract
+  | Ttype_variant list ->
+      Ptype_variant (List.map (sub.constructor_declaration sub) list)
+  | Ttype_record list ->
+      Ptype_record (List.map (sub.label_declaration sub) list)
+  | Ttype_open -> Ptype_open
+
+let constructor_arguments sub = function
+   | Cstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
+   | Cstr_record l -> Pcstr_record (List.map (sub.label_declaration sub) l)
+
+let constructor_declaration sub cd =
+  let loc = sub.location sub cd.cd_loc in
+  let attrs = sub.attributes sub cd.cd_attributes in
+  Type.constructor ~loc ~attrs
+    ~args:(constructor_arguments sub cd.cd_args)
+    ?res:(Option.map (sub.typ sub) cd.cd_res)
+    (map_loc sub cd.cd_name)
+
+let label_declaration sub ld =
+  let loc = sub.location sub ld.ld_loc in
+  let attrs = sub.attributes sub ld.ld_attributes in
+  Type.field ~loc ~attrs
+    ~mut:ld.ld_mutable
+    (map_loc sub ld.ld_name)
+    (sub.typ sub ld.ld_type)
+
+let type_extension sub tyext =
+  let attrs = sub.attributes sub tyext.tyext_attributes in
+  Te.mk ~attrs
+    ~params:(List.map (type_parameter sub) tyext.tyext_params)
+    ~priv:tyext.tyext_private
+    (map_loc sub tyext.tyext_txt)
+    (List.map (sub.extension_constructor sub) tyext.tyext_constructors)
+
+let type_exception sub tyexn =
+  let attrs = sub.attributes sub tyexn.tyexn_attributes in
+  Te.mk_exception ~attrs
+    (sub.extension_constructor sub tyexn.tyexn_constructor)
+
+let extension_constructor sub ext =
+  let loc = sub.location sub ext.ext_loc in
+  let attrs = sub.attributes sub ext.ext_attributes in
+  Te.constructor ~loc ~attrs
+    (map_loc sub ext.ext_name)
+    (match ext.ext_kind with
+      | Text_decl (args, ret) ->
+          Pext_decl (constructor_arguments sub args,
+                     Option.map (sub.typ sub) ret)
+      | Text_rebind (_p, lid) -> Pext_rebind (map_loc sub lid)
+    )
+
+let pattern sub pat =
+  let loc = sub.location sub pat.pat_loc in
+  (* todo: fix attributes on extras *)
+  let attrs = sub.attributes sub pat.pat_attributes in
+  let desc =
+  match pat with
+      { pat_extra=[Tpat_unpack, loc, _attrs]; pat_desc = Tpat_any; _ } ->
+        Ppat_unpack { txt = None; loc  }
+    | { pat_extra=[Tpat_unpack, _, _attrs]; pat_desc = Tpat_var (_,name); _ } ->
+        Ppat_unpack { name with txt = Some name.txt }
+    | { pat_extra=[Tpat_type (_path, lid), _, _attrs]; _ } ->
+        Ppat_type (map_loc sub lid)
+    | { pat_extra= (Tpat_constraint ct, _, _attrs) :: rem; _ } ->
+        Ppat_constraint (sub.pat sub { pat with pat_extra=rem },
+                         sub.typ sub ct)
+    | _ ->
+    match pat.pat_desc with
+      Tpat_any -> Ppat_any
+    | Tpat_var (id, name) ->
+        begin
+          match (Ident.name id).[0] with
+            'A'..'Z' ->
+              Ppat_unpack { name with txt = Some name.txt}
+          | _ ->
+              Ppat_var name
+        end
+
+    (* We transform (_ as x) in x if _ and x have the same location.
+       The compiler transforms (x:t) into (_ as x : t).
+       This avoids transforming a warning 27 into a 26.
+     *)
+    | Tpat_alias ({pat_desc = Tpat_any; pat_loc}, _id, name)
+         when pat_loc = pat.pat_loc ->
+       Ppat_var name
+
+    | Tpat_alias (pat, _id, name) ->
+        Ppat_alias (sub.pat sub pat, name)
+    | Tpat_constant cst -> Ppat_constant (constant cst)
+    | Tpat_tuple list ->
+        Ppat_tuple (List.map (sub.pat sub) list)
+    | Tpat_construct (lid, _, args) ->
+        Ppat_construct (map_loc sub lid,
+          (match args with
+              [] -> None
+            | [arg] -> Some (sub.pat sub arg)
+            | args ->
+                Some
+                  (Pat.tuple ~loc
+                     (List.map (sub.pat sub) args)
+                  )
+          ))
+    | Tpat_variant (label, pato, _) ->
+        Ppat_variant (label, Option.map (sub.pat sub) pato)
+    | Tpat_record (list, closed) ->
+        Ppat_record (List.map (fun (lid, _, pat) ->
+            map_loc sub lid, sub.pat sub pat) list, closed)
+    | Tpat_array list -> Ppat_array (List.map (sub.pat sub) list)
+    | Tpat_or (p1, p2, _) -> Ppat_or (sub.pat sub p1, sub.pat sub p2)
+    | Tpat_lazy p -> Ppat_lazy (sub.pat sub p)
+    | Tpat_exception p -> Ppat_exception (sub.pat sub p)
+  in
+  Pat.mk ~loc ~attrs desc
+
+let exp_extra sub (extra, loc, attrs) sexp =
+  let loc = sub.location sub loc in
+  let attrs = sub.attributes sub attrs in
+  let desc =
+    match extra with
+      Texp_coerce (cty1, cty2) ->
+        Pexp_coerce (sexp,
+                     Option.map (sub.typ sub) cty1,
+                     sub.typ sub cty2)
+    | Texp_constraint cty ->
+        Pexp_constraint (sexp, sub.typ sub cty)
+    | Texp_poly cto -> Pexp_poly (sexp, Option.map (sub.typ sub) cto)
+    | Texp_newtype s -> Pexp_newtype (mkloc s loc, sexp)
+  in
+  Exp.mk ~loc ~attrs desc
+
+let cases sub l = List.map (sub.case sub) l
+
+let case sub {c_lhs; c_guard; c_rhs} =
+  {
+   pc_lhs = sub.pat sub c_lhs;
+   pc_guard = Option.map (sub.expr sub) c_guard;
+   pc_rhs = sub.expr sub c_rhs;
+  }
+
+let value_binding sub vb =
+  let loc = sub.location sub vb.vb_loc in
+  let attrs = sub.attributes sub vb.vb_attributes in
+  Vb.mk ~loc ~attrs
+    (sub.pat sub vb.vb_pat)
+    (sub.expr sub vb.vb_expr)
+
+let expression sub exp =
+  let loc = sub.location sub exp.exp_loc in
+  let attrs = sub.attributes sub exp.exp_attributes in
+  let desc =
+    match exp.exp_desc with
+      Texp_ident (_path, lid, _) -> Pexp_ident (map_loc sub lid)
+    | Texp_constant cst -> Pexp_constant (constant cst)
+    | Texp_let (rec_flag, list, exp) ->
+        Pexp_let (rec_flag,
+          List.map (sub.value_binding sub) list,
+          sub.expr sub exp)
+
+    (* Pexp_function can't have a label, so we split in 3 cases. *)
+    (* One case, no guard: It's a fun. *)
+    | Texp_function { arg_label; cases = [{c_lhs=p; c_guard=None; c_rhs=e}];
+          _ } ->
+        Pexp_fun (arg_label, None, sub.pat sub p, sub.expr sub e)
+    (* No label: it's a function. *)
+    | Texp_function { arg_label = Nolabel; cases; _; } ->
+        Pexp_function (sub.cases sub cases)
+    (* Mix of both, we generate `fun ~label:$name$ -> match $name$ with ...` *)
+    | Texp_function { arg_label = Labelled s | Optional s as label; cases;
+          _ } ->
+        let name = fresh_name s exp.exp_env in
+        Pexp_fun (label, None, Pat.var ~loc {loc;txt = name },
+          Exp.match_ ~loc (Exp.ident ~loc {loc;txt= Lident name})
+                          (sub.cases sub cases))
+    | Texp_apply (exp, list) ->
+        Pexp_apply (sub.expr sub exp,
+          List.fold_right (fun (label, expo) list ->
+              match expo with
+                None -> list
+              | Some exp -> (label, sub.expr sub exp) :: list
+          ) list [])
+    | Texp_match (exp, cases, _) ->
+      Pexp_match (sub.expr sub exp, sub.cases sub cases)
+    | Texp_try (exp, cases) ->
+        Pexp_try (sub.expr sub exp, sub.cases sub cases)
+    | Texp_tuple list ->
+        Pexp_tuple (List.map (sub.expr sub) list)
+    | Texp_construct (lid, _, args) ->
+        Pexp_construct (map_loc sub lid,
+          (match args with
+              [] -> None
+          | [ arg ] -> Some (sub.expr sub arg)
+          | args ->
+              Some
+                (Exp.tuple ~loc (List.map (sub.expr sub) args))
+          ))
+    | Texp_variant (label, expo) ->
+        Pexp_variant (label, Option.map (sub.expr sub) expo)
+    | Texp_record { fields; extended_expression; _ } ->
+        let list = Array.fold_left (fun l -> function
+            | _, Kept _ -> l
+            | _, Overridden (lid, exp) -> (lid, sub.expr sub exp) :: l)
+            [] fields
+        in
+        Pexp_record (list, Option.map (sub.expr sub) extended_expression)
+    | Texp_field (exp, lid, _label) ->
+        Pexp_field (sub.expr sub exp, map_loc sub lid)
+    | Texp_setfield (exp1, lid, _label, exp2) ->
+        Pexp_setfield (sub.expr sub exp1, map_loc sub lid,
+          sub.expr sub exp2)
+    | Texp_array list ->
+        Pexp_array (List.map (sub.expr sub) list)
+    | Texp_ifthenelse (exp1, exp2, expo) ->
+        Pexp_ifthenelse (sub.expr sub exp1,
+          sub.expr sub exp2,
+          Option.map (sub.expr sub) expo)
+    | Texp_sequence (exp1, exp2) ->
+        Pexp_sequence (sub.expr sub exp1, sub.expr sub exp2)
+    | Texp_while (exp1, exp2) ->
+        Pexp_while (sub.expr sub exp1, sub.expr sub exp2)
+    | Texp_for (_id, name, exp1, exp2, dir, exp3) ->
+        Pexp_for (name,
+          sub.expr sub exp1, sub.expr sub exp2,
+          dir, sub.expr sub exp3)
+    | Texp_send (exp, meth, _) ->
+        Pexp_send (sub.expr sub exp, match meth with
+            Tmeth_name name -> mkloc name loc
+          | Tmeth_val id -> mkloc (Ident.name id) loc)
+    | Texp_new (_path, lid, _) -> Pexp_new (map_loc sub lid)
+    | Texp_instvar (_, path, name) ->
+      Pexp_ident ({loc = sub.location sub name.loc ; txt = lident_of_path path})
+    | Texp_setinstvar (_, _path, lid, exp) ->
+        Pexp_setinstvar (map_loc sub lid, sub.expr sub exp)
+    | Texp_override (_, list) ->
+        Pexp_override (List.map (fun (_path, lid, exp) ->
+              (map_loc sub lid, sub.expr sub exp)
+          ) list)
+    | Texp_letmodule (_id, name, _pres, mexpr, exp) ->
+        Pexp_letmodule (name, sub.module_expr sub mexpr,
+          sub.expr sub exp)
+    | Texp_letexception (ext, exp) ->
+        Pexp_letexception (sub.extension_constructor sub ext,
+                           sub.expr sub exp)
+    | Texp_assert exp -> Pexp_assert (sub.expr sub exp)
+    | Texp_lazy exp -> Pexp_lazy (sub.expr sub exp)
+    | Texp_object (cl, _) ->
+        Pexp_object (sub.class_structure sub cl)
+    | Texp_pack (mexpr) ->
+        Pexp_pack (sub.module_expr sub mexpr)
+    | Texp_letop {let_; ands; body; _} ->
+        let pat, and_pats =
+          extract_letop_patterns (List.length ands) body.c_lhs
+        in
+        let let_ = sub.binding_op sub let_ pat in
+        let ands = List.map2 (sub.binding_op sub) ands and_pats in
+        let body = sub.expr sub body.c_rhs in
+        Pexp_letop {let_; ands; body }
+    | Texp_unreachable ->
+        Pexp_unreachable
+    | Texp_extension_constructor (lid, _) ->
+        Pexp_extension ({ txt = "ocaml.extension_constructor"; loc },
+                        PStr [ Str.eval ~loc
+                                 (Exp.construct ~loc (map_loc sub lid) None)
+                             ])
+    | Texp_open (od, exp) ->
+        Pexp_open (sub.open_declaration sub od, sub.expr sub exp)
+  in
+  List.fold_right (exp_extra sub) exp.exp_extra
+    (Exp.mk ~loc ~attrs desc)
+
+let binding_op sub bop pat =
+  let pbop_op = bop.bop_op_name in
+  let pbop_pat = sub.pat sub pat in
+  let pbop_exp = sub.expr sub bop.bop_exp in
+  let pbop_loc = bop.bop_loc in
+  {pbop_op; pbop_pat; pbop_exp; pbop_loc}
+
+let package_type sub pack =
+  (map_loc sub pack.pack_txt,
+    List.map (fun (s, ct) ->
+        (s, sub.typ sub ct)) pack.pack_fields)
+
+let module_type_declaration sub mtd =
+  let loc = sub.location sub mtd.mtd_loc in
+  let attrs = sub.attributes sub mtd.mtd_attributes in
+  Mtd.mk ~loc ~attrs
+    ?typ:(Option.map (sub.module_type sub) mtd.mtd_type)
+    (map_loc sub mtd.mtd_name)
+
+let signature sub sg =
+  List.map (sub.signature_item sub) sg.sig_items
+
+let signature_item sub item =
+  let loc = sub.location sub item.sig_loc in
+  let desc =
+    match item.sig_desc with
+      Tsig_value v ->
+        Psig_value (sub.value_description sub v)
+    | Tsig_type (rec_flag, list) ->
+        Psig_type (rec_flag, List.map (sub.type_declaration sub) list)
+    | Tsig_typesubst list ->
+        Psig_typesubst (List.map (sub.type_declaration sub) list)
+    | Tsig_typext tyext ->
+        Psig_typext (sub.type_extension sub tyext)
+    | Tsig_exception ext ->
+        Psig_exception (sub.type_exception sub ext)
+    | Tsig_module md ->
+        Psig_module (sub.module_declaration sub md)
+    | Tsig_modsubst ms ->
+        Psig_modsubst (sub.module_substitution sub ms)
+    | Tsig_recmodule list ->
+        Psig_recmodule (List.map (sub.module_declaration sub) list)
+    | Tsig_modtype mtd ->
+        Psig_modtype (sub.module_type_declaration sub mtd)
+    | Tsig_open od ->
+        Psig_open (sub.open_description sub od)
+    | Tsig_include incl ->
+        Psig_include (sub.include_description sub incl)
+    | Tsig_class list ->
+        Psig_class (List.map (sub.class_description sub) list)
+    | Tsig_class_type list ->
+        Psig_class_type (List.map (sub.class_type_declaration sub) list)
+    | Tsig_attribute x ->
+        Psig_attribute x
+  in
+  Sig.mk ~loc desc
+
+let module_declaration sub md =
+  let loc = sub.location sub md.md_loc in
+  let attrs = sub.attributes sub md.md_attributes in
+  Md.mk ~loc ~attrs
+    (map_loc sub md.md_name)
+    (sub.module_type sub md.md_type)
+
+let module_substitution sub ms =
+  let loc = sub.location sub ms.ms_loc in
+  let attrs = sub.attributes sub ms.ms_attributes in
+  Ms.mk ~loc ~attrs
+    (map_loc sub ms.ms_name)
+    (map_loc sub ms.ms_txt)
+
+let include_infos f sub incl =
+  let loc = sub.location sub incl.incl_loc in
+  let attrs = sub.attributes sub incl.incl_attributes in
+  Incl.mk ~loc ~attrs
+    (f sub incl.incl_mod)
+
+let include_declaration sub = include_infos sub.module_expr sub
+let include_description sub = include_infos sub.module_type sub
+
+let class_infos f sub ci =
+  let loc = sub.location sub ci.ci_loc in
+  let attrs = sub.attributes sub ci.ci_attributes in
+  Ci.mk ~loc ~attrs
+    ~virt:ci.ci_virt
+    ~params:(List.map (type_parameter sub) ci.ci_params)
+    (map_loc sub ci.ci_id_name)
+    (f sub ci.ci_expr)
+
+let class_declaration sub = class_infos sub.class_expr sub
+let class_description sub = class_infos sub.class_type sub
+let class_type_declaration sub = class_infos sub.class_type sub
+
+let functor_parameter sub : functor_parameter -> Parsetree.functor_parameter =
+  function
+  | Unit -> Unit
+  | Named (_, name, mtype) -> Named (name, sub.module_type sub mtype)
+
+let module_type sub mty =
+  let loc = sub.location sub mty.mty_loc in
+  let attrs = sub.attributes sub mty.mty_attributes in
+  let desc = match mty.mty_desc with
+      Tmty_ident (_path, lid) -> Pmty_ident (map_loc sub lid)
+    | Tmty_alias (_path, lid) -> Pmty_alias (map_loc sub lid)
+    | Tmty_signature sg -> Pmty_signature (sub.signature sub sg)
+    | Tmty_functor (arg, mtype2) ->
+        Pmty_functor (functor_parameter sub arg, sub.module_type sub mtype2)
+    | Tmty_with (mtype, list) ->
+        Pmty_with (sub.module_type sub mtype,
+          List.map (sub.with_constraint sub) list)
+    | Tmty_typeof mexpr ->
+        Pmty_typeof (sub.module_expr sub mexpr)
+  in
+  Mty.mk ~loc ~attrs desc
+
+let with_constraint sub (_path, lid, cstr) =
+  match cstr with
+  | Twith_type decl ->
+      Pwith_type (map_loc sub lid, sub.type_declaration sub decl)
+  | Twith_module (_path, lid2) ->
+      Pwith_module (map_loc sub lid, map_loc sub lid2)
+  | Twith_typesubst decl ->
+     Pwith_typesubst (map_loc sub lid, sub.type_declaration sub decl)
+  | Twith_modsubst (_path, lid2) ->
+      Pwith_modsubst (map_loc sub lid, map_loc sub lid2)
+
+let module_expr sub mexpr =
+  let loc = sub.location sub mexpr.mod_loc in
+  let attrs = sub.attributes sub mexpr.mod_attributes in
+  match mexpr.mod_desc with
+      Tmod_constraint (m, _, Tmodtype_implicit, _ ) ->
+        sub.module_expr sub m
+    | _ ->
+        let desc = match mexpr.mod_desc with
+            Tmod_ident (_p, lid) -> Pmod_ident (map_loc sub lid)
+          | Tmod_structure st -> Pmod_structure (sub.structure sub st)
+          | Tmod_functor (arg, mexpr) ->
+              Pmod_functor
+                (functor_parameter sub arg, sub.module_expr sub mexpr)
+          | Tmod_apply (mexp1, mexp2, _) ->
+              Pmod_apply (sub.module_expr sub mexp1, sub.module_expr sub mexp2)
+          | Tmod_constraint (mexpr, _, Tmodtype_explicit mtype, _) ->
+              Pmod_constraint (sub.module_expr sub mexpr,
+                sub.module_type sub mtype)
+          | Tmod_constraint (_mexpr, _, Tmodtype_implicit, _) ->
+              assert false
+          | Tmod_unpack (exp, _pack) ->
+              Pmod_unpack (sub.expr sub exp)
+              (* TODO , sub.package_type sub pack) *)
+        in
+        Mod.mk ~loc ~attrs desc
+
+let class_expr sub cexpr =
+  let loc = sub.location sub cexpr.cl_loc in
+  let attrs = sub.attributes sub cexpr.cl_attributes in
+  let desc = match cexpr.cl_desc with
+    | Tcl_constraint ( { cl_desc = Tcl_ident (_path, lid, tyl); _ },
+                       None, _, _, _ ) ->
+        Pcl_constr (map_loc sub lid,
+          List.map (sub.typ sub) tyl)
+    | Tcl_structure clstr -> Pcl_structure (sub.class_structure sub clstr)
+
+    | Tcl_fun (label, pat, _pv, cl, _partial) ->
+        Pcl_fun (label, None, sub.pat sub pat, sub.class_expr sub cl)
+
+    | Tcl_apply (cl, args) ->
+        Pcl_apply (sub.class_expr sub cl,
+          List.fold_right (fun (label, expo) list ->
+              match expo with
+                None -> list
+              | Some exp -> (label, sub.expr sub exp) :: list
+          ) args [])
+
+    | Tcl_let (rec_flat, bindings, _ivars, cl) ->
+        Pcl_let (rec_flat,
+          List.map (sub.value_binding sub) bindings,
+          sub.class_expr sub cl)
+
+    | Tcl_constraint (cl, Some clty, _vals, _meths, _concrs) ->
+        Pcl_constraint (sub.class_expr sub cl,  sub.class_type sub clty)
+
+    | Tcl_open (od, e) ->
+        Pcl_open (sub.open_description sub od, sub.class_expr sub e)
+
+    | Tcl_ident _ -> assert false
+    | Tcl_constraint (_, None, _, _, _) -> assert false
+  in
+  Cl.mk ~loc ~attrs desc
+
+let class_type sub ct =
+  let loc = sub.location sub ct.cltyp_loc in
+  let attrs = sub.attributes sub ct.cltyp_attributes in
+  let desc = match ct.cltyp_desc with
+      Tcty_signature csg -> Pcty_signature (sub.class_signature sub csg)
+    | Tcty_constr (_path, lid, list) ->
+        Pcty_constr (map_loc sub lid, List.map (sub.typ sub) list)
+    | Tcty_arrow (label, ct, cl) ->
+        Pcty_arrow (label, sub.typ sub ct, sub.class_type sub cl)
+    | Tcty_open (od, e) ->
+        Pcty_open (sub.open_description sub od, sub.class_type sub e)
+  in
+  Cty.mk ~loc ~attrs desc
+
+let class_signature sub cs =
+  {
+    pcsig_self = sub.typ sub cs.csig_self;
+    pcsig_fields = List.map (sub.class_type_field sub) cs.csig_fields;
+  }
+
+let class_type_field sub ctf =
+  let loc = sub.location sub ctf.ctf_loc in
+  let attrs = sub.attributes sub ctf.ctf_attributes in
+  let desc = match ctf.ctf_desc with
+      Tctf_inherit ct -> Pctf_inherit (sub.class_type sub ct)
+    | Tctf_val (s, mut, virt, ct) ->
+        Pctf_val (mkloc s loc, mut, virt, sub.typ sub ct)
+    | Tctf_method  (s, priv, virt, ct) ->
+        Pctf_method  (mkloc s loc, priv, virt, sub.typ sub ct)
+    | Tctf_constraint  (ct1, ct2) ->
+        Pctf_constraint (sub.typ sub ct1, sub.typ sub ct2)
+    | Tctf_attribute x -> Pctf_attribute x
+  in
+  Ctf.mk ~loc ~attrs desc
+
+let core_type sub ct =
+  let loc = sub.location sub ct.ctyp_loc in
+  let attrs = sub.attributes sub ct.ctyp_attributes in
+  let desc = match ct.ctyp_desc with
+      Ttyp_any -> Ptyp_any
+    | Ttyp_var s -> Ptyp_var s
+    | Ttyp_arrow (label, ct1, ct2) ->
+        Ptyp_arrow (label, sub.typ sub ct1, sub.typ sub ct2)
+    | Ttyp_tuple list -> Ptyp_tuple (List.map (sub.typ sub) list)
+    | Ttyp_constr (_path, lid, list) ->
+        Ptyp_constr (map_loc sub lid,
+          List.map (sub.typ sub) list)
+    | Ttyp_object (list, o) ->
+        Ptyp_object
+          (List.map (sub.object_field sub) list, o)
+    | Ttyp_class (_path, lid, list) ->
+        Ptyp_class (map_loc sub lid, List.map (sub.typ sub) list)
+    | Ttyp_alias (ct, s) ->
+        Ptyp_alias (sub.typ sub ct, s)
+    | Ttyp_variant (list, bool, labels) ->
+        Ptyp_variant (List.map (sub.row_field sub) list, bool, labels)
+    | Ttyp_poly (list, ct) ->
+        let list = List.map (fun v -> mkloc v loc) list in
+        Ptyp_poly (list, sub.typ sub ct)
+    | Ttyp_package pack -> Ptyp_package (sub.package_type sub pack)
+  in
+  Typ.mk ~loc ~attrs desc
+
+let class_structure sub cs =
+  let rec remove_self = function
+    | { pat_desc = Tpat_alias (p, id, _s) }
+      when string_is_prefix "selfpat-" (Ident.name id) ->
+        remove_self p
+    | p -> p
+  in
+  { pcstr_self = sub.pat sub (remove_self cs.cstr_self);
+    pcstr_fields = List.map (sub.class_field sub) cs.cstr_fields;
+  }
+
+let row_field sub {rf_loc; rf_desc; rf_attributes;} =
+  let loc = sub.location sub rf_loc in
+  let attrs = sub.attributes sub rf_attributes in
+  let desc = match rf_desc with
+    | Ttag (label, bool, list) ->
+        Rtag (label, bool, List.map (sub.typ sub) list)
+    | Tinherit ct -> Rinherit (sub.typ sub ct)
+  in
+  Rf.mk ~loc ~attrs desc
+
+let object_field sub {of_loc; of_desc; of_attributes;} =
+  let loc = sub.location sub of_loc in
+  let attrs = sub.attributes sub of_attributes in
+  let desc = match of_desc with
+    | OTtag (label, ct) ->
+        Otag (label, sub.typ sub ct)
+    | OTinherit ct -> Oinherit (sub.typ sub ct)
+  in
+  Of.mk ~loc ~attrs desc
+
+and is_self_pat = function
+  | { pat_desc = Tpat_alias(_pat, id, _) } ->
+      string_is_prefix "self-" (Ident.name id)
+  | _ -> false
+
+let class_field sub cf =
+  let loc = sub.location sub cf.cf_loc in
+  let attrs = sub.attributes sub cf.cf_attributes in
+  let desc = match cf.cf_desc with
+      Tcf_inherit (ovf, cl, super, _vals, _meths) ->
+        Pcf_inherit (ovf, sub.class_expr sub cl,
+                     Option.map (fun v -> mkloc v loc) super)
+    | Tcf_constraint (cty, cty') ->
+        Pcf_constraint (sub.typ sub cty, sub.typ sub cty')
+    | Tcf_val (lab, mut, _, Tcfk_virtual cty, _) ->
+        Pcf_val (lab, mut, Cfk_virtual (sub.typ sub cty))
+    | Tcf_val (lab, mut, _, Tcfk_concrete (o, exp), _) ->
+        Pcf_val (lab, mut, Cfk_concrete (o, sub.expr sub exp))
+    | Tcf_method (lab, priv, Tcfk_virtual cty) ->
+        Pcf_method (lab, priv, Cfk_virtual (sub.typ sub cty))
+    | Tcf_method (lab, priv, Tcfk_concrete (o, exp)) ->
+        let remove_fun_self = function
+          | { exp_desc =
+              Texp_function { arg_label = Nolabel; cases = [case]; _ } }
+            when is_self_pat case.c_lhs && case.c_guard = None -> case.c_rhs
+          | e -> e
+        in
+        let exp = remove_fun_self exp in
+        Pcf_method (lab, priv, Cfk_concrete (o, sub.expr sub exp))
+    | Tcf_initializer exp ->
+        let remove_fun_self = function
+          | { exp_desc =
+              Texp_function { arg_label = Nolabel; cases = [case]; _ } }
+            when is_self_pat case.c_lhs && case.c_guard = None -> case.c_rhs
+          | e -> e
+        in
+        let exp = remove_fun_self exp in
+        Pcf_initializer (sub.expr sub exp)
+    | Tcf_attribute x -> Pcf_attribute x
+  in
+  Cf.mk ~loc ~attrs desc
+
+let location _sub l = l
+
+let default_mapper =
+  {
+    attribute = attribute;
+    attributes = attributes;
+    binding_op = binding_op;
+    structure = structure;
+    structure_item = structure_item;
+    module_expr = module_expr;
+    signature = signature;
+    signature_item = signature_item;
+    module_type = module_type;
+    with_constraint = with_constraint;
+    class_declaration = class_declaration;
+    class_expr = class_expr;
+    class_field = class_field;
+    class_structure = class_structure;
+    class_type = class_type;
+    class_type_field = class_type_field;
+    class_signature = class_signature;
+    class_type_declaration = class_type_declaration;
+    class_description = class_description;
+    type_declaration = type_declaration;
+    type_kind = type_kind;
+    typ = core_type;
+    type_extension = type_extension;
+    type_exception = type_exception;
+    extension_constructor = extension_constructor;
+    value_description = value_description;
+    pat = pattern;
+    expr = expression;
+    module_declaration = module_declaration;
+    module_substitution = module_substitution;
+    module_type_declaration = module_type_declaration;
+    module_binding = module_binding;
+    package_type = package_type ;
+    open_declaration = open_declaration;
+    open_description = open_description;
+    include_description = include_description;
+    include_declaration = include_declaration;
+    value_binding = value_binding;
+    constructor_declaration = constructor_declaration;
+    label_declaration = label_declaration;
+    cases = cases;
+    case = case;
+    location = location;
+    row_field = row_field ;
+    object_field = object_field ;
+  }
+
+let untype_structure ?(mapper=default_mapper) structure =
+  mapper.structure mapper structure
+
+let untype_signature ?(mapper=default_mapper) signature =
+  mapper.signature mapper signature
+
+(* Merlin *)
+let untype_pattern pat =
+  default_mapper.pat default_mapper pat
+
+let untype_expression exp =
+  default_mapper.expr default_mapper exp
diff --git a/src/ocaml/typing/410+multicore/untypeast.mli b/src/ocaml/typing/410+multicore/untypeast.mli
new file mode 100644
index 00000000..58105345
--- /dev/null
+++ b/src/ocaml/typing/410+multicore/untypeast.mli
@@ -0,0 +1,89 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*      Thomas Gazagnaire (OCamlPro), Fabrice Le Fessant (INRIA Saclay)   *)
+(*                                                                        *)
+(*   Copyright 2007 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+open Parsetree
+
+val lident_of_path : Path.t -> Longident.t
+
+type mapper = {
+  attribute: mapper -> Typedtree.attribute -> attribute;
+  attributes: mapper -> Typedtree.attribute list -> attribute list;
+  binding_op: mapper -> Typedtree.binding_op -> Typedtree.pattern
+              -> binding_op;
+  case: mapper -> Typedtree.case -> case;
+  cases: mapper -> Typedtree.case list -> case list;
+  class_declaration: mapper -> Typedtree.class_declaration -> class_declaration;
+  class_description: mapper -> Typedtree.class_description -> class_description;
+  class_expr: mapper -> Typedtree.class_expr -> class_expr;
+  class_field: mapper -> Typedtree.class_field -> class_field;
+  class_signature: mapper -> Typedtree.class_signature -> class_signature;
+  class_structure: mapper -> Typedtree.class_structure -> class_structure;
+  class_type: mapper -> Typedtree.class_type -> class_type;
+  class_type_declaration: mapper -> Typedtree.class_type_declaration
+                          -> class_type_declaration;
+  class_type_field: mapper -> Typedtree.class_type_field -> class_type_field;
+  constructor_declaration: mapper -> Typedtree.constructor_declaration
+                           -> constructor_declaration;
+  expr: mapper -> Typedtree.expression -> expression;
+  extension_constructor: mapper -> Typedtree.extension_constructor
+                         -> extension_constructor;
+  include_declaration:
+    mapper -> Typedtree.include_declaration -> include_declaration;
+  include_description:
+    mapper -> Typedtree.include_description -> include_description;
+  label_declaration:
+    mapper -> Typedtree.label_declaration -> label_declaration;
+  location: mapper -> Location.t -> Location.t;
+  module_binding: mapper -> Typedtree.module_binding -> module_binding;
+  module_declaration:
+    mapper -> Typedtree.module_declaration -> module_declaration;
+  module_substitution:
+    mapper -> Typedtree.module_substitution -> module_substitution;
+  module_expr: mapper -> Typedtree.module_expr -> module_expr;
+  module_type: mapper -> Typedtree.module_type -> module_type;
+  module_type_declaration:
+    mapper -> Typedtree.module_type_declaration -> module_type_declaration;
+  package_type: mapper -> Typedtree.package_type -> package_type;
+  open_declaration: mapper -> Typedtree.open_declaration -> open_declaration;
+  open_description: mapper -> Typedtree.open_description -> open_description;
+  pat: mapper -> Typedtree.pattern -> pattern;
+  row_field: mapper -> Typedtree.row_field -> row_field;
+  object_field: mapper -> Typedtree.object_field -> object_field;
+  signature: mapper -> Typedtree.signature -> signature;
+  signature_item: mapper -> Typedtree.signature_item -> signature_item;
+  structure: mapper -> Typedtree.structure -> structure;
+  structure_item: mapper -> Typedtree.structure_item -> structure_item;
+  typ: mapper -> Typedtree.core_type -> core_type;
+  type_declaration: mapper -> Typedtree.type_declaration -> type_declaration;
+  type_extension: mapper -> Typedtree.type_extension -> type_extension;
+  type_exception: mapper -> Typedtree.type_exception -> type_exception;
+  type_kind: mapper -> Typedtree.type_kind -> type_kind;
+  value_binding: mapper -> Typedtree.value_binding -> value_binding;
+  value_description: mapper -> Typedtree.value_description -> value_description;
+  with_constraint:
+    mapper -> (Path.t * Longident.t Location.loc * Typedtree.with_constraint)
+    -> with_constraint;
+}
+
+val default_mapper : mapper
+
+val untype_structure : ?mapper:mapper -> Typedtree.structure -> structure
+val untype_signature : ?mapper:mapper -> Typedtree.signature -> signature
+
+val constant : Asttypes.constant -> Parsetree.constant
+
+(* Merlin *)
+val untype_pattern : Typedtree.pattern -> Parsetree.pattern
+val untype_expression : Typedtree.expression -> Parsetree.expression
-- 
2.29.2

