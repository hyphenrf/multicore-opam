From 5b9d4b291f2e157ec3d62dbc069c189c757ae6db Mon Sep 17 00:00:00 2001
From: "matt@pallissard.net" <matt@pallissard.net>
Date: Tue, 17 Nov 2020 21:43:02 -0800
Subject: [PATCH 06/16] multicore: initial merlin_specific copy

---
 .../410+multicore/browse_raw.ml               | 889 ++++++++++++++++++
 .../410+multicore/browse_raw.mli              | 117 +++
 .../410+multicore/raw_compat.ml               | 209 ++++
 .../410+multicore/raw_compat.mli              |  88 ++
 .../410+multicore/tail_analysis.ml            |  87 ++
 .../410+multicore/tast_helper.ml              |  39 +
 .../410+multicore/typer_raw.ml                | 582 ++++++++++++
 7 files changed, 2011 insertions(+)
 create mode 100644 src/ocaml/merlin_specific/410+multicore/browse_raw.ml
 create mode 100644 src/ocaml/merlin_specific/410+multicore/browse_raw.mli
 create mode 100644 src/ocaml/merlin_specific/410+multicore/raw_compat.ml
 create mode 100644 src/ocaml/merlin_specific/410+multicore/raw_compat.mli
 create mode 100644 src/ocaml/merlin_specific/410+multicore/tail_analysis.ml
 create mode 100644 src/ocaml/merlin_specific/410+multicore/tast_helper.ml
 create mode 100644 src/ocaml/merlin_specific/410+multicore/typer_raw.ml

diff --git a/src/ocaml/merlin_specific/410+multicore/browse_raw.ml b/src/ocaml/merlin_specific/410+multicore/browse_raw.ml
new file mode 100644
index 00000000..c451de40
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/browse_raw.ml
@@ -0,0 +1,889 @@
+(* {{{ Copying *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2017  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+[@@@ocaml.warning "-9"]
+
+open Std
+
+type constructor_declaration = Typedtree.constructor_declaration
+
+open Typedtree
+
+type node =
+  | Dummy
+  | Pattern                  of pattern
+  | Expression               of expression
+  | Case                     of case
+  | Class_expr               of class_expr
+  | Class_structure          of class_structure
+  | Class_field              of class_field
+  | Class_field_kind         of class_field_kind
+  | Module_expr              of module_expr
+  | Module_type_constraint   of module_type_constraint
+  | Structure                of structure
+  | Signature                of signature
+  | Structure_item           of structure_item * Env.t
+  | Signature_item           of signature_item * Env.t
+  | Module_binding           of module_binding
+  | Value_binding            of value_binding
+  | Module_type              of module_type
+  | Module_declaration       of module_declaration
+  | Module_type_declaration  of module_type_declaration
+  | With_constraint          of with_constraint
+  | Core_type                of core_type
+  | Package_type             of package_type
+  | Row_field                of row_field
+  | Value_description        of value_description
+  | Type_declaration         of type_declaration
+  | Type_kind                of type_kind
+  | Type_extension           of type_extension
+  | Extension_constructor    of extension_constructor
+  | Label_declaration        of label_declaration
+  | Constructor_declaration  of constructor_declaration
+  | Class_type               of class_type
+  | Class_signature          of class_signature
+  | Class_type_field         of class_type_field
+  | Class_declaration        of class_declaration
+  | Class_description        of class_description
+  | Class_type_declaration   of class_type_declaration
+
+  | Include_description      of include_description
+  | Include_declaration      of include_declaration
+  | Open_description         of open_description
+  | Open_declaration         of open_declaration
+
+  | Method_call              of expression * meth * Location.t
+  | Record_field             of [`Expression of expression | `Pattern of pattern]
+                                * Types.label_description * Location.t
+  | Module_binding_name      of module_binding
+  | Module_declaration_name  of module_declaration
+  | Module_type_declaration_name of module_type_declaration
+
+let node_update_env env0 = function
+  | Pattern        {pat_env = env}  | Expression     {exp_env = env}
+  | Class_expr     {cl_env = env}   | Method_call    ({exp_env = env}, _, _)
+  | Record_field   (`Expression {exp_env = env}, _, _)
+  | Record_field   (`Pattern {pat_env = env}, _, _)
+  | Module_expr    {mod_env = env}  | Module_type    {mty_env = env}
+  | Structure_item (_, env)         | Signature_item (_, env)
+  | Core_type      {ctyp_env = env} | Class_type     {cltyp_env = env}
+    -> env
+  | Dummy                     | Case                    _
+  | Class_structure         _ | Class_signature         _
+  | Class_field             _ | Class_field_kind        _
+  | Type_extension          _ | Extension_constructor   _
+  | Package_type            _ | Row_field               _
+  | Type_declaration        _ | Type_kind               _
+  | Module_binding          _ | Module_declaration      _
+  | Module_binding_name     _ | Module_declaration_name _
+  | Module_type_declaration _ | Module_type_constraint  _
+  | Module_type_declaration_name _ | With_constraint    _
+  | Structure               _ | Signature               _
+  | Value_description       _ | Value_binding           _
+  | Constructor_declaration _ | Label_declaration       _
+  | Class_declaration       _ | Class_description       _
+  | Class_type_declaration  _ | Class_type_field        _
+  | Include_description     _ | Include_declaration     _
+  | Open_description        _ | Open_declaration        _
+    -> env0
+
+let node_real_loc loc0 = function
+  | Expression              {exp_loc = loc}
+  | Pattern                 {pat_loc = loc}
+  | Method_call             (_, _, loc)
+  | Record_field            (_, _, loc)
+  | Class_expr              {cl_loc = loc}
+  | Module_expr             {mod_loc = loc}
+  | Structure_item          ({str_loc = loc}, _)
+  | Signature_item          ({sig_loc = loc}, _)
+  | Module_type             {mty_loc = loc}
+  | Core_type               {ctyp_loc = loc}
+  | Class_type              {cltyp_loc = loc}
+  | Class_field             {cf_loc = loc}
+  | Module_binding          {mb_loc = loc}
+  | Module_declaration      {md_loc = loc}
+  | Module_type_declaration {mtd_loc = loc}
+  | Value_description       {val_loc = loc}
+  | Value_binding           {vb_loc = loc}
+  | Type_declaration        {typ_loc = loc}
+  | Label_declaration       {ld_loc = loc}
+  | Constructor_declaration {cd_loc = loc}
+  | Class_type_field        {ctf_loc = loc}
+  | Class_declaration       {ci_loc = loc}
+  | Class_description       {ci_loc = loc}
+  | Class_type_declaration  {ci_loc = loc}
+  | Extension_constructor   {ext_loc = loc}
+  | Include_description     {incl_loc = loc}
+  | Include_declaration     {incl_loc = loc}
+  | Open_description        {open_loc = loc}
+  | Open_declaration        {open_loc = loc}
+    -> loc
+  | Module_type_declaration_name {mtd_name = loc}
+    -> loc.Location.loc
+  | Module_declaration_name      {md_name = loc}
+  | Module_binding_name          {mb_name = loc}
+    -> loc.Location.loc
+  | Structure _ | Signature _ | Case _ | Class_structure _ | Type_extension _
+  | Class_field_kind _ | Module_type_constraint _ | With_constraint _
+  | Row_field _ | Type_kind _ | Class_signature _ | Package_type _
+  | Dummy
+    -> loc0
+
+let node_attributes = function
+  | Expression exp        -> exp.exp_attributes
+  | Pattern pat           -> pat.pat_attributes
+  | Class_expr cl         -> cl.cl_attributes
+  | Class_field cf        -> cf.cf_attributes
+  | Module_expr me        -> me.mod_attributes
+  | Structure_item ({str_desc = Tstr_eval (_,attr)},_) -> attr
+  | Structure_item ({str_desc = Tstr_attribute a},_) -> [a]
+  | Signature_item ({sig_desc = Tsig_attribute a},_) -> [a]
+  | Module_binding mb     -> mb.mb_attributes
+  | Value_binding vb      -> vb.vb_attributes
+  | Module_type mt        -> mt.mty_attributes
+  | Module_declaration md -> md.md_attributes
+  | Module_type_declaration mtd -> mtd.mtd_attributes
+  | Open_description o    -> o.open_attributes
+  | Include_declaration i -> i.incl_attributes
+  | Include_description i -> i.incl_attributes
+  | Core_type ct          -> ct.ctyp_attributes
+  | Row_field rf          -> rf.rf_attributes
+  | Value_description vd  -> vd.val_attributes
+  | Type_declaration td   -> td.typ_attributes
+  | Label_declaration ld  -> ld.ld_attributes
+  | Constructor_declaration cd -> cd.cd_attributes
+  | Type_extension te     -> te.tyext_attributes
+  | Extension_constructor ec -> ec.ext_attributes
+  | Class_type ct         -> ct.cltyp_attributes
+  | Class_type_field ctf  -> ctf.ctf_attributes
+  | Class_declaration ci -> ci.ci_attributes
+  | Class_description ci -> ci.ci_attributes
+  | Class_type_declaration ci -> ci.ci_attributes
+  | Method_call (obj,_,_) -> obj.exp_attributes
+  | Record_field (`Expression obj,_,_) -> obj.exp_attributes
+  | Record_field (`Pattern obj,_,_) -> obj.pat_attributes
+  | _ -> []
+
+let node_merlin_loc loc0 node =
+  let attributes = node_attributes node in
+  let loc =
+    let open Parsetree in
+    let pred { attr_name = loc; _ } = Location_aux.is_relaxed_location loc in
+    match List.find attributes ~f:pred with
+    | { attr_name; _ } -> attr_name.Location.loc
+    | exception Not_found -> node_real_loc loc0 node
+  in
+  let loc = match node with
+    | Expression {exp_extra; _} ->
+      List.fold_left ~f:(fun loc0 (_,loc,_) -> Location_aux.union loc0 loc)
+        ~init:loc exp_extra
+    | Pattern {pat_extra; _} ->
+      List.fold_left ~f:(fun loc0 (_,loc,_) -> Location_aux.union loc0 loc)
+        ~init:loc pat_extra
+    | _ -> loc
+  in
+  loc
+
+let app node env f acc =
+  f (node_update_env env node)
+    node acc
+
+type 'a f0 = Env.t -> node -> 'a -> 'a
+type ('b,'a) f1 = 'b -> Env.t -> 'a f0 -> 'a -> 'a
+
+let id_fold _env (_f : _ f0) acc = acc
+
+let ( ** ) f1 f2 env (f : _ f0) acc =
+  f2 env f (f1 env f acc)
+
+let rec list_fold (f' : _ f1) xs env f acc = match xs with
+  | x :: xs -> list_fold f' xs env f (f' x env f acc)
+  | [] -> acc
+
+let array_fold (f' : _ f1) arr env f acc =
+  let acc = ref acc in
+  for i = 0 to Array.length arr - 1 do
+    acc := f' arr.(i) env f !acc
+  done;
+  !acc
+
+let rec list_fold_with_next (f' : _ -> _ f1) xs env f acc = match xs with
+  | x :: (y :: _ as xs) -> list_fold_with_next f' xs env f (f' (Some y) x env f acc)
+  | [x] -> f' None x env f acc
+  | [] -> acc
+
+let option_fold f' o env (f : _ f0) acc = match o with
+  | None -> acc
+  | Some x -> f' x env f acc
+
+let of_core_type ct = app (Core_type ct)
+
+let of_exp_extra (exp,_,_) = match exp with
+  | Texp_constraint ct ->
+    of_core_type ct
+  | Texp_coerce (cto,ct) ->
+    of_core_type ct ** option_fold of_core_type cto
+  | Texp_poly cto ->
+    option_fold of_core_type cto
+  | Texp_newtype _ ->
+    id_fold
+let of_expression e = app (Expression e) ** list_fold of_exp_extra e.exp_extra
+
+let of_pat_extra (pat,_,_) = match pat with
+  | Tpat_constraint ct -> of_core_type ct
+  | Tpat_type _ | Tpat_unpack | Tpat_open _ -> id_fold
+let of_pattern p = app (Pattern p) ** list_fold of_pat_extra p.pat_extra
+
+let of_case c = app (Case c)
+let of_label_declaration ct = app (Label_declaration ct)
+let of_value_binding vb = app (Value_binding vb)
+let of_module_type mt = app (Module_type mt)
+let of_module_expr me = app (Module_expr me)
+let of_typ_param (ct,_) = of_core_type ct
+let of_constructor_arguments = function
+  | Cstr_tuple cts -> list_fold of_core_type cts
+  | Cstr_record lbls -> list_fold of_label_declaration lbls
+
+let of_bop { bop_op_path = _; bop_op_val = _; bop_exp; _ } =
+  of_expression bop_exp
+
+let of_record_field obj loc lbl =
+  fun env (f : _ f0) acc ->
+  app (Record_field (obj,lbl,loc)) env f acc
+
+let of_exp_record_field obj loc lbl =
+  of_record_field (`Expression obj) loc lbl
+
+let of_pat_record_field obj loc lbl =
+  of_record_field (`Pattern obj) loc lbl
+
+let of_pattern_desc = function
+  | Tpat_any | Tpat_var _ | Tpat_constant _ | Tpat_variant (_,None,_) -> id_fold
+  | Tpat_alias (p,_,_) | Tpat_variant (_,Some p,_) | Tpat_lazy p
+  | Tpat_exception p -> of_pattern p
+  | Tpat_tuple ps | Tpat_construct (_,_,ps) | Tpat_array ps ->
+    list_fold of_pattern ps
+  | Tpat_record (ls,_) ->
+    list_fold (fun ({Location. txt = _; loc},desc,p) ->
+        of_pat_record_field p loc desc ** of_pattern p) ls
+  | Tpat_or (p1,p2,_) ->
+    of_pattern p1 ** of_pattern p2
+
+let of_method_call obj meth arg loc =
+  fun env (f : _ f0) acc ->
+  let loc_start = obj.exp_loc.Location.loc_end in
+  let loc_end = match arg with
+    | None -> loc.Location.loc_end
+    | Some e -> e.exp_loc.Location.loc_start
+  in
+  let loc = {loc with Location. loc_start; loc_end} in
+  app (Method_call (obj,meth,loc)) env f acc
+
+let of_expression_desc loc = function
+  | Texp_ident _ | Texp_constant _ | Texp_instvar _
+  | Texp_variant (_,None) | Texp_new _ -> id_fold
+  | Texp_let (_,vbs,e) ->
+    of_expression e ** list_fold of_value_binding vbs
+  | Texp_function { cases; _ } ->
+    list_fold of_case cases
+  | Texp_apply (e,ls) ->
+    of_expression e **
+    list_fold (function
+        | (_,None) -> id_fold
+        | (_,Some e) -> of_expression e)
+      ls
+  | Texp_match (e,cs,_)
+  | Texp_try (e,cs) ->
+    of_expression e **
+    list_fold of_case cs
+  | Texp_tuple es | Texp_construct (_,_,es) | Texp_array es ->
+    list_fold of_expression es
+  | Texp_variant (_,Some e)
+  | Texp_assert e | Texp_lazy e | Texp_setinstvar (_,_,_,e) ->
+    of_expression e
+  | Texp_record { fields; extended_expression } ->
+    option_fold of_expression extended_expression **
+    let fold_field = function
+      | (_,Typedtree.Kept _) -> id_fold
+      | (desc,Typedtree.Overridden (_,e)) ->
+        of_exp_record_field e loc desc ** of_expression e
+    in
+    array_fold fold_field fields
+  | Texp_field (e,{Location.loc},lbl) ->
+    of_expression e ** of_exp_record_field e loc lbl
+  | Texp_setfield (e1,{Location.loc},lbl,e2) ->
+    of_expression e1 ** of_expression e2 ** of_exp_record_field e1 loc lbl
+  | Texp_ifthenelse (e1,e2,None)
+  | Texp_sequence (e1,e2) | Texp_while (e1,e2) ->
+    of_expression e1 ** of_expression e2
+  | Texp_ifthenelse (e1,e2,Some e3) | Texp_for (_,_,e1,e2,_,e3) ->
+    of_expression e1 ** of_expression e2 ** of_expression e3
+  | Texp_send (e,meth,eo) ->
+    of_expression e **
+    of_method_call e meth eo loc **
+    option_fold of_expression eo
+  | Texp_override (_,ls) ->
+    list_fold (fun (_,_,e) -> of_expression e) ls
+  | Texp_letmodule (mb_id, mb_name, mb_presence, mb_expr, e) ->
+    let mb =
+      {mb_id;mb_name;mb_expr;mb_loc=Location.none;mb_attributes=[]
+      ; mb_presence }
+    in
+    app (Module_binding mb) ** of_expression e
+  | Texp_letexception (ec,e) ->
+    app (Extension_constructor ec) ** of_expression e
+  | Texp_object (cs,_) ->
+    app (Class_structure cs)
+  | Texp_pack me ->
+    of_module_expr me
+  | Texp_unreachable | Texp_extension_constructor _ ->
+    id_fold
+  | Texp_letop { let_; ands; body; _ } ->
+    of_bop let_ **
+    list_fold of_bop ands **
+    of_case body
+  | Texp_open (od, e) ->
+    app (Module_expr od.open_expr) ** of_expression e
+
+and of_class_expr_desc = function
+  | Tcl_ident (_,_,cts) ->
+    list_fold of_core_type cts
+  | Tcl_structure cs ->
+    app (Class_structure cs)
+  | Tcl_fun (_,p,es,ce,_) ->
+    list_fold (fun (_,e) -> of_expression e) es **
+    of_pattern p **
+    app (Class_expr ce)
+  | Tcl_apply (ce,es) ->
+    list_fold (function
+        | (_,None) -> id_fold
+        | (_,Some e) -> of_expression e)
+      es **
+    app (Class_expr ce)
+  | Tcl_let (_,vbs,es,ce) ->
+    list_fold of_value_binding vbs **
+    list_fold (fun (_,e) -> of_expression e) es **
+    app (Class_expr ce)
+  | Tcl_constraint (ce,cto,_,_,_) ->
+    option_fold (fun ct -> app (Class_type ct)) cto **
+    app (Class_expr ce)
+  | Tcl_open (_,ce) ->
+    app (Class_expr ce)
+
+and of_class_field_desc = function
+  | Tcf_inherit (_,ce,_,_,_) ->
+    app (Class_expr ce)
+  | Tcf_val (_,_,_,cfk,_) | Tcf_method (_,_,cfk) ->
+    app (Class_field_kind cfk)
+  | Tcf_constraint (ct1,ct2) ->
+    of_core_type ct1 ** of_core_type ct2
+  | Tcf_initializer e ->
+    of_expression e
+  | Tcf_attribute _ ->
+    id_fold (*TODO*)
+
+and of_module_expr_desc = function
+  | Tmod_ident _ -> id_fold
+  | Tmod_structure str ->
+    app (Structure str)
+  | Tmod_functor (Unit,me) -> of_module_expr me
+  | Tmod_functor (Named (_, _, mt),me) ->
+    of_module_type mt ** of_module_expr me
+  | Tmod_apply (me1,me2,_) ->
+    of_module_expr me1 **
+    of_module_expr me2
+  | Tmod_constraint (me,_,mtc,_) ->
+    of_module_expr me **
+    app (Module_type_constraint mtc)
+  | Tmod_unpack (e,_) ->
+    of_expression e
+
+and of_structure_item_desc = function
+  | Tstr_eval (e,_) ->
+    of_expression e
+  | Tstr_value (_,vbs) ->
+    list_fold of_value_binding vbs
+  | Tstr_primitive vd ->
+    app (Value_description vd)
+  | Tstr_type (_,tds) ->
+    list_fold (fun td -> app (Type_declaration td)) tds
+  | Tstr_typext text ->
+    app (Type_extension text)
+  | Tstr_exception texn ->
+    app (Extension_constructor texn.tyexn_constructor)
+  | Tstr_module mb ->
+    app (Module_binding mb)
+  | Tstr_recmodule mbs ->
+    list_fold (fun x -> app (Module_binding x)) mbs
+  | Tstr_modtype mtd ->
+    app (Module_type_declaration mtd)
+  | Tstr_class cds ->
+    list_fold (fun (cd,_) -> app (Class_declaration cd)) cds
+  | Tstr_class_type ctds ->
+    list_fold (fun (_,_,ctd) -> app (Class_type_declaration ctd)) ctds
+  | Tstr_include i ->
+    app (Include_declaration i)
+  | Tstr_open d ->
+    app (Open_declaration d)
+  | Tstr_attribute _ ->
+    id_fold
+
+and of_module_type_desc = function
+  | Tmty_ident _ | Tmty_alias _ -> id_fold
+  | Tmty_signature sg ->
+    app (Signature sg)
+  | Tmty_functor (Named (_,_,mt1),mt2) ->
+    of_module_type mt1 ** of_module_type mt2
+  | Tmty_functor (Unit,mt) -> of_module_type mt
+  | Tmty_with (mt,wcs) ->
+    list_fold (fun (_,_,wc) -> app (With_constraint wc)) wcs **
+    of_module_type mt
+  | Tmty_typeof me ->
+    of_module_expr me
+
+and of_signature_item_desc = function
+  | Tsig_attribute _ ->
+    id_fold
+  | Tsig_open d ->
+    app (Open_description d)
+  | Tsig_value vd ->
+    app (Value_description vd)
+  | Tsig_type (_,tds) ->
+    list_fold (fun td -> app (Type_declaration td)) tds
+  | Tsig_typext text ->
+    app (Type_extension text)
+  | Tsig_exception texn ->
+    app (Extension_constructor texn.tyexn_constructor)
+  | Tsig_module md ->
+    app (Module_declaration md)
+  | Tsig_recmodule mds ->
+    list_fold (fun md -> app (Module_declaration md)) mds
+  | Tsig_modtype mtd ->
+    app (Module_type_declaration mtd)
+  | Tsig_include i ->
+    app (Include_description i)
+  | Tsig_class cds ->
+    list_fold (fun cd -> app (Class_description cd)) cds
+  | Tsig_class_type ctds ->
+    list_fold (fun ctd -> app (Class_type_declaration ctd)) ctds
+  | Tsig_typesubst tds ->
+    (* FIXME: shitty approximation *)
+    list_fold (fun td -> app (Type_declaration td)) tds
+  | Tsig_modsubst _ms ->
+    (* TODO. *)
+    id_fold
+
+and of_core_type_desc = function
+  | Ttyp_any | Ttyp_var _ -> id_fold
+  | Ttyp_arrow (_,ct1,ct2) ->
+    of_core_type ct1 ** of_core_type ct2
+  | Ttyp_tuple cts | Ttyp_constr (_,_,cts) | Ttyp_class (_,_,cts) ->
+    list_fold of_core_type cts
+  | Ttyp_object (cts,_) ->
+    list_fold (fun of_ ->
+      match of_.of_desc with
+      | OTtag (_,ct)
+      | OTinherit ct -> of_core_type ct
+    ) cts
+  | Ttyp_poly (_,ct) | Ttyp_alias (ct,_) ->
+    of_core_type ct
+  | Ttyp_variant (rfs,_,_) ->
+    list_fold (fun rf -> app (Row_field rf)) rfs
+  | Ttyp_package pt ->
+    app (Package_type pt)
+
+and of_class_type_desc = function
+  | Tcty_constr (_,_,cts) ->
+    list_fold of_core_type cts
+  | Tcty_signature cs ->
+    app (Class_signature cs)
+  | Tcty_arrow (_,ct,clt) ->
+    of_core_type ct ** app (Class_type clt)
+  | Tcty_open (_,ct) ->
+    app (Class_type ct)
+
+and of_class_type_field_desc = function
+  | Tctf_inherit ct ->
+    app (Class_type ct)
+  | Tctf_val (_,_,_,ct) | Tctf_method (_,_,_,ct) ->
+    of_core_type ct
+  | Tctf_constraint (ct1,ct2) ->
+    of_core_type ct1 ** of_core_type ct2
+  | Tctf_attribute _ ->
+    id_fold
+
+let of_node = function
+  | Dummy -> id_fold
+  | Pattern { pat_desc; pat_extra=_ } ->
+    of_pattern_desc pat_desc
+  | Expression { exp_desc; exp_extra=_; exp_loc } ->
+    of_expression_desc exp_loc exp_desc
+  | Case { c_lhs; c_guard; c_rhs } ->
+    of_pattern c_lhs ** of_expression c_rhs **
+    option_fold of_expression c_guard
+  | Class_expr { cl_desc } ->
+    of_class_expr_desc cl_desc
+  | Class_structure { cstr_self; cstr_fields } ->
+    of_pattern cstr_self **
+    list_fold (fun f -> app (Class_field f)) cstr_fields
+  | Class_field { cf_desc } ->
+    of_class_field_desc cf_desc
+  | Class_field_kind (Tcfk_virtual ct) ->
+    of_core_type ct
+  | Class_field_kind (Tcfk_concrete (_,e)) ->
+    of_expression e
+  | Module_expr { mod_desc } ->
+    of_module_expr_desc mod_desc
+  | Module_type_constraint Tmodtype_implicit ->
+    id_fold
+  | Module_type_constraint (Tmodtype_explicit mt) ->
+    of_module_type mt
+  | Structure { str_items; str_final_env } ->
+    list_fold_with_next (fun next item ->
+        match next with
+        | None -> app (Structure_item (item, str_final_env))
+        | Some item' -> app (Structure_item (item, item'.str_env)))
+      str_items
+  | Structure_item ({ str_desc }, _) ->
+    of_structure_item_desc str_desc
+  | Module_binding mb ->
+    app (Module_expr mb.mb_expr) **
+    app (Module_binding_name mb)
+  | Value_binding { vb_pat; vb_expr } ->
+    of_pattern vb_pat **
+    of_expression vb_expr
+  | Module_type { mty_desc } ->
+    of_module_type_desc mty_desc
+  | Signature { sig_items; sig_final_env } ->
+    list_fold_with_next (fun next item ->
+        match next with
+        | None -> app (Signature_item (item, sig_final_env))
+        | Some item' -> app (Signature_item (item, item'.sig_env)))
+      sig_items
+  | Signature_item ({ sig_desc }, _) ->
+    of_signature_item_desc sig_desc
+  | Module_declaration md ->
+    of_module_type md.md_type **
+    app (Module_declaration_name md)
+  | Module_type_declaration mtd ->
+    option_fold of_module_type mtd.mtd_type **
+    app (Module_type_declaration_name mtd)
+  | With_constraint (Twith_type td | Twith_typesubst td) ->
+    app (Type_declaration td)
+  | With_constraint (Twith_module _ | Twith_modsubst _) ->
+    id_fold
+  | Core_type { ctyp_desc } ->
+    of_core_type_desc ctyp_desc
+  | Package_type { pack_fields } ->
+    list_fold (fun (_,ct) -> of_core_type ct) pack_fields
+  | Row_field rf -> begin
+      match rf.rf_desc with
+      | Ttag (_,_,cts) -> list_fold of_core_type cts
+      | Tinherit ct -> of_core_type ct
+    end
+  | Value_description { val_desc } ->
+    of_core_type val_desc
+  | Type_declaration { typ_params; typ_cstrs; typ_kind; typ_manifest } ->
+    let of_typ_cstrs (ct1,ct2,_) = of_core_type ct1 ** of_core_type ct2 in
+    option_fold of_core_type typ_manifest **
+    list_fold of_typ_param typ_params **
+    app (Type_kind typ_kind) **
+    list_fold of_typ_cstrs typ_cstrs
+  | Type_kind (Ttype_abstract | Ttype_open) ->
+    id_fold
+  | Type_kind (Ttype_variant cds) ->
+    list_fold (fun cd -> app (Constructor_declaration cd)) cds
+  | Type_kind (Ttype_record lds) ->
+    list_fold of_label_declaration lds
+  | Type_extension { tyext_params; tyext_constructors } ->
+    list_fold of_typ_param tyext_params **
+    list_fold (fun ec -> app (Extension_constructor ec)) tyext_constructors
+  | Extension_constructor { ext_kind = Text_decl (carg,cto) } ->
+    option_fold of_core_type cto **
+    of_constructor_arguments carg
+  | Extension_constructor { ext_kind = Text_rebind _ } ->
+    id_fold
+  | Label_declaration { ld_type } ->
+    of_core_type ld_type
+  | Constructor_declaration { cd_args; cd_res } ->
+    option_fold of_core_type cd_res **
+    of_constructor_arguments cd_args
+  | Class_type { cltyp_desc } ->
+    of_class_type_desc cltyp_desc
+  | Class_signature { csig_self; csig_fields } ->
+    of_core_type csig_self **
+    list_fold (fun x -> app (Class_type_field x)) csig_fields
+  | Class_type_field { ctf_desc } ->
+    of_class_type_field_desc ctf_desc
+  | Class_declaration { ci_params; ci_expr } ->
+    app (Class_expr ci_expr) **
+    list_fold of_typ_param ci_params
+  | Class_description { ci_params; ci_expr } ->
+    app (Class_type ci_expr) **
+    list_fold of_typ_param ci_params
+  | Class_type_declaration { ci_params; ci_expr } ->
+    app (Class_type ci_expr) **
+    list_fold of_typ_param ci_params
+  | Method_call _ -> id_fold
+  | Record_field _ -> id_fold
+  | Module_binding_name _ -> id_fold
+  | Module_declaration_name _ -> id_fold
+  | Module_type_declaration_name _ -> id_fold
+  | Open_description _ -> id_fold
+  | Open_declaration od ->
+    app (Module_expr od.open_expr)
+  | Include_declaration i ->
+    of_module_expr i.incl_mod
+  | Include_description i ->
+    of_module_type i.incl_mod
+
+let fold_node f env node acc =
+  of_node node env f acc
+
+(** Accessors for information specific to a node *)
+
+let string_of_node = function
+  | Dummy -> "dummy"
+  | Pattern                 p ->
+    let fmt, printer = Format.to_string () in
+    Printtyped.pattern 0 fmt p ;
+    printer ()
+  | Expression              _ -> "expression"
+  | Case                    _ -> "case"
+  | Class_expr              _ -> "class_expr"
+  | Class_structure         _ -> "class_structure"
+  | Class_field             _ -> "class_field"
+  | Class_field_kind        _ -> "class_field_kind"
+  | Module_expr             _ -> "module_expr"
+  | Module_type_constraint  _ -> "module_type_constraint"
+  | Structure               _ -> "structure"
+  | Structure_item          _ -> "structure_item"
+  | Module_binding          _ -> "module_binding"
+  | Value_binding           _ -> "value_binding"
+  | Module_type             _ -> "module_type"
+  | Signature               _ -> "signature"
+  | Signature_item          _ -> "signature_item"
+  | Module_declaration      _ -> "module_declaration"
+  | Module_type_declaration _ -> "module_type_declaration"
+  | With_constraint         _ -> "with_constraint"
+  | Core_type               _ -> "core_type"
+  | Package_type            _ -> "package_type"
+  | Row_field               _ -> "row_field"
+  | Value_description       _ -> "value_description"
+  | Type_declaration        _ -> "type_declaration"
+  | Type_kind               _ -> "type_kind"
+  | Type_extension          _ -> "type_extension"
+  | Extension_constructor   _ -> "extension_constructor"
+  | Label_declaration       _ -> "label_declaration"
+  | Constructor_declaration _ -> "constructor_declaration"
+  | Class_type              _ -> "class_type"
+  | Class_signature         _ -> "class_signature"
+  | Class_type_field        _ -> "class_type_field"
+  | Class_declaration       _ -> "class_declaration"
+  | Class_description       _ -> "class_description"
+  | Class_type_declaration  _ -> "class_type_declaration"
+  | Method_call             _ -> "method_call"
+  | Record_field            _ -> "record_field"
+  | Module_binding_name     _ -> "module_binding_name"
+  | Module_declaration_name _ -> "module_declaration_name"
+  | Module_type_declaration_name _ -> "module_type_declaration_name"
+  | Open_description        _ -> "open_description"
+  | Open_declaration        _ -> "open_declaration"
+  | Include_description     _ -> "include_description"
+  | Include_declaration     _ -> "include_declaration"
+
+let mkloc = Location.mkloc
+let reloc txt loc = {loc with Location. txt}
+
+let type_constructor_path = function
+  | {Types.desc = Types.Tconstr (p,_,_)} -> p
+  | _ -> raise Not_found
+
+(* Build a fake path for value constructors and labels *)
+let fake_path typ name loc =
+    begin match type_constructor_path typ with
+      | Path.Pdot (p, _) ->
+        [mkloc (Path.Pdot (p, name)) loc]
+      | Path.Pident _ ->
+        [mkloc (Path.Pident (Ident.create_persistent name)) loc]
+      | _ -> []
+      | exception Not_found -> []
+    end
+
+let pattern_paths { Typedtree. pat_desc; pat_extra; pat_loc } =
+  let init =
+    match pat_desc with
+    | Tpat_construct ({Location. loc},{Types. cstr_name; cstr_res; _},_) ->
+      fake_path cstr_res cstr_name loc
+    | Tpat_var (id,_) -> [mkloc (Path.Pident id) pat_loc]
+    | Tpat_alias (_,id,loc) -> [reloc (Path.Pident id) loc]
+    | _ -> []
+  in
+  List.fold_left ~init pat_extra
+    ~f:(fun acc (extra,_,_) ->
+      match extra with
+      | Tpat_open (path,loc,_) | Tpat_type (path,loc) ->
+        reloc path loc :: acc
+      | _ -> acc)
+
+let module_expr_paths { Typedtree. mod_desc } =
+  match mod_desc with
+  | Tmod_ident (path, loc) -> [reloc path loc]
+  | Tmod_functor (Named (Some id, loc, _), _) -> [reloc (Path.Pident id) loc]
+  | _ -> []
+
+let expression_paths { Typedtree. exp_desc; _ } =
+  match exp_desc with
+  | Texp_ident (path,loc,_) -> [reloc path loc]
+  | Texp_new (path,loc,_) -> [reloc path loc]
+  | Texp_instvar (_,path,loc)  -> [reloc path loc]
+  | Texp_setinstvar (_,path,loc,_) -> [reloc path loc]
+  | Texp_override (_,ps) ->
+    List.map ~f:(fun (path,loc,_) -> reloc path loc) ps
+  | Texp_letmodule (Some id,loc,_,_,_) -> [reloc (Path.Pident id) loc]
+  | Texp_for (id,{Parsetree.ppat_loc = loc},_,_,_,_) ->
+    [mkloc (Path.Pident id) loc]
+  | Texp_construct ({Location. loc}, {Types. cstr_name; cstr_res; _}, _) ->
+    fake_path cstr_res cstr_name loc
+  | Texp_open (od,_) -> module_expr_paths od.open_expr
+  | _ -> []
+
+let core_type_paths { Typedtree. ctyp_desc } =
+  match ctyp_desc with
+  | Ttyp_constr (path,loc,_) -> [reloc path loc]
+  | Ttyp_class (path,loc,_) -> [reloc path loc]
+  | _ -> []
+
+let class_expr_paths { Typedtree. cl_desc } =
+  match cl_desc with
+  | Tcl_ident (path, loc, _) -> [reloc path loc]
+  | _ -> []
+
+let class_field_paths { Typedtree. cf_desc } =
+  match cf_desc with
+  | Tcf_val (loc,_,id,_,_) -> [reloc (Path.Pident id) loc]
+  | _ -> []
+
+let structure_item_paths { Typedtree. str_desc } =
+  match str_desc with
+  | Tstr_class_type cls ->
+    List.map ~f:(fun (id,loc,_) -> reloc (Path.Pident id) loc) cls
+  | Tstr_open od -> module_expr_paths od.open_expr
+  | _ -> []
+
+let module_type_paths { Typedtree. mty_desc } =
+  match mty_desc with
+  | Tmty_ident (path, loc) | Tmty_alias (path, loc) ->
+    [reloc path loc]
+  | Tmty_functor (Named (Some id,loc,_),_) ->
+    [reloc (Path.Pident id) loc]
+  | Tmty_with (_,ls) ->
+    List.map ~f:(fun (p,l,_) -> reloc p l) ls
+  | _ -> []
+
+let signature_item_paths { Typedtree. sig_desc } =
+  match sig_desc with
+  | Tsig_open { Typedtree. open_expr = (open_path, open_txt); _ } ->
+    [reloc open_path open_txt]
+  | _ -> []
+
+let with_constraint_paths = function
+  | Twith_module (path,loc) | Twith_modsubst (path,loc) ->
+    [reloc path loc]
+  | _ -> []
+
+let ci_paths {Typedtree. ci_id_name; ci_id_class } =
+  [reloc (Path.Pident ci_id_class) ci_id_name]
+
+let node_paths =
+  let open Typedtree in function
+  | Pattern p -> pattern_paths p
+  | Expression e -> expression_paths e
+  | Class_expr e -> class_expr_paths e
+  | Class_field f -> class_field_paths f
+  | Module_expr me -> module_expr_paths me
+  | Structure_item (i,_) -> structure_item_paths i
+  | Module_binding_name { mb_id = Some mb_id; mb_name } ->
+    [reloc (Path.Pident mb_id) mb_name]
+  | Module_type mt -> module_type_paths mt
+  | Signature_item (i,_) -> signature_item_paths i
+  | Module_declaration_name { md_id = Some md_id; md_name } ->
+    [reloc (Path.Pident md_id) md_name]
+  | Module_type_declaration_name { mtd_id; mtd_name } ->
+    [reloc (Path.Pident mtd_id) mtd_name]
+  | With_constraint c -> with_constraint_paths c
+  | Core_type ct -> core_type_paths ct
+  | Package_type { pack_path; pack_txt } ->
+    [reloc pack_path pack_txt]
+  | Value_description { val_id; val_name } ->
+    [reloc (Path.Pident val_id) val_name]
+  | Type_declaration { typ_id; typ_name } ->
+    [reloc (Path.Pident typ_id) typ_name]
+  | Type_extension { tyext_path; tyext_txt } ->
+    [reloc tyext_path tyext_txt]
+  | Extension_constructor { ext_id; ext_name } ->
+    [reloc (Path.Pident ext_id) ext_name]
+  | Label_declaration { ld_id; ld_name } ->
+    [reloc (Path.Pident ld_id) ld_name]
+  | Constructor_declaration { cd_id; cd_name } ->
+    [reloc (Path.Pident cd_id) cd_name]
+  | Class_declaration ci -> ci_paths ci
+  | Class_description ci -> ci_paths ci
+  | Class_type_declaration ci -> ci_paths ci
+  | Record_field (_,{Types.lbl_res; lbl_name; _},loc) ->
+    fake_path lbl_res lbl_name loc
+  | _ -> []
+
+let node_is_constructor = function
+  | Constructor_declaration decl ->
+    Some {decl.cd_name with Location.txt = `Declaration decl}
+  | Expression {exp_desc = Texp_construct (loc, desc, _)} ->
+    Some {loc with Location.txt = `Description desc}
+  | Pattern {pat_desc = Tpat_construct (loc, desc, _)} ->
+    Some {loc with Location.txt = `Description desc}
+  | _ -> None
+
+let node_of_binary_part env part =
+  let open Cmt_format in
+  match part with
+  | Partial_structure x ->
+    Structure x
+  | Partial_structure_item x ->
+    Structure_item (x, env)
+  | Partial_expression x ->
+    Expression x
+  | Partial_pattern x ->
+    Pattern x
+  | Partial_class_expr x ->
+    Class_expr x
+  | Partial_signature x ->
+    Signature x
+  | Partial_signature_item x ->
+    Signature_item (x, env)
+  | Partial_module_type x ->
+    Module_type x
diff --git a/src/ocaml/merlin_specific/410+multicore/browse_raw.mli b/src/ocaml/merlin_specific/410+multicore/browse_raw.mli
new file mode 100644
index 00000000..71266ba0
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/browse_raw.mli
@@ -0,0 +1,117 @@
+(* {{{ COPYING *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2014  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+(** [Browse_node] offers a uniform interface to traverse constructions from
+  * [TypedTree].
+  *
+  * Mutually recursive types from [TypedTree] are wrapped into different
+  * constructors of the type [node].
+  * Then the [fold] function traverses one-level of sub-nodes.
+  *
+  * In the meantime, the most specific environment and location are threaded
+  * (FIXME: should these two be managed separately?).
+  *
+  * Finally [BrowseT] module a node into a tree which structure mimics
+  * the recursive structure of the [TypedTree] node.
+  *
+  *)
+
+(* Compatibility with previous versions of OCaml *)
+type constructor_declaration = Typedtree.constructor_declaration
+
+open Typedtree
+
+type node =
+  | Dummy
+  | Pattern                  of pattern
+  | Expression               of expression
+  | Case                     of case
+  | Class_expr               of class_expr
+  | Class_structure          of class_structure
+  | Class_field              of class_field
+  | Class_field_kind         of class_field_kind
+  | Module_expr              of module_expr
+  | Module_type_constraint   of module_type_constraint
+  | Structure                of structure
+  | Signature                of signature
+  | (* Items come with their final environment *)
+    Structure_item           of structure_item * Env.t
+  | Signature_item           of signature_item * Env.t
+  | Module_binding           of module_binding
+  | Value_binding            of value_binding
+  | Module_type              of module_type
+  | Module_declaration       of module_declaration
+  | Module_type_declaration  of module_type_declaration
+  | With_constraint          of with_constraint
+  | Core_type                of core_type
+  | Package_type             of package_type
+  | Row_field                of row_field
+  | Value_description        of value_description
+  | Type_declaration         of type_declaration
+  | Type_kind                of type_kind
+  | Type_extension           of type_extension
+  | Extension_constructor    of extension_constructor
+  | Label_declaration        of label_declaration
+  | Constructor_declaration  of constructor_declaration
+  | Class_type               of class_type
+  | Class_signature          of class_signature
+  | Class_type_field         of class_type_field
+  | Class_declaration        of class_declaration
+  | Class_description        of class_description
+  | Class_type_declaration   of class_type_declaration
+
+  | Include_description      of include_description
+  | Include_declaration      of include_declaration
+  | Open_description         of open_description
+  | Open_declaration         of open_declaration
+
+  | Method_call              of expression * meth * Location.t
+  | Record_field             of [ `Expression of expression | `Pattern of pattern ] *
+                                Types.label_description * Location.t
+  | Module_binding_name      of module_binding
+  | Module_declaration_name  of module_declaration
+  | Module_type_declaration_name of module_type_declaration
+
+val fold_node : (Env.t -> node -> 'a -> 'a) -> Env.t -> node -> 'a -> 'a
+
+(** Accessors for information specific to a node *)
+
+val node_update_env : Env.t -> node -> Env.t
+val node_real_loc : Location.t -> node -> Location.t
+val node_merlin_loc : Location.t -> node -> Location.t
+val node_attributes : node -> attribute list
+
+val string_of_node : node -> string
+
+val node_paths : node -> Path.t Location.loc list
+
+val node_is_constructor : node ->
+  [ `Description of Types.constructor_description
+  | `Declaration of Typedtree.constructor_declaration ] Location.loc option
+
+val node_of_binary_part : Env.t -> Cmt_format.binary_part -> node
diff --git a/src/ocaml/merlin_specific/410+multicore/raw_compat.ml b/src/ocaml/merlin_specific/410+multicore/raw_compat.ml
new file mode 100644
index 00000000..9b6012b2
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/raw_compat.ml
@@ -0,0 +1,209 @@
+(* {{{ COPYING *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2015  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+[@@@ocaml.warning "-9"] (* yolo *)
+
+open Std
+
+(* For Browse_misc *)
+
+let signature_of_summary =
+  let open Env in
+  let open Types in
+  (* FIXME: the use of [Exported] here is wrong... The compiler should export
+     that information. *)
+  function
+  | Env_value (_,i,v)      -> Some (Sig_value (i,v,Exported))
+  (* Trec_not == bluff, FIXME *)
+  | Env_type (_,i,t)       -> Some (Sig_type (i,t,Trec_not,Exported))
+  (* Texp_first == bluff, FIXME *)
+  | Env_extension (_,i,e)  ->
+    begin match e.ext_type_path with
+    | Path.Pident id when Ident.name id = "exn" ->
+      Some (Sig_typext (i,e, Text_exception, Exported))
+    | _ ->
+      Some (Sig_typext (i,e, Text_first, Exported))
+    end
+  | Env_module (_,i,pr,m)  -> Some (Sig_module (i,pr,m,Trec_not,Exported))
+  | Env_modtype (_,i,m)    -> Some (Sig_modtype (i,m,Exported))
+  | Env_class (_,i,c)      -> Some (Sig_class (i,c,Trec_not,Exported))
+  | Env_cltype (_,i,c)     -> Some (Sig_class_type (i,c,Trec_not,Exported))
+  | Env_open _ | Env_empty | Env_functor_arg _
+  | Env_constraints _ | Env_copy_types _ | Env_persistent _
+  | Env_value_unbound _ | Env_module_unbound _ -> None
+
+let summary_prev = function
+  | Env.Env_empty -> None
+  | Env.Env_open (s,_)       | Env.Env_value (s,_,_)
+  | Env.Env_type (s,_,_)     | Env.Env_extension (s,_,_)
+  | Env.Env_module (s,_,_,_) | Env.Env_modtype (s,_,_)
+  | Env.Env_class (s,_,_)    | Env.Env_cltype (s,_,_)
+  | Env.Env_functor_arg (s,_)
+  | Env.Env_constraints (s,_)
+  | Env.Env_copy_types s
+  | Env.Env_persistent (s,_)
+  | Env.Env_value_unbound (s, _, _) | Env.Env_module_unbound (s, _, _) ->
+    Some s
+
+let summary_module_ident_opt = function
+  | Env.Env_module (_,i,_,_) -> Some i
+  | _ -> None
+
+(* For Type_utils *)
+
+let dest_tstr_eval str =
+  let open Typedtree in
+  match str.str_items with
+  | [ { str_desc = Tstr_eval (exp,_) }] -> exp
+  | _ -> failwith "unhandled expression"
+
+(* For Completion *)
+
+let labels_of_application ~prefix = function
+  | {Typedtree. exp_desc = Typedtree.Texp_apply (f, args); exp_env; _} ->
+    let open Typedtree in
+    let rec labels t =
+      let t = Ctype.repr t in
+      match t.Types.desc with
+      | Types.Tarrow (label, lhs, rhs, _) ->
+        (label, lhs) :: labels rhs
+      | _ ->
+        let t' = Ctype.full_expand exp_env t in
+        if Types.TypeOps.equal t t' then
+          []
+        else
+          labels t'
+    in
+    let labels = labels f.exp_type in
+    let is_application_of label (label',expr) =
+      match expr with
+      | Some {exp_loc = {Location. loc_ghost; loc_start; loc_end}} ->
+        label = label'
+        && (Btype.prefixed_label_name label <> prefix)
+        && not loc_ghost
+        && not (loc_start = loc_end)
+      | None -> false
+    in
+    List.filter_map ~f:(fun (label, ty) ->
+        match label with
+        | Asttypes.Nolabel -> None
+        | label when List.exists ~f:(is_application_of label) args -> None
+        | Asttypes.Labelled str -> Some ("~" ^ str, ty)
+        | Asttypes.Optional str ->
+          let ty = match (Ctype.repr ty).Types.desc with
+            | Types.Tconstr (path, [ty], _)
+              when Path.same path Predef.path_option -> ty
+            | _ -> ty
+          in
+          Some ("?" ^ str, ty)
+      ) labels
+  | _ -> []
+
+(* Select open nodes *)
+
+let rec select_open_node =
+  let open Typedtree in
+  let open Browse_raw in
+  function
+  | (_, ( Structure_item ({str_desc =
+                             Tstr_open { open_expr =
+                                           { mod_desc = Tmod_ident (p, _) }}},
+                          _)))
+    :: ancestors ->
+    Some (p, ancestors)
+  | (_, ( Signature_item ({sig_desc = Tsig_open op}, _))) :: ancestors ->
+    Some (fst op.open_expr, ancestors)
+  | (_, Pattern {pat_extra; _}) :: ancestors
+    when List.exists pat_extra
+        ~f:(function (Tpat_open _, _ ,_) -> true | _ -> false) ->
+    let p = List.find_map pat_extra
+        ~f:(function | Tpat_open (p,_,_), _ ,_ -> Some p
+                     | _ -> None)
+    in
+    Some (p, ancestors)
+  | (_, Expression { exp_desc =
+                       Texp_open ({ open_expr =
+                                      { mod_desc = Tmod_ident (p, _)}}, _);
+                     _
+                   }) :: _ as ancestors ->
+    Some (p, ancestors)
+  | [] -> None
+  | _ :: ancestors -> select_open_node ancestors
+
+let texp_function_cases = function
+  | Typedtree.Texp_function {cases; _} -> cases
+  | _ -> assert false
+
+let tmatch_scrutinee = function
+  | Typedtree.Texp_match (e, _, _) -> e
+  | _ -> assert false
+
+let const_string (s, o) = Asttypes.Const_string (s, o)
+
+let dummy_type_scheme desc =
+  { Types. level = 0 ; id = 0 ; scope = Btype.generic_level ; desc }
+
+let ctype_instance _env scheme =
+  Ctype.instance scheme
+
+let si_modtype_opt : Types.signature_item -> Types.module_type option = function
+  | Sig_modtype (_, m, _) -> m.mtd_type
+  | Sig_module (_, _, m, _, _) -> Some m.md_type
+  | _ -> None
+
+module Pattern = struct
+  open Asttypes
+
+  type pattern = Typedtree.pattern
+
+  type desc_view = Typedtree.pattern_desc =
+    | Tpat_any
+    | Tpat_var of Ident.t * string loc
+    | Tpat_alias of pattern * Ident.t * string loc
+    | Tpat_constant of constant
+    | Tpat_tuple of pattern list
+    | Tpat_construct of
+        Longident.t loc * Types.constructor_description * pattern list
+    | Tpat_variant of label * pattern option * Types.row_desc ref
+    | Tpat_record of
+        (Longident.t loc * Types.label_description * pattern) list *
+        closed_flag
+    | Tpat_array of pattern list
+    | Tpat_or of pattern * pattern * Types.row_desc option
+    | Tpat_lazy of pattern
+    | Tpat_exception of pattern
+
+  let view p = p.Typedtree.pat_desc
+
+  exception Not_supported
+
+  let update_desc_exn p pat_desc = { p with Typedtree. pat_desc }
+end
+
+let md_id { Typedtree.md_id; _ } = md_id
+let mb_id { Typedtree.mb_id; _ } = mb_id
diff --git a/src/ocaml/merlin_specific/410+multicore/raw_compat.mli b/src/ocaml/merlin_specific/410+multicore/raw_compat.mli
new file mode 100644
index 00000000..2664b68b
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/raw_compat.mli
@@ -0,0 +1,88 @@
+(* {{{ COPYING *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2015  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+val signature_of_summary : Env.summary -> Types.signature_item option
+
+val summary_prev : Env.summary -> Env.summary option
+
+val summary_module_ident_opt : Env.summary -> Ident.t option
+
+val dest_tstr_eval : Typedtree.structure -> Typedtree.expression
+
+val labels_of_application :
+  prefix:string -> Typedtree.expression -> (string * Types.type_expr) list
+
+val select_open_node :
+  ('a * Browse_raw.node) list ->
+  (Path.t * ('a * Browse_raw.node) list) option
+
+val texp_function_cases : Typedtree.expression_desc -> Typedtree.case list
+
+val tmatch_scrutinee : Typedtree.expression_desc -> Typedtree.expression
+
+val const_string : string * string option -> Asttypes.constant
+
+val dummy_type_scheme : Types.type_desc -> Types.type_expr
+
+val ctype_instance : Env.t -> Types.type_expr -> Types.type_expr
+
+val si_modtype_opt : Types.signature_item -> Types.module_type option
+
+module Pattern : sig
+  open Asttypes
+
+  type pattern = Typedtree.pattern
+
+  type desc_view =
+    | Tpat_any
+    | Tpat_var of Ident.t * string loc
+    | Tpat_alias of pattern * Ident.t * string loc
+    | Tpat_constant of constant
+    | Tpat_tuple of pattern list
+    | Tpat_construct of
+        Longident.t loc * Types.constructor_description * pattern list
+    | Tpat_variant of label * pattern option * Types.row_desc ref
+    | Tpat_record of
+        (Longident.t loc * Types.label_description * pattern) list *
+        closed_flag
+    | Tpat_array of pattern list
+    | Tpat_or of pattern * pattern * Types.row_desc option
+    | Tpat_lazy of pattern
+    | Tpat_exception of pattern
+
+  val view : pattern -> desc_view
+
+  exception Not_supported
+
+  val update_desc_exn : pattern -> desc_view -> pattern
+  (** will raise [Not_supported] if the desc doesn't exist in that version of
+      OCaml. *)
+end
+
+val md_id : Typedtree.module_declaration -> Ident.t option
+val mb_id : Typedtree.module_binding -> Ident.t option
diff --git a/src/ocaml/merlin_specific/410+multicore/tail_analysis.ml b/src/ocaml/merlin_specific/410+multicore/tail_analysis.ml
new file mode 100644
index 00000000..0c9680d6
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/tail_analysis.ml
@@ -0,0 +1,87 @@
+(* {{{ COPYING *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2015  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+open Std
+open Browse_raw
+open Typedtree
+
+let tail_operator = function
+  | {exp_desc = Texp_ident
+                  (_,_, {Types.val_kind =
+                           Types.Val_prim
+                             {Primitive.prim_name = "%sequand"|"%sequor"; _ }
+                        ; _ })
+    ; _ }
+    -> true
+  | _ -> false
+
+let expr_tail_positions = function
+  | Texp_apply (callee, args) when tail_operator callee ->
+    begin match List.last args with
+      | None | Some (_, None)-> []
+      | Some (_, Some expr) -> [Expression expr]
+    end
+  | Texp_instvar _ | Texp_setinstvar _ | Texp_override _ | Texp_assert _
+  | Texp_lazy _ | Texp_object _ | Texp_pack _
+  | Texp_function _ | Texp_apply _ | Texp_tuple _
+  | Texp_ident _ | Texp_constant _
+  | Texp_construct _ | Texp_variant _ | Texp_record _
+  | Texp_field _ | Texp_setfield _ | Texp_array _
+  | Texp_while _ | Texp_for _ | Texp_send _ | Texp_new _
+  | Texp_unreachable | Texp_extension_constructor _ | Texp_letop _
+    -> []
+  | Texp_match (_,cs,_)
+  | Texp_try (_,cs)
+    -> List.map cs ~f:(fun c -> Case c)
+  | Texp_letmodule (_,_,_,_,e) | Texp_letexception (_,e) | Texp_let (_,_,e)
+  | Texp_sequence (_,e) | Texp_ifthenelse (_,e,None) | Texp_open (_, e)
+    -> [Expression e]
+  | Texp_ifthenelse (_,e1,Some e2)
+    -> [Expression e1; Expression e2]
+
+
+let tail_positions = function
+  | Expression expr -> expr_tail_positions expr.exp_desc
+  | Case case -> [Expression case.c_rhs]
+  | _ -> []
+
+(* If the expression is a function, return all of its entry-points (which are
+   in tail-positions). Returns an empty list otherwise *)
+let expr_entry_points = function
+  | Texp_function {cases; _} -> List.map cases ~f:(fun c -> Case c)
+  | _ -> []
+
+let entry_points = function
+  | Expression expr -> expr_entry_points expr.exp_desc
+  | _ -> []
+
+(* FIXME: what about method call? It should be translated to a Texp_apply,
+   but I am not sure *)
+let is_call = function
+  | Expression {exp_desc = Texp_apply _; _} -> true
+  | _ -> false
diff --git a/src/ocaml/merlin_specific/410+multicore/tast_helper.ml b/src/ocaml/merlin_specific/410+multicore/tast_helper.ml
new file mode 100644
index 00000000..922da39a
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/tast_helper.ml
@@ -0,0 +1,39 @@
+open Typedtree
+
+module Pat = struct
+  let pat_extra = []
+  let pat_attributes = []
+
+  let constant ?(loc=Location.none) pat_env pat_type c =
+    let pat_desc = Tpat_constant c in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let var ?loc pat_env pat_type str =
+    let pat_loc =
+      match loc with
+      | None -> str.Asttypes.loc
+      | Some loc -> loc
+    in
+    let pat_desc = Tpat_var (Ident.create_local str.Asttypes.txt, str) in
+    { pat_desc; pat_loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let record ?(loc=Location.none) pat_env pat_type lst closed_flag =
+    let pat_desc = Tpat_record (lst, closed_flag) in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let tuple ?(loc=Location.none) pat_env pat_type lst =
+    let pat_desc = Tpat_tuple lst in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let construct ?(loc=Location.none) pat_env pat_type lid cstr_desc args =
+    let pat_desc = Tpat_construct (lid, cstr_desc, args) in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let pat_or ?(loc=Location.none) ?row_desc pat_env pat_type p1 p2 =
+    let pat_desc = Tpat_or (p1, p2, row_desc) in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+
+  let variant ?(loc=Location.none) pat_env pat_type lbl sub rd =
+    let pat_desc = Tpat_variant (lbl, sub, rd) in
+    { pat_desc; pat_loc = loc; pat_extra; pat_attributes; pat_type; pat_env }
+end
diff --git a/src/ocaml/merlin_specific/410+multicore/typer_raw.ml b/src/ocaml/merlin_specific/410+multicore/typer_raw.ml
new file mode 100644
index 00000000..759875c4
--- /dev/null
+++ b/src/ocaml/merlin_specific/410+multicore/typer_raw.ml
@@ -0,0 +1,582 @@
+(* {{{ COPYING *(
+
+  This file is part of Merlin, an helper for ocaml editors
+
+  Copyright (C) 2013 - 2015  Frédéric Bour  <frederic.bour(_)lakaban.net>
+                             Thomas Refis  <refis.thomas(_)gmail.com>
+                             Simon Castellan  <simon.castellan(_)iuwt.fr>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation the
+  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+  sell copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  The Software is provided "as is", without warranty of any kind, express or
+  implied, including but not limited to the warranties of merchantability,
+  fitness for a particular purpose and noninfringement. In no event shall
+  the authors or copyright holders be liable for any claim, damages or other
+  liability, whether in an action of contract, tort or otherwise, arising
+  from, out of or in connection with the software or the use or other dealings
+  in the Software.
+
+)* }}} *)
+
+open Std
+open Location
+open Parsetree
+
+let fresh_env () =
+  (*Ident.reinit();*)
+  let initially_opened_module =
+    if !Clflags.nopervasives then
+      None
+    else
+      Some "Stdlib"
+  in
+  Typemod.initial_env
+    ~loc:(Location.in_file "command line")
+    ~safe_string:(not !Clflags.unsafe_string)
+    ~initially_opened_module
+    ~open_implicit_modules:(List.rev !Clflags.open_modules)
+
+module Rewrite_loc = struct
+  let queue = ref []
+
+  let update l =
+    if l <> none then
+      match !queue with
+      | [] -> assert false
+      | l' :: ls -> queue := Location_aux.union l l' :: ls
+
+  let enter () = queue := Location.none :: !queue
+  let leave l0 = match !queue with
+    | [] -> assert false
+    | [l] -> queue := []; Location_aux.extend l0 l
+    | l :: l' :: ls ->
+      let l = Location_aux.extend l0 l in
+      queue := Location_aux.union l l' :: ls;
+      l
+
+  let start () = assert (!queue = []); enter ()
+  let exit () = match !queue with
+    | [_] -> queue := []
+    | _ -> assert false
+
+  let u_option f = function
+    | None -> None
+    | Some x -> Some (f x)
+
+  let u_loc (loc : _ Location.loc) =
+    update loc.loc; loc
+
+  let rec u_attribute { attr_name = loc ; attr_payload; attr_loc } =
+    let loc = if Location_aux.is_relaxed_location loc then loc else u_loc loc in
+    { attr_name = loc
+    ; attr_payload = u_payload attr_payload
+    ; attr_loc }
+
+  and u_extension (loc, payload) =
+    let loc = if Location_aux.is_relaxed_location loc then loc else u_loc loc in
+    (loc, u_payload payload)
+
+  and u_attributes l = List.map ~f:u_attribute l
+
+  and u_payload = function
+    | PStr str -> PStr (u_structure str)
+    | PSig sg -> PSig (u_signature sg)
+    | PTyp ct  -> PTyp (u_core_type ct)
+    | PPat (p, eo) -> PPat (u_pattern p, u_option u_expression eo)
+
+  and u_core_type {ptyp_desc; ptyp_attributes; ptyp_loc; ptyp_loc_stack} =
+    enter ();
+    let ptyp_desc = u_core_type_desc ptyp_desc in
+    let ptyp_attributes = u_attributes ptyp_attributes in
+    let ptyp_loc = leave ptyp_loc in
+    {ptyp_desc; ptyp_loc; ptyp_attributes; ptyp_loc_stack}
+
+  and u_core_type_desc = function
+    | Ptyp_any | Ptyp_var _ as desc -> desc
+    | Ptyp_arrow (l, t1, t2) -> Ptyp_arrow (l, u_core_type t1, u_core_type t2)
+    | Ptyp_tuple ts -> Ptyp_tuple (List.map ~f:u_core_type ts)
+    | Ptyp_constr (loc, ts) -> Ptyp_constr (u_loc loc, List.map ~f:u_core_type ts)
+    | Ptyp_object (fields, flag) ->
+      let object_field_desc = function
+        | Otag (lbl, ct) -> Otag (lbl, u_core_type ct)
+        | Oinherit ct -> Oinherit (u_core_type ct)
+      in
+      let object_field { pof_desc; pof_loc; pof_attributes } =
+        { pof_desc = object_field_desc pof_desc
+        ; pof_attributes = u_attributes pof_attributes
+        ; pof_loc }
+      in
+      Ptyp_object (List.map ~f:object_field fields, flag)
+    | Ptyp_class (loc, ts) -> Ptyp_class (u_loc loc, List.map ~f:u_core_type ts)
+    | Ptyp_alias (ct, name) -> Ptyp_alias (u_core_type ct, name)
+    | Ptyp_variant (fields, flag, label) -> Ptyp_variant (List.map ~f:u_row_field fields, flag, label)
+    | Ptyp_poly (ss,ct) -> Ptyp_poly (ss, u_core_type ct)
+    | Ptyp_package pt -> Ptyp_package (u_package_type pt)
+    | Ptyp_extension ext -> Ptyp_extension (u_extension ext)
+
+  and u_package_type (loc, cts) =
+    (u_loc loc, List.map ~f:(fun (l,ct) -> u_loc l, u_core_type ct) cts)
+
+  and u_row_field { prf_desc; prf_loc; prf_attributes } =
+    let desc = function
+      | Rtag (l,has_const,cts) ->
+        Rtag (l, has_const, List.map ~f:u_core_type cts)
+      | Rinherit ct -> Rinherit (u_core_type ct)
+    in
+    { prf_desc = desc prf_desc
+    ; prf_loc
+    ; prf_attributes = u_attributes prf_attributes }
+
+  and u_pattern {ppat_desc; ppat_loc; ppat_attributes; ppat_loc_stack} =
+    enter ();
+    let ppat_desc = u_pattern_desc ppat_desc in
+    let ppat_attributes = u_attributes ppat_attributes in
+    let ppat_loc = leave ppat_loc in
+    {ppat_desc; ppat_loc; ppat_attributes; ppat_loc_stack}
+
+  and u_pattern_desc = function
+    | Ppat_any | Ppat_constant _ | Ppat_interval _ as p -> p
+    | Ppat_var l -> Ppat_var (u_loc l)
+    | Ppat_alias (p, l) -> Ppat_alias (u_pattern p, u_loc l)
+    | Ppat_tuple ps -> Ppat_tuple (List.map ~f:u_pattern ps)
+    | Ppat_construct (loc, po) -> Ppat_construct (u_loc loc, u_option u_pattern po)
+    | Ppat_variant (lbl, po) -> Ppat_variant (lbl, u_option u_pattern po)
+    | Ppat_record (fields, flag) -> Ppat_record (List.map ~f:(fun (l,p) -> (u_loc l, u_pattern p)) fields, flag)
+    | Ppat_array ps -> Ppat_array (List.map ~f:u_pattern ps)
+    | Ppat_or (p1, p2) -> Ppat_or (u_pattern p1, u_pattern p2)
+    | Ppat_constraint (p, ct) -> Ppat_constraint (u_pattern p, u_core_type ct)
+    | Ppat_type loc -> Ppat_type (u_loc loc)
+    | Ppat_lazy p -> Ppat_lazy (u_pattern p)
+    | Ppat_unpack loc -> Ppat_unpack (u_loc loc)
+    | Ppat_exception p -> Ppat_exception (u_pattern p)
+    | Ppat_extension ext -> Ppat_extension (u_extension ext)
+    | Ppat_open (l,p) -> Ppat_open (u_loc l, u_pattern p)
+
+  and u_expression {pexp_desc; pexp_loc; pexp_attributes; pexp_loc_stack} =
+    enter ();
+    let pexp_desc = u_expression_desc pexp_desc in
+    let pexp_attributes = u_attributes pexp_attributes in
+    let pexp_loc = leave pexp_loc in
+    {pexp_desc; pexp_loc; pexp_attributes; pexp_loc_stack}
+
+  and u_expression_desc = function
+    | Pexp_ident loc -> Pexp_ident (u_loc loc)
+    | Pexp_constant _ as e -> e
+    | Pexp_let (flag, vs, e) ->
+      Pexp_let (flag, List.map ~f:u_value_binding vs, u_expression e)
+    | Pexp_function cs ->
+      Pexp_function (List.map ~f:u_case cs)
+    | Pexp_fun (lbl, eo, pattern, expr) ->
+      Pexp_fun (lbl, u_option u_expression eo, u_pattern pattern, u_expression expr)
+    | Pexp_apply (e, les) ->
+      Pexp_apply (u_expression e, List.map ~f:(fun (l,e) -> (l, u_expression e)) les)
+    | Pexp_match (e, cs) -> Pexp_match (u_expression e, List.map ~f:u_case cs)
+    | Pexp_try (e, cs) -> Pexp_try (u_expression e, List.map ~f:u_case cs)
+    | Pexp_tuple es -> Pexp_tuple (List.map ~f:u_expression es)
+    | Pexp_construct (loc, eo) ->
+      Pexp_construct (u_loc loc, u_option u_expression eo)
+    | Pexp_variant (lbl, eo) ->
+      Pexp_variant (lbl, u_option u_expression eo)
+    | Pexp_record (les, eo) ->
+      Pexp_record (List.map ~f:(fun (loc,e) -> (u_loc loc, u_expression e)) les, u_option u_expression eo)
+    | Pexp_field (e, loc) -> Pexp_field (u_expression e, u_loc loc)
+    | Pexp_setfield (e1, loc, e2) -> Pexp_setfield (u_expression e1, u_loc loc, u_expression e2)
+    | Pexp_array es -> Pexp_array (List.map ~f:u_expression es)
+    | Pexp_ifthenelse (e1,e2,e3) -> Pexp_ifthenelse (u_expression e1, u_expression e2, u_option u_expression e3)
+    | Pexp_sequence (e1, e2) -> Pexp_sequence (u_expression e1, u_expression e2)
+    | Pexp_while (e1, e2) -> Pexp_while (u_expression e1, u_expression e2)
+    | Pexp_for (p, e1, e2, flag, e3) -> Pexp_for (u_pattern p, u_expression e1, u_expression e2, flag, u_expression e3)
+    | Pexp_constraint (e, ct) -> Pexp_constraint (u_expression e, u_core_type ct)
+    | Pexp_coerce (e, cto, ct) -> Pexp_coerce (u_expression e, u_option u_core_type cto, u_core_type ct)
+    | Pexp_send (e, s) -> Pexp_send (u_expression e, s)
+    | Pexp_new loc -> Pexp_new (u_loc loc)
+    | Pexp_setinstvar (s, e) -> Pexp_setinstvar (u_loc s, u_expression e)
+    | Pexp_override es -> Pexp_override (List.map ~f:(fun (loc,e) -> (u_loc loc, u_expression e)) es)
+    | Pexp_letmodule (s, me, e) -> Pexp_letmodule (u_loc s, u_module_expr me, u_expression e)
+    | Pexp_letexception (c, e) -> Pexp_letexception (u_extension_constructor c, u_expression e)
+    | Pexp_assert e -> Pexp_assert (u_expression e)
+    | Pexp_lazy e -> Pexp_lazy (u_expression e)
+    | Pexp_poly (e, cto) -> Pexp_poly (u_expression e, u_option u_core_type cto)
+    | Pexp_object cs -> Pexp_object (u_class_structure cs)
+    | Pexp_newtype (s, e) -> Pexp_newtype (s, u_expression e)
+    | Pexp_pack me -> Pexp_pack (u_module_expr me)
+    | Pexp_open (od, e) -> Pexp_open (u_open_declaration od, u_expression e)
+    | Pexp_extension ext -> Pexp_extension (u_extension ext)
+    | Pexp_unreachable -> Pexp_unreachable
+    | Pexp_letop { let_; ands; body } ->
+      Pexp_letop {
+        let_ = u_binding_op let_;
+        ands = List.map ~f:u_binding_op ands;
+        body = u_expression body;
+      }
+
+  and u_binding_op { pbop_op; pbop_pat; pbop_exp; pbop_loc } =
+    { pbop_op = u_loc pbop_op
+    ; pbop_pat = u_pattern pbop_pat
+    ; pbop_exp = u_expression pbop_exp
+    ; pbop_loc }
+
+  and u_case {pc_lhs; pc_guard; pc_rhs} = {
+    pc_lhs = u_pattern pc_lhs;
+    pc_guard = u_option u_expression pc_guard;
+    pc_rhs = u_expression pc_rhs;
+  }
+
+  and u_value_description {pval_name; pval_type; pval_prim; pval_attributes; pval_loc} =
+    enter ();
+    let pval_name = u_loc pval_name in
+    let pval_type = u_core_type pval_type in
+    let pval_attributes = u_attributes pval_attributes in
+    let pval_loc = leave pval_loc in
+    {pval_name; pval_type; pval_prim; pval_attributes; pval_loc}
+
+  and u_type_declaration {ptype_name; ptype_params; ptype_cstrs; ptype_kind;
+                        ptype_private; ptype_manifest; ptype_attributes; ptype_loc} =
+    enter ();
+    let ptype_name = u_loc ptype_name
+    and ptype_params = List.map ~f:(fun (ct,v) -> (u_core_type ct, v)) ptype_params
+    and ptype_cstrs = List.map ~f:(fun (ct1,ct2,l) ->
+        update l; (u_core_type ct1, u_core_type ct2, l)) ptype_cstrs
+    and ptype_kind = u_type_kind ptype_kind
+    and ptype_manifest = u_option u_core_type ptype_manifest
+    and ptype_attributes = u_attributes ptype_attributes
+    in
+    let ptype_loc = leave ptype_loc in
+    {ptype_name; ptype_params; ptype_cstrs; ptype_kind;
+     ptype_private; ptype_manifest; ptype_attributes; ptype_loc}
+
+  and u_type_kind = function
+    | Ptype_abstract | Ptype_open as k -> k
+    | Ptype_variant cstrs -> Ptype_variant (List.map ~f:u_constructor_declaration cstrs)
+    | Ptype_record lbls -> Ptype_record (List.map ~f:u_label_declaration lbls)
+
+  and u_label_declaration {pld_name; pld_mutable; pld_type; pld_loc; pld_attributes} =
+    enter ();
+    let pld_name = u_loc pld_name in
+    let pld_type = u_core_type pld_type in
+    let pld_attributes = u_attributes pld_attributes in
+    let pld_loc = leave pld_loc in
+    {pld_name; pld_mutable; pld_type; pld_loc; pld_attributes}
+
+  and u_constructor_declaration {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} =
+    enter ();
+    let pcd_name = u_loc pcd_name in
+    let pcd_args = u_constructor_arguments pcd_args in
+    let pcd_res = u_option u_core_type pcd_res in
+    let pcd_attributes = u_attributes pcd_attributes in
+    let pcd_loc = leave pcd_loc in
+    {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes}
+
+  and u_constructor_arguments = function
+    | Pcstr_tuple cts -> Pcstr_tuple (List.map ~f:u_core_type cts)
+    | Pcstr_record lbls -> Pcstr_record (List.map ~f:u_label_declaration lbls)
+
+  and u_type_extension
+        {ptyext_path; ptyext_params; ptyext_constructors; ptyext_private
+        ; ptyext_attributes; ptyext_loc } =
+    let ptyext_path = u_loc ptyext_path in
+    let ptyext_params = List.map ~f:(fun (ct,v) -> (u_core_type ct, v)) ptyext_params in
+    let ptyext_constructors = List.map ~f:u_extension_constructor ptyext_constructors in
+    let ptyext_attributes = u_attributes ptyext_attributes in
+    {ptyext_path; ptyext_params; ptyext_constructors; ptyext_private
+    ; ptyext_attributes; ptyext_loc }
+
+  and u_extension_constructor {pext_name; pext_kind; pext_loc; pext_attributes} =
+    enter ();
+    let pext_name = u_loc pext_name in
+    let pext_kind = u_extension_constructor_kind pext_kind in
+    let pext_attributes = u_attributes pext_attributes in
+    let pext_loc = leave pext_loc in
+    {pext_name; pext_kind; pext_loc; pext_attributes}
+
+  and u_extension_constructor_kind = function
+    | Pext_decl (cargs, cto) ->
+      Pext_decl (u_constructor_arguments cargs, u_option u_core_type cto)
+    | Pext_rebind loc -> Pext_rebind (u_loc loc)
+
+  (** {2 Class language} *)
+
+  (* Type expressions for the class language *)
+
+  and u_class_type {pcty_desc; pcty_loc; pcty_attributes} =
+    enter ();
+    let pcty_desc = u_class_type_desc pcty_desc in
+    let pcty_attributes = u_attributes pcty_attributes in
+    let pcty_loc = leave pcty_loc in
+    {pcty_desc; pcty_loc; pcty_attributes}
+
+  and u_class_type_desc = function
+    | Pcty_constr (loc, cts) ->
+      Pcty_constr (u_loc loc, List.map ~f:u_core_type cts)
+    | Pcty_signature cs -> Pcty_signature (u_class_signature cs)
+    | Pcty_arrow (lbl, ct, clt) ->
+      Pcty_arrow (lbl, u_core_type ct, u_class_type clt)
+    | Pcty_extension ext ->
+      Pcty_extension (u_extension ext)
+    | Pcty_open (od, cty) ->
+      Pcty_open (u_open_description od, u_class_type cty)
+
+  and u_class_signature {pcsig_self; pcsig_fields} =
+    let pcsig_self = u_core_type pcsig_self in
+    let pcsig_fields = List.map ~f:u_class_type_field pcsig_fields in
+    {pcsig_self; pcsig_fields}
+
+  and u_class_type_field {pctf_desc; pctf_loc; pctf_attributes} =
+    enter ();
+    let pctf_desc = u_class_type_field_desc pctf_desc in
+    let pctf_attributes = u_attributes pctf_attributes in
+    let pctf_loc = leave pctf_loc in
+    {pctf_desc; pctf_loc; pctf_attributes}
+
+  and u_class_type_field_desc = function
+    | Pctf_inherit clt -> Pctf_inherit (u_class_type clt)
+    | Pctf_val (s, fl1, fl2, ct) -> Pctf_val (s, fl1, fl2, u_core_type ct)
+    | Pctf_method (s, fl1, fl2, ct) -> Pctf_method (s, fl1, fl2, u_core_type ct)
+    | Pctf_constraint (ct1, ct2) -> Pctf_constraint (u_core_type ct1, u_core_type ct2)
+    | Pctf_attribute attr ->
+      Pctf_attribute (u_attribute attr)
+    | Pctf_extension ext -> Pctf_extension (u_extension ext)
+
+  and u_class_infos : 'a 'b. ('a -> 'b) -> 'a class_infos -> 'b class_infos =
+    fun u_a {pci_virt; pci_params; pci_name; pci_expr; pci_loc; pci_attributes} ->
+    enter ();
+    let pci_params = List.map ~f:(fun (ct,v) -> (u_core_type ct, v)) pci_params in
+    let pci_name = u_loc pci_name in
+    let pci_expr = u_a pci_expr in
+    let pci_attributes = u_attributes pci_attributes in
+    let pci_loc = leave pci_loc in
+    {pci_virt; pci_params; pci_name; pci_expr; pci_loc; pci_attributes}
+
+  and u_class_description clt = u_class_infos u_class_type clt
+
+  and u_class_type_declaration clt = u_class_infos u_class_type clt
+
+  and u_class_expr {pcl_desc; pcl_loc; pcl_attributes} =
+    enter ();
+    let pcl_desc = u_class_expr_desc pcl_desc in
+    let pcl_attributes = u_attributes pcl_attributes in
+    let pcl_loc = leave pcl_loc in
+    {pcl_desc; pcl_loc; pcl_attributes}
+
+  and u_class_expr_desc = function
+    | Pcl_constr (loc, cts) -> Pcl_constr (u_loc loc, List.map ~f:u_core_type cts)
+    | Pcl_structure cs -> Pcl_structure (u_class_structure cs)
+    | Pcl_fun (lbl, eo, p, ce) ->
+      Pcl_fun (lbl, u_option u_expression eo, u_pattern p, u_class_expr ce)
+    | Pcl_apply (ce, les) ->
+      Pcl_apply (u_class_expr ce, List.map ~f:(fun (l,e) -> (l, u_expression e)) les)
+    | Pcl_let (rf, vbs, ce) ->
+      Pcl_let (rf, List.map ~f:u_value_binding vbs, u_class_expr ce)
+    | Pcl_constraint (ce, ct) -> Pcl_constraint (u_class_expr ce, u_class_type ct)
+    | Pcl_extension ext -> Pcl_extension (u_extension ext)
+    | Pcl_open (od, ce) ->
+      Pcl_open (u_open_description od, u_class_expr ce)
+
+  and u_class_structure {pcstr_self; pcstr_fields} =
+    let pcstr_self = u_pattern pcstr_self in
+    let pcstr_fields = List.map ~f:u_class_field pcstr_fields in
+    {pcstr_self; pcstr_fields}
+
+  and u_class_field {pcf_desc; pcf_loc; pcf_attributes} =
+    enter ();
+    let pcf_desc = u_class_field_desc pcf_desc in
+    let pcf_attributes = u_attributes pcf_attributes in
+    let pcf_loc = leave pcf_loc in
+    {pcf_desc; pcf_loc; pcf_attributes}
+
+  and u_class_field_desc = function
+    | Pcf_inherit (fl, ce, so) -> Pcf_inherit (fl, u_class_expr ce, so)
+    | Pcf_val (loc, fl, cfk) -> Pcf_val (u_loc loc, fl, u_class_field_kind cfk)
+    | Pcf_method (loc, fl, cfk) -> Pcf_method (u_loc loc, fl, u_class_field_kind cfk)
+    | Pcf_constraint (c1, c2) -> Pcf_constraint (u_core_type c1, u_core_type c2)
+    | Pcf_initializer e -> Pcf_initializer (u_expression e)
+    | Pcf_attribute attr -> Pcf_attribute (u_attribute attr)
+    | Pcf_extension ext -> Pcf_extension (u_extension ext)
+
+  and u_class_field_kind = function
+    | Cfk_virtual ct -> Cfk_virtual (u_core_type ct)
+    | Cfk_concrete (fl,e) -> Cfk_concrete (fl, u_expression e)
+
+  and u_class_declaration cd = u_class_infos u_class_expr cd
+
+  and u_module_type {pmty_desc; pmty_loc; pmty_attributes} =
+    enter ();
+    let pmty_desc = u_module_type_desc pmty_desc in
+    let pmty_attributes = u_attributes pmty_attributes in
+    let pmty_loc = leave pmty_loc in
+    {pmty_desc; pmty_loc; pmty_attributes}
+
+  and u_module_type_desc = function
+    | Pmty_ident loc -> Pmty_ident (u_loc loc)
+    | Pmty_signature sg -> Pmty_signature (u_signature sg)
+    | Pmty_functor (fp, mt) -> Pmty_functor (u_functor_parameter fp, u_module_type mt)
+    | Pmty_with (mt, wts) -> Pmty_with (u_module_type mt, List.map ~f:u_with_constraint wts)
+    | Pmty_typeof me -> Pmty_typeof (u_module_expr me)
+    | Pmty_extension ext -> Pmty_extension (u_extension ext)
+    | Pmty_alias loc -> Pmty_alias (u_loc loc)
+
+  and u_functor_parameter = function
+    | Unit -> Unit
+    | Named (name, mt) -> Named (u_loc name, u_module_type mt)
+
+  and u_signature l = List.map ~f:u_signature_item l
+
+  and u_signature_item {psig_desc; psig_loc} =
+    enter ();
+    let psig_desc = u_signature_item_desc psig_desc in
+    let psig_loc = leave psig_loc in
+    {psig_desc; psig_loc}
+
+  and u_signature_item_desc = function
+    | Psig_value vd -> Psig_value (u_value_description vd)
+    | Psig_type (fl, tds) -> Psig_type (fl, List.map ~f:u_type_declaration tds)
+    | Psig_typext text -> Psig_typext (u_type_extension text)
+    | Psig_exception texn -> Psig_exception (u_type_exception texn)
+    | Psig_module md -> Psig_module (u_module_declaration md)
+    | Psig_recmodule mds -> Psig_recmodule (List.map ~f:u_module_declaration mds)
+    | Psig_modtype mtd -> Psig_modtype (u_module_type_declaration mtd)
+    | Psig_open od -> Psig_open (u_open_description od)
+    | Psig_include id -> Psig_include (u_include_description id)
+    | Psig_class cds -> Psig_class (List.map ~f:u_class_description cds)
+    | Psig_class_type cts -> Psig_class_type (List.map ~f:u_class_type_declaration cts)
+    | Psig_attribute attr -> Psig_attribute (u_attribute attr)
+    | Psig_extension (ext, attrs) -> Psig_extension (u_extension ext, u_attributes attrs)
+    | Psig_typesubst tds -> Psig_typesubst (List.map ~f:u_type_declaration tds)
+    | Psig_modsubst ms -> Psig_modsubst (u_module_substitution ms)
+
+  and u_type_exception {ptyexn_constructor; ptyexn_loc; ptyexn_attributes } =
+    { ptyexn_constructor = u_extension_constructor ptyexn_constructor
+    ; ptyexn_loc
+    ; ptyexn_attributes = u_attributes ptyexn_attributes }
+
+  and u_module_declaration {pmd_name; pmd_type; pmd_attributes; pmd_loc} =
+    enter ();
+    let pmd_name = u_loc pmd_name in
+    let pmd_type = u_module_type pmd_type in
+    let pmd_attributes = u_attributes pmd_attributes in
+    let pmd_loc = leave pmd_loc in
+    {pmd_name; pmd_type; pmd_attributes; pmd_loc}
+
+  and u_module_substitution {pms_name; pms_manifest; pms_attributes; pms_loc} =
+    let pms_name = u_loc pms_name in
+    let pms_manifest = u_loc pms_manifest in
+    let pms_attributes = u_attributes pms_attributes in
+    { pms_name; pms_manifest; pms_attributes; pms_loc }
+
+  and u_module_type_declaration {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} =
+    enter ();
+    let pmtd_name = u_loc pmtd_name in
+    let pmtd_type = u_option u_module_type pmtd_type in
+    let pmtd_attributes = u_attributes pmtd_attributes in
+    let pmtd_loc = leave pmtd_loc in
+    {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc}
+
+  and u_open_declaration {popen_expr; popen_override; popen_loc; popen_attributes} =
+    enter ();
+    let popen_expr = u_module_expr popen_expr in
+    let popen_attributes = u_attributes popen_attributes in
+    let popen_loc = leave popen_loc in
+    {popen_expr; popen_override; popen_loc; popen_attributes}
+
+  and u_open_description {popen_expr; popen_override; popen_loc; popen_attributes} =
+    enter ();
+    let popen_expr = u_loc popen_expr in
+    let popen_attributes = u_attributes popen_attributes in
+    let popen_loc = leave popen_loc in
+    {popen_expr; popen_override; popen_loc; popen_attributes}
+
+  and u_include_infos : 'a 'b . ('a -> 'b) -> 'a include_infos -> 'b include_infos =
+    fun u_a {pincl_mod; pincl_loc; pincl_attributes} ->
+    enter ();
+    let pincl_mod = u_a pincl_mod in
+    let pincl_attributes = u_attributes pincl_attributes in
+    let pincl_loc = leave pincl_loc in
+    {pincl_mod; pincl_loc; pincl_attributes}
+
+  and u_include_description id = u_include_infos u_module_type id
+  and u_include_declaration id = u_include_infos u_module_expr id
+
+  and u_with_constraint = function
+    | Pwith_type (loc, td) -> Pwith_type (u_loc loc, u_type_declaration td)
+    | Pwith_module (loc1, loc2) -> Pwith_module (u_loc loc1, u_loc loc2)
+    | Pwith_typesubst (loc, td) -> Pwith_typesubst (u_loc loc, u_type_declaration td)
+    | Pwith_modsubst (loc1, loc2) -> Pwith_modsubst (u_loc loc1, u_loc loc2)
+
+  and u_module_expr {pmod_desc; pmod_loc; pmod_attributes} =
+    enter ();
+    let pmod_desc = u_module_expr_desc pmod_desc in
+    let pmod_attributes = u_attributes pmod_attributes in
+    let pmod_loc = leave pmod_loc in
+    {pmod_desc; pmod_loc; pmod_attributes}
+
+  and u_module_expr_desc = function
+    | Pmod_ident loc -> Pmod_ident (u_loc loc)
+    | Pmod_structure str -> Pmod_structure (u_structure str)
+    | Pmod_functor (fp, me) ->
+      Pmod_functor (u_functor_parameter fp, u_module_expr me)
+    | Pmod_apply (me1, me2) ->
+      Pmod_apply (u_module_expr me1, u_module_expr me2)
+    | Pmod_constraint (me, mt) ->
+      Pmod_constraint (u_module_expr me, u_module_type mt)
+    | Pmod_unpack e -> Pmod_unpack (u_expression e)
+    | Pmod_extension ext -> Pmod_extension (u_extension ext)
+
+  and u_structure l = List.map ~f:u_structure_item l
+
+  and u_structure_item {pstr_desc; pstr_loc} =
+    enter ();
+    let pstr_desc = u_structure_item_desc pstr_desc in
+    let pstr_loc = leave pstr_loc in
+    {pstr_desc; pstr_loc}
+
+  and u_structure_item_desc = function
+    | Pstr_eval (expr, attrs) -> Pstr_eval (u_expression expr, u_attributes attrs)
+    | Pstr_value (fl, vbs) -> Pstr_value (fl, List.map ~f:u_value_binding vbs)
+    | Pstr_primitive vd -> Pstr_primitive (u_value_description vd)
+    | Pstr_type (fl, tds) -> Pstr_type (fl, List.map ~f:u_type_declaration tds)
+    | Pstr_typext text -> Pstr_typext (u_type_extension text)
+    | Pstr_exception texn -> Pstr_exception (u_type_exception texn)
+    | Pstr_module mb -> Pstr_module (u_module_binding mb)
+    | Pstr_recmodule mbs -> Pstr_recmodule (List.map ~f:u_module_binding mbs)
+    | Pstr_modtype mtd -> Pstr_modtype (u_module_type_declaration mtd)
+    | Pstr_open od -> Pstr_open (u_open_declaration od)
+    | Pstr_class cds -> Pstr_class (List.map ~f:u_class_declaration cds)
+    | Pstr_class_type ctds -> Pstr_class_type (List.map ~f:u_class_type_declaration ctds)
+    | Pstr_include id -> Pstr_include (u_include_declaration id)
+    | Pstr_attribute attr -> Pstr_attribute (u_attribute attr)
+    | Pstr_extension (ext, attrs) -> Pstr_extension (u_extension ext, u_attributes attrs)
+
+  and u_value_binding {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} =
+    enter ();
+    let pvb_pat = u_pattern pvb_pat in
+    let pvb_expr = u_expression pvb_expr in
+    let pvb_attributes = u_attributes pvb_attributes in
+    let pvb_loc = leave pvb_loc in
+    {pvb_pat; pvb_expr; pvb_attributes; pvb_loc}
+
+  and u_module_binding {pmb_name; pmb_expr; pmb_attributes; pmb_loc} =
+    enter ();
+    let pmb_name = u_loc pmb_name in
+    let pmb_expr = u_module_expr pmb_expr in
+    let pmb_attributes = u_attributes pmb_attributes in
+    let pmb_loc = leave pmb_loc in
+    {pmb_name; pmb_expr; pmb_attributes; pmb_loc}
+end
+
+let rewrite_loc t =
+  Rewrite_loc.start ();
+  let t = match t with
+    | `str str -> `str (Rewrite_loc.u_structure str)
+    | `fake str -> `fake (Rewrite_loc.u_structure str)
+    | `sg sg -> `sg (Rewrite_loc.u_signature sg)
+  in
+  Rewrite_loc.exit ();
+  t
-- 
2.29.2

